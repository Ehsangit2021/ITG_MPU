
EMD-App-ICM20948.elf:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         0001d8d4  00400000  00400000  00010000  2**6
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .ARM.exidx    00000008  0041d8d4  0041d8d4  0002d8d4  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  2 .relocate     00000d08  20000000  0041d8dc  00030000  2**3
                  CONTENTS, ALLOC, LOAD, CODE
  3 .bss          0000143c  20000d08  0041e5e8  00030d08  2**3
                  ALLOC
  4 .stack        00003004  20002144  0041fa24  00030d08  2**0
                  ALLOC
  5 .ARM.attributes 00000030  00000000  00000000  00030d08  2**0
                  CONTENTS, READONLY
  6 .comment      00000059  00000000  00000000  00030d38  2**0
                  CONTENTS, READONLY
  7 .debug_info   00039ac8  00000000  00000000  00030d91  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_abbrev 000063e9  00000000  00000000  0006a859  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_aranges 00001a70  00000000  00000000  00070c42  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_macro  0001be8f  00000000  00000000  000726b2  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_line   00017f27  00000000  00000000  0008e541  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_str    0006116f  00000000  00000000  000a6468  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_loc    0000ee28  00000000  00000000  001075d7  2**0
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_ranges 000018c0  00000000  00000000  001163ff  2**0
                  CONTENTS, READONLY, DEBUGGING
 15 .debug_frame  00007f04  00000000  00000000  00117cc0  2**2
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00400000 <exception_table>:
  400000:	48 51 00 20 ed 45 40 00 bd 46 40 00 bd 46 40 00     HQ. .E@..F@..F@.
  400010:	bd 46 40 00 bd 46 40 00 bd 46 40 00 00 00 00 00     .F@..F@..F@.....
	...
  40002c:	bd 46 40 00 bd 46 40 00 00 00 00 00 bd 46 40 00     .F@..F@......F@.
  40003c:	15 33 40 00 bd 46 40 00 bd 46 40 00 bd 46 40 00     .3@..F@..F@..F@.
  40004c:	bd 46 40 00 bd 46 40 00 bd 46 40 00 bd 46 40 00     .F@..F@..F@..F@.
  40005c:	bd 46 40 00 d9 2f 40 00 bd 46 40 00 00 00 00 00     .F@../@..F@.....
  40006c:	35 07 40 00 4d 07 40 00 bd 46 40 00 bd 46 40 00     5.@.M.@..F@..F@.
  40007c:	bd 46 40 00 bd 46 40 00 bd 46 40 00 bd 46 40 00     .F@..F@..F@..F@.
  40008c:	bd 46 40 00 bd 46 40 00 bd 46 40 00 bd 46 40 00     .F@..F@..F@..F@.
  40009c:	c9 32 40 00 bd 46 40 00 bd 46 40 00 bd 46 40 00     .2@..F@..F@..F@.
  4000ac:	bd 46 40 00 bd 46 40 00 bd 46 40 00 bd 46 40 00     .F@..F@..F@..F@.
	...
  4000fc:	bd 46 40 00 bd 46 40 00 bd 46 40 00 00 00 00 00     .F@..F@..F@.....
	...

00400148 <__do_global_dtors_aux>:
  400148:	b510      	push	{r4, lr}
  40014a:	4c05      	ldr	r4, [pc, #20]	; (400160 <__do_global_dtors_aux+0x18>)
  40014c:	7823      	ldrb	r3, [r4, #0]
  40014e:	b933      	cbnz	r3, 40015e <__do_global_dtors_aux+0x16>
  400150:	4b04      	ldr	r3, [pc, #16]	; (400164 <__do_global_dtors_aux+0x1c>)
  400152:	b113      	cbz	r3, 40015a <__do_global_dtors_aux+0x12>
  400154:	4804      	ldr	r0, [pc, #16]	; (400168 <__do_global_dtors_aux+0x20>)
  400156:	f3af 8000 	nop.w
  40015a:	2301      	movs	r3, #1
  40015c:	7023      	strb	r3, [r4, #0]
  40015e:	bd10      	pop	{r4, pc}
  400160:	20000d08 	.word	0x20000d08
  400164:	00000000 	.word	0x00000000
  400168:	0041d8dc 	.word	0x0041d8dc

0040016c <frame_dummy>:
  40016c:	4b0c      	ldr	r3, [pc, #48]	; (4001a0 <frame_dummy+0x34>)
  40016e:	b143      	cbz	r3, 400182 <frame_dummy+0x16>
  400170:	480c      	ldr	r0, [pc, #48]	; (4001a4 <frame_dummy+0x38>)
  400172:	490d      	ldr	r1, [pc, #52]	; (4001a8 <frame_dummy+0x3c>)
  400174:	b510      	push	{r4, lr}
  400176:	f3af 8000 	nop.w
  40017a:	480c      	ldr	r0, [pc, #48]	; (4001ac <frame_dummy+0x40>)
  40017c:	6803      	ldr	r3, [r0, #0]
  40017e:	b923      	cbnz	r3, 40018a <frame_dummy+0x1e>
  400180:	bd10      	pop	{r4, pc}
  400182:	480a      	ldr	r0, [pc, #40]	; (4001ac <frame_dummy+0x40>)
  400184:	6803      	ldr	r3, [r0, #0]
  400186:	b933      	cbnz	r3, 400196 <frame_dummy+0x2a>
  400188:	4770      	bx	lr
  40018a:	4b09      	ldr	r3, [pc, #36]	; (4001b0 <frame_dummy+0x44>)
  40018c:	2b00      	cmp	r3, #0
  40018e:	d0f7      	beq.n	400180 <frame_dummy+0x14>
  400190:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  400194:	4718      	bx	r3
  400196:	4b06      	ldr	r3, [pc, #24]	; (4001b0 <frame_dummy+0x44>)
  400198:	2b00      	cmp	r3, #0
  40019a:	d0f5      	beq.n	400188 <frame_dummy+0x1c>
  40019c:	4718      	bx	r3
  40019e:	bf00      	nop
  4001a0:	00000000 	.word	0x00000000
  4001a4:	0041d8dc 	.word	0x0041d8dc
  4001a8:	20000d0c 	.word	0x20000d0c
  4001ac:	0041d8dc 	.word	0x0041d8dc
  4001b0:	00000000 	.word	0x00000000

004001b4 <pio_pull_up>:
 * \param ul_pull_up_enable Indicates if the pin(s) internal pull-up shall be
 * configured.
 */
void pio_pull_up(Pio *p_pio, const uint32_t ul_mask,
		const uint32_t ul_pull_up_enable)
{
  4001b4:	b480      	push	{r7}
  4001b6:	b085      	sub	sp, #20
  4001b8:	af00      	add	r7, sp, #0
  4001ba:	60f8      	str	r0, [r7, #12]
  4001bc:	60b9      	str	r1, [r7, #8]
  4001be:	607a      	str	r2, [r7, #4]
	/* Enable the pull-up(s) if necessary */
	if (ul_pull_up_enable) {
  4001c0:	687b      	ldr	r3, [r7, #4]
  4001c2:	2b00      	cmp	r3, #0
  4001c4:	d003      	beq.n	4001ce <pio_pull_up+0x1a>
		p_pio->PIO_PUER = ul_mask;
  4001c6:	68fb      	ldr	r3, [r7, #12]
  4001c8:	68ba      	ldr	r2, [r7, #8]
  4001ca:	665a      	str	r2, [r3, #100]	; 0x64
	} else {
		p_pio->PIO_PUDR = ul_mask;
	}
}
  4001cc:	e002      	b.n	4001d4 <pio_pull_up+0x20>
		p_pio->PIO_PUDR = ul_mask;
  4001ce:	68fb      	ldr	r3, [r7, #12]
  4001d0:	68ba      	ldr	r2, [r7, #8]
  4001d2:	661a      	str	r2, [r3, #96]	; 0x60
}
  4001d4:	bf00      	nop
  4001d6:	3714      	adds	r7, #20
  4001d8:	46bd      	mov	sp, r7
  4001da:	f85d 7b04 	ldr.w	r7, [sp], #4
  4001de:	4770      	bx	lr

004001e0 <pio_clear>:
 *
 * \param p_pio Pointer to a PIO instance.
 * \param ul_mask Bitmask of one or more pin(s) to configure.
 */
void pio_clear(Pio *p_pio, const uint32_t ul_mask)
{
  4001e0:	b480      	push	{r7}
  4001e2:	b083      	sub	sp, #12
  4001e4:	af00      	add	r7, sp, #0
  4001e6:	6078      	str	r0, [r7, #4]
  4001e8:	6039      	str	r1, [r7, #0]
	p_pio->PIO_CODR = ul_mask;
  4001ea:	687b      	ldr	r3, [r7, #4]
  4001ec:	683a      	ldr	r2, [r7, #0]
  4001ee:	635a      	str	r2, [r3, #52]	; 0x34
}
  4001f0:	bf00      	nop
  4001f2:	370c      	adds	r7, #12
  4001f4:	46bd      	mov	sp, r7
  4001f6:	f85d 7b04 	ldr.w	r7, [sp], #4
  4001fa:	4770      	bx	lr

004001fc <pio_set_peripheral>:
 * \param ul_type PIO type.
 * \param ul_mask Bitmask of one or more pin(s) to configure.
 */
void pio_set_peripheral(Pio *p_pio, const pio_type_t ul_type,
		const uint32_t ul_mask)
{
  4001fc:	b480      	push	{r7}
  4001fe:	b087      	sub	sp, #28
  400200:	af00      	add	r7, sp, #0
  400202:	60f8      	str	r0, [r7, #12]
  400204:	60b9      	str	r1, [r7, #8]
  400206:	607a      	str	r2, [r7, #4]
	uint32_t ul_sr;

	/* Disable interrupts on the pin(s) */
	p_pio->PIO_IDR = ul_mask;
  400208:	68fb      	ldr	r3, [r7, #12]
  40020a:	687a      	ldr	r2, [r7, #4]
  40020c:	645a      	str	r2, [r3, #68]	; 0x44

#if (SAM3S || SAM3N || SAM4S || SAM4E || SAM4N || SAM4C || SAMG || SAM4CP || SAM4CM || SAMV71 || SAMV70 || SAME70 || SAMS70)
	switch (ul_type) {
  40020e:	68bb      	ldr	r3, [r7, #8]
  400210:	f1b3 5f80 	cmp.w	r3, #268435456	; 0x10000000
  400214:	d02b      	beq.n	40026e <pio_set_peripheral+0x72>
  400216:	f1b3 5f80 	cmp.w	r3, #268435456	; 0x10000000
  40021a:	d805      	bhi.n	400228 <pio_set_peripheral+0x2c>
  40021c:	2b00      	cmp	r3, #0
  40021e:	d03f      	beq.n	4002a0 <pio_set_peripheral+0xa4>
  400220:	f1b3 6f00 	cmp.w	r3, #134217728	; 0x8000000
  400224:	d00a      	beq.n	40023c <pio_set_peripheral+0x40>
  400226:	e037      	b.n	400298 <pio_set_peripheral+0x9c>
  400228:	f1b3 5f40 	cmp.w	r3, #805306368	; 0x30000000
  40022c:	d038      	beq.n	4002a0 <pio_set_peripheral+0xa4>
  40022e:	f1b3 5f60 	cmp.w	r3, #939524096	; 0x38000000
  400232:	d035      	beq.n	4002a0 <pio_set_peripheral+0xa4>
  400234:	f1b3 5f20 	cmp.w	r3, #671088640	; 0x28000000
  400238:	d032      	beq.n	4002a0 <pio_set_peripheral+0xa4>
  40023a:	e02d      	b.n	400298 <pio_set_peripheral+0x9c>
	case PIO_PERIPH_A:
		ul_sr = p_pio->PIO_ABCDSR[0];
  40023c:	68fb      	ldr	r3, [r7, #12]
  40023e:	6f1b      	ldr	r3, [r3, #112]	; 0x70
  400240:	617b      	str	r3, [r7, #20]
		p_pio->PIO_ABCDSR[0] &= (~ul_mask & ul_sr);
  400242:	68fb      	ldr	r3, [r7, #12]
  400244:	6f1a      	ldr	r2, [r3, #112]	; 0x70
  400246:	687b      	ldr	r3, [r7, #4]
  400248:	43d9      	mvns	r1, r3
  40024a:	697b      	ldr	r3, [r7, #20]
  40024c:	400b      	ands	r3, r1
  40024e:	401a      	ands	r2, r3
  400250:	68fb      	ldr	r3, [r7, #12]
  400252:	671a      	str	r2, [r3, #112]	; 0x70

		ul_sr = p_pio->PIO_ABCDSR[1];
  400254:	68fb      	ldr	r3, [r7, #12]
  400256:	6f5b      	ldr	r3, [r3, #116]	; 0x74
  400258:	617b      	str	r3, [r7, #20]
		p_pio->PIO_ABCDSR[1] &= (~ul_mask & ul_sr);
  40025a:	68fb      	ldr	r3, [r7, #12]
  40025c:	6f5a      	ldr	r2, [r3, #116]	; 0x74
  40025e:	687b      	ldr	r3, [r7, #4]
  400260:	43d9      	mvns	r1, r3
  400262:	697b      	ldr	r3, [r7, #20]
  400264:	400b      	ands	r3, r1
  400266:	401a      	ands	r2, r3
  400268:	68fb      	ldr	r3, [r7, #12]
  40026a:	675a      	str	r2, [r3, #116]	; 0x74
		break;
  40026c:	e014      	b.n	400298 <pio_set_peripheral+0x9c>
	case PIO_PERIPH_B:
		ul_sr = p_pio->PIO_ABCDSR[0];
  40026e:	68fb      	ldr	r3, [r7, #12]
  400270:	6f1b      	ldr	r3, [r3, #112]	; 0x70
  400272:	617b      	str	r3, [r7, #20]
		p_pio->PIO_ABCDSR[0] = (ul_mask | ul_sr);
  400274:	687a      	ldr	r2, [r7, #4]
  400276:	697b      	ldr	r3, [r7, #20]
  400278:	431a      	orrs	r2, r3
  40027a:	68fb      	ldr	r3, [r7, #12]
  40027c:	671a      	str	r2, [r3, #112]	; 0x70

		ul_sr = p_pio->PIO_ABCDSR[1];
  40027e:	68fb      	ldr	r3, [r7, #12]
  400280:	6f5b      	ldr	r3, [r3, #116]	; 0x74
  400282:	617b      	str	r3, [r7, #20]
		p_pio->PIO_ABCDSR[1] &= (~ul_mask & ul_sr);
  400284:	68fb      	ldr	r3, [r7, #12]
  400286:	6f5a      	ldr	r2, [r3, #116]	; 0x74
  400288:	687b      	ldr	r3, [r7, #4]
  40028a:	43d9      	mvns	r1, r3
  40028c:	697b      	ldr	r3, [r7, #20]
  40028e:	400b      	ands	r3, r1
  400290:	401a      	ands	r2, r3
  400292:	68fb      	ldr	r3, [r7, #12]
  400294:	675a      	str	r2, [r3, #116]	; 0x74
		break;
  400296:	bf00      	nop
#else
#error "Unsupported device"
#endif

	/* Remove the pins from under the control of PIO */
	p_pio->PIO_PDR = ul_mask;
  400298:	68fb      	ldr	r3, [r7, #12]
  40029a:	687a      	ldr	r2, [r7, #4]
  40029c:	605a      	str	r2, [r3, #4]
  40029e:	e000      	b.n	4002a2 <pio_set_peripheral+0xa6>
		return;
  4002a0:	bf00      	nop
}
  4002a2:	371c      	adds	r7, #28
  4002a4:	46bd      	mov	sp, r7
  4002a6:	f85d 7b04 	ldr.w	r7, [sp], #4
  4002aa:	4770      	bx	lr

004002ac <pio_set_input>:
 * \param ul_mask Bitmask indicating which pin(s) to configure as input(s).
 * \param ul_attribute PIO attribute(s).
 */
void pio_set_input(Pio *p_pio, const uint32_t ul_mask,
		const uint32_t ul_attribute)
{
  4002ac:	b580      	push	{r7, lr}
  4002ae:	b084      	sub	sp, #16
  4002b0:	af00      	add	r7, sp, #0
  4002b2:	60f8      	str	r0, [r7, #12]
  4002b4:	60b9      	str	r1, [r7, #8]
  4002b6:	607a      	str	r2, [r7, #4]
	pio_disable_interrupt(p_pio, ul_mask);
  4002b8:	68b9      	ldr	r1, [r7, #8]
  4002ba:	68f8      	ldr	r0, [r7, #12]
  4002bc:	4b19      	ldr	r3, [pc, #100]	; (400324 <pio_set_input+0x78>)
  4002be:	4798      	blx	r3
	pio_pull_up(p_pio, ul_mask, ul_attribute & PIO_PULLUP);
  4002c0:	687b      	ldr	r3, [r7, #4]
  4002c2:	f003 0301 	and.w	r3, r3, #1
  4002c6:	461a      	mov	r2, r3
  4002c8:	68b9      	ldr	r1, [r7, #8]
  4002ca:	68f8      	ldr	r0, [r7, #12]
  4002cc:	4b16      	ldr	r3, [pc, #88]	; (400328 <pio_set_input+0x7c>)
  4002ce:	4798      	blx	r3

	/* Enable Input Filter if necessary */
	if (ul_attribute & (PIO_DEGLITCH | PIO_DEBOUNCE)) {
  4002d0:	687b      	ldr	r3, [r7, #4]
  4002d2:	f003 030a 	and.w	r3, r3, #10
  4002d6:	2b00      	cmp	r3, #0
  4002d8:	d003      	beq.n	4002e2 <pio_set_input+0x36>
		p_pio->PIO_IFER = ul_mask;
  4002da:	68fb      	ldr	r3, [r7, #12]
  4002dc:	68ba      	ldr	r2, [r7, #8]
  4002de:	621a      	str	r2, [r3, #32]
  4002e0:	e002      	b.n	4002e8 <pio_set_input+0x3c>
	} else {
		p_pio->PIO_IFDR = ul_mask;
  4002e2:	68fb      	ldr	r3, [r7, #12]
  4002e4:	68ba      	ldr	r2, [r7, #8]
  4002e6:	625a      	str	r2, [r3, #36]	; 0x24
	}

#if (SAM3S || SAM3N || SAM4S || SAM4E || SAM4N || SAM4C || SAMG || SAM4CP || SAM4CM || SAMV71 || SAMV70 || SAME70 || SAMS70)
	/* Enable de-glitch or de-bounce if necessary */
	if (ul_attribute & PIO_DEGLITCH) {
  4002e8:	687b      	ldr	r3, [r7, #4]
  4002ea:	f003 0302 	and.w	r3, r3, #2
  4002ee:	2b00      	cmp	r3, #0
  4002f0:	d004      	beq.n	4002fc <pio_set_input+0x50>
		p_pio->PIO_IFSCDR = ul_mask;
  4002f2:	68fb      	ldr	r3, [r7, #12]
  4002f4:	68ba      	ldr	r2, [r7, #8]
  4002f6:	f8c3 2080 	str.w	r2, [r3, #128]	; 0x80
  4002fa:	e008      	b.n	40030e <pio_set_input+0x62>
	} else {
		if (ul_attribute & PIO_DEBOUNCE) {
  4002fc:	687b      	ldr	r3, [r7, #4]
  4002fe:	f003 0308 	and.w	r3, r3, #8
  400302:	2b00      	cmp	r3, #0
  400304:	d003      	beq.n	40030e <pio_set_input+0x62>
			p_pio->PIO_IFSCER = ul_mask;
  400306:	68fb      	ldr	r3, [r7, #12]
  400308:	68ba      	ldr	r2, [r7, #8]
  40030a:	f8c3 2084 	str.w	r2, [r3, #132]	; 0x84
#else
#error "Unsupported device"
#endif

	/* Configure pin as input */
	p_pio->PIO_ODR = ul_mask;
  40030e:	68fb      	ldr	r3, [r7, #12]
  400310:	68ba      	ldr	r2, [r7, #8]
  400312:	615a      	str	r2, [r3, #20]
	p_pio->PIO_PER = ul_mask;
  400314:	68fb      	ldr	r3, [r7, #12]
  400316:	68ba      	ldr	r2, [r7, #8]
  400318:	601a      	str	r2, [r3, #0]
}
  40031a:	bf00      	nop
  40031c:	3710      	adds	r7, #16
  40031e:	46bd      	mov	sp, r7
  400320:	bd80      	pop	{r7, pc}
  400322:	bf00      	nop
  400324:	004004dd 	.word	0x004004dd
  400328:	004001b5 	.word	0x004001b5

0040032c <pio_set_output>:
 */
void pio_set_output(Pio *p_pio, const uint32_t ul_mask,
		const uint32_t ul_default_level,
		const uint32_t ul_multidrive_enable,
		const uint32_t ul_pull_up_enable)
{
  40032c:	b580      	push	{r7, lr}
  40032e:	b084      	sub	sp, #16
  400330:	af00      	add	r7, sp, #0
  400332:	60f8      	str	r0, [r7, #12]
  400334:	60b9      	str	r1, [r7, #8]
  400336:	607a      	str	r2, [r7, #4]
  400338:	603b      	str	r3, [r7, #0]
	pio_disable_interrupt(p_pio, ul_mask);
  40033a:	68b9      	ldr	r1, [r7, #8]
  40033c:	68f8      	ldr	r0, [r7, #12]
  40033e:	4b12      	ldr	r3, [pc, #72]	; (400388 <pio_set_output+0x5c>)
  400340:	4798      	blx	r3
	pio_pull_up(p_pio, ul_mask, ul_pull_up_enable);
  400342:	69ba      	ldr	r2, [r7, #24]
  400344:	68b9      	ldr	r1, [r7, #8]
  400346:	68f8      	ldr	r0, [r7, #12]
  400348:	4b10      	ldr	r3, [pc, #64]	; (40038c <pio_set_output+0x60>)
  40034a:	4798      	blx	r3

	/* Enable multi-drive if necessary */
	if (ul_multidrive_enable) {
  40034c:	683b      	ldr	r3, [r7, #0]
  40034e:	2b00      	cmp	r3, #0
  400350:	d003      	beq.n	40035a <pio_set_output+0x2e>
		p_pio->PIO_MDER = ul_mask;
  400352:	68fb      	ldr	r3, [r7, #12]
  400354:	68ba      	ldr	r2, [r7, #8]
  400356:	651a      	str	r2, [r3, #80]	; 0x50
  400358:	e002      	b.n	400360 <pio_set_output+0x34>
	} else {
		p_pio->PIO_MDDR = ul_mask;
  40035a:	68fb      	ldr	r3, [r7, #12]
  40035c:	68ba      	ldr	r2, [r7, #8]
  40035e:	655a      	str	r2, [r3, #84]	; 0x54
	}

	/* Set default value */
	if (ul_default_level) {
  400360:	687b      	ldr	r3, [r7, #4]
  400362:	2b00      	cmp	r3, #0
  400364:	d003      	beq.n	40036e <pio_set_output+0x42>
		p_pio->PIO_SODR = ul_mask;
  400366:	68fb      	ldr	r3, [r7, #12]
  400368:	68ba      	ldr	r2, [r7, #8]
  40036a:	631a      	str	r2, [r3, #48]	; 0x30
  40036c:	e002      	b.n	400374 <pio_set_output+0x48>
	} else {
		p_pio->PIO_CODR = ul_mask;
  40036e:	68fb      	ldr	r3, [r7, #12]
  400370:	68ba      	ldr	r2, [r7, #8]
  400372:	635a      	str	r2, [r3, #52]	; 0x34
	}

	/* Configure pin(s) as output(s) */
	p_pio->PIO_OER = ul_mask;
  400374:	68fb      	ldr	r3, [r7, #12]
  400376:	68ba      	ldr	r2, [r7, #8]
  400378:	611a      	str	r2, [r3, #16]
	p_pio->PIO_PER = ul_mask;
  40037a:	68fb      	ldr	r3, [r7, #12]
  40037c:	68ba      	ldr	r2, [r7, #8]
  40037e:	601a      	str	r2, [r3, #0]
}
  400380:	bf00      	nop
  400382:	3710      	adds	r7, #16
  400384:	46bd      	mov	sp, r7
  400386:	bd80      	pop	{r7, pc}
  400388:	004004dd 	.word	0x004004dd
  40038c:	004001b5 	.word	0x004001b5

00400390 <pio_configure>:
 *
 * \return Whether the pin(s) have been configured properly.
 */
uint32_t pio_configure(Pio *p_pio, const pio_type_t ul_type,
		const uint32_t ul_mask, const uint32_t ul_attribute)
{
  400390:	b590      	push	{r4, r7, lr}
  400392:	b087      	sub	sp, #28
  400394:	af02      	add	r7, sp, #8
  400396:	60f8      	str	r0, [r7, #12]
  400398:	60b9      	str	r1, [r7, #8]
  40039a:	607a      	str	r2, [r7, #4]
  40039c:	603b      	str	r3, [r7, #0]
	/* Configure pins */
	switch (ul_type) {
  40039e:	68bb      	ldr	r3, [r7, #8]
  4003a0:	f1b3 5f20 	cmp.w	r3, #671088640	; 0x28000000
  4003a4:	d01e      	beq.n	4003e4 <pio_configure+0x54>
  4003a6:	f1b3 5f20 	cmp.w	r3, #671088640	; 0x28000000
  4003aa:	d806      	bhi.n	4003ba <pio_configure+0x2a>
  4003ac:	f1b3 6f00 	cmp.w	r3, #134217728	; 0x8000000
  4003b0:	d00a      	beq.n	4003c8 <pio_configure+0x38>
  4003b2:	f1b3 5f80 	cmp.w	r3, #268435456	; 0x10000000
  4003b6:	d007      	beq.n	4003c8 <pio_configure+0x38>
  4003b8:	e03a      	b.n	400430 <pio_configure+0xa0>
  4003ba:	f1b3 5f40 	cmp.w	r3, #805306368	; 0x30000000
  4003be:	d017      	beq.n	4003f0 <pio_configure+0x60>
  4003c0:	f1b3 5f60 	cmp.w	r3, #939524096	; 0x38000000
  4003c4:	d014      	beq.n	4003f0 <pio_configure+0x60>
  4003c6:	e033      	b.n	400430 <pio_configure+0xa0>
	case PIO_PERIPH_B:
#if (SAM3S || SAM3N || SAM4S || SAM4E || SAM4N || SAM4C || SAM4CP || SAM4CM || SAMV71 || SAMV70 || SAME70 || SAMS70)
	case PIO_PERIPH_C:
	case PIO_PERIPH_D:
#endif
		pio_set_peripheral(p_pio, ul_type, ul_mask);
  4003c8:	687a      	ldr	r2, [r7, #4]
  4003ca:	68b9      	ldr	r1, [r7, #8]
  4003cc:	68f8      	ldr	r0, [r7, #12]
  4003ce:	4b1c      	ldr	r3, [pc, #112]	; (400440 <pio_configure+0xb0>)
  4003d0:	4798      	blx	r3
		pio_pull_up(p_pio, ul_mask, (ul_attribute & PIO_PULLUP));
  4003d2:	683b      	ldr	r3, [r7, #0]
  4003d4:	f003 0301 	and.w	r3, r3, #1
  4003d8:	461a      	mov	r2, r3
  4003da:	6879      	ldr	r1, [r7, #4]
  4003dc:	68f8      	ldr	r0, [r7, #12]
  4003de:	4b19      	ldr	r3, [pc, #100]	; (400444 <pio_configure+0xb4>)
  4003e0:	4798      	blx	r3
		break;
  4003e2:	e027      	b.n	400434 <pio_configure+0xa4>

	case PIO_INPUT:
		pio_set_input(p_pio, ul_mask, ul_attribute);
  4003e4:	683a      	ldr	r2, [r7, #0]
  4003e6:	6879      	ldr	r1, [r7, #4]
  4003e8:	68f8      	ldr	r0, [r7, #12]
  4003ea:	4b17      	ldr	r3, [pc, #92]	; (400448 <pio_configure+0xb8>)
  4003ec:	4798      	blx	r3
		break;
  4003ee:	e021      	b.n	400434 <pio_configure+0xa4>

	case PIO_OUTPUT_0:
	case PIO_OUTPUT_1:
		pio_set_output(p_pio, ul_mask, (ul_type == PIO_OUTPUT_1),
  4003f0:	68bb      	ldr	r3, [r7, #8]
  4003f2:	f1b3 5f60 	cmp.w	r3, #939524096	; 0x38000000
  4003f6:	bf0c      	ite	eq
  4003f8:	2301      	moveq	r3, #1
  4003fa:	2300      	movne	r3, #0
  4003fc:	b2db      	uxtb	r3, r3
  4003fe:	461a      	mov	r2, r3
				(ul_attribute & PIO_OPENDRAIN) ? 1 : 0,
  400400:	683b      	ldr	r3, [r7, #0]
  400402:	f003 0304 	and.w	r3, r3, #4
		pio_set_output(p_pio, ul_mask, (ul_type == PIO_OUTPUT_1),
  400406:	2b00      	cmp	r3, #0
  400408:	bf14      	ite	ne
  40040a:	2301      	movne	r3, #1
  40040c:	2300      	moveq	r3, #0
  40040e:	b2db      	uxtb	r3, r3
  400410:	4619      	mov	r1, r3
				(ul_attribute & PIO_PULLUP) ? 1 : 0);
  400412:	683b      	ldr	r3, [r7, #0]
  400414:	f003 0301 	and.w	r3, r3, #1
		pio_set_output(p_pio, ul_mask, (ul_type == PIO_OUTPUT_1),
  400418:	2b00      	cmp	r3, #0
  40041a:	bf14      	ite	ne
  40041c:	2301      	movne	r3, #1
  40041e:	2300      	moveq	r3, #0
  400420:	b2db      	uxtb	r3, r3
  400422:	9300      	str	r3, [sp, #0]
  400424:	460b      	mov	r3, r1
  400426:	6879      	ldr	r1, [r7, #4]
  400428:	68f8      	ldr	r0, [r7, #12]
  40042a:	4c08      	ldr	r4, [pc, #32]	; (40044c <pio_configure+0xbc>)
  40042c:	47a0      	blx	r4
		break;
  40042e:	e001      	b.n	400434 <pio_configure+0xa4>

	default:
		return 0;
  400430:	2300      	movs	r3, #0
  400432:	e000      	b.n	400436 <pio_configure+0xa6>
	}

	return 1;
  400434:	2301      	movs	r3, #1
}
  400436:	4618      	mov	r0, r3
  400438:	3714      	adds	r7, #20
  40043a:	46bd      	mov	sp, r7
  40043c:	bd90      	pop	{r4, r7, pc}
  40043e:	bf00      	nop
  400440:	004001fd 	.word	0x004001fd
  400444:	004001b5 	.word	0x004001b5
  400448:	004002ad 	.word	0x004002ad
  40044c:	0040032d 	.word	0x0040032d

00400450 <pio_configure_interrupt>:
 * \param ul_mask Interrupt source bit map.
 * \param ul_attr Interrupt source attributes.
 */
void pio_configure_interrupt(Pio *p_pio, const uint32_t ul_mask,
		const uint32_t ul_attr)
{
  400450:	b480      	push	{r7}
  400452:	b085      	sub	sp, #20
  400454:	af00      	add	r7, sp, #0
  400456:	60f8      	str	r0, [r7, #12]
  400458:	60b9      	str	r1, [r7, #8]
  40045a:	607a      	str	r2, [r7, #4]
	/* Configure additional interrupt mode registers. */
	if (ul_attr & PIO_IT_AIME) {
  40045c:	687b      	ldr	r3, [r7, #4]
  40045e:	f003 0310 	and.w	r3, r3, #16
  400462:	2b00      	cmp	r3, #0
  400464:	d020      	beq.n	4004a8 <pio_configure_interrupt+0x58>
		/* Enable additional interrupt mode. */
		p_pio->PIO_AIMER = ul_mask;
  400466:	68fb      	ldr	r3, [r7, #12]
  400468:	68ba      	ldr	r2, [r7, #8]
  40046a:	f8c3 20b0 	str.w	r2, [r3, #176]	; 0xb0

		/* If bit field of the selected pin is 1, set as
		   Rising Edge/High level detection event. */
		if (ul_attr & PIO_IT_RE_OR_HL) {
  40046e:	687b      	ldr	r3, [r7, #4]
  400470:	f003 0320 	and.w	r3, r3, #32
  400474:	2b00      	cmp	r3, #0
  400476:	d004      	beq.n	400482 <pio_configure_interrupt+0x32>
			/* Rising Edge or High Level */
			p_pio->PIO_REHLSR = ul_mask;
  400478:	68fb      	ldr	r3, [r7, #12]
  40047a:	68ba      	ldr	r2, [r7, #8]
  40047c:	f8c3 20d4 	str.w	r2, [r3, #212]	; 0xd4
  400480:	e003      	b.n	40048a <pio_configure_interrupt+0x3a>
		} else {
			/* Falling Edge or Low Level */
			p_pio->PIO_FELLSR = ul_mask;
  400482:	68fb      	ldr	r3, [r7, #12]
  400484:	68ba      	ldr	r2, [r7, #8]
  400486:	f8c3 20d0 	str.w	r2, [r3, #208]	; 0xd0
		}

		/* If bit field of the selected pin is 1, set as
		   edge detection source. */
		if (ul_attr & PIO_IT_EDGE) {
  40048a:	687b      	ldr	r3, [r7, #4]
  40048c:	f003 0340 	and.w	r3, r3, #64	; 0x40
  400490:	2b00      	cmp	r3, #0
  400492:	d004      	beq.n	40049e <pio_configure_interrupt+0x4e>
			/* Edge select */
			p_pio->PIO_ESR = ul_mask;
  400494:	68fb      	ldr	r3, [r7, #12]
  400496:	68ba      	ldr	r2, [r7, #8]
  400498:	f8c3 20c0 	str.w	r2, [r3, #192]	; 0xc0
		}
	} else {
		/* Disable additional interrupt mode. */
		p_pio->PIO_AIMDR = ul_mask;
	}
}
  40049c:	e008      	b.n	4004b0 <pio_configure_interrupt+0x60>
			p_pio->PIO_LSR = ul_mask;
  40049e:	68fb      	ldr	r3, [r7, #12]
  4004a0:	68ba      	ldr	r2, [r7, #8]
  4004a2:	f8c3 20c4 	str.w	r2, [r3, #196]	; 0xc4
}
  4004a6:	e003      	b.n	4004b0 <pio_configure_interrupt+0x60>
		p_pio->PIO_AIMDR = ul_mask;
  4004a8:	68fb      	ldr	r3, [r7, #12]
  4004aa:	68ba      	ldr	r2, [r7, #8]
  4004ac:	f8c3 20b4 	str.w	r2, [r3, #180]	; 0xb4
}
  4004b0:	bf00      	nop
  4004b2:	3714      	adds	r7, #20
  4004b4:	46bd      	mov	sp, r7
  4004b6:	f85d 7b04 	ldr.w	r7, [sp], #4
  4004ba:	4770      	bx	lr

004004bc <pio_enable_interrupt>:
 *
 * \param p_pio Pointer to a PIO instance.
 * \param ul_mask Interrupt sources bit map.
 */
void pio_enable_interrupt(Pio *p_pio, const uint32_t ul_mask)
{
  4004bc:	b480      	push	{r7}
  4004be:	b083      	sub	sp, #12
  4004c0:	af00      	add	r7, sp, #0
  4004c2:	6078      	str	r0, [r7, #4]
  4004c4:	6039      	str	r1, [r7, #0]
	p_pio->PIO_ISR;
  4004c6:	687b      	ldr	r3, [r7, #4]
  4004c8:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
	p_pio->PIO_IER = ul_mask;
  4004ca:	687b      	ldr	r3, [r7, #4]
  4004cc:	683a      	ldr	r2, [r7, #0]
  4004ce:	641a      	str	r2, [r3, #64]	; 0x40
}
  4004d0:	bf00      	nop
  4004d2:	370c      	adds	r7, #12
  4004d4:	46bd      	mov	sp, r7
  4004d6:	f85d 7b04 	ldr.w	r7, [sp], #4
  4004da:	4770      	bx	lr

004004dc <pio_disable_interrupt>:
 *
 * \param p_pio Pointer to a PIO instance.
 * \param ul_mask Interrupt sources bit map.
 */
void pio_disable_interrupt(Pio *p_pio, const uint32_t ul_mask)
{
  4004dc:	b480      	push	{r7}
  4004de:	b083      	sub	sp, #12
  4004e0:	af00      	add	r7, sp, #0
  4004e2:	6078      	str	r0, [r7, #4]
  4004e4:	6039      	str	r1, [r7, #0]
	p_pio->PIO_IDR = ul_mask;
  4004e6:	687b      	ldr	r3, [r7, #4]
  4004e8:	683a      	ldr	r2, [r7, #0]
  4004ea:	645a      	str	r2, [r3, #68]	; 0x44
}
  4004ec:	bf00      	nop
  4004ee:	370c      	adds	r7, #12
  4004f0:	46bd      	mov	sp, r7
  4004f2:	f85d 7b04 	ldr.w	r7, [sp], #4
  4004f6:	4770      	bx	lr

004004f8 <pio_get_interrupt_status>:
 * \param p_pio Pointer to a PIO instance.
 *
 * \return The interrupt status mask value.
 */
uint32_t pio_get_interrupt_status(const Pio *p_pio)
{
  4004f8:	b480      	push	{r7}
  4004fa:	b083      	sub	sp, #12
  4004fc:	af00      	add	r7, sp, #0
  4004fe:	6078      	str	r0, [r7, #4]
	return p_pio->PIO_ISR;
  400500:	687b      	ldr	r3, [r7, #4]
  400502:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
}
  400504:	4618      	mov	r0, r3
  400506:	370c      	adds	r7, #12
  400508:	46bd      	mov	sp, r7
  40050a:	f85d 7b04 	ldr.w	r7, [sp], #4
  40050e:	4770      	bx	lr

00400510 <pio_get_interrupt_mask>:
 * \param p_pio Pointer to a PIO instance.
 *
 * \return The interrupt mask value.
 */
uint32_t pio_get_interrupt_mask(const Pio *p_pio)
{
  400510:	b480      	push	{r7}
  400512:	b083      	sub	sp, #12
  400514:	af00      	add	r7, sp, #0
  400516:	6078      	str	r0, [r7, #4]
	return p_pio->PIO_IMR;
  400518:	687b      	ldr	r3, [r7, #4]
  40051a:	6c9b      	ldr	r3, [r3, #72]	; 0x48
}
  40051c:	4618      	mov	r0, r3
  40051e:	370c      	adds	r7, #12
  400520:	46bd      	mov	sp, r7
  400522:	f85d 7b04 	ldr.w	r7, [sp], #4
  400526:	4770      	bx	lr

00400528 <NVIC_EnableIRQ>:
    The function enables a device-specific interrupt in the NVIC interrupt controller.

    \param [in]      IRQn  External interrupt number. Value cannot be negative.
 */
__STATIC_INLINE void NVIC_EnableIRQ(IRQn_Type IRQn)
{
  400528:	b480      	push	{r7}
  40052a:	b083      	sub	sp, #12
  40052c:	af00      	add	r7, sp, #0
  40052e:	4603      	mov	r3, r0
  400530:	71fb      	strb	r3, [r7, #7]
/*  NVIC->ISER[((uint32_t)(IRQn) >> 5)] = (1 << ((uint32_t)(IRQn) & 0x1F));  enable interrupt */
  NVIC->ISER[(uint32_t)((int32_t)IRQn) >> 5] = (uint32_t)(1 << ((uint32_t)((int32_t)IRQn) & (uint32_t)0x1F)); /* enable interrupt */
  400532:	4909      	ldr	r1, [pc, #36]	; (400558 <NVIC_EnableIRQ+0x30>)
  400534:	f997 3007 	ldrsb.w	r3, [r7, #7]
  400538:	095b      	lsrs	r3, r3, #5
  40053a:	79fa      	ldrb	r2, [r7, #7]
  40053c:	f002 021f 	and.w	r2, r2, #31
  400540:	2001      	movs	r0, #1
  400542:	fa00 f202 	lsl.w	r2, r0, r2
  400546:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
  40054a:	bf00      	nop
  40054c:	370c      	adds	r7, #12
  40054e:	46bd      	mov	sp, r7
  400550:	f85d 7b04 	ldr.w	r7, [sp], #4
  400554:	4770      	bx	lr
  400556:	bf00      	nop
  400558:	e000e100 	.word	0xe000e100

0040055c <NVIC_DisableIRQ>:
    The function disables a device-specific interrupt in the NVIC interrupt controller.

    \param [in]      IRQn  External interrupt number. Value cannot be negative.
 */
__STATIC_INLINE void NVIC_DisableIRQ(IRQn_Type IRQn)
{
  40055c:	b480      	push	{r7}
  40055e:	b083      	sub	sp, #12
  400560:	af00      	add	r7, sp, #0
  400562:	4603      	mov	r3, r0
  400564:	71fb      	strb	r3, [r7, #7]
  NVIC->ICER[((uint32_t)(IRQn) >> 5)] = (1 << ((uint32_t)(IRQn) & 0x1F)); /* disable interrupt */
  400566:	4909      	ldr	r1, [pc, #36]	; (40058c <NVIC_DisableIRQ+0x30>)
  400568:	f997 3007 	ldrsb.w	r3, [r7, #7]
  40056c:	095b      	lsrs	r3, r3, #5
  40056e:	79fa      	ldrb	r2, [r7, #7]
  400570:	f002 021f 	and.w	r2, r2, #31
  400574:	2001      	movs	r0, #1
  400576:	fa00 f202 	lsl.w	r2, r0, r2
  40057a:	3320      	adds	r3, #32
  40057c:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
  400580:	bf00      	nop
  400582:	370c      	adds	r7, #12
  400584:	46bd      	mov	sp, r7
  400586:	f85d 7b04 	ldr.w	r7, [sp], #4
  40058a:	4770      	bx	lr
  40058c:	e000e100 	.word	0xe000e100

00400590 <NVIC_ClearPendingIRQ>:
    The function clears the pending bit of an external interrupt.

    \param [in]      IRQn  External interrupt number. Value cannot be negative.
 */
__STATIC_INLINE void NVIC_ClearPendingIRQ(IRQn_Type IRQn)
{
  400590:	b480      	push	{r7}
  400592:	b083      	sub	sp, #12
  400594:	af00      	add	r7, sp, #0
  400596:	4603      	mov	r3, r0
  400598:	71fb      	strb	r3, [r7, #7]
  NVIC->ICPR[((uint32_t)(IRQn) >> 5)] = (1 << ((uint32_t)(IRQn) & 0x1F)); /* Clear pending interrupt */
  40059a:	4909      	ldr	r1, [pc, #36]	; (4005c0 <NVIC_ClearPendingIRQ+0x30>)
  40059c:	f997 3007 	ldrsb.w	r3, [r7, #7]
  4005a0:	095b      	lsrs	r3, r3, #5
  4005a2:	79fa      	ldrb	r2, [r7, #7]
  4005a4:	f002 021f 	and.w	r2, r2, #31
  4005a8:	2001      	movs	r0, #1
  4005aa:	fa00 f202 	lsl.w	r2, r0, r2
  4005ae:	3360      	adds	r3, #96	; 0x60
  4005b0:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
  4005b4:	bf00      	nop
  4005b6:	370c      	adds	r7, #12
  4005b8:	46bd      	mov	sp, r7
  4005ba:	f85d 7b04 	ldr.w	r7, [sp], #4
  4005be:	4770      	bx	lr
  4005c0:	e000e100 	.word	0xe000e100

004005c4 <NVIC_SetPriority>:

    \param [in]      IRQn  Interrupt number.
    \param [in]  priority  Priority to set.
 */
__STATIC_INLINE void NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
  4005c4:	b480      	push	{r7}
  4005c6:	b083      	sub	sp, #12
  4005c8:	af00      	add	r7, sp, #0
  4005ca:	4603      	mov	r3, r0
  4005cc:	6039      	str	r1, [r7, #0]
  4005ce:	71fb      	strb	r3, [r7, #7]
  if(IRQn < 0) {
  4005d0:	f997 3007 	ldrsb.w	r3, [r7, #7]
  4005d4:	2b00      	cmp	r3, #0
  4005d6:	da0b      	bge.n	4005f0 <NVIC_SetPriority+0x2c>
    SCB->SHP[((uint32_t)(IRQn) & 0xF)-4] = ((priority << (8 - __NVIC_PRIO_BITS)) & 0xff); } /* set Priority for Cortex-M  System Interrupts */
  4005d8:	490d      	ldr	r1, [pc, #52]	; (400610 <NVIC_SetPriority+0x4c>)
  4005da:	79fb      	ldrb	r3, [r7, #7]
  4005dc:	f003 030f 	and.w	r3, r3, #15
  4005e0:	3b04      	subs	r3, #4
  4005e2:	683a      	ldr	r2, [r7, #0]
  4005e4:	b2d2      	uxtb	r2, r2
  4005e6:	0112      	lsls	r2, r2, #4
  4005e8:	b2d2      	uxtb	r2, r2
  4005ea:	440b      	add	r3, r1
  4005ec:	761a      	strb	r2, [r3, #24]
  else {
    NVIC->IP[(uint32_t)(IRQn)] = ((priority << (8 - __NVIC_PRIO_BITS)) & 0xff);    }        /* set Priority for device specific Interrupts  */
}
  4005ee:	e009      	b.n	400604 <NVIC_SetPriority+0x40>
    NVIC->IP[(uint32_t)(IRQn)] = ((priority << (8 - __NVIC_PRIO_BITS)) & 0xff);    }        /* set Priority for device specific Interrupts  */
  4005f0:	4908      	ldr	r1, [pc, #32]	; (400614 <NVIC_SetPriority+0x50>)
  4005f2:	f997 3007 	ldrsb.w	r3, [r7, #7]
  4005f6:	683a      	ldr	r2, [r7, #0]
  4005f8:	b2d2      	uxtb	r2, r2
  4005fa:	0112      	lsls	r2, r2, #4
  4005fc:	b2d2      	uxtb	r2, r2
  4005fe:	440b      	add	r3, r1
  400600:	f883 2300 	strb.w	r2, [r3, #768]	; 0x300
}
  400604:	bf00      	nop
  400606:	370c      	adds	r7, #12
  400608:	46bd      	mov	sp, r7
  40060a:	f85d 7b04 	ldr.w	r7, [sp], #4
  40060e:	4770      	bx	lr
  400610:	e000ed00 	.word	0xe000ed00
  400614:	e000e100 	.word	0xe000e100

00400618 <pio_handler_process>:
 *
 * \param p_pio PIO controller base address.
 * \param ul_id PIO controller ID.
 */
void pio_handler_process(Pio *p_pio, uint32_t ul_id)
{
  400618:	b580      	push	{r7, lr}
  40061a:	b084      	sub	sp, #16
  40061c:	af00      	add	r7, sp, #0
  40061e:	6078      	str	r0, [r7, #4]
  400620:	6039      	str	r1, [r7, #0]
	uint32_t status;
	uint32_t i;

	/* Read PIO controller status */
	status = pio_get_interrupt_status(p_pio);
  400622:	6878      	ldr	r0, [r7, #4]
  400624:	4b26      	ldr	r3, [pc, #152]	; (4006c0 <pio_handler_process+0xa8>)
  400626:	4798      	blx	r3
  400628:	60f8      	str	r0, [r7, #12]
	status &= pio_get_interrupt_mask(p_pio);
  40062a:	6878      	ldr	r0, [r7, #4]
  40062c:	4b25      	ldr	r3, [pc, #148]	; (4006c4 <pio_handler_process+0xac>)
  40062e:	4798      	blx	r3
  400630:	4602      	mov	r2, r0
  400632:	68fb      	ldr	r3, [r7, #12]
  400634:	4013      	ands	r3, r2
  400636:	60fb      	str	r3, [r7, #12]

	/* Check pending events */
	if (status != 0) {
  400638:	68fb      	ldr	r3, [r7, #12]
  40063a:	2b00      	cmp	r3, #0
  40063c:	d03c      	beq.n	4006b8 <pio_handler_process+0xa0>
		/* Find triggering source */
		i = 0;
  40063e:	2300      	movs	r3, #0
  400640:	60bb      	str	r3, [r7, #8]
		while (status != 0) {
  400642:	e034      	b.n	4006ae <pio_handler_process+0x96>
			/* Source is configured on the same controller */
			if (gs_interrupt_sources[i].id == ul_id) {
  400644:	4a20      	ldr	r2, [pc, #128]	; (4006c8 <pio_handler_process+0xb0>)
  400646:	68bb      	ldr	r3, [r7, #8]
  400648:	011b      	lsls	r3, r3, #4
  40064a:	4413      	add	r3, r2
  40064c:	681a      	ldr	r2, [r3, #0]
  40064e:	683b      	ldr	r3, [r7, #0]
  400650:	429a      	cmp	r2, r3
  400652:	d126      	bne.n	4006a2 <pio_handler_process+0x8a>
				/* Source has PIOs whose statuses have changed */
				if ((status & gs_interrupt_sources[i].mask) != 0) {
  400654:	4a1c      	ldr	r2, [pc, #112]	; (4006c8 <pio_handler_process+0xb0>)
  400656:	68bb      	ldr	r3, [r7, #8]
  400658:	011b      	lsls	r3, r3, #4
  40065a:	4413      	add	r3, r2
  40065c:	3304      	adds	r3, #4
  40065e:	681a      	ldr	r2, [r3, #0]
  400660:	68fb      	ldr	r3, [r7, #12]
  400662:	4013      	ands	r3, r2
  400664:	2b00      	cmp	r3, #0
  400666:	d01c      	beq.n	4006a2 <pio_handler_process+0x8a>
					gs_interrupt_sources[i].handler(gs_interrupt_sources[i].id,
  400668:	4a17      	ldr	r2, [pc, #92]	; (4006c8 <pio_handler_process+0xb0>)
  40066a:	68bb      	ldr	r3, [r7, #8]
  40066c:	011b      	lsls	r3, r3, #4
  40066e:	4413      	add	r3, r2
  400670:	330c      	adds	r3, #12
  400672:	681b      	ldr	r3, [r3, #0]
  400674:	4914      	ldr	r1, [pc, #80]	; (4006c8 <pio_handler_process+0xb0>)
  400676:	68ba      	ldr	r2, [r7, #8]
  400678:	0112      	lsls	r2, r2, #4
  40067a:	440a      	add	r2, r1
  40067c:	6810      	ldr	r0, [r2, #0]
  40067e:	4912      	ldr	r1, [pc, #72]	; (4006c8 <pio_handler_process+0xb0>)
  400680:	68ba      	ldr	r2, [r7, #8]
  400682:	0112      	lsls	r2, r2, #4
  400684:	440a      	add	r2, r1
  400686:	3204      	adds	r2, #4
  400688:	6812      	ldr	r2, [r2, #0]
  40068a:	4611      	mov	r1, r2
  40068c:	4798      	blx	r3
							gs_interrupt_sources[i].mask);
					status &= ~(gs_interrupt_sources[i].mask);
  40068e:	4a0e      	ldr	r2, [pc, #56]	; (4006c8 <pio_handler_process+0xb0>)
  400690:	68bb      	ldr	r3, [r7, #8]
  400692:	011b      	lsls	r3, r3, #4
  400694:	4413      	add	r3, r2
  400696:	3304      	adds	r3, #4
  400698:	681b      	ldr	r3, [r3, #0]
  40069a:	43db      	mvns	r3, r3
  40069c:	68fa      	ldr	r2, [r7, #12]
  40069e:	4013      	ands	r3, r2
  4006a0:	60fb      	str	r3, [r7, #12]
				}
			}
			i++;
  4006a2:	68bb      	ldr	r3, [r7, #8]
  4006a4:	3301      	adds	r3, #1
  4006a6:	60bb      	str	r3, [r7, #8]
			if (i >= MAX_INTERRUPT_SOURCES) {
  4006a8:	68bb      	ldr	r3, [r7, #8]
  4006aa:	2b06      	cmp	r3, #6
  4006ac:	d803      	bhi.n	4006b6 <pio_handler_process+0x9e>
		while (status != 0) {
  4006ae:	68fb      	ldr	r3, [r7, #12]
  4006b0:	2b00      	cmp	r3, #0
  4006b2:	d1c7      	bne.n	400644 <pio_handler_process+0x2c>
		if (pio_capture_handler) {
			pio_capture_handler(p_pio);
		}
	}
#endif
}
  4006b4:	e000      	b.n	4006b8 <pio_handler_process+0xa0>
				break;
  4006b6:	bf00      	nop
}
  4006b8:	bf00      	nop
  4006ba:	3710      	adds	r7, #16
  4006bc:	46bd      	mov	sp, r7
  4006be:	bd80      	pop	{r7, pc}
  4006c0:	004004f9 	.word	0x004004f9
  4006c4:	00400511 	.word	0x00400511
  4006c8:	20000d24 	.word	0x20000d24

004006cc <pio_handler_set>:
 *
 * \return 0 if successful, 1 if the maximum number of sources has been defined.
 */
uint32_t pio_handler_set(Pio *p_pio, uint32_t ul_id, uint32_t ul_mask,
		uint32_t ul_attr, void (*p_handler) (uint32_t, uint32_t))
{
  4006cc:	b580      	push	{r7, lr}
  4006ce:	b086      	sub	sp, #24
  4006d0:	af00      	add	r7, sp, #0
  4006d2:	60f8      	str	r0, [r7, #12]
  4006d4:	60b9      	str	r1, [r7, #8]
  4006d6:	607a      	str	r2, [r7, #4]
  4006d8:	603b      	str	r3, [r7, #0]
	struct s_interrupt_source *pSource;

	if (gs_ul_nb_sources >= MAX_INTERRUPT_SOURCES)
  4006da:	4b13      	ldr	r3, [pc, #76]	; (400728 <pio_handler_set+0x5c>)
  4006dc:	681b      	ldr	r3, [r3, #0]
  4006de:	2b06      	cmp	r3, #6
  4006e0:	d901      	bls.n	4006e6 <pio_handler_set+0x1a>
		return 1;
  4006e2:	2301      	movs	r3, #1
  4006e4:	e01c      	b.n	400720 <pio_handler_set+0x54>

	/* Define new source */
	pSource = &(gs_interrupt_sources[gs_ul_nb_sources]);
  4006e6:	4b10      	ldr	r3, [pc, #64]	; (400728 <pio_handler_set+0x5c>)
  4006e8:	681b      	ldr	r3, [r3, #0]
  4006ea:	011b      	lsls	r3, r3, #4
  4006ec:	4a0f      	ldr	r2, [pc, #60]	; (40072c <pio_handler_set+0x60>)
  4006ee:	4413      	add	r3, r2
  4006f0:	617b      	str	r3, [r7, #20]
	pSource->id = ul_id;
  4006f2:	697b      	ldr	r3, [r7, #20]
  4006f4:	68ba      	ldr	r2, [r7, #8]
  4006f6:	601a      	str	r2, [r3, #0]
	pSource->mask = ul_mask;
  4006f8:	697b      	ldr	r3, [r7, #20]
  4006fa:	687a      	ldr	r2, [r7, #4]
  4006fc:	605a      	str	r2, [r3, #4]
	pSource->attr = ul_attr;
  4006fe:	697b      	ldr	r3, [r7, #20]
  400700:	683a      	ldr	r2, [r7, #0]
  400702:	609a      	str	r2, [r3, #8]
	pSource->handler = p_handler;
  400704:	697b      	ldr	r3, [r7, #20]
  400706:	6a3a      	ldr	r2, [r7, #32]
  400708:	60da      	str	r2, [r3, #12]
	gs_ul_nb_sources++;
  40070a:	4b07      	ldr	r3, [pc, #28]	; (400728 <pio_handler_set+0x5c>)
  40070c:	681b      	ldr	r3, [r3, #0]
  40070e:	3301      	adds	r3, #1
  400710:	4a05      	ldr	r2, [pc, #20]	; (400728 <pio_handler_set+0x5c>)
  400712:	6013      	str	r3, [r2, #0]

	/* Configure interrupt mode */
	pio_configure_interrupt(p_pio, ul_mask, ul_attr);
  400714:	683a      	ldr	r2, [r7, #0]
  400716:	6879      	ldr	r1, [r7, #4]
  400718:	68f8      	ldr	r0, [r7, #12]
  40071a:	4b05      	ldr	r3, [pc, #20]	; (400730 <pio_handler_set+0x64>)
  40071c:	4798      	blx	r3

	return 0;
  40071e:	2300      	movs	r3, #0
}
  400720:	4618      	mov	r0, r3
  400722:	3718      	adds	r7, #24
  400724:	46bd      	mov	sp, r7
  400726:	bd80      	pop	{r7, pc}
  400728:	20000d94 	.word	0x20000d94
  40072c:	20000d24 	.word	0x20000d24
  400730:	00400451 	.word	0x00400451

00400734 <PIOA_Handler>:
/**
 * \brief Parallel IO Controller A interrupt handler.
 * Redefined PIOA interrupt handler for NVIC interrupt table.
 */
void PIOA_Handler(void)
{
  400734:	b580      	push	{r7, lr}
  400736:	af00      	add	r7, sp, #0
	pio_handler_process(PIOA, ID_PIOA);
  400738:	210b      	movs	r1, #11
  40073a:	4802      	ldr	r0, [pc, #8]	; (400744 <PIOA_Handler+0x10>)
  40073c:	4b02      	ldr	r3, [pc, #8]	; (400748 <PIOA_Handler+0x14>)
  40073e:	4798      	blx	r3
}
  400740:	bf00      	nop
  400742:	bd80      	pop	{r7, pc}
  400744:	400e0e00 	.word	0x400e0e00
  400748:	00400619 	.word	0x00400619

0040074c <PIOB_Handler>:
/**
 * \brief Parallel IO Controller B interrupt handler
 * Redefined PIOB interrupt handler for NVIC interrupt table.
 */
void PIOB_Handler(void)
{
  40074c:	b580      	push	{r7, lr}
  40074e:	af00      	add	r7, sp, #0
    pio_handler_process(PIOB, ID_PIOB);
  400750:	210c      	movs	r1, #12
  400752:	4802      	ldr	r0, [pc, #8]	; (40075c <PIOB_Handler+0x10>)
  400754:	4b02      	ldr	r3, [pc, #8]	; (400760 <PIOB_Handler+0x14>)
  400756:	4798      	blx	r3
}
  400758:	bf00      	nop
  40075a:	bd80      	pop	{r7, pc}
  40075c:	400e1000 	.word	0x400e1000
  400760:	00400619 	.word	0x00400619

00400764 <pio_handler_set_priority>:
 * \param p_pio PIO controller base address.
 * \param ul_irqn NVIC line number.
 * \param ul_priority PIO controller interrupts priority.
 */
void pio_handler_set_priority(Pio *p_pio, IRQn_Type ul_irqn, uint32_t ul_priority)
{
  400764:	b580      	push	{r7, lr}
  400766:	b086      	sub	sp, #24
  400768:	af00      	add	r7, sp, #0
  40076a:	60f8      	str	r0, [r7, #12]
  40076c:	460b      	mov	r3, r1
  40076e:	607a      	str	r2, [r7, #4]
  400770:	72fb      	strb	r3, [r7, #11]
	uint32_t bitmask = 0;
  400772:	2300      	movs	r3, #0
  400774:	617b      	str	r3, [r7, #20]

	bitmask = pio_get_interrupt_mask(p_pio);
  400776:	68f8      	ldr	r0, [r7, #12]
  400778:	4b13      	ldr	r3, [pc, #76]	; (4007c8 <pio_handler_set_priority+0x64>)
  40077a:	4798      	blx	r3
  40077c:	6178      	str	r0, [r7, #20]
	pio_disable_interrupt(p_pio, 0xFFFFFFFF);
  40077e:	f04f 31ff 	mov.w	r1, #4294967295
  400782:	68f8      	ldr	r0, [r7, #12]
  400784:	4b11      	ldr	r3, [pc, #68]	; (4007cc <pio_handler_set_priority+0x68>)
  400786:	4798      	blx	r3
	pio_get_interrupt_status(p_pio);
  400788:	68f8      	ldr	r0, [r7, #12]
  40078a:	4b11      	ldr	r3, [pc, #68]	; (4007d0 <pio_handler_set_priority+0x6c>)
  40078c:	4798      	blx	r3
	NVIC_DisableIRQ(ul_irqn);
  40078e:	f997 300b 	ldrsb.w	r3, [r7, #11]
  400792:	4618      	mov	r0, r3
  400794:	4b0f      	ldr	r3, [pc, #60]	; (4007d4 <pio_handler_set_priority+0x70>)
  400796:	4798      	blx	r3
	NVIC_ClearPendingIRQ(ul_irqn);
  400798:	f997 300b 	ldrsb.w	r3, [r7, #11]
  40079c:	4618      	mov	r0, r3
  40079e:	4b0e      	ldr	r3, [pc, #56]	; (4007d8 <pio_handler_set_priority+0x74>)
  4007a0:	4798      	blx	r3
	NVIC_SetPriority(ul_irqn, ul_priority);
  4007a2:	f997 300b 	ldrsb.w	r3, [r7, #11]
  4007a6:	6879      	ldr	r1, [r7, #4]
  4007a8:	4618      	mov	r0, r3
  4007aa:	4b0c      	ldr	r3, [pc, #48]	; (4007dc <pio_handler_set_priority+0x78>)
  4007ac:	4798      	blx	r3
	NVIC_EnableIRQ(ul_irqn);
  4007ae:	f997 300b 	ldrsb.w	r3, [r7, #11]
  4007b2:	4618      	mov	r0, r3
  4007b4:	4b0a      	ldr	r3, [pc, #40]	; (4007e0 <pio_handler_set_priority+0x7c>)
  4007b6:	4798      	blx	r3
	pio_enable_interrupt(p_pio, bitmask);
  4007b8:	6979      	ldr	r1, [r7, #20]
  4007ba:	68f8      	ldr	r0, [r7, #12]
  4007bc:	4b09      	ldr	r3, [pc, #36]	; (4007e4 <pio_handler_set_priority+0x80>)
  4007be:	4798      	blx	r3
}
  4007c0:	bf00      	nop
  4007c2:	3718      	adds	r7, #24
  4007c4:	46bd      	mov	sp, r7
  4007c6:	bd80      	pop	{r7, pc}
  4007c8:	00400511 	.word	0x00400511
  4007cc:	004004dd 	.word	0x004004dd
  4007d0:	004004f9 	.word	0x004004f9
  4007d4:	0040055d 	.word	0x0040055d
  4007d8:	00400591 	.word	0x00400591
  4007dc:	004005c5 	.word	0x004005c5
  4007e0:	00400529 	.word	0x00400529
  4007e4:	004004bd 	.word	0x004004bd

004007e8 <tc_init>:
 */
void tc_init(
		Tc *p_tc,
		uint32_t ul_channel,
		uint32_t ul_mode)
{
  4007e8:	b480      	push	{r7}
  4007ea:	b087      	sub	sp, #28
  4007ec:	af00      	add	r7, sp, #0
  4007ee:	60f8      	str	r0, [r7, #12]
  4007f0:	60b9      	str	r1, [r7, #8]
  4007f2:	607a      	str	r2, [r7, #4]

	/* Validate inputs. */
	Assert(p_tc);
	Assert(ul_channel <
			(sizeof(p_tc->TC_CHANNEL) / sizeof(p_tc->TC_CHANNEL[0])));
	tc_channel = p_tc->TC_CHANNEL + ul_channel;
  4007f4:	68fa      	ldr	r2, [r7, #12]
  4007f6:	68bb      	ldr	r3, [r7, #8]
  4007f8:	019b      	lsls	r3, r3, #6
  4007fa:	4413      	add	r3, r2
  4007fc:	617b      	str	r3, [r7, #20]

	/*  Disable TC clock. */
	tc_channel->TC_CCR = TC_CCR_CLKDIS;
  4007fe:	697b      	ldr	r3, [r7, #20]
  400800:	2202      	movs	r2, #2
  400802:	601a      	str	r2, [r3, #0]

	/*  Disable interrupts. */
	tc_channel->TC_IDR = 0xFFFFFFFF;
  400804:	697b      	ldr	r3, [r7, #20]
  400806:	f04f 32ff 	mov.w	r2, #4294967295
  40080a:	629a      	str	r2, [r3, #40]	; 0x28

	/*  Clear status register. */
	tc_channel->TC_SR;
  40080c:	697b      	ldr	r3, [r7, #20]
  40080e:	6a1b      	ldr	r3, [r3, #32]

	/*  Set mode. */
	tc_channel->TC_CMR = ul_mode;
  400810:	697b      	ldr	r3, [r7, #20]
  400812:	687a      	ldr	r2, [r7, #4]
  400814:	605a      	str	r2, [r3, #4]
}
  400816:	bf00      	nop
  400818:	371c      	adds	r7, #28
  40081a:	46bd      	mov	sp, r7
  40081c:	f85d 7b04 	ldr.w	r7, [sp], #4
  400820:	4770      	bx	lr

00400822 <tc_start>:
 * \param[in] ul_channel Channel to configure
 */
void tc_start(
		Tc *p_tc,
		uint32_t ul_channel)
{
  400822:	b480      	push	{r7}
  400824:	b083      	sub	sp, #12
  400826:	af00      	add	r7, sp, #0
  400828:	6078      	str	r0, [r7, #4]
  40082a:	6039      	str	r1, [r7, #0]
	/* Validate inputs. */
	Assert(p_tc);
	Assert(ul_channel <
			(sizeof(p_tc->TC_CHANNEL) / sizeof(p_tc->TC_CHANNEL[0])));

	p_tc->TC_CHANNEL[ul_channel].TC_CCR = TC_CCR_CLKEN | TC_CCR_SWTRG;
  40082c:	687a      	ldr	r2, [r7, #4]
  40082e:	683b      	ldr	r3, [r7, #0]
  400830:	019b      	lsls	r3, r3, #6
  400832:	4413      	add	r3, r2
  400834:	2205      	movs	r2, #5
  400836:	601a      	str	r2, [r3, #0]
}
  400838:	bf00      	nop
  40083a:	370c      	adds	r7, #12
  40083c:	46bd      	mov	sp, r7
  40083e:	f85d 7b04 	ldr.w	r7, [sp], #4
  400842:	4770      	bx	lr

00400844 <tc_read_cv>:
 * \return The counter value.
 */
uint32_t tc_read_cv(
		Tc *p_tc,
		uint32_t ul_channel)
{
  400844:	b480      	push	{r7}
  400846:	b083      	sub	sp, #12
  400848:	af00      	add	r7, sp, #0
  40084a:	6078      	str	r0, [r7, #4]
  40084c:	6039      	str	r1, [r7, #0]
	/* Validate inputs. */
	Assert(p_tc);
	Assert(ul_channel <
			(sizeof(p_tc->TC_CHANNEL) / sizeof(p_tc->TC_CHANNEL[0])));

	return p_tc->TC_CHANNEL[ul_channel].TC_CV;
  40084e:	687a      	ldr	r2, [r7, #4]
  400850:	683b      	ldr	r3, [r7, #0]
  400852:	019b      	lsls	r3, r3, #6
  400854:	4413      	add	r3, r2
  400856:	3310      	adds	r3, #16
  400858:	681b      	ldr	r3, [r3, #0]
}
  40085a:	4618      	mov	r0, r3
  40085c:	370c      	adds	r7, #12
  40085e:	46bd      	mov	sp, r7
  400860:	f85d 7b04 	ldr.w	r7, [sp], #4
  400864:	4770      	bx	lr

00400866 <tc_read_rc>:
 * \return The Register C (RC) value.
 */
uint32_t tc_read_rc(
		Tc *p_tc,
		uint32_t ul_channel)
{
  400866:	b480      	push	{r7}
  400868:	b083      	sub	sp, #12
  40086a:	af00      	add	r7, sp, #0
  40086c:	6078      	str	r0, [r7, #4]
  40086e:	6039      	str	r1, [r7, #0]
	/* Validate inputs. */
	Assert(p_tc);
	Assert(ul_channel <
			(sizeof(p_tc->TC_CHANNEL) / sizeof(p_tc->TC_CHANNEL[0])));

	return p_tc->TC_CHANNEL[ul_channel].TC_RC;
  400870:	687a      	ldr	r2, [r7, #4]
  400872:	683b      	ldr	r3, [r7, #0]
  400874:	019b      	lsls	r3, r3, #6
  400876:	4413      	add	r3, r2
  400878:	331c      	adds	r3, #28
  40087a:	681b      	ldr	r3, [r3, #0]
}
  40087c:	4618      	mov	r0, r3
  40087e:	370c      	adds	r7, #12
  400880:	46bd      	mov	sp, r7
  400882:	f85d 7b04 	ldr.w	r7, [sp], #4
  400886:	4770      	bx	lr

00400888 <tc_write_rc>:
 */
void tc_write_rc(
		Tc *p_tc,
		uint32_t ul_channel,
		uint32_t ul_value)
{
  400888:	b480      	push	{r7}
  40088a:	b085      	sub	sp, #20
  40088c:	af00      	add	r7, sp, #0
  40088e:	60f8      	str	r0, [r7, #12]
  400890:	60b9      	str	r1, [r7, #8]
  400892:	607a      	str	r2, [r7, #4]
	/* Validate inputs. */
	Assert(p_tc);
	Assert(ul_channel <
			(sizeof(p_tc->TC_CHANNEL) / sizeof(p_tc->TC_CHANNEL[0])));

	p_tc->TC_CHANNEL[ul_channel].TC_RC = ul_value;
  400894:	68fa      	ldr	r2, [r7, #12]
  400896:	68bb      	ldr	r3, [r7, #8]
  400898:	019b      	lsls	r3, r3, #6
  40089a:	4413      	add	r3, r2
  40089c:	331c      	adds	r3, #28
  40089e:	687a      	ldr	r2, [r7, #4]
  4008a0:	601a      	str	r2, [r3, #0]
}
  4008a2:	bf00      	nop
  4008a4:	3714      	adds	r7, #20
  4008a6:	46bd      	mov	sp, r7
  4008a8:	f85d 7b04 	ldr.w	r7, [sp], #4
  4008ac:	4770      	bx	lr

004008ae <tc_enable_interrupt>:
 */
void tc_enable_interrupt(
		Tc *p_tc,
		uint32_t ul_channel,
		uint32_t ul_sources)
{
  4008ae:	b480      	push	{r7}
  4008b0:	b087      	sub	sp, #28
  4008b2:	af00      	add	r7, sp, #0
  4008b4:	60f8      	str	r0, [r7, #12]
  4008b6:	60b9      	str	r1, [r7, #8]
  4008b8:	607a      	str	r2, [r7, #4]

	/* Validate inputs. */
	Assert(p_tc);
	Assert(ul_channel <
			(sizeof(p_tc->TC_CHANNEL) / sizeof(p_tc->TC_CHANNEL[0])));
	tc_channel = p_tc->TC_CHANNEL + ul_channel;
  4008ba:	68fa      	ldr	r2, [r7, #12]
  4008bc:	68bb      	ldr	r3, [r7, #8]
  4008be:	019b      	lsls	r3, r3, #6
  4008c0:	4413      	add	r3, r2
  4008c2:	617b      	str	r3, [r7, #20]
	tc_channel->TC_IER = ul_sources;
  4008c4:	697b      	ldr	r3, [r7, #20]
  4008c6:	687a      	ldr	r2, [r7, #4]
  4008c8:	625a      	str	r2, [r3, #36]	; 0x24
}
  4008ca:	bf00      	nop
  4008cc:	371c      	adds	r7, #28
  4008ce:	46bd      	mov	sp, r7
  4008d0:	f85d 7b04 	ldr.w	r7, [sp], #4
  4008d4:	4770      	bx	lr

004008d6 <tc_get_interrupt_mask>:
 * \return The TC interrupt mask value.
 */
uint32_t tc_get_interrupt_mask(
		Tc *p_tc,
		uint32_t ul_channel)
{
  4008d6:	b480      	push	{r7}
  4008d8:	b085      	sub	sp, #20
  4008da:	af00      	add	r7, sp, #0
  4008dc:	6078      	str	r0, [r7, #4]
  4008de:	6039      	str	r1, [r7, #0]

	/* Validate inputs. */
	Assert(p_tc);
	Assert(ul_channel <
			(sizeof(p_tc->TC_CHANNEL) / sizeof(p_tc->TC_CHANNEL[0])));
	tc_channel = p_tc->TC_CHANNEL + ul_channel;
  4008e0:	687a      	ldr	r2, [r7, #4]
  4008e2:	683b      	ldr	r3, [r7, #0]
  4008e4:	019b      	lsls	r3, r3, #6
  4008e6:	4413      	add	r3, r2
  4008e8:	60fb      	str	r3, [r7, #12]
	return tc_channel->TC_IMR;
  4008ea:	68fb      	ldr	r3, [r7, #12]
  4008ec:	6adb      	ldr	r3, [r3, #44]	; 0x2c
}
  4008ee:	4618      	mov	r0, r3
  4008f0:	3714      	adds	r7, #20
  4008f2:	46bd      	mov	sp, r7
  4008f4:	f85d 7b04 	ldr.w	r7, [sp], #4
  4008f8:	4770      	bx	lr

004008fa <tc_get_status>:
 * \return The current TC status.
 */
uint32_t tc_get_status(
		Tc *p_tc,
		uint32_t ul_channel)
{
  4008fa:	b480      	push	{r7}
  4008fc:	b085      	sub	sp, #20
  4008fe:	af00      	add	r7, sp, #0
  400900:	6078      	str	r0, [r7, #4]
  400902:	6039      	str	r1, [r7, #0]
	/* Validate inputs. */
	Assert(p_tc);
	Assert(ul_channel <
			(sizeof(p_tc->TC_CHANNEL) / sizeof(p_tc->TC_CHANNEL[0])));
			
	tc_channel = p_tc->TC_CHANNEL + ul_channel;
  400904:	687a      	ldr	r2, [r7, #4]
  400906:	683b      	ldr	r3, [r7, #0]
  400908:	019b      	lsls	r3, r3, #6
  40090a:	4413      	add	r3, r2
  40090c:	60fb      	str	r3, [r7, #12]
	return tc_channel->TC_SR;
  40090e:	68fb      	ldr	r3, [r7, #12]
  400910:	6a1b      	ldr	r3, [r3, #32]
}
  400912:	4618      	mov	r0, r3
  400914:	3714      	adds	r7, #20
  400916:	46bd      	mov	sp, r7
  400918:	f85d 7b04 	ldr.w	r7, [sp], #4
  40091c:	4770      	bx	lr

0040091e <tc_find_mck_divisor>:
		uint32_t ul_freq,
		uint32_t ul_mck,
		uint32_t *p_uldiv,
		uint32_t *p_ultcclks,
		uint32_t ul_boardmck)
{
  40091e:	b480      	push	{r7}
  400920:	b08d      	sub	sp, #52	; 0x34
  400922:	af00      	add	r7, sp, #0
  400924:	60f8      	str	r0, [r7, #12]
  400926:	60b9      	str	r1, [r7, #8]
  400928:	607a      	str	r2, [r7, #4]
  40092a:	603b      	str	r3, [r7, #0]
	const uint32_t divisors[5] = { 2, 8, 32, 128,
  40092c:	2302      	movs	r3, #2
  40092e:	613b      	str	r3, [r7, #16]
  400930:	2308      	movs	r3, #8
  400932:	617b      	str	r3, [r7, #20]
  400934:	2320      	movs	r3, #32
  400936:	61bb      	str	r3, [r7, #24]
  400938:	2380      	movs	r3, #128	; 0x80
  40093a:	61fb      	str	r3, [r7, #28]
			ul_boardmck / FREQ_SLOW_CLOCK_EXT };
  40093c:	6bbb      	ldr	r3, [r7, #56]	; 0x38
  40093e:	0bdb      	lsrs	r3, r3, #15
	const uint32_t divisors[5] = { 2, 8, 32, 128,
  400940:	623b      	str	r3, [r7, #32]
	uint32_t ul_index;
	uint32_t ul_high, ul_low;

	/*  Satisfy frequency bound. */
	for (ul_index = 0;
  400942:	2300      	movs	r3, #0
  400944:	62fb      	str	r3, [r7, #44]	; 0x2c
  400946:	e01a      	b.n	40097e <tc_find_mck_divisor+0x60>
			ul_index < (sizeof(divisors) / sizeof(divisors[0]));
			ul_index++) {
		ul_high = ul_mck / divisors[ul_index];
  400948:	6afb      	ldr	r3, [r7, #44]	; 0x2c
  40094a:	009b      	lsls	r3, r3, #2
  40094c:	f107 0230 	add.w	r2, r7, #48	; 0x30
  400950:	4413      	add	r3, r2
  400952:	f853 3c20 	ldr.w	r3, [r3, #-32]
  400956:	68ba      	ldr	r2, [r7, #8]
  400958:	fbb2 f3f3 	udiv	r3, r2, r3
  40095c:	62bb      	str	r3, [r7, #40]	; 0x28
		ul_low  = ul_high / TC_DIV_FACTOR;
  40095e:	6abb      	ldr	r3, [r7, #40]	; 0x28
  400960:	0c1b      	lsrs	r3, r3, #16
  400962:	627b      	str	r3, [r7, #36]	; 0x24
		if (ul_freq > ul_high) {
  400964:	68fa      	ldr	r2, [r7, #12]
  400966:	6abb      	ldr	r3, [r7, #40]	; 0x28
  400968:	429a      	cmp	r2, r3
  40096a:	d901      	bls.n	400970 <tc_find_mck_divisor+0x52>
			return 0;
  40096c:	2300      	movs	r3, #0
  40096e:	e023      	b.n	4009b8 <tc_find_mck_divisor+0x9a>
		} else if (ul_freq >= ul_low) {
  400970:	68fa      	ldr	r2, [r7, #12]
  400972:	6a7b      	ldr	r3, [r7, #36]	; 0x24
  400974:	429a      	cmp	r2, r3
  400976:	d206      	bcs.n	400986 <tc_find_mck_divisor+0x68>
			ul_index++) {
  400978:	6afb      	ldr	r3, [r7, #44]	; 0x2c
  40097a:	3301      	adds	r3, #1
  40097c:	62fb      	str	r3, [r7, #44]	; 0x2c
	for (ul_index = 0;
  40097e:	6afb      	ldr	r3, [r7, #44]	; 0x2c
  400980:	2b04      	cmp	r3, #4
  400982:	d9e1      	bls.n	400948 <tc_find_mck_divisor+0x2a>
  400984:	e000      	b.n	400988 <tc_find_mck_divisor+0x6a>
			break;
  400986:	bf00      	nop
		}
	}
	if (ul_index >= (sizeof(divisors) / sizeof(divisors[0]))) {
  400988:	6afb      	ldr	r3, [r7, #44]	; 0x2c
  40098a:	2b04      	cmp	r3, #4
  40098c:	d901      	bls.n	400992 <tc_find_mck_divisor+0x74>
		return 0;
  40098e:	2300      	movs	r3, #0
  400990:	e012      	b.n	4009b8 <tc_find_mck_divisor+0x9a>
	}

	/*  Store results. */
	if (p_uldiv) {
  400992:	687b      	ldr	r3, [r7, #4]
  400994:	2b00      	cmp	r3, #0
  400996:	d008      	beq.n	4009aa <tc_find_mck_divisor+0x8c>
		*p_uldiv = divisors[ul_index];
  400998:	6afb      	ldr	r3, [r7, #44]	; 0x2c
  40099a:	009b      	lsls	r3, r3, #2
  40099c:	f107 0230 	add.w	r2, r7, #48	; 0x30
  4009a0:	4413      	add	r3, r2
  4009a2:	f853 2c20 	ldr.w	r2, [r3, #-32]
  4009a6:	687b      	ldr	r3, [r7, #4]
  4009a8:	601a      	str	r2, [r3, #0]
	}

	if (p_ultcclks) {
  4009aa:	683b      	ldr	r3, [r7, #0]
  4009ac:	2b00      	cmp	r3, #0
  4009ae:	d002      	beq.n	4009b6 <tc_find_mck_divisor+0x98>
		*p_ultcclks = ul_index;
  4009b0:	683b      	ldr	r3, [r7, #0]
  4009b2:	6afa      	ldr	r2, [r7, #44]	; 0x2c
  4009b4:	601a      	str	r2, [r3, #0]
	}

	return 1;
  4009b6:	2301      	movs	r3, #1
}
  4009b8:	4618      	mov	r0, r3
  4009ba:	3734      	adds	r7, #52	; 0x34
  4009bc:	46bd      	mov	sp, r7
  4009be:	f85d 7b04 	ldr.w	r7, [sp], #4
  4009c2:	4770      	bx	lr

004009c4 <twi_enable_master_mode>:
 * \brief Enable TWI master mode.
 *
 * \param p_twi Pointer to a TWI instance.
 */
void twi_enable_master_mode(Twi *p_twi)
{
  4009c4:	b480      	push	{r7}
  4009c6:	b083      	sub	sp, #12
  4009c8:	af00      	add	r7, sp, #0
  4009ca:	6078      	str	r0, [r7, #4]
	/* Set Master Disable bit and Slave Disable bit */
	p_twi->TWI_CR = TWI_CR_MSDIS;
  4009cc:	687b      	ldr	r3, [r7, #4]
  4009ce:	2208      	movs	r2, #8
  4009d0:	601a      	str	r2, [r3, #0]
	p_twi->TWI_CR = TWI_CR_SVDIS;
  4009d2:	687b      	ldr	r3, [r7, #4]
  4009d4:	2220      	movs	r2, #32
  4009d6:	601a      	str	r2, [r3, #0]

	/* Set Master Enable bit */
	p_twi->TWI_CR = TWI_CR_MSEN;
  4009d8:	687b      	ldr	r3, [r7, #4]
  4009da:	2204      	movs	r2, #4
  4009dc:	601a      	str	r2, [r3, #0]
}
  4009de:	bf00      	nop
  4009e0:	370c      	adds	r7, #12
  4009e2:	46bd      	mov	sp, r7
  4009e4:	f85d 7b04 	ldr.w	r7, [sp], #4
  4009e8:	4770      	bx	lr
	...

004009ec <twi_master_init>:
 * \param p_opt Options for initializing the TWI module (see \ref twi_options_t).
 *
 * \return TWI_SUCCESS if initialization is complete, error code otherwise.
 */
uint32_t twi_master_init(Twi *p_twi, const twi_options_t *p_opt)
{
  4009ec:	b580      	push	{r7, lr}
  4009ee:	b084      	sub	sp, #16
  4009f0:	af00      	add	r7, sp, #0
  4009f2:	6078      	str	r0, [r7, #4]
  4009f4:	6039      	str	r1, [r7, #0]
	uint32_t status = TWI_SUCCESS;
  4009f6:	2300      	movs	r3, #0
  4009f8:	60fb      	str	r3, [r7, #12]

	/* Disable TWI interrupts */
	p_twi->TWI_IDR = ~0UL;
  4009fa:	687b      	ldr	r3, [r7, #4]
  4009fc:	f04f 32ff 	mov.w	r2, #4294967295
  400a00:	629a      	str	r2, [r3, #40]	; 0x28

	/* Dummy read in status register */
	p_twi->TWI_SR;
  400a02:	687b      	ldr	r3, [r7, #4]
  400a04:	6a1b      	ldr	r3, [r3, #32]

	/* Reset TWI peripheral */
	twi_reset(p_twi);
  400a06:	6878      	ldr	r0, [r7, #4]
  400a08:	4b0e      	ldr	r3, [pc, #56]	; (400a44 <twi_master_init+0x58>)
  400a0a:	4798      	blx	r3

	twi_enable_master_mode(p_twi);
  400a0c:	6878      	ldr	r0, [r7, #4]
  400a0e:	4b0e      	ldr	r3, [pc, #56]	; (400a48 <twi_master_init+0x5c>)
  400a10:	4798      	blx	r3

	/* Select the speed */
	if (twi_set_speed(p_twi, p_opt->speed, p_opt->master_clk) == FAIL) {
  400a12:	683b      	ldr	r3, [r7, #0]
  400a14:	6859      	ldr	r1, [r3, #4]
  400a16:	683b      	ldr	r3, [r7, #0]
  400a18:	681b      	ldr	r3, [r3, #0]
  400a1a:	461a      	mov	r2, r3
  400a1c:	6878      	ldr	r0, [r7, #4]
  400a1e:	4b0b      	ldr	r3, [pc, #44]	; (400a4c <twi_master_init+0x60>)
  400a20:	4798      	blx	r3
  400a22:	4603      	mov	r3, r0
  400a24:	2b01      	cmp	r3, #1
  400a26:	d101      	bne.n	400a2c <twi_master_init+0x40>
		/* The desired speed setting is rejected */
		status = TWI_INVALID_ARGUMENT;
  400a28:	2301      	movs	r3, #1
  400a2a:	60fb      	str	r3, [r7, #12]
	}

	if (p_opt->smbus == 1) {
  400a2c:	683b      	ldr	r3, [r7, #0]
  400a2e:	7a5b      	ldrb	r3, [r3, #9]
  400a30:	2b01      	cmp	r3, #1
  400a32:	d102      	bne.n	400a3a <twi_master_init+0x4e>
		p_twi->TWI_CR = TWI_CR_QUICK;
  400a34:	687b      	ldr	r3, [r7, #4]
  400a36:	2240      	movs	r2, #64	; 0x40
  400a38:	601a      	str	r2, [r3, #0]
	}

	return status;
  400a3a:	68fb      	ldr	r3, [r7, #12]
}
  400a3c:	4618      	mov	r0, r3
  400a3e:	3710      	adds	r7, #16
  400a40:	46bd      	mov	sp, r7
  400a42:	bd80      	pop	{r7, pc}
  400a44:	00400d05 	.word	0x00400d05
  400a48:	004009c5 	.word	0x004009c5
  400a4c:	00400a51 	.word	0x00400a51

00400a50 <twi_set_speed>:
 *
 * \retval PASS New speed setting is accepted.
 * \retval FAIL New speed setting is rejected.
 */
uint32_t twi_set_speed(Twi *p_twi, uint32_t ul_speed, uint32_t ul_mck)
{
  400a50:	b480      	push	{r7}
  400a52:	b087      	sub	sp, #28
  400a54:	af00      	add	r7, sp, #0
  400a56:	60f8      	str	r0, [r7, #12]
  400a58:	60b9      	str	r1, [r7, #8]
  400a5a:	607a      	str	r2, [r7, #4]
	uint32_t ckdiv = 0;
  400a5c:	2300      	movs	r3, #0
  400a5e:	617b      	str	r3, [r7, #20]
	uint32_t c_lh_div;

	if (ul_speed > I2C_FAST_MODE_SPEED) {
  400a60:	68bb      	ldr	r3, [r7, #8]
  400a62:	4a16      	ldr	r2, [pc, #88]	; (400abc <twi_set_speed+0x6c>)
  400a64:	4293      	cmp	r3, r2
  400a66:	d901      	bls.n	400a6c <twi_set_speed+0x1c>
		return FAIL;
  400a68:	2301      	movs	r3, #1
  400a6a:	e021      	b.n	400ab0 <twi_set_speed+0x60>
	}

	c_lh_div = ul_mck / (ul_speed * TWI_CLK_DIVIDER) - TWI_CLK_CALC_ARGU;
  400a6c:	68bb      	ldr	r3, [r7, #8]
  400a6e:	005b      	lsls	r3, r3, #1
  400a70:	687a      	ldr	r2, [r7, #4]
  400a72:	fbb2 f3f3 	udiv	r3, r2, r3
  400a76:	3b03      	subs	r3, #3
  400a78:	613b      	str	r3, [r7, #16]

	/* cldiv must fit in 8 bits, ckdiv must fit in 3 bits */
	while ((c_lh_div > TWI_CLK_DIV_MAX) && (ckdiv < TWI_CLK_DIV_MIN)) {
  400a7a:	e005      	b.n	400a88 <twi_set_speed+0x38>
		/* Increase clock divider */
		ckdiv++;
  400a7c:	697b      	ldr	r3, [r7, #20]
  400a7e:	3301      	adds	r3, #1
  400a80:	617b      	str	r3, [r7, #20]
		/* Divide cldiv value */
		c_lh_div /= TWI_CLK_DIVIDER;
  400a82:	693b      	ldr	r3, [r7, #16]
  400a84:	085b      	lsrs	r3, r3, #1
  400a86:	613b      	str	r3, [r7, #16]
	while ((c_lh_div > TWI_CLK_DIV_MAX) && (ckdiv < TWI_CLK_DIV_MIN)) {
  400a88:	693b      	ldr	r3, [r7, #16]
  400a8a:	2bff      	cmp	r3, #255	; 0xff
  400a8c:	d902      	bls.n	400a94 <twi_set_speed+0x44>
  400a8e:	697b      	ldr	r3, [r7, #20]
  400a90:	2b06      	cmp	r3, #6
  400a92:	d9f3      	bls.n	400a7c <twi_set_speed+0x2c>
	}

	/* set clock waveform generator register */
	p_twi->TWI_CWGR =
			TWI_CWGR_CLDIV(c_lh_div) | TWI_CWGR_CHDIV(c_lh_div) |
  400a94:	693b      	ldr	r3, [r7, #16]
  400a96:	b2da      	uxtb	r2, r3
  400a98:	693b      	ldr	r3, [r7, #16]
  400a9a:	021b      	lsls	r3, r3, #8
  400a9c:	b29b      	uxth	r3, r3
  400a9e:	431a      	orrs	r2, r3
			TWI_CWGR_CKDIV(ckdiv);
  400aa0:	697b      	ldr	r3, [r7, #20]
  400aa2:	041b      	lsls	r3, r3, #16
  400aa4:	f403 23e0 	and.w	r3, r3, #458752	; 0x70000
			TWI_CWGR_CLDIV(c_lh_div) | TWI_CWGR_CHDIV(c_lh_div) |
  400aa8:	431a      	orrs	r2, r3
	p_twi->TWI_CWGR =
  400aaa:	68fb      	ldr	r3, [r7, #12]
  400aac:	611a      	str	r2, [r3, #16]

	return PASS;
  400aae:	2300      	movs	r3, #0
}
  400ab0:	4618      	mov	r0, r3
  400ab2:	371c      	adds	r7, #28
  400ab4:	46bd      	mov	sp, r7
  400ab6:	f85d 7b04 	ldr.w	r7, [sp], #4
  400aba:	4770      	bx	lr
  400abc:	00061a80 	.word	0x00061a80

00400ac0 <twi_mk_addr>:
 * which byte is the MSB to start with.
 *
 * Please see the device datasheet for details on this.
 */
uint32_t twi_mk_addr(const uint8_t *addr, int len)
{
  400ac0:	b480      	push	{r7}
  400ac2:	b085      	sub	sp, #20
  400ac4:	af00      	add	r7, sp, #0
  400ac6:	6078      	str	r0, [r7, #4]
  400ac8:	6039      	str	r1, [r7, #0]
	uint32_t val;

	if (len == 0)
  400aca:	683b      	ldr	r3, [r7, #0]
  400acc:	2b00      	cmp	r3, #0
  400ace:	d101      	bne.n	400ad4 <twi_mk_addr+0x14>
		return 0;
  400ad0:	2300      	movs	r3, #0
  400ad2:	e01d      	b.n	400b10 <twi_mk_addr+0x50>

	val = addr[0];
  400ad4:	687b      	ldr	r3, [r7, #4]
  400ad6:	781b      	ldrb	r3, [r3, #0]
  400ad8:	60fb      	str	r3, [r7, #12]
	if (len > 1) {
  400ada:	683b      	ldr	r3, [r7, #0]
  400adc:	2b01      	cmp	r3, #1
  400ade:	dd09      	ble.n	400af4 <twi_mk_addr+0x34>
		val <<= 8;
  400ae0:	68fb      	ldr	r3, [r7, #12]
  400ae2:	021b      	lsls	r3, r3, #8
  400ae4:	60fb      	str	r3, [r7, #12]
		val |= addr[1];
  400ae6:	687b      	ldr	r3, [r7, #4]
  400ae8:	3301      	adds	r3, #1
  400aea:	781b      	ldrb	r3, [r3, #0]
  400aec:	461a      	mov	r2, r3
  400aee:	68fb      	ldr	r3, [r7, #12]
  400af0:	4313      	orrs	r3, r2
  400af2:	60fb      	str	r3, [r7, #12]
	}
	if (len > 2) {
  400af4:	683b      	ldr	r3, [r7, #0]
  400af6:	2b02      	cmp	r3, #2
  400af8:	dd09      	ble.n	400b0e <twi_mk_addr+0x4e>
		val <<= 8;
  400afa:	68fb      	ldr	r3, [r7, #12]
  400afc:	021b      	lsls	r3, r3, #8
  400afe:	60fb      	str	r3, [r7, #12]
		val |= addr[2];
  400b00:	687b      	ldr	r3, [r7, #4]
  400b02:	3302      	adds	r3, #2
  400b04:	781b      	ldrb	r3, [r3, #0]
  400b06:	461a      	mov	r2, r3
  400b08:	68fb      	ldr	r3, [r7, #12]
  400b0a:	4313      	orrs	r3, r2
  400b0c:	60fb      	str	r3, [r7, #12]
	}
	return val;
  400b0e:	68fb      	ldr	r3, [r7, #12]
}
  400b10:	4618      	mov	r0, r3
  400b12:	3714      	adds	r7, #20
  400b14:	46bd      	mov	sp, r7
  400b16:	f85d 7b04 	ldr.w	r7, [sp], #4
  400b1a:	4770      	bx	lr

00400b1c <twi_master_read>:
 * \param p_packet Packet information and data (see \ref twi_packet_t).
 *
 * \return TWI_SUCCESS if all bytes were read, error code otherwise.
 */
uint32_t twi_master_read(Twi *p_twi, twi_packet_t *p_packet)
{
  400b1c:	b580      	push	{r7, lr}
  400b1e:	b088      	sub	sp, #32
  400b20:	af00      	add	r7, sp, #0
  400b22:	6078      	str	r0, [r7, #4]
  400b24:	6039      	str	r1, [r7, #0]
	uint32_t status;
	uint32_t cnt = p_packet->length;
  400b26:	683b      	ldr	r3, [r7, #0]
  400b28:	68db      	ldr	r3, [r3, #12]
  400b2a:	61fb      	str	r3, [r7, #28]
	uint8_t *buffer = p_packet->buffer;
  400b2c:	683b      	ldr	r3, [r7, #0]
  400b2e:	689b      	ldr	r3, [r3, #8]
  400b30:	61bb      	str	r3, [r7, #24]
	uint8_t stop_sent = 0;
  400b32:	2300      	movs	r3, #0
  400b34:	75fb      	strb	r3, [r7, #23]
	uint32_t timeout = TWI_TIMEOUT;;
  400b36:	f643 2398 	movw	r3, #15000	; 0x3a98
  400b3a:	613b      	str	r3, [r7, #16]
	
	/* Check argument */
	if (cnt == 0) {
  400b3c:	69fb      	ldr	r3, [r7, #28]
  400b3e:	2b00      	cmp	r3, #0
  400b40:	d101      	bne.n	400b46 <twi_master_read+0x2a>
		return TWI_INVALID_ARGUMENT;
  400b42:	2301      	movs	r3, #1
  400b44:	e069      	b.n	400c1a <twi_master_read+0xfe>
	}

	/* Set read mode, slave address and 3 internal address byte lengths */
	p_twi->TWI_MMR = 0;
  400b46:	687b      	ldr	r3, [r7, #4]
  400b48:	2200      	movs	r2, #0
  400b4a:	605a      	str	r2, [r3, #4]
	p_twi->TWI_MMR = TWI_MMR_MREAD | TWI_MMR_DADR(p_packet->chip) |
  400b4c:	683b      	ldr	r3, [r7, #0]
  400b4e:	7c1b      	ldrb	r3, [r3, #16]
  400b50:	041b      	lsls	r3, r3, #16
  400b52:	f403 02fe 	and.w	r2, r3, #8323072	; 0x7f0000
			((p_packet->addr_length << TWI_MMR_IADRSZ_Pos) &
  400b56:	683b      	ldr	r3, [r7, #0]
  400b58:	685b      	ldr	r3, [r3, #4]
  400b5a:	021b      	lsls	r3, r3, #8
  400b5c:	f403 7340 	and.w	r3, r3, #768	; 0x300
	p_twi->TWI_MMR = TWI_MMR_MREAD | TWI_MMR_DADR(p_packet->chip) |
  400b60:	4313      	orrs	r3, r2
  400b62:	f443 5280 	orr.w	r2, r3, #4096	; 0x1000
  400b66:	687b      	ldr	r3, [r7, #4]
  400b68:	605a      	str	r2, [r3, #4]
			TWI_MMR_IADRSZ_Msk);

	/* Set internal address for remote chip */
	p_twi->TWI_IADR = 0;
  400b6a:	687b      	ldr	r3, [r7, #4]
  400b6c:	2200      	movs	r2, #0
  400b6e:	60da      	str	r2, [r3, #12]
	p_twi->TWI_IADR = twi_mk_addr(p_packet->addr, p_packet->addr_length);
  400b70:	683a      	ldr	r2, [r7, #0]
  400b72:	683b      	ldr	r3, [r7, #0]
  400b74:	685b      	ldr	r3, [r3, #4]
  400b76:	4619      	mov	r1, r3
  400b78:	4610      	mov	r0, r2
  400b7a:	4b2a      	ldr	r3, [pc, #168]	; (400c24 <twi_master_read+0x108>)
  400b7c:	4798      	blx	r3
  400b7e:	4602      	mov	r2, r0
  400b80:	687b      	ldr	r3, [r7, #4]
  400b82:	60da      	str	r2, [r3, #12]

	/* Send a START condition */
	if (cnt == 1) {
  400b84:	69fb      	ldr	r3, [r7, #28]
  400b86:	2b01      	cmp	r3, #1
  400b88:	d105      	bne.n	400b96 <twi_master_read+0x7a>
		p_twi->TWI_CR = TWI_CR_START | TWI_CR_STOP;
  400b8a:	687b      	ldr	r3, [r7, #4]
  400b8c:	2203      	movs	r2, #3
  400b8e:	601a      	str	r2, [r3, #0]
		stop_sent = 1;
  400b90:	2301      	movs	r3, #1
  400b92:	75fb      	strb	r3, [r7, #23]
  400b94:	e034      	b.n	400c00 <twi_master_read+0xe4>
	} else {
		p_twi->TWI_CR = TWI_CR_START;
  400b96:	687b      	ldr	r3, [r7, #4]
  400b98:	2201      	movs	r2, #1
  400b9a:	601a      	str	r2, [r3, #0]
		stop_sent = 0;
  400b9c:	2300      	movs	r3, #0
  400b9e:	75fb      	strb	r3, [r7, #23]
	}

	while (cnt > 0) {
  400ba0:	e02e      	b.n	400c00 <twi_master_read+0xe4>
		status = p_twi->TWI_SR;
  400ba2:	687b      	ldr	r3, [r7, #4]
  400ba4:	6a1b      	ldr	r3, [r3, #32]
  400ba6:	60fb      	str	r3, [r7, #12]
		if (status & TWI_SR_NACK) {
  400ba8:	68fb      	ldr	r3, [r7, #12]
  400baa:	f403 7380 	and.w	r3, r3, #256	; 0x100
  400bae:	2b00      	cmp	r3, #0
  400bb0:	d001      	beq.n	400bb6 <twi_master_read+0x9a>
			return TWI_RECEIVE_NACK;
  400bb2:	2305      	movs	r3, #5
  400bb4:	e031      	b.n	400c1a <twi_master_read+0xfe>
		}

		if (!timeout--) {
  400bb6:	693b      	ldr	r3, [r7, #16]
  400bb8:	1e5a      	subs	r2, r3, #1
  400bba:	613a      	str	r2, [r7, #16]
  400bbc:	2b00      	cmp	r3, #0
  400bbe:	d101      	bne.n	400bc4 <twi_master_read+0xa8>
			return TWI_ERROR_TIMEOUT;
  400bc0:	2309      	movs	r3, #9
  400bc2:	e02a      	b.n	400c1a <twi_master_read+0xfe>
		}
		if (!(status & TWI_SR_RXRDY)) {
  400bc4:	68fb      	ldr	r3, [r7, #12]
  400bc6:	f003 0302 	and.w	r3, r3, #2
  400bca:	2b00      	cmp	r3, #0
  400bcc:	d100      	bne.n	400bd0 <twi_master_read+0xb4>
			continue;
  400bce:	e017      	b.n	400c00 <twi_master_read+0xe4>
		}

		/* Send STOP before reading TWI_RHR on the penultimate data */
		if (cnt == 2 && !stop_sent) {
  400bd0:	69fb      	ldr	r3, [r7, #28]
  400bd2:	2b02      	cmp	r3, #2
  400bd4:	d107      	bne.n	400be6 <twi_master_read+0xca>
  400bd6:	7dfb      	ldrb	r3, [r7, #23]
  400bd8:	2b00      	cmp	r3, #0
  400bda:	d104      	bne.n	400be6 <twi_master_read+0xca>
			p_twi->TWI_CR = TWI_CR_STOP;
  400bdc:	687b      	ldr	r3, [r7, #4]
  400bde:	2202      	movs	r2, #2
  400be0:	601a      	str	r2, [r3, #0]
			stop_sent = 1;
  400be2:	2301      	movs	r3, #1
  400be4:	75fb      	strb	r3, [r7, #23]
		}
		*buffer++ = p_twi->TWI_RHR;
  400be6:	69bb      	ldr	r3, [r7, #24]
  400be8:	1c5a      	adds	r2, r3, #1
  400bea:	61ba      	str	r2, [r7, #24]
  400bec:	687a      	ldr	r2, [r7, #4]
  400bee:	6b12      	ldr	r2, [r2, #48]	; 0x30
  400bf0:	b2d2      	uxtb	r2, r2
  400bf2:	701a      	strb	r2, [r3, #0]
		
		cnt--;
  400bf4:	69fb      	ldr	r3, [r7, #28]
  400bf6:	3b01      	subs	r3, #1
  400bf8:	61fb      	str	r3, [r7, #28]
		
		timeout = TWI_TIMEOUT;
  400bfa:	f643 2398 	movw	r3, #15000	; 0x3a98
  400bfe:	613b      	str	r3, [r7, #16]
	while (cnt > 0) {
  400c00:	69fb      	ldr	r3, [r7, #28]
  400c02:	2b00      	cmp	r3, #0
  400c04:	d1cd      	bne.n	400ba2 <twi_master_read+0x86>
	}

	while (!(p_twi->TWI_SR & TWI_SR_TXCOMP)) {
  400c06:	bf00      	nop
  400c08:	687b      	ldr	r3, [r7, #4]
  400c0a:	6a1b      	ldr	r3, [r3, #32]
  400c0c:	f003 0301 	and.w	r3, r3, #1
  400c10:	2b00      	cmp	r3, #0
  400c12:	d0f9      	beq.n	400c08 <twi_master_read+0xec>
	}

	p_twi->TWI_SR;
  400c14:	687b      	ldr	r3, [r7, #4]
  400c16:	6a1b      	ldr	r3, [r3, #32]

	return TWI_SUCCESS;
  400c18:	2300      	movs	r3, #0
}
  400c1a:	4618      	mov	r0, r3
  400c1c:	3720      	adds	r7, #32
  400c1e:	46bd      	mov	sp, r7
  400c20:	bd80      	pop	{r7, pc}
  400c22:	bf00      	nop
  400c24:	00400ac1 	.word	0x00400ac1

00400c28 <twi_master_write>:
 * \param p_packet Packet information and data (see \ref twi_packet_t).
 *
 * \return TWI_SUCCESS if all bytes were written, error code otherwise.
 */
uint32_t twi_master_write(Twi *p_twi, twi_packet_t *p_packet)
{
  400c28:	b580      	push	{r7, lr}
  400c2a:	b086      	sub	sp, #24
  400c2c:	af00      	add	r7, sp, #0
  400c2e:	6078      	str	r0, [r7, #4]
  400c30:	6039      	str	r1, [r7, #0]
	uint32_t status;
	uint32_t cnt = p_packet->length;
  400c32:	683b      	ldr	r3, [r7, #0]
  400c34:	68db      	ldr	r3, [r3, #12]
  400c36:	617b      	str	r3, [r7, #20]
	uint8_t *buffer = p_packet->buffer;
  400c38:	683b      	ldr	r3, [r7, #0]
  400c3a:	689b      	ldr	r3, [r3, #8]
  400c3c:	613b      	str	r3, [r7, #16]

	/* Check argument */
	if (cnt == 0) {
  400c3e:	697b      	ldr	r3, [r7, #20]
  400c40:	2b00      	cmp	r3, #0
  400c42:	d101      	bne.n	400c48 <twi_master_write+0x20>
		return TWI_INVALID_ARGUMENT;
  400c44:	2301      	movs	r3, #1
  400c46:	e056      	b.n	400cf6 <twi_master_write+0xce>
	}

	/* Set write mode, slave address and 3 internal address byte lengths */
	p_twi->TWI_MMR = 0;
  400c48:	687b      	ldr	r3, [r7, #4]
  400c4a:	2200      	movs	r2, #0
  400c4c:	605a      	str	r2, [r3, #4]
	p_twi->TWI_MMR = TWI_MMR_DADR(p_packet->chip) |
  400c4e:	683b      	ldr	r3, [r7, #0]
  400c50:	7c1b      	ldrb	r3, [r3, #16]
  400c52:	041b      	lsls	r3, r3, #16
  400c54:	f403 02fe 	and.w	r2, r3, #8323072	; 0x7f0000
			((p_packet->addr_length << TWI_MMR_IADRSZ_Pos) &
  400c58:	683b      	ldr	r3, [r7, #0]
  400c5a:	685b      	ldr	r3, [r3, #4]
  400c5c:	021b      	lsls	r3, r3, #8
  400c5e:	f403 7340 	and.w	r3, r3, #768	; 0x300
	p_twi->TWI_MMR = TWI_MMR_DADR(p_packet->chip) |
  400c62:	431a      	orrs	r2, r3
  400c64:	687b      	ldr	r3, [r7, #4]
  400c66:	605a      	str	r2, [r3, #4]
			TWI_MMR_IADRSZ_Msk);

	/* Set internal address for remote chip */
	p_twi->TWI_IADR = 0;
  400c68:	687b      	ldr	r3, [r7, #4]
  400c6a:	2200      	movs	r2, #0
  400c6c:	60da      	str	r2, [r3, #12]
	p_twi->TWI_IADR = twi_mk_addr(p_packet->addr, p_packet->addr_length);
  400c6e:	683a      	ldr	r2, [r7, #0]
  400c70:	683b      	ldr	r3, [r7, #0]
  400c72:	685b      	ldr	r3, [r3, #4]
  400c74:	4619      	mov	r1, r3
  400c76:	4610      	mov	r0, r2
  400c78:	4b21      	ldr	r3, [pc, #132]	; (400d00 <twi_master_write+0xd8>)
  400c7a:	4798      	blx	r3
  400c7c:	4602      	mov	r2, r0
  400c7e:	687b      	ldr	r3, [r7, #4]
  400c80:	60da      	str	r2, [r3, #12]

	/* Send all bytes */
	while (cnt > 0) {
  400c82:	e019      	b.n	400cb8 <twi_master_write+0x90>
		status = p_twi->TWI_SR;
  400c84:	687b      	ldr	r3, [r7, #4]
  400c86:	6a1b      	ldr	r3, [r3, #32]
  400c88:	60fb      	str	r3, [r7, #12]
		if (status & TWI_SR_NACK) {
  400c8a:	68fb      	ldr	r3, [r7, #12]
  400c8c:	f403 7380 	and.w	r3, r3, #256	; 0x100
  400c90:	2b00      	cmp	r3, #0
  400c92:	d001      	beq.n	400c98 <twi_master_write+0x70>
			return TWI_RECEIVE_NACK;
  400c94:	2305      	movs	r3, #5
  400c96:	e02e      	b.n	400cf6 <twi_master_write+0xce>
		}

		if (!(status & TWI_SR_TXRDY)) {
  400c98:	68fb      	ldr	r3, [r7, #12]
  400c9a:	f003 0304 	and.w	r3, r3, #4
  400c9e:	2b00      	cmp	r3, #0
  400ca0:	d100      	bne.n	400ca4 <twi_master_write+0x7c>
			continue;
  400ca2:	e009      	b.n	400cb8 <twi_master_write+0x90>
		}
		p_twi->TWI_THR = *buffer++;
  400ca4:	693b      	ldr	r3, [r7, #16]
  400ca6:	1c5a      	adds	r2, r3, #1
  400ca8:	613a      	str	r2, [r7, #16]
  400caa:	781b      	ldrb	r3, [r3, #0]
  400cac:	461a      	mov	r2, r3
  400cae:	687b      	ldr	r3, [r7, #4]
  400cb0:	635a      	str	r2, [r3, #52]	; 0x34

		cnt--;
  400cb2:	697b      	ldr	r3, [r7, #20]
  400cb4:	3b01      	subs	r3, #1
  400cb6:	617b      	str	r3, [r7, #20]
	while (cnt > 0) {
  400cb8:	697b      	ldr	r3, [r7, #20]
  400cba:	2b00      	cmp	r3, #0
  400cbc:	d1e2      	bne.n	400c84 <twi_master_write+0x5c>
	}

	while (1) {
		status = p_twi->TWI_SR;
  400cbe:	687b      	ldr	r3, [r7, #4]
  400cc0:	6a1b      	ldr	r3, [r3, #32]
  400cc2:	60fb      	str	r3, [r7, #12]
		if (status & TWI_SR_NACK) {
  400cc4:	68fb      	ldr	r3, [r7, #12]
  400cc6:	f403 7380 	and.w	r3, r3, #256	; 0x100
  400cca:	2b00      	cmp	r3, #0
  400ccc:	d001      	beq.n	400cd2 <twi_master_write+0xaa>
			return TWI_RECEIVE_NACK;
  400cce:	2305      	movs	r3, #5
  400cd0:	e011      	b.n	400cf6 <twi_master_write+0xce>
		}

		if (status & TWI_SR_TXRDY) {
  400cd2:	68fb      	ldr	r3, [r7, #12]
  400cd4:	f003 0304 	and.w	r3, r3, #4
  400cd8:	2b00      	cmp	r3, #0
  400cda:	d100      	bne.n	400cde <twi_master_write+0xb6>
		status = p_twi->TWI_SR;
  400cdc:	e7ef      	b.n	400cbe <twi_master_write+0x96>
			break;
  400cde:	bf00      	nop
		}
	}

	p_twi->TWI_CR = TWI_CR_STOP;
  400ce0:	687b      	ldr	r3, [r7, #4]
  400ce2:	2202      	movs	r2, #2
  400ce4:	601a      	str	r2, [r3, #0]

	while (!(p_twi->TWI_SR & TWI_SR_TXCOMP)) {
  400ce6:	bf00      	nop
  400ce8:	687b      	ldr	r3, [r7, #4]
  400cea:	6a1b      	ldr	r3, [r3, #32]
  400cec:	f003 0301 	and.w	r3, r3, #1
  400cf0:	2b00      	cmp	r3, #0
  400cf2:	d0f9      	beq.n	400ce8 <twi_master_write+0xc0>
	}

	return TWI_SUCCESS;
  400cf4:	2300      	movs	r3, #0
}
  400cf6:	4618      	mov	r0, r3
  400cf8:	3718      	adds	r7, #24
  400cfa:	46bd      	mov	sp, r7
  400cfc:	bd80      	pop	{r7, pc}
  400cfe:	bf00      	nop
  400d00:	00400ac1 	.word	0x00400ac1

00400d04 <twi_reset>:
 * \brief Reset TWI.
 *
 * \param p_twi Pointer to a TWI instance.
 */
void twi_reset(Twi *p_twi)
{
  400d04:	b480      	push	{r7}
  400d06:	b083      	sub	sp, #12
  400d08:	af00      	add	r7, sp, #0
  400d0a:	6078      	str	r0, [r7, #4]
	/* Set SWRST bit to reset TWI peripheral */
	p_twi->TWI_CR = TWI_CR_SWRST;
  400d0c:	687b      	ldr	r3, [r7, #4]
  400d0e:	2280      	movs	r2, #128	; 0x80
  400d10:	601a      	str	r2, [r3, #0]
	p_twi->TWI_RHR;
  400d12:	687b      	ldr	r3, [r7, #4]
  400d14:	6b1b      	ldr	r3, [r3, #48]	; 0x30
}
  400d16:	bf00      	nop
  400d18:	370c      	adds	r7, #12
  400d1a:	46bd      	mov	sp, r7
  400d1c:	f85d 7b04 	ldr.w	r7, [sp], #4
  400d20:	4770      	bx	lr
	...

00400d24 <NVIC_SetPriority>:
{
  400d24:	b480      	push	{r7}
  400d26:	b083      	sub	sp, #12
  400d28:	af00      	add	r7, sp, #0
  400d2a:	4603      	mov	r3, r0
  400d2c:	6039      	str	r1, [r7, #0]
  400d2e:	71fb      	strb	r3, [r7, #7]
  if(IRQn < 0) {
  400d30:	f997 3007 	ldrsb.w	r3, [r7, #7]
  400d34:	2b00      	cmp	r3, #0
  400d36:	da0b      	bge.n	400d50 <NVIC_SetPriority+0x2c>
    SCB->SHP[((uint32_t)(IRQn) & 0xF)-4] = ((priority << (8 - __NVIC_PRIO_BITS)) & 0xff); } /* set Priority for Cortex-M  System Interrupts */
  400d38:	490d      	ldr	r1, [pc, #52]	; (400d70 <NVIC_SetPriority+0x4c>)
  400d3a:	79fb      	ldrb	r3, [r7, #7]
  400d3c:	f003 030f 	and.w	r3, r3, #15
  400d40:	3b04      	subs	r3, #4
  400d42:	683a      	ldr	r2, [r7, #0]
  400d44:	b2d2      	uxtb	r2, r2
  400d46:	0112      	lsls	r2, r2, #4
  400d48:	b2d2      	uxtb	r2, r2
  400d4a:	440b      	add	r3, r1
  400d4c:	761a      	strb	r2, [r3, #24]
}
  400d4e:	e009      	b.n	400d64 <NVIC_SetPriority+0x40>
    NVIC->IP[(uint32_t)(IRQn)] = ((priority << (8 - __NVIC_PRIO_BITS)) & 0xff);    }        /* set Priority for device specific Interrupts  */
  400d50:	4908      	ldr	r1, [pc, #32]	; (400d74 <NVIC_SetPriority+0x50>)
  400d52:	f997 3007 	ldrsb.w	r3, [r7, #7]
  400d56:	683a      	ldr	r2, [r7, #0]
  400d58:	b2d2      	uxtb	r2, r2
  400d5a:	0112      	lsls	r2, r2, #4
  400d5c:	b2d2      	uxtb	r2, r2
  400d5e:	440b      	add	r3, r1
  400d60:	f883 2300 	strb.w	r2, [r3, #768]	; 0x300
}
  400d64:	bf00      	nop
  400d66:	370c      	adds	r7, #12
  400d68:	46bd      	mov	sp, r7
  400d6a:	f85d 7b04 	ldr.w	r7, [sp], #4
  400d6e:	4770      	bx	lr
  400d70:	e000ed00 	.word	0xe000ed00
  400d74:	e000e100 	.word	0xe000e100

00400d78 <SysTick_Config>:
    function <b>SysTick_Config</b> is not included. In this case, the file <b><i>device</i>.h</b>
    must contain a vendor-specific implementation of this function.

 */
__STATIC_INLINE uint32_t SysTick_Config(uint32_t ticks)
{
  400d78:	b580      	push	{r7, lr}
  400d7a:	b082      	sub	sp, #8
  400d7c:	af00      	add	r7, sp, #0
  400d7e:	6078      	str	r0, [r7, #4]
  if ((ticks - 1) > SysTick_LOAD_RELOAD_Msk)  return (1);      /* Reload value impossible */
  400d80:	687b      	ldr	r3, [r7, #4]
  400d82:	3b01      	subs	r3, #1
  400d84:	f1b3 7f80 	cmp.w	r3, #16777216	; 0x1000000
  400d88:	d301      	bcc.n	400d8e <SysTick_Config+0x16>
  400d8a:	2301      	movs	r3, #1
  400d8c:	e00f      	b.n	400dae <SysTick_Config+0x36>

  SysTick->LOAD  = ticks - 1;                                  /* set reload register */
  400d8e:	4a0a      	ldr	r2, [pc, #40]	; (400db8 <SysTick_Config+0x40>)
  400d90:	687b      	ldr	r3, [r7, #4]
  400d92:	3b01      	subs	r3, #1
  400d94:	6053      	str	r3, [r2, #4]
  NVIC_SetPriority (SysTick_IRQn, (1<<__NVIC_PRIO_BITS) - 1);  /* set Priority for Systick Interrupt */
  400d96:	210f      	movs	r1, #15
  400d98:	f04f 30ff 	mov.w	r0, #4294967295
  400d9c:	4b07      	ldr	r3, [pc, #28]	; (400dbc <SysTick_Config+0x44>)
  400d9e:	4798      	blx	r3
  SysTick->VAL   = 0;                                          /* Load the SysTick Counter Value */
  400da0:	4b05      	ldr	r3, [pc, #20]	; (400db8 <SysTick_Config+0x40>)
  400da2:	2200      	movs	r2, #0
  400da4:	609a      	str	r2, [r3, #8]
  SysTick->CTRL  = SysTick_CTRL_CLKSOURCE_Msk |
  400da6:	4b04      	ldr	r3, [pc, #16]	; (400db8 <SysTick_Config+0x40>)
  400da8:	2207      	movs	r2, #7
  400daa:	601a      	str	r2, [r3, #0]
                   SysTick_CTRL_TICKINT_Msk   |
                   SysTick_CTRL_ENABLE_Msk;                    /* Enable SysTick IRQ and SysTick Timer */
  return (0);                                                  /* Function successful */
  400dac:	2300      	movs	r3, #0
}
  400dae:	4618      	mov	r0, r3
  400db0:	3708      	adds	r7, #8
  400db2:	46bd      	mov	sp, r7
  400db4:	bd80      	pop	{r7, pc}
  400db6:	bf00      	nop
  400db8:	e000e010 	.word	0xe000e010
  400dbc:	00400d25 	.word	0x00400d25

00400dc0 <osc_get_rate>:

	return 0;
}

static inline uint32_t osc_get_rate(uint32_t ul_id)
{
  400dc0:	b480      	push	{r7}
  400dc2:	b083      	sub	sp, #12
  400dc4:	af00      	add	r7, sp, #0
  400dc6:	6078      	str	r0, [r7, #4]
	switch (ul_id) {
  400dc8:	687b      	ldr	r3, [r7, #4]
  400dca:	2b07      	cmp	r3, #7
  400dcc:	d825      	bhi.n	400e1a <osc_get_rate+0x5a>
  400dce:	a201      	add	r2, pc, #4	; (adr r2, 400dd4 <osc_get_rate+0x14>)
  400dd0:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
  400dd4:	00400df5 	.word	0x00400df5
  400dd8:	00400dfb 	.word	0x00400dfb
  400ddc:	00400e01 	.word	0x00400e01
  400de0:	00400e07 	.word	0x00400e07
  400de4:	00400e0b 	.word	0x00400e0b
  400de8:	00400e0f 	.word	0x00400e0f
  400dec:	00400e13 	.word	0x00400e13
  400df0:	00400e17 	.word	0x00400e17
	case OSC_SLCK_32K_RC:
		return OSC_SLCK_32K_RC_HZ;
  400df4:	f44f 43fa 	mov.w	r3, #32000	; 0x7d00
  400df8:	e010      	b.n	400e1c <osc_get_rate+0x5c>

#ifdef BOARD_FREQ_SLCK_XTAL
	case OSC_SLCK_32K_XTAL:
		return BOARD_FREQ_SLCK_XTAL;
  400dfa:	f44f 4300 	mov.w	r3, #32768	; 0x8000
  400dfe:	e00d      	b.n	400e1c <osc_get_rate+0x5c>
#endif

#ifdef BOARD_FREQ_SLCK_BYPASS
	case OSC_SLCK_32K_BYPASS:
		return BOARD_FREQ_SLCK_BYPASS;
  400e00:	f44f 4300 	mov.w	r3, #32768	; 0x8000
  400e04:	e00a      	b.n	400e1c <osc_get_rate+0x5c>
#endif

	case OSC_MAINCK_8M_RC:
		return OSC_MAINCK_8M_RC_HZ;
  400e06:	4b08      	ldr	r3, [pc, #32]	; (400e28 <osc_get_rate+0x68>)
  400e08:	e008      	b.n	400e1c <osc_get_rate+0x5c>

	case OSC_MAINCK_16M_RC:
		return OSC_MAINCK_16M_RC_HZ;
  400e0a:	4b08      	ldr	r3, [pc, #32]	; (400e2c <osc_get_rate+0x6c>)
  400e0c:	e006      	b.n	400e1c <osc_get_rate+0x5c>

	case OSC_MAINCK_24M_RC:
		return OSC_MAINCK_24M_RC_HZ;
  400e0e:	4b08      	ldr	r3, [pc, #32]	; (400e30 <osc_get_rate+0x70>)
  400e10:	e004      	b.n	400e1c <osc_get_rate+0x5c>

#ifdef BOARD_FREQ_MAINCK_XTAL
	case OSC_MAINCK_XTAL:
		return BOARD_FREQ_MAINCK_XTAL;
  400e12:	2300      	movs	r3, #0
  400e14:	e002      	b.n	400e1c <osc_get_rate+0x5c>
#endif

#ifdef BOARD_FREQ_MAINCK_BYPASS
	case OSC_MAINCK_BYPASS:
		return BOARD_FREQ_MAINCK_BYPASS;
  400e16:	2300      	movs	r3, #0
  400e18:	e000      	b.n	400e1c <osc_get_rate+0x5c>
#endif
	}

	return 0;
  400e1a:	2300      	movs	r3, #0
}
  400e1c:	4618      	mov	r0, r3
  400e1e:	370c      	adds	r7, #12
  400e20:	46bd      	mov	sp, r7
  400e22:	f85d 7b04 	ldr.w	r7, [sp], #4
  400e26:	4770      	bx	lr
  400e28:	007a1200 	.word	0x007a1200
  400e2c:	00f42400 	.word	0x00f42400
  400e30:	016e3600 	.word	0x016e3600

00400e34 <sysclk_get_main_hz>:
 */
#if (defined CONFIG_SYSCLK_DEFAULT_RETURNS_SLOW_OSC)
extern uint32_t sysclk_initialized;
#endif
static inline uint32_t sysclk_get_main_hz(void)
{
  400e34:	b580      	push	{r7, lr}
  400e36:	af00      	add	r7, sp, #0
	} else if (CONFIG_SYSCLK_SOURCE == SYSCLK_SRC_MAINCK_BYPASS) {
		return OSC_MAINCK_BYPASS_HZ;
	}
#ifdef CONFIG_PLL0_SOURCE
	else if (CONFIG_SYSCLK_SOURCE == SYSCLK_SRC_PLLACK) {
		return pll_get_default_rate(0);
  400e38:	2001      	movs	r0, #1
  400e3a:	4b04      	ldr	r3, [pc, #16]	; (400e4c <sysclk_get_main_hz+0x18>)
  400e3c:	4798      	blx	r3
  400e3e:	4602      	mov	r2, r0
  400e40:	f640 634e 	movw	r3, #3662	; 0xe4e
  400e44:	fb03 f302 	mul.w	r3, r3, r2

	else {
		/* unhandled_case(CONFIG_SYSCLK_SOURCE); */
		return 0;
	}
}
  400e48:	4618      	mov	r0, r3
  400e4a:	bd80      	pop	{r7, pc}
  400e4c:	00400dc1 	.word	0x00400dc1

00400e50 <sysclk_get_cpu_hz>:
 * clocks.
 *
 * \return Frequency of the CPU clock, in Hz.
 */
static inline uint32_t sysclk_get_cpu_hz(void)
{
  400e50:	b580      	push	{r7, lr}
  400e52:	af00      	add	r7, sp, #0
	/* CONFIG_SYSCLK_PRES is the register value for setting the expected */
	/* prescaler, not an immediate value. */
	return sysclk_get_main_hz() /
  400e54:	4b02      	ldr	r3, [pc, #8]	; (400e60 <sysclk_get_cpu_hz+0x10>)
  400e56:	4798      	blx	r3
  400e58:	4603      	mov	r3, r0
		((CONFIG_SYSCLK_PRES == SYSCLK_PRES_3) ? 3 :
			(1 << (CONFIG_SYSCLK_PRES >> PMC_MCKR_PRES_Pos)));
}
  400e5a:	4618      	mov	r0, r3
  400e5c:	bd80      	pop	{r7, pc}
  400e5e:	bf00      	nop
  400e60:	00400e35 	.word	0x00400e35

00400e64 <sysclk_enable_peripheral_clock>:
 * \brief Enable a peripheral's clock.
 *
 * \param ul_id Id (number) of the peripheral clock.
 */
static inline void sysclk_enable_peripheral_clock(uint32_t ul_id)
{
  400e64:	b580      	push	{r7, lr}
  400e66:	b082      	sub	sp, #8
  400e68:	af00      	add	r7, sp, #0
  400e6a:	6078      	str	r0, [r7, #4]
	pmc_enable_periph_clk(ul_id);
  400e6c:	6878      	ldr	r0, [r7, #4]
  400e6e:	4b03      	ldr	r3, [pc, #12]	; (400e7c <sysclk_enable_peripheral_clock+0x18>)
  400e70:	4798      	blx	r3
}
  400e72:	bf00      	nop
  400e74:	3708      	adds	r7, #8
  400e76:	46bd      	mov	sp, r7
  400e78:	bd80      	pop	{r7, pc}
  400e7a:	bf00      	nop
  400e7c:	00404401 	.word	0x00404401

00400e80 <ioport_toggle_pin_level>:
 * an output.
 *
 * \param pin IOPORT pin to toggle
 */
static inline void ioport_toggle_pin_level(ioport_pin_t pin)
{
  400e80:	b480      	push	{r7}
  400e82:	b08b      	sub	sp, #44	; 0x2c
  400e84:	af00      	add	r7, sp, #0
  400e86:	6078      	str	r0, [r7, #4]
  400e88:	687b      	ldr	r3, [r7, #4]
  400e8a:	627b      	str	r3, [r7, #36]	; 0x24
  400e8c:	6a7b      	ldr	r3, [r7, #36]	; 0x24
  400e8e:	623b      	str	r3, [r7, #32]
  400e90:	6a3b      	ldr	r3, [r7, #32]
  400e92:	61fb      	str	r3, [r7, #28]
typedef uint32_t ioport_port_t;
typedef uint32_t ioport_port_mask_t;

__always_inline static ioport_port_t arch_ioport_pin_to_port_id(ioport_pin_t pin)
{
	return pin >> 5;
  400e94:	69fb      	ldr	r3, [r7, #28]
  400e96:	095b      	lsrs	r3, r3, #5
  400e98:	61bb      	str	r3, [r7, #24]
	} else {
		return (Pio *)((uintptr_t)IOPORT_BASE_ADDRESS +
		       (IOPORT_PIO_OFFSET * port));
	}
#else
	return (Pio *)((uintptr_t)IOPORT_BASE_ADDRESS +
  400e9a:	69bb      	ldr	r3, [r7, #24]
  400e9c:	f503 1300 	add.w	r3, r3, #2097152	; 0x200000
  400ea0:	f203 7307 	addw	r3, r3, #1799	; 0x707
  400ea4:	025b      	lsls	r3, r3, #9
	return arch_ioport_port_to_base(port)->PIO_PDSR & mask;
}

__always_inline static void arch_ioport_toggle_pin_level(ioport_pin_t pin)
{
	Pio *port = arch_ioport_pin_to_base(pin);
  400ea6:	617b      	str	r3, [r7, #20]
  400ea8:	6a7b      	ldr	r3, [r7, #36]	; 0x24
  400eaa:	613b      	str	r3, [r7, #16]
	return 1U << (pin & 0x1F);
  400eac:	693b      	ldr	r3, [r7, #16]
  400eae:	f003 031f 	and.w	r3, r3, #31
  400eb2:	2201      	movs	r2, #1
  400eb4:	fa02 f303 	lsl.w	r3, r2, r3
	ioport_port_mask_t mask = arch_ioport_pin_to_mask(pin);
  400eb8:	60fb      	str	r3, [r7, #12]

	if (port->PIO_PDSR & arch_ioport_pin_to_mask(pin)) {
  400eba:	697b      	ldr	r3, [r7, #20]
  400ebc:	6bda      	ldr	r2, [r3, #60]	; 0x3c
  400ebe:	6a7b      	ldr	r3, [r7, #36]	; 0x24
  400ec0:	60bb      	str	r3, [r7, #8]
	return 1U << (pin & 0x1F);
  400ec2:	68bb      	ldr	r3, [r7, #8]
  400ec4:	f003 031f 	and.w	r3, r3, #31
  400ec8:	2101      	movs	r1, #1
  400eca:	fa01 f303 	lsl.w	r3, r1, r3
	if (port->PIO_PDSR & arch_ioport_pin_to_mask(pin)) {
  400ece:	4013      	ands	r3, r2
  400ed0:	2b00      	cmp	r3, #0
  400ed2:	d003      	beq.n	400edc <ioport_toggle_pin_level+0x5c>
		port->PIO_CODR = mask;
  400ed4:	697b      	ldr	r3, [r7, #20]
  400ed6:	68fa      	ldr	r2, [r7, #12]
  400ed8:	635a      	str	r2, [r3, #52]	; 0x34
	arch_ioport_toggle_pin_level(pin);
}
  400eda:	e002      	b.n	400ee2 <ioport_toggle_pin_level+0x62>
	} else {
		port->PIO_SODR = mask;
  400edc:	697b      	ldr	r3, [r7, #20]
  400ede:	68fa      	ldr	r2, [r7, #12]
  400ee0:	631a      	str	r2, [r3, #48]	; 0x30
  400ee2:	bf00      	nop
  400ee4:	372c      	adds	r7, #44	; 0x2c
  400ee6:	46bd      	mov	sp, r7
  400ee8:	f85d 7b04 	ldr.w	r7, [sp], #4
  400eec:	4770      	bx	lr
	...

00400ef0 <usart_serial_putchar>:
 *   \retval 1  The character was written.
 *   \retval 0  The function timed out before the USART transmitter became
 * ready to send.
 */
static inline int usart_serial_putchar(usart_if p_usart, const uint8_t c)
{
  400ef0:	b580      	push	{r7, lr}
  400ef2:	b082      	sub	sp, #8
  400ef4:	af00      	add	r7, sp, #0
  400ef6:	6078      	str	r0, [r7, #4]
  400ef8:	460b      	mov	r3, r1
  400efa:	70fb      	strb	r3, [r7, #3]
		while (usart_write(p_usart, c)!=0);
		return 1;
	}
#else
# ifdef USART0
	if (USART0 == p_usart) {
  400efc:	687b      	ldr	r3, [r7, #4]
  400efe:	4a3e      	ldr	r2, [pc, #248]	; (400ff8 <usart_serial_putchar+0x108>)
  400f00:	4293      	cmp	r3, r2
  400f02:	d10a      	bne.n	400f1a <usart_serial_putchar+0x2a>
		while (usart_write(p_usart, c)!=0);
  400f04:	bf00      	nop
  400f06:	78fb      	ldrb	r3, [r7, #3]
  400f08:	4619      	mov	r1, r3
  400f0a:	6878      	ldr	r0, [r7, #4]
  400f0c:	4b3b      	ldr	r3, [pc, #236]	; (400ffc <usart_serial_putchar+0x10c>)
  400f0e:	4798      	blx	r3
  400f10:	4603      	mov	r3, r0
  400f12:	2b00      	cmp	r3, #0
  400f14:	d1f7      	bne.n	400f06 <usart_serial_putchar+0x16>
		return 1;
  400f16:	2301      	movs	r3, #1
  400f18:	e069      	b.n	400fee <usart_serial_putchar+0xfe>
	}
# endif
# ifdef USART1
	if (USART1 == p_usart) {
  400f1a:	687b      	ldr	r3, [r7, #4]
  400f1c:	4a38      	ldr	r2, [pc, #224]	; (401000 <usart_serial_putchar+0x110>)
  400f1e:	4293      	cmp	r3, r2
  400f20:	d10a      	bne.n	400f38 <usart_serial_putchar+0x48>
		while (usart_write(p_usart, c)!=0);
  400f22:	bf00      	nop
  400f24:	78fb      	ldrb	r3, [r7, #3]
  400f26:	4619      	mov	r1, r3
  400f28:	6878      	ldr	r0, [r7, #4]
  400f2a:	4b34      	ldr	r3, [pc, #208]	; (400ffc <usart_serial_putchar+0x10c>)
  400f2c:	4798      	blx	r3
  400f2e:	4603      	mov	r3, r0
  400f30:	2b00      	cmp	r3, #0
  400f32:	d1f7      	bne.n	400f24 <usart_serial_putchar+0x34>
		return 1;
  400f34:	2301      	movs	r3, #1
  400f36:	e05a      	b.n	400fee <usart_serial_putchar+0xfe>
	}
# endif
# ifdef USART2
	if (USART2 == p_usart) {
  400f38:	687b      	ldr	r3, [r7, #4]
  400f3a:	4a32      	ldr	r2, [pc, #200]	; (401004 <usart_serial_putchar+0x114>)
  400f3c:	4293      	cmp	r3, r2
  400f3e:	d10a      	bne.n	400f56 <usart_serial_putchar+0x66>
		while (usart_write(p_usart, c)!=0);
  400f40:	bf00      	nop
  400f42:	78fb      	ldrb	r3, [r7, #3]
  400f44:	4619      	mov	r1, r3
  400f46:	6878      	ldr	r0, [r7, #4]
  400f48:	4b2c      	ldr	r3, [pc, #176]	; (400ffc <usart_serial_putchar+0x10c>)
  400f4a:	4798      	blx	r3
  400f4c:	4603      	mov	r3, r0
  400f4e:	2b00      	cmp	r3, #0
  400f50:	d1f7      	bne.n	400f42 <usart_serial_putchar+0x52>
		return 1;
  400f52:	2301      	movs	r3, #1
  400f54:	e04b      	b.n	400fee <usart_serial_putchar+0xfe>
	}
# endif
# ifdef USART3
	if (USART3 == p_usart) {
  400f56:	687b      	ldr	r3, [r7, #4]
  400f58:	4a2b      	ldr	r2, [pc, #172]	; (401008 <usart_serial_putchar+0x118>)
  400f5a:	4293      	cmp	r3, r2
  400f5c:	d10a      	bne.n	400f74 <usart_serial_putchar+0x84>
		while (usart_write(p_usart, c)!=0);
  400f5e:	bf00      	nop
  400f60:	78fb      	ldrb	r3, [r7, #3]
  400f62:	4619      	mov	r1, r3
  400f64:	6878      	ldr	r0, [r7, #4]
  400f66:	4b25      	ldr	r3, [pc, #148]	; (400ffc <usart_serial_putchar+0x10c>)
  400f68:	4798      	blx	r3
  400f6a:	4603      	mov	r3, r0
  400f6c:	2b00      	cmp	r3, #0
  400f6e:	d1f7      	bne.n	400f60 <usart_serial_putchar+0x70>
		return 1;
  400f70:	2301      	movs	r3, #1
  400f72:	e03c      	b.n	400fee <usart_serial_putchar+0xfe>
	}
# endif
# ifdef USART4
	if (USART4 == p_usart) {
  400f74:	687b      	ldr	r3, [r7, #4]
  400f76:	4a25      	ldr	r2, [pc, #148]	; (40100c <usart_serial_putchar+0x11c>)
  400f78:	4293      	cmp	r3, r2
  400f7a:	d10a      	bne.n	400f92 <usart_serial_putchar+0xa2>
		while (usart_write(p_usart, c)!=0);
  400f7c:	bf00      	nop
  400f7e:	78fb      	ldrb	r3, [r7, #3]
  400f80:	4619      	mov	r1, r3
  400f82:	6878      	ldr	r0, [r7, #4]
  400f84:	4b1d      	ldr	r3, [pc, #116]	; (400ffc <usart_serial_putchar+0x10c>)
  400f86:	4798      	blx	r3
  400f88:	4603      	mov	r3, r0
  400f8a:	2b00      	cmp	r3, #0
  400f8c:	d1f7      	bne.n	400f7e <usart_serial_putchar+0x8e>
		return 1;
  400f8e:	2301      	movs	r3, #1
  400f90:	e02d      	b.n	400fee <usart_serial_putchar+0xfe>
	}
# endif
# ifdef USART5
	if (USART5 == p_usart) {
  400f92:	687b      	ldr	r3, [r7, #4]
  400f94:	4a1e      	ldr	r2, [pc, #120]	; (401010 <usart_serial_putchar+0x120>)
  400f96:	4293      	cmp	r3, r2
  400f98:	d10a      	bne.n	400fb0 <usart_serial_putchar+0xc0>
		while (usart_write(p_usart, c)!=0);
  400f9a:	bf00      	nop
  400f9c:	78fb      	ldrb	r3, [r7, #3]
  400f9e:	4619      	mov	r1, r3
  400fa0:	6878      	ldr	r0, [r7, #4]
  400fa2:	4b16      	ldr	r3, [pc, #88]	; (400ffc <usart_serial_putchar+0x10c>)
  400fa4:	4798      	blx	r3
  400fa6:	4603      	mov	r3, r0
  400fa8:	2b00      	cmp	r3, #0
  400faa:	d1f7      	bne.n	400f9c <usart_serial_putchar+0xac>
		return 1;
  400fac:	2301      	movs	r3, #1
  400fae:	e01e      	b.n	400fee <usart_serial_putchar+0xfe>
	}
# endif
# ifdef USART6
	if (USART6 == p_usart) {
  400fb0:	687b      	ldr	r3, [r7, #4]
  400fb2:	4a18      	ldr	r2, [pc, #96]	; (401014 <usart_serial_putchar+0x124>)
  400fb4:	4293      	cmp	r3, r2
  400fb6:	d10a      	bne.n	400fce <usart_serial_putchar+0xde>
		while (usart_write(p_usart, c)!=0);
  400fb8:	bf00      	nop
  400fba:	78fb      	ldrb	r3, [r7, #3]
  400fbc:	4619      	mov	r1, r3
  400fbe:	6878      	ldr	r0, [r7, #4]
  400fc0:	4b0e      	ldr	r3, [pc, #56]	; (400ffc <usart_serial_putchar+0x10c>)
  400fc2:	4798      	blx	r3
  400fc4:	4603      	mov	r3, r0
  400fc6:	2b00      	cmp	r3, #0
  400fc8:	d1f7      	bne.n	400fba <usart_serial_putchar+0xca>
		return 1;
  400fca:	2301      	movs	r3, #1
  400fcc:	e00f      	b.n	400fee <usart_serial_putchar+0xfe>
	}
# endif
# ifdef USART7
	if (USART7 == p_usart) {
  400fce:	687b      	ldr	r3, [r7, #4]
  400fd0:	4a11      	ldr	r2, [pc, #68]	; (401018 <usart_serial_putchar+0x128>)
  400fd2:	4293      	cmp	r3, r2
  400fd4:	d10a      	bne.n	400fec <usart_serial_putchar+0xfc>
		while (usart_write(p_usart, c)!=0);
  400fd6:	bf00      	nop
  400fd8:	78fb      	ldrb	r3, [r7, #3]
  400fda:	4619      	mov	r1, r3
  400fdc:	6878      	ldr	r0, [r7, #4]
  400fde:	4b07      	ldr	r3, [pc, #28]	; (400ffc <usart_serial_putchar+0x10c>)
  400fe0:	4798      	blx	r3
  400fe2:	4603      	mov	r3, r0
  400fe4:	2b00      	cmp	r3, #0
  400fe6:	d1f7      	bne.n	400fd8 <usart_serial_putchar+0xe8>
		return 1;
  400fe8:	2301      	movs	r3, #1
  400fea:	e000      	b.n	400fee <usart_serial_putchar+0xfe>
	}
# endif
#endif /* ifdef USART */

	return 0;
  400fec:	2300      	movs	r3, #0
}
  400fee:	4618      	mov	r0, r3
  400ff0:	3708      	adds	r7, #8
  400ff2:	46bd      	mov	sp, r7
  400ff4:	bd80      	pop	{r7, pc}
  400ff6:	bf00      	nop
  400ff8:	4000c200 	.word	0x4000c200
  400ffc:	004035d9 	.word	0x004035d9
  401000:	40020200 	.word	0x40020200
  401004:	40024200 	.word	0x40024200
  401008:	40018200 	.word	0x40018200
  40100c:	4001c200 	.word	0x4001c200
  401010:	40008200 	.word	0x40008200
  401014:	40040200 	.word	0x40040200
  401018:	40034200 	.word	0x40034200

0040101c <inv_icm20948_reset_states>:
/** @brief Reset and initialize driver states
 *  @param[in] s             handle to driver states structure
 */
static inline void inv_icm20948_reset_states(struct inv_icm20948 * s,
		const struct inv_icm20948_serif * serif)
{
  40101c:	b5b0      	push	{r4, r5, r7, lr}
  40101e:	b082      	sub	sp, #8
  401020:	af00      	add	r7, sp, #0
  401022:	6078      	str	r0, [r7, #4]
  401024:	6039      	str	r1, [r7, #0]
	assert(icm20948_instance == 0);

	memset(s, 0, sizeof(*s));
  401026:	f44f 629f 	mov.w	r2, #1272	; 0x4f8
  40102a:	2100      	movs	r1, #0
  40102c:	6878      	ldr	r0, [r7, #4]
  40102e:	4b09      	ldr	r3, [pc, #36]	; (401054 <inv_icm20948_reset_states+0x38>)
  401030:	4798      	blx	r3
	s->serif = *serif;
  401032:	687a      	ldr	r2, [r7, #4]
  401034:	683b      	ldr	r3, [r7, #0]
  401036:	4614      	mov	r4, r2
  401038:	461d      	mov	r5, r3
  40103a:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
  40103c:	c40f      	stmia	r4!, {r0, r1, r2, r3}
  40103e:	e895 0003 	ldmia.w	r5, {r0, r1}
  401042:	e884 0003 	stmia.w	r4, {r0, r1}
	icm20948_instance = s;
  401046:	4a04      	ldr	r2, [pc, #16]	; (401058 <inv_icm20948_reset_states+0x3c>)
  401048:	687b      	ldr	r3, [r7, #4]
  40104a:	6013      	str	r3, [r2, #0]
}
  40104c:	bf00      	nop
  40104e:	3708      	adds	r7, #8
  401050:	46bd      	mov	sp, r7
  401052:	bdb0      	pop	{r4, r5, r7, pc}
  401054:	00414241 	.word	0x00414241
  401058:	20002118 	.word	0x20002118

0040105c <InvScheduler_init>:

/** @brief Reset scheduler states
 *  @param[in] scheduler    handle to scheduler
 */
static inline void InvScheduler_init(InvScheduler *scheduler)
{
  40105c:	b480      	push	{r7}
  40105e:	b083      	sub	sp, #12
  401060:	af00      	add	r7, sp, #0
  401062:	6078      	str	r0, [r7, #4]
	scheduler->currentTime  = 0;
  401064:	687b      	ldr	r3, [r7, #4]
  401066:	2200      	movs	r2, #0
  401068:	601a      	str	r2, [r3, #0]
	scheduler->queue        = 0;
  40106a:	687b      	ldr	r3, [r7, #4]
  40106c:	2200      	movs	r2, #0
  40106e:	605a      	str	r2, [r3, #4]
	scheduler->contextLock  = 0;
  401070:	687b      	ldr	r3, [r7, #4]
  401072:	2200      	movs	r2, #0
  401074:	609a      	str	r2, [r3, #8]
}
  401076:	bf00      	nop
  401078:	370c      	adds	r7, #12
  40107a:	46bd      	mov	sp, r7
  40107c:	f85d 7b04 	ldr.w	r7, [sp], #4
  401080:	4770      	bx	lr
	...

00401084 <InvScheduler_initTask>:
/** @brief Simitlar to InvScheduler_initTaskDo() but allow to set a name
 */
static inline void InvScheduler_initTask(InvScheduler *scheduler,
		InvSchedulerTask *task, const char *name, void (*func)(void *),
		void *arg, uint8_t prio, uint32_t period)
{
  401084:	b590      	push	{r4, r7, lr}
  401086:	b087      	sub	sp, #28
  401088:	af02      	add	r7, sp, #8
  40108a:	60f8      	str	r0, [r7, #12]
  40108c:	60b9      	str	r1, [r7, #8]
  40108e:	607a      	str	r2, [r7, #4]
  401090:	603b      	str	r3, [r7, #0]
	InvScheduler_initTaskDo(scheduler, task, func, arg, prio, period);
  401092:	6abb      	ldr	r3, [r7, #40]	; 0x28
  401094:	9301      	str	r3, [sp, #4]
  401096:	f897 3024 	ldrb.w	r3, [r7, #36]	; 0x24
  40109a:	9300      	str	r3, [sp, #0]
  40109c:	6a3b      	ldr	r3, [r7, #32]
  40109e:	683a      	ldr	r2, [r7, #0]
  4010a0:	68b9      	ldr	r1, [r7, #8]
  4010a2:	68f8      	ldr	r0, [r7, #12]
  4010a4:	4c02      	ldr	r4, [pc, #8]	; (4010b0 <InvScheduler_initTask+0x2c>)
  4010a6:	47a0      	blx	r4
#ifdef INVSCHEDULER_TASK_NAME
	task->name = name;
#else
	(void)name;
#endif
}
  4010a8:	bf00      	nop
  4010aa:	3714      	adds	r7, #20
  4010ac:	46bd      	mov	sp, r7
  4010ae:	bd90      	pop	{r4, r7, pc}
  4010b0:	0040fc25 	.word	0x0040fc25

004010b4 <RingByteBuffer_isEmpty>:

/** @brief 		Check for ring buffer emptyness
	@return 	Return true if ring buffer is empty, false otherwise
*/
static inline inv_bool_t RingByteBuffer_isEmpty(const RingByteBuffer *self)
{
  4010b4:	b480      	push	{r7}
  4010b6:	b083      	sub	sp, #12
  4010b8:	af00      	add	r7, sp, #0
  4010ba:	6078      	str	r0, [r7, #4]
	ASSERT(self);

	return (self->end == self->start && self->msbEnd == self->msbStart);
  4010bc:	687b      	ldr	r3, [r7, #4]
  4010be:	891a      	ldrh	r2, [r3, #8]
  4010c0:	687b      	ldr	r3, [r7, #4]
  4010c2:	88db      	ldrh	r3, [r3, #6]
  4010c4:	429a      	cmp	r2, r3
  4010c6:	d107      	bne.n	4010d8 <RingByteBuffer_isEmpty+0x24>
  4010c8:	687b      	ldr	r3, [r7, #4]
  4010ca:	7ada      	ldrb	r2, [r3, #11]
  4010cc:	687b      	ldr	r3, [r7, #4]
  4010ce:	7a9b      	ldrb	r3, [r3, #10]
  4010d0:	429a      	cmp	r2, r3
  4010d2:	d101      	bne.n	4010d8 <RingByteBuffer_isEmpty+0x24>
  4010d4:	2301      	movs	r3, #1
  4010d6:	e000      	b.n	4010da <RingByteBuffer_isEmpty+0x26>
  4010d8:	2300      	movs	r3, #0
}
  4010da:	4618      	mov	r0, r3
  4010dc:	370c      	adds	r7, #12
  4010de:	46bd      	mov	sp, r7
  4010e0:	f85d 7b04 	ldr.w	r7, [sp], #4
  4010e4:	4770      	bx	lr
	...

004010e8 <BlinkerLedTaskMain>:
#endif

/*
* BlinkerLedTaskMain - Task that blinks the LED.
*/
static void BlinkerLedTaskMain(void * arg){
  4010e8:	b580      	push	{r7, lr}
  4010ea:	b082      	sub	sp, #8
  4010ec:	af00      	add	r7, sp, #0
  4010ee:	6078      	str	r0, [r7, #4]
	(void)arg;

	ioport_toggle_pin_level(LED_0_PIN);
  4010f0:	2006      	movs	r0, #6
  4010f2:	4b03      	ldr	r3, [pc, #12]	; (401100 <BlinkerLedTaskMain+0x18>)
  4010f4:	4798      	blx	r3
}
  4010f6:	bf00      	nop
  4010f8:	3708      	adds	r7, #8
  4010fa:	46bd      	mov	sp, r7
  4010fc:	bd80      	pop	{r7, pc}
  4010fe:	bf00      	nop
  401100:	00400e81 	.word	0x00400e81

00401104 <inv_icm20948_get_time_us>:

uint64_t inv_icm20948_get_time_us(void){
  401104:	b598      	push	{r3, r4, r7, lr}
  401106:	af00      	add	r7, sp, #0
	return InvEMDFrontEnd_getTimestampUs();
  401108:	4b03      	ldr	r3, [pc, #12]	; (401118 <inv_icm20948_get_time_us+0x14>)
  40110a:	4798      	blx	r3
  40110c:	4603      	mov	r3, r0
  40110e:	460c      	mov	r4, r1
}
  401110:	4618      	mov	r0, r3
  401112:	4621      	mov	r1, r4
  401114:	bd98      	pop	{r3, r4, r7, pc}
  401116:	bf00      	nop
  401118:	0040322d 	.word	0x0040322d

0040111c <CommandHandlerTaskMain>:

/*
* CommandHandlerTaskMain - Task that monitors the UART
*/
static void CommandHandlerTaskMain(void * arg){
  40111c:	b580      	push	{r7, lr}
  40111e:	b084      	sub	sp, #16
  401120:	af00      	add	r7, sp, #0
  401122:	6078      	str	r0, [r7, #4]
	(void)arg;

	int byte;
	do {
		byte = EOF;
  401124:	f04f 33ff 	mov.w	r3, #4294967295
  401128:	60fb      	str	r3, [r7, #12]
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
  40112a:	b672      	cpsid	i
		__disable_irq();

		if(!RingByteBuffer_isEmpty(&uart_rx_rb)) {
  40112c:	480e      	ldr	r0, [pc, #56]	; (401168 <CommandHandlerTaskMain+0x4c>)
  40112e:	4b0f      	ldr	r3, [pc, #60]	; (40116c <CommandHandlerTaskMain+0x50>)
  401130:	4798      	blx	r3
  401132:	4603      	mov	r3, r0
  401134:	2b00      	cmp	r3, #0
  401136:	d104      	bne.n	401142 <CommandHandlerTaskMain+0x26>
			byte = RingByteBuffer_popByte(&uart_rx_rb);
  401138:	480b      	ldr	r0, [pc, #44]	; (401168 <CommandHandlerTaskMain+0x4c>)
  40113a:	4b0d      	ldr	r3, [pc, #52]	; (401170 <CommandHandlerTaskMain+0x54>)
  40113c:	4798      	blx	r3
  40113e:	4603      	mov	r3, r0
  401140:	60fb      	str	r3, [r7, #12]
  __ASM volatile ("cpsie i" : : : "memory");
  401142:	b662      	cpsie	i
		}
		__enable_irq();

		if(byte != EOF) {
  401144:	68fb      	ldr	r3, [r7, #12]
  401146:	f1b3 3fff 	cmp.w	r3, #4294967295
  40114a:	d005      	beq.n	401158 <CommandHandlerTaskMain+0x3c>
			DynProTransportUart_rxProcessByte(&transport, (uint8_t)byte);
  40114c:	68fb      	ldr	r3, [r7, #12]
  40114e:	b2db      	uxtb	r3, r3
  401150:	4619      	mov	r1, r3
  401152:	4808      	ldr	r0, [pc, #32]	; (401174 <CommandHandlerTaskMain+0x58>)
  401154:	4b08      	ldr	r3, [pc, #32]	; (401178 <CommandHandlerTaskMain+0x5c>)
  401156:	4798      	blx	r3
		}
	} while(byte != EOF);
  401158:	68fb      	ldr	r3, [r7, #12]
  40115a:	f1b3 3fff 	cmp.w	r3, #4294967295
  40115e:	d1e1      	bne.n	401124 <CommandHandlerTaskMain+0x8>
}
  401160:	bf00      	nop
  401162:	3710      	adds	r7, #16
  401164:	46bd      	mov	sp, r7
  401166:	bd80      	pop	{r7, pc}
  401168:	20002068 	.word	0x20002068
  40116c:	004010b5 	.word	0x004010b5
  401170:	0040fe0f 	.word	0x0040fe0f
  401174:	20001b20 	.word	0x20001b20
  401178:	0040f5ad 	.word	0x0040f5ad

0040117c <main>:

int main (void){
  40117c:	b590      	push	{r4, r7, lr}
  40117e:	b08d      	sub	sp, #52	; 0x34
  401180:	af04      	add	r7, sp, #16

	int rc = 0;
  401182:	2300      	movs	r3, #0
  401184:	61fb      	str	r3, [r7, #28]

	/* Hardware initialization */
	sysclk_init();
  401186:	4b4b      	ldr	r3, [pc, #300]	; (4012b4 <main+0x138>)
  401188:	4798      	blx	r3
	board_init();
  40118a:	4b4b      	ldr	r3, [pc, #300]	; (4012b8 <main+0x13c>)
  40118c:	4798      	blx	r3
	sysclk_enable_peripheral_clock(ID_TC0);
  40118e:	2017      	movs	r0, #23
  401190:	4b4a      	ldr	r3, [pc, #296]	; (4012bc <main+0x140>)
  401192:	4798      	blx	r3

	/* Configure Device - Host Interface */
	configure_console();
  401194:	4b4a      	ldr	r3, [pc, #296]	; (4012c0 <main+0x144>)
  401196:	4798      	blx	r3

#ifdef INV_MSG_ENABLE
	/* Setup message logging */
	INV_MSG_SETUP(INV_MSG_ENABLE, msg_printer);
  401198:	494a      	ldr	r1, [pc, #296]	; (4012c4 <main+0x148>)
  40119a:	2005      	movs	r0, #5
  40119c:	4b4a      	ldr	r3, [pc, #296]	; (4012c8 <main+0x14c>)
  40119e:	4798      	blx	r3
#endif

	INV_MSG(INV_MSG_LEVEL_INFO, "##########################");
  4011a0:	494a      	ldr	r1, [pc, #296]	; (4012cc <main+0x150>)
  4011a2:	2003      	movs	r0, #3
  4011a4:	4b4a      	ldr	r3, [pc, #296]	; (4012d0 <main+0x154>)
  4011a6:	4798      	blx	r3
	INV_MSG(INV_MSG_LEVEL_INFO, "     ICM20948 example     ");
  4011a8:	494a      	ldr	r1, [pc, #296]	; (4012d4 <main+0x158>)
  4011aa:	2003      	movs	r0, #3
  4011ac:	4b48      	ldr	r3, [pc, #288]	; (4012d0 <main+0x154>)
  4011ae:	4798      	blx	r3
	INV_MSG(INV_MSG_LEVEL_INFO, "     Ver: %s", EMD_RELEASE_VERSION_STRING);
  4011b0:	4a49      	ldr	r2, [pc, #292]	; (4012d8 <main+0x15c>)
  4011b2:	494a      	ldr	r1, [pc, #296]	; (4012dc <main+0x160>)
  4011b4:	2003      	movs	r0, #3
  4011b6:	4b46      	ldr	r3, [pc, #280]	; (4012d0 <main+0x154>)
  4011b8:	4798      	blx	r3
	INV_MSG(INV_MSG_LEVEL_INFO, "##########################");
  4011ba:	4944      	ldr	r1, [pc, #272]	; (4012cc <main+0x150>)
  4011bc:	2003      	movs	r0, #3
  4011be:	4b44      	ldr	r3, [pc, #272]	; (4012d0 <main+0x154>)
  4011c0:	4798      	blx	r3

	/* Initialize External Sensor Interrupt */
	ext_int_initialize(&ext_interrupt_handler);
  4011c2:	4847      	ldr	r0, [pc, #284]	; (4012e0 <main+0x164>)
  4011c4:	4b47      	ldr	r3, [pc, #284]	; (4012e4 <main+0x168>)
  4011c6:	4798      	blx	r3
	interface_initialize();
  4011c8:	4b47      	ldr	r3, [pc, #284]	; (4012e8 <main+0x16c>)
  4011ca:	4798      	blx	r3

	/* Configure sysTick Timer */
	SysTick_Config(sysclk_get_cpu_hz() / MILLISECONDS_PER_SECOND);
  4011cc:	4b47      	ldr	r3, [pc, #284]	; (4012ec <main+0x170>)
  4011ce:	4798      	blx	r3
  4011d0:	4602      	mov	r2, r0
  4011d2:	4b47      	ldr	r3, [pc, #284]	; (4012f0 <main+0x174>)
  4011d4:	fba3 2302 	umull	r2, r3, r3, r2
  4011d8:	099b      	lsrs	r3, r3, #6
  4011da:	4618      	mov	r0, r3
  4011dc:	4b45      	ldr	r3, [pc, #276]	; (4012f4 <main+0x178>)
  4011de:	4798      	blx	r3

	/*
	* Initialize icm20948 serif structure
	*/
	struct inv_icm20948_serif icm20948_serif;
	icm20948_serif.context   = 0; /* no need */
  4011e0:	2300      	movs	r3, #0
  4011e2:	607b      	str	r3, [r7, #4]
	icm20948_serif.read_reg  = idd_io_hal_read_reg;
  4011e4:	4b44      	ldr	r3, [pc, #272]	; (4012f8 <main+0x17c>)
  4011e6:	60bb      	str	r3, [r7, #8]
	icm20948_serif.write_reg = idd_io_hal_write_reg;
  4011e8:	4b44      	ldr	r3, [pc, #272]	; (4012fc <main+0x180>)
  4011ea:	60fb      	str	r3, [r7, #12]
	icm20948_serif.max_read  = 1024*16; /* maximum number of bytes allowed per serial read */
  4011ec:	f44f 4380 	mov.w	r3, #16384	; 0x4000
  4011f0:	613b      	str	r3, [r7, #16]
	icm20948_serif.max_write = 1024*16; /* maximum number of bytes allowed per serial write */
  4011f2:	f44f 4380 	mov.w	r3, #16384	; 0x4000
  4011f6:	617b      	str	r3, [r7, #20]

	icm20948_serif.is_spi = interface_is_SPI();
  4011f8:	4b41      	ldr	r3, [pc, #260]	; (401300 <main+0x184>)
  4011fa:	4798      	blx	r3
  4011fc:	4603      	mov	r3, r0
  4011fe:	61bb      	str	r3, [r7, #24]

	/*
	* Reset icm20948 driver states
	*/
	inv_icm20948_reset_states(&icm_device, &icm20948_serif);
  401200:	1d3b      	adds	r3, r7, #4
  401202:	4619      	mov	r1, r3
  401204:	483f      	ldr	r0, [pc, #252]	; (401304 <main+0x188>)
  401206:	4b40      	ldr	r3, [pc, #256]	; (401308 <main+0x18c>)
  401208:	4798      	blx	r3

	inv_icm20948_register_aux_compass(&icm_device, INV_ICM20948_COMPASS_ID_AK09916, AK0991x_DEFAULT_I2C_ADDR);
  40120a:	220c      	movs	r2, #12
  40120c:	2103      	movs	r1, #3
  40120e:	483d      	ldr	r0, [pc, #244]	; (401304 <main+0x188>)
  401210:	4b3e      	ldr	r3, [pc, #248]	; (40130c <main+0x190>)
  401212:	4798      	blx	r3

	/*
	* Setup the icm20948 device
	*/
	rc = icm20948_sensor_setup();
  401214:	4b3e      	ldr	r3, [pc, #248]	; (401310 <main+0x194>)
  401216:	4798      	blx	r3
  401218:	61f8      	str	r0, [r7, #28]

	/*
	* Now that Icm20948 device was initialized, we can proceed with DMP image loading
	* This step is mandatory as DMP image are not store in non volatile memory
	*/
	rc += load_dmp3();
  40121a:	4b3e      	ldr	r3, [pc, #248]	; (401314 <main+0x198>)
  40121c:	4798      	blx	r3
  40121e:	4602      	mov	r2, r0
  401220:	69fb      	ldr	r3, [r7, #28]
  401222:	4413      	add	r3, r2
  401224:	61fb      	str	r3, [r7, #28]
	check_rc(rc, "Error sensor_setup/DMP loading.");
  401226:	493c      	ldr	r1, [pc, #240]	; (401318 <main+0x19c>)
  401228:	69f8      	ldr	r0, [r7, #28]
  40122a:	4b3c      	ldr	r3, [pc, #240]	; (40131c <main+0x1a0>)
  40122c:	4798      	blx	r3

	/*
	* Initialize Dynamic protocol stuff
	*/
	DynProTransportUart_init(&transport, iddwrapper_transport_event_cb, 0);
  40122e:	2200      	movs	r2, #0
  401230:	493b      	ldr	r1, [pc, #236]	; (401320 <main+0x1a4>)
  401232:	483c      	ldr	r0, [pc, #240]	; (401324 <main+0x1a8>)
  401234:	4b3c      	ldr	r3, [pc, #240]	; (401328 <main+0x1ac>)
  401236:	4798      	blx	r3
	DynProtocol_init(&protocol, iddwrapper_protocol_event_cb, 0);
  401238:	2200      	movs	r2, #0
  40123a:	493c      	ldr	r1, [pc, #240]	; (40132c <main+0x1b0>)
  40123c:	483c      	ldr	r0, [pc, #240]	; (401330 <main+0x1b4>)
  40123e:	4b3d      	ldr	r3, [pc, #244]	; (401334 <main+0x1b8>)
  401240:	4798      	blx	r3

	InvScheduler_init(&scheduler);
  401242:	483d      	ldr	r0, [pc, #244]	; (401338 <main+0x1bc>)
  401244:	4b3d      	ldr	r3, [pc, #244]	; (40133c <main+0x1c0>)
  401246:	4798      	blx	r3
	InvScheduler_initTask(&scheduler, &commandHandlerTask, "commandHandlerTask", CommandHandlerTaskMain, 0, INVSCHEDULER_TASK_PRIO_MIN, 1);
  401248:	2301      	movs	r3, #1
  40124a:	9302      	str	r3, [sp, #8]
  40124c:	2301      	movs	r3, #1
  40124e:	9301      	str	r3, [sp, #4]
  401250:	2300      	movs	r3, #0
  401252:	9300      	str	r3, [sp, #0]
  401254:	4b3a      	ldr	r3, [pc, #232]	; (401340 <main+0x1c4>)
  401256:	4a3b      	ldr	r2, [pc, #236]	; (401344 <main+0x1c8>)
  401258:	493b      	ldr	r1, [pc, #236]	; (401348 <main+0x1cc>)
  40125a:	4837      	ldr	r0, [pc, #220]	; (401338 <main+0x1bc>)
  40125c:	4c3b      	ldr	r4, [pc, #236]	; (40134c <main+0x1d0>)
  40125e:	47a0      	blx	r4
	InvScheduler_initTask(&scheduler, &blinkerLedTask, "blinkerLedTask", BlinkerLedTaskMain, 0, INVSCHEDULER_TASK_PRIO_MIN+1, 1000000/SCHEDULER_PERIOD);
  401260:	f44f 737a 	mov.w	r3, #1000	; 0x3e8
  401264:	9302      	str	r3, [sp, #8]
  401266:	2302      	movs	r3, #2
  401268:	9301      	str	r3, [sp, #4]
  40126a:	2300      	movs	r3, #0
  40126c:	9300      	str	r3, [sp, #0]
  40126e:	4b38      	ldr	r3, [pc, #224]	; (401350 <main+0x1d4>)
  401270:	4a38      	ldr	r2, [pc, #224]	; (401354 <main+0x1d8>)
  401272:	4939      	ldr	r1, [pc, #228]	; (401358 <main+0x1dc>)
  401274:	4830      	ldr	r0, [pc, #192]	; (401338 <main+0x1bc>)
  401276:	4c35      	ldr	r4, [pc, #212]	; (40134c <main+0x1d0>)
  401278:	47a0      	blx	r4
	InvScheduler_startTask(&blinkerLedTask, 0);
  40127a:	2100      	movs	r1, #0
  40127c:	4836      	ldr	r0, [pc, #216]	; (401358 <main+0x1dc>)
  40127e:	4b37      	ldr	r3, [pc, #220]	; (40135c <main+0x1e0>)
  401280:	4798      	blx	r3
	InvScheduler_startTask(&commandHandlerTask, 0);
  401282:	2100      	movs	r1, #0
  401284:	4830      	ldr	r0, [pc, #192]	; (401348 <main+0x1cc>)
  401286:	4b35      	ldr	r3, [pc, #212]	; (40135c <main+0x1e0>)
  401288:	4798      	blx	r3

	hw_timer_start(20);		// Start the timestamp timer at 20 Hz.
  40128a:	2014      	movs	r0, #20
  40128c:	4b34      	ldr	r3, [pc, #208]	; (401360 <main+0x1e4>)
  40128e:	4798      	blx	r3
	while (1) {
		InvScheduler_dispatchTasks(&scheduler);
  401290:	4829      	ldr	r0, [pc, #164]	; (401338 <main+0x1bc>)
  401292:	4b34      	ldr	r3, [pc, #208]	; (401364 <main+0x1e8>)
  401294:	4798      	blx	r3

		if (irq_from_device == 1) {
  401296:	4b34      	ldr	r3, [pc, #208]	; (401368 <main+0x1ec>)
  401298:	681b      	ldr	r3, [r3, #0]
  40129a:	2b01      	cmp	r3, #1
  40129c:	d1f8      	bne.n	401290 <main+0x114>
			inv_icm20948_poll_sensor(&icm_device, (void *)0, build_sensor_event_data);
  40129e:	4a33      	ldr	r2, [pc, #204]	; (40136c <main+0x1f0>)
  4012a0:	2100      	movs	r1, #0
  4012a2:	4818      	ldr	r0, [pc, #96]	; (401304 <main+0x188>)
  4012a4:	4b32      	ldr	r3, [pc, #200]	; (401370 <main+0x1f4>)
  4012a6:	4798      	blx	r3
  __ASM volatile ("cpsid i" : : : "memory");
  4012a8:	b672      	cpsid	i

			__disable_irq();
			irq_from_device = 0;
  4012aa:	4b2f      	ldr	r3, [pc, #188]	; (401368 <main+0x1ec>)
  4012ac:	2200      	movs	r2, #0
  4012ae:	601a      	str	r2, [r3, #0]
  __ASM volatile ("cpsie i" : : : "memory");
  4012b0:	b662      	cpsie	i
		InvScheduler_dispatchTasks(&scheduler);
  4012b2:	e7ed      	b.n	401290 <main+0x114>
  4012b4:	00403bc1 	.word	0x00403bc1
  4012b8:	0040404d 	.word	0x0040404d
  4012bc:	00400e65 	.word	0x00400e65
  4012c0:	00402f41 	.word	0x00402f41
  4012c4:	00401375 	.word	0x00401375
  4012c8:	0040fcd5 	.word	0x0040fcd5
  4012cc:	00417f88 	.word	0x00417f88
  4012d0:	0040fd19 	.word	0x0040fd19
  4012d4:	00417fa4 	.word	0x00417fa4
  4012d8:	00417fc0 	.word	0x00417fc0
  4012dc:	00417fc8 	.word	0x00417fc8
  4012e0:	00402ec9 	.word	0x00402ec9
  4012e4:	00402ee1 	.word	0x00402ee1
  4012e8:	00403149 	.word	0x00403149
  4012ec:	00400e51 	.word	0x00400e51
  4012f0:	10624dd3 	.word	0x10624dd3
  4012f4:	00400d79 	.word	0x00400d79
  4012f8:	00403339 	.word	0x00403339
  4012fc:	0040336d 	.word	0x0040336d
  401300:	00403139 	.word	0x00403139
  401304:	20001b30 	.word	0x20001b30
  401308:	0040101d 	.word	0x0040101d
  40130c:	004048d9 	.word	0x004048d9
  401310:	00401769 	.word	0x00401769
  401314:	004016a1 	.word	0x004016a1
  401318:	00417fd8 	.word	0x00417fd8
  40131c:	004018a9 	.word	0x004018a9
  401320:	00401981 	.word	0x00401981
  401324:	20001b20 	.word	0x20001b20
  401328:	0040f57d 	.word	0x0040f57d
  40132c:	004018e5 	.word	0x004018e5
  401330:	20001888 	.word	0x20001888
  401334:	0040ef5d 	.word	0x0040ef5d
  401338:	20002048 	.word	0x20002048
  40133c:	0040105d 	.word	0x0040105d
  401340:	0040111d 	.word	0x0040111d
  401344:	00417ff8 	.word	0x00417ff8
  401348:	20000dc0 	.word	0x20000dc0
  40134c:	00401085 	.word	0x00401085
  401350:	004010e9 	.word	0x004010e9
  401354:	0041800c 	.word	0x0041800c
  401358:	20000d9c 	.word	0x20000d9c
  40135c:	0040fcb5 	.word	0x0040fcb5
  401360:	00403171 	.word	0x00403171
  401364:	0040fbf5 	.word	0x0040fbf5
  401368:	20000d98 	.word	0x20000d98
  40136c:	00401a79 	.word	0x00401a79
  401370:	0040b039 	.word	0x0040b039

00401374 <msg_printer>:

#ifdef INV_MSG_ENABLE
/*
* Printer function for message facility
*/
static void msg_printer(int level, const char * str, va_list ap){
  401374:	b5b0      	push	{r4, r5, r7, lr}
  401376:	b08c      	sub	sp, #48	; 0x30
  401378:	af00      	add	r7, sp, #0
  40137a:	60f8      	str	r0, [r7, #12]
  40137c:	60b9      	str	r1, [r7, #8]
  40137e:	607a      	str	r2, [r7, #4]

	static char out_str[256]; /* static to limit stack usage */
	unsigned idx = 0;
  401380:	2300      	movs	r3, #0
  401382:	62bb      	str	r3, [r7, #40]	; 0x28
	const char * ptr = out_str;
  401384:	4b2f      	ldr	r3, [pc, #188]	; (401444 <msg_printer+0xd0>)
  401386:	62fb      	str	r3, [r7, #44]	; 0x2c
	const char * s[INV_MSG_LEVEL_MAX] = {
  401388:	4b2f      	ldr	r3, [pc, #188]	; (401448 <msg_printer+0xd4>)
  40138a:	f107 0410 	add.w	r4, r7, #16
  40138e:	461d      	mov	r5, r3
  401390:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
  401392:	c40f      	stmia	r4!, {r0, r1, r2, r3}
  401394:	e895 0003 	ldmia.w	r5, {r0, r1}
  401398:	e884 0003 	stmia.w	r4, {r0, r1}
		"[W] ", // INV_MSG_LEVEL_WARNING
		"[I] ", // INV_MSG_LEVEL_INFO
		"[V] ", // INV_MSG_LEVEL_VERBOSE
		"[D] ", // INV_MSG_LEVEL_DEBUG
	};
	idx += snprintf(&out_str[idx], sizeof(out_str) - idx, "%s", s[level]);
  40139c:	6abb      	ldr	r3, [r7, #40]	; 0x28
  40139e:	4a29      	ldr	r2, [pc, #164]	; (401444 <msg_printer+0xd0>)
  4013a0:	1898      	adds	r0, r3, r2
  4013a2:	6abb      	ldr	r3, [r7, #40]	; 0x28
  4013a4:	f5c3 7180 	rsb	r1, r3, #256	; 0x100
  4013a8:	68fb      	ldr	r3, [r7, #12]
  4013aa:	009b      	lsls	r3, r3, #2
  4013ac:	f107 0230 	add.w	r2, r7, #48	; 0x30
  4013b0:	4413      	add	r3, r2
  4013b2:	f853 3c20 	ldr.w	r3, [r3, #-32]
  4013b6:	4a25      	ldr	r2, [pc, #148]	; (40144c <msg_printer+0xd8>)
  4013b8:	4c25      	ldr	r4, [pc, #148]	; (401450 <msg_printer+0xdc>)
  4013ba:	47a0      	blx	r4
  4013bc:	4603      	mov	r3, r0
  4013be:	461a      	mov	r2, r3
  4013c0:	6abb      	ldr	r3, [r7, #40]	; 0x28
  4013c2:	4413      	add	r3, r2
  4013c4:	62bb      	str	r3, [r7, #40]	; 0x28
	if(idx >= (sizeof(out_str)))
  4013c6:	6abb      	ldr	r3, [r7, #40]	; 0x28
  4013c8:	2bff      	cmp	r3, #255	; 0xff
  4013ca:	d832      	bhi.n	401432 <msg_printer+0xbe>
		return;
	idx += vsnprintf(&out_str[idx], sizeof(out_str) - idx, str, ap);
  4013cc:	6abb      	ldr	r3, [r7, #40]	; 0x28
  4013ce:	4a1d      	ldr	r2, [pc, #116]	; (401444 <msg_printer+0xd0>)
  4013d0:	1898      	adds	r0, r3, r2
  4013d2:	6abb      	ldr	r3, [r7, #40]	; 0x28
  4013d4:	f5c3 7180 	rsb	r1, r3, #256	; 0x100
  4013d8:	687b      	ldr	r3, [r7, #4]
  4013da:	68ba      	ldr	r2, [r7, #8]
  4013dc:	4c1d      	ldr	r4, [pc, #116]	; (401454 <msg_printer+0xe0>)
  4013de:	47a0      	blx	r4
  4013e0:	4603      	mov	r3, r0
  4013e2:	461a      	mov	r2, r3
  4013e4:	6abb      	ldr	r3, [r7, #40]	; 0x28
  4013e6:	4413      	add	r3, r2
  4013e8:	62bb      	str	r3, [r7, #40]	; 0x28
	if(idx >= (sizeof(out_str)))
  4013ea:	6abb      	ldr	r3, [r7, #40]	; 0x28
  4013ec:	2bff      	cmp	r3, #255	; 0xff
  4013ee:	d822      	bhi.n	401436 <msg_printer+0xc2>
		return;
	idx += snprintf(&out_str[idx], sizeof(out_str) - idx, "\r\n");
  4013f0:	6abb      	ldr	r3, [r7, #40]	; 0x28
  4013f2:	4a14      	ldr	r2, [pc, #80]	; (401444 <msg_printer+0xd0>)
  4013f4:	1898      	adds	r0, r3, r2
  4013f6:	6abb      	ldr	r3, [r7, #40]	; 0x28
  4013f8:	f5c3 7380 	rsb	r3, r3, #256	; 0x100
  4013fc:	4a16      	ldr	r2, [pc, #88]	; (401458 <msg_printer+0xe4>)
  4013fe:	4619      	mov	r1, r3
  401400:	4b13      	ldr	r3, [pc, #76]	; (401450 <msg_printer+0xdc>)
  401402:	4798      	blx	r3
  401404:	4603      	mov	r3, r0
  401406:	461a      	mov	r2, r3
  401408:	6abb      	ldr	r3, [r7, #40]	; 0x28
  40140a:	4413      	add	r3, r2
  40140c:	62bb      	str	r3, [r7, #40]	; 0x28
	if(idx >= (sizeof(out_str)))
  40140e:	6abb      	ldr	r3, [r7, #40]	; 0x28
  401410:	2bff      	cmp	r3, #255	; 0xff
  401412:	d812      	bhi.n	40143a <msg_printer+0xc6>
		return;

	while(*ptr != '\0') {
  401414:	e008      	b.n	401428 <msg_printer+0xb4>
		usart_serial_putchar(DEBUG_UART, *ptr);
  401416:	6afb      	ldr	r3, [r7, #44]	; 0x2c
  401418:	781b      	ldrb	r3, [r3, #0]
  40141a:	4619      	mov	r1, r3
  40141c:	480f      	ldr	r0, [pc, #60]	; (40145c <msg_printer+0xe8>)
  40141e:	4b10      	ldr	r3, [pc, #64]	; (401460 <msg_printer+0xec>)
  401420:	4798      	blx	r3
		++ptr;
  401422:	6afb      	ldr	r3, [r7, #44]	; 0x2c
  401424:	3301      	adds	r3, #1
  401426:	62fb      	str	r3, [r7, #44]	; 0x2c
	while(*ptr != '\0') {
  401428:	6afb      	ldr	r3, [r7, #44]	; 0x2c
  40142a:	781b      	ldrb	r3, [r3, #0]
  40142c:	2b00      	cmp	r3, #0
  40142e:	d1f2      	bne.n	401416 <msg_printer+0xa2>
  401430:	e004      	b.n	40143c <msg_printer+0xc8>
		return;
  401432:	bf00      	nop
  401434:	e002      	b.n	40143c <msg_printer+0xc8>
		return;
  401436:	bf00      	nop
  401438:	e000      	b.n	40143c <msg_printer+0xc8>
		return;
  40143a:	bf00      	nop
	}
}
  40143c:	3730      	adds	r7, #48	; 0x30
  40143e:	46bd      	mov	sp, r7
  401440:	bdb0      	pop	{r4, r5, r7, pc}
  401442:	bf00      	nop
  401444:	20000de4 	.word	0x20000de4
  401448:	00418050 	.word	0x00418050
  40144c:	0041801c 	.word	0x0041801c
  401450:	004142dd 	.word	0x004142dd
  401454:	00415881 	.word	0x00415881
  401458:	00418020 	.word	0x00418020
  40145c:	40034200 	.word	0x40034200
  401460:	00400ef1 	.word	0x00400ef1
  401464:	00000000 	.word	0x00000000

00401468 <InvEMDFrontEnd_busyWaitUsHook>:
#endif

void InvEMDFrontEnd_busyWaitUsHook(uint32_t us){
  401468:	b5f0      	push	{r4, r5, r6, r7, lr}
  40146a:	b083      	sub	sp, #12
  40146c:	af00      	add	r7, sp, #0
  40146e:	6078      	str	r0, [r7, #4]
	delay_us(us);
  401470:	687b      	ldr	r3, [r7, #4]
  401472:	2b00      	cmp	r3, #0
  401474:	d024      	beq.n	4014c0 <InvEMDFrontEnd_busyWaitUsHook+0x58>
  401476:	687b      	ldr	r3, [r7, #4]
  401478:	461d      	mov	r5, r3
  40147a:	f04f 0600 	mov.w	r6, #0
  40147e:	4b20      	ldr	r3, [pc, #128]	; (401500 <InvEMDFrontEnd_busyWaitUsHook+0x98>)
  401480:	4798      	blx	r3
  401482:	4603      	mov	r3, r0
  401484:	f04f 0400 	mov.w	r4, #0
  401488:	fb03 f106 	mul.w	r1, r3, r6
  40148c:	fb05 f204 	mul.w	r2, r5, r4
  401490:	440a      	add	r2, r1
  401492:	fba5 3403 	umull	r3, r4, r5, r3
  401496:	4422      	add	r2, r4
  401498:	4614      	mov	r4, r2
  40149a:	a217      	add	r2, pc, #92	; (adr r2, 4014f8 <InvEMDFrontEnd_busyWaitUsHook+0x90>)
  40149c:	e9d2 1200 	ldrd	r1, r2, [r2]
  4014a0:	185d      	adds	r5, r3, r1
  4014a2:	eb44 0602 	adc.w	r6, r4, r2
  4014a6:	4628      	mov	r0, r5
  4014a8:	4631      	mov	r1, r6
  4014aa:	4c16      	ldr	r4, [pc, #88]	; (401504 <InvEMDFrontEnd_busyWaitUsHook+0x9c>)
  4014ac:	4a16      	ldr	r2, [pc, #88]	; (401508 <InvEMDFrontEnd_busyWaitUsHook+0xa0>)
  4014ae:	f04f 0300 	mov.w	r3, #0
  4014b2:	47a0      	blx	r4
  4014b4:	4603      	mov	r3, r0
  4014b6:	460c      	mov	r4, r1
  4014b8:	4618      	mov	r0, r3
  4014ba:	4b14      	ldr	r3, [pc, #80]	; (40150c <InvEMDFrontEnd_busyWaitUsHook+0xa4>)
  4014bc:	4798      	blx	r3
}
  4014be:	e016      	b.n	4014ee <InvEMDFrontEnd_busyWaitUsHook+0x86>
	delay_us(us);
  4014c0:	4b0f      	ldr	r3, [pc, #60]	; (401500 <InvEMDFrontEnd_busyWaitUsHook+0x98>)
  4014c2:	4798      	blx	r3
  4014c4:	4603      	mov	r3, r0
  4014c6:	f04f 0400 	mov.w	r4, #0
  4014ca:	a20b      	add	r2, pc, #44	; (adr r2, 4014f8 <InvEMDFrontEnd_busyWaitUsHook+0x90>)
  4014cc:	e9d2 1200 	ldrd	r1, r2, [r2]
  4014d0:	185d      	adds	r5, r3, r1
  4014d2:	eb44 0602 	adc.w	r6, r4, r2
  4014d6:	4628      	mov	r0, r5
  4014d8:	4631      	mov	r1, r6
  4014da:	4c0a      	ldr	r4, [pc, #40]	; (401504 <InvEMDFrontEnd_busyWaitUsHook+0x9c>)
  4014dc:	4a0a      	ldr	r2, [pc, #40]	; (401508 <InvEMDFrontEnd_busyWaitUsHook+0xa0>)
  4014de:	f04f 0300 	mov.w	r3, #0
  4014e2:	47a0      	blx	r4
  4014e4:	4603      	mov	r3, r0
  4014e6:	460c      	mov	r4, r1
  4014e8:	4618      	mov	r0, r3
  4014ea:	4b08      	ldr	r3, [pc, #32]	; (40150c <InvEMDFrontEnd_busyWaitUsHook+0xa4>)
  4014ec:	4798      	blx	r3
}
  4014ee:	bf00      	nop
  4014f0:	370c      	adds	r7, #12
  4014f2:	46bd      	mov	sp, r7
  4014f4:	bdf0      	pop	{r4, r5, r6, r7, pc}
  4014f6:	bf00      	nop
  4014f8:	00d59f7f 	.word	0x00d59f7f
  4014fc:	00000000 	.word	0x00000000
  401500:	00400e51 	.word	0x00400e51
  401504:	00413c79 	.word	0x00413c79
  401508:	00d59f80 	.word	0x00d59f80
  40150c:	20000001 	.word	0x20000001

00401510 <InvEMDFrontEnd_isHwFlowCtrlSupportedHook>:

int InvEMDFrontEnd_isHwFlowCtrlSupportedHook(void){
  401510:	b480      	push	{r7}
  401512:	af00      	add	r7, sp, #0
	return 0;
  401514:	2300      	movs	r3, #0
}
  401516:	4618      	mov	r0, r3
  401518:	46bd      	mov	sp, r7
  40151a:	f85d 7b04 	ldr.w	r7, [sp], #4
  40151e:	4770      	bx	lr

00401520 <InvEMDFrontEnd_putcharHook>:

int InvEMDFrontEnd_putcharHook(int c){
  401520:	b580      	push	{r7, lr}
  401522:	b082      	sub	sp, #8
  401524:	af00      	add	r7, sp, #0
  401526:	6078      	str	r0, [r7, #4]
	if(usart_serial_putchar(CONF_UART, (uint8_t)c))
  401528:	687b      	ldr	r3, [r7, #4]
  40152a:	b2db      	uxtb	r3, r3
  40152c:	4619      	mov	r1, r3
  40152e:	4807      	ldr	r0, [pc, #28]	; (40154c <InvEMDFrontEnd_putcharHook+0x2c>)
  401530:	4b07      	ldr	r3, [pc, #28]	; (401550 <InvEMDFrontEnd_putcharHook+0x30>)
  401532:	4798      	blx	r3
  401534:	4603      	mov	r3, r0
  401536:	2b00      	cmp	r3, #0
  401538:	d001      	beq.n	40153e <InvEMDFrontEnd_putcharHook+0x1e>
		return c;
  40153a:	687b      	ldr	r3, [r7, #4]
  40153c:	e001      	b.n	401542 <InvEMDFrontEnd_putcharHook+0x22>
	else
		return -1;
  40153e:	f04f 33ff 	mov.w	r3, #4294967295
}
  401542:	4618      	mov	r0, r3
  401544:	3708      	adds	r7, #8
  401546:	46bd      	mov	sp, r7
  401548:	bd80      	pop	{r7, pc}
  40154a:	bf00      	nop
  40154c:	4000c200 	.word	0x4000c200
  401550:	00400ef1 	.word	0x00400ef1

00401554 <osc_get_rate>:
{
  401554:	b480      	push	{r7}
  401556:	b083      	sub	sp, #12
  401558:	af00      	add	r7, sp, #0
  40155a:	6078      	str	r0, [r7, #4]
	switch (ul_id) {
  40155c:	687b      	ldr	r3, [r7, #4]
  40155e:	2b07      	cmp	r3, #7
  401560:	d825      	bhi.n	4015ae <osc_get_rate+0x5a>
  401562:	a201      	add	r2, pc, #4	; (adr r2, 401568 <osc_get_rate+0x14>)
  401564:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
  401568:	00401589 	.word	0x00401589
  40156c:	0040158f 	.word	0x0040158f
  401570:	00401595 	.word	0x00401595
  401574:	0040159b 	.word	0x0040159b
  401578:	0040159f 	.word	0x0040159f
  40157c:	004015a3 	.word	0x004015a3
  401580:	004015a7 	.word	0x004015a7
  401584:	004015ab 	.word	0x004015ab
		return OSC_SLCK_32K_RC_HZ;
  401588:	f44f 43fa 	mov.w	r3, #32000	; 0x7d00
  40158c:	e010      	b.n	4015b0 <osc_get_rate+0x5c>
		return BOARD_FREQ_SLCK_XTAL;
  40158e:	f44f 4300 	mov.w	r3, #32768	; 0x8000
  401592:	e00d      	b.n	4015b0 <osc_get_rate+0x5c>
		return BOARD_FREQ_SLCK_BYPASS;
  401594:	f44f 4300 	mov.w	r3, #32768	; 0x8000
  401598:	e00a      	b.n	4015b0 <osc_get_rate+0x5c>
		return OSC_MAINCK_8M_RC_HZ;
  40159a:	4b08      	ldr	r3, [pc, #32]	; (4015bc <osc_get_rate+0x68>)
  40159c:	e008      	b.n	4015b0 <osc_get_rate+0x5c>
		return OSC_MAINCK_16M_RC_HZ;
  40159e:	4b08      	ldr	r3, [pc, #32]	; (4015c0 <osc_get_rate+0x6c>)
  4015a0:	e006      	b.n	4015b0 <osc_get_rate+0x5c>
		return OSC_MAINCK_24M_RC_HZ;
  4015a2:	4b08      	ldr	r3, [pc, #32]	; (4015c4 <osc_get_rate+0x70>)
  4015a4:	e004      	b.n	4015b0 <osc_get_rate+0x5c>
		return BOARD_FREQ_MAINCK_XTAL;
  4015a6:	2300      	movs	r3, #0
  4015a8:	e002      	b.n	4015b0 <osc_get_rate+0x5c>
		return BOARD_FREQ_MAINCK_BYPASS;
  4015aa:	2300      	movs	r3, #0
  4015ac:	e000      	b.n	4015b0 <osc_get_rate+0x5c>
	return 0;
  4015ae:	2300      	movs	r3, #0
}
  4015b0:	4618      	mov	r0, r3
  4015b2:	370c      	adds	r7, #12
  4015b4:	46bd      	mov	sp, r7
  4015b6:	f85d 7b04 	ldr.w	r7, [sp], #4
  4015ba:	4770      	bx	lr
  4015bc:	007a1200 	.word	0x007a1200
  4015c0:	00f42400 	.word	0x00f42400
  4015c4:	016e3600 	.word	0x016e3600

004015c8 <sysclk_get_main_hz>:
{
  4015c8:	b580      	push	{r7, lr}
  4015ca:	af00      	add	r7, sp, #0
		return pll_get_default_rate(0);
  4015cc:	2001      	movs	r0, #1
  4015ce:	4b04      	ldr	r3, [pc, #16]	; (4015e0 <sysclk_get_main_hz+0x18>)
  4015d0:	4798      	blx	r3
  4015d2:	4602      	mov	r2, r0
  4015d4:	f640 634e 	movw	r3, #3662	; 0xe4e
  4015d8:	fb03 f302 	mul.w	r3, r3, r2
}
  4015dc:	4618      	mov	r0, r3
  4015de:	bd80      	pop	{r7, pc}
  4015e0:	00401555 	.word	0x00401555

004015e4 <sysclk_get_cpu_hz>:
{
  4015e4:	b580      	push	{r7, lr}
  4015e6:	af00      	add	r7, sp, #0
	return sysclk_get_main_hz() /
  4015e8:	4b02      	ldr	r3, [pc, #8]	; (4015f4 <sysclk_get_cpu_hz+0x10>)
  4015ea:	4798      	blx	r3
  4015ec:	4603      	mov	r3, r0
}
  4015ee:	4618      	mov	r0, r3
  4015f0:	bd80      	pop	{r7, pc}
  4015f2:	bf00      	nop
  4015f4:	004015c9 	.word	0x004015c9

004015f8 <inv_icm20948_sleep_us>:
*/
void inv_icm20948_sleep(int ms) {
	delay_ms(ms);
}

void inv_icm20948_sleep_us(int us){
  4015f8:	b5f0      	push	{r4, r5, r6, r7, lr}
  4015fa:	b083      	sub	sp, #12
  4015fc:	af00      	add	r7, sp, #0
  4015fe:	6078      	str	r0, [r7, #4]
	delay_us(us);
  401600:	687b      	ldr	r3, [r7, #4]
  401602:	2b00      	cmp	r3, #0
  401604:	d024      	beq.n	401650 <inv_icm20948_sleep_us+0x58>
  401606:	687b      	ldr	r3, [r7, #4]
  401608:	461d      	mov	r5, r3
  40160a:	ea4f 76e5 	mov.w	r6, r5, asr #31
  40160e:	4b20      	ldr	r3, [pc, #128]	; (401690 <inv_icm20948_sleep_us+0x98>)
  401610:	4798      	blx	r3
  401612:	4603      	mov	r3, r0
  401614:	f04f 0400 	mov.w	r4, #0
  401618:	fb03 f106 	mul.w	r1, r3, r6
  40161c:	fb05 f204 	mul.w	r2, r5, r4
  401620:	440a      	add	r2, r1
  401622:	fba5 3403 	umull	r3, r4, r5, r3
  401626:	4422      	add	r2, r4
  401628:	4614      	mov	r4, r2
  40162a:	a217      	add	r2, pc, #92	; (adr r2, 401688 <inv_icm20948_sleep_us+0x90>)
  40162c:	e9d2 1200 	ldrd	r1, r2, [r2]
  401630:	185d      	adds	r5, r3, r1
  401632:	eb44 0602 	adc.w	r6, r4, r2
  401636:	4628      	mov	r0, r5
  401638:	4631      	mov	r1, r6
  40163a:	4c16      	ldr	r4, [pc, #88]	; (401694 <inv_icm20948_sleep_us+0x9c>)
  40163c:	4a16      	ldr	r2, [pc, #88]	; (401698 <inv_icm20948_sleep_us+0xa0>)
  40163e:	f04f 0300 	mov.w	r3, #0
  401642:	47a0      	blx	r4
  401644:	4603      	mov	r3, r0
  401646:	460c      	mov	r4, r1
  401648:	4618      	mov	r0, r3
  40164a:	4b14      	ldr	r3, [pc, #80]	; (40169c <inv_icm20948_sleep_us+0xa4>)
  40164c:	4798      	blx	r3
}
  40164e:	e016      	b.n	40167e <inv_icm20948_sleep_us+0x86>
	delay_us(us);
  401650:	4b0f      	ldr	r3, [pc, #60]	; (401690 <inv_icm20948_sleep_us+0x98>)
  401652:	4798      	blx	r3
  401654:	4603      	mov	r3, r0
  401656:	f04f 0400 	mov.w	r4, #0
  40165a:	a20b      	add	r2, pc, #44	; (adr r2, 401688 <inv_icm20948_sleep_us+0x90>)
  40165c:	e9d2 1200 	ldrd	r1, r2, [r2]
  401660:	185d      	adds	r5, r3, r1
  401662:	eb44 0602 	adc.w	r6, r4, r2
  401666:	4628      	mov	r0, r5
  401668:	4631      	mov	r1, r6
  40166a:	4c0a      	ldr	r4, [pc, #40]	; (401694 <inv_icm20948_sleep_us+0x9c>)
  40166c:	4a0a      	ldr	r2, [pc, #40]	; (401698 <inv_icm20948_sleep_us+0xa0>)
  40166e:	f04f 0300 	mov.w	r3, #0
  401672:	47a0      	blx	r4
  401674:	4603      	mov	r3, r0
  401676:	460c      	mov	r4, r1
  401678:	4618      	mov	r0, r3
  40167a:	4b08      	ldr	r3, [pc, #32]	; (40169c <inv_icm20948_sleep_us+0xa4>)
  40167c:	4798      	blx	r3
}
  40167e:	bf00      	nop
  401680:	370c      	adds	r7, #12
  401682:	46bd      	mov	sp, r7
  401684:	bdf0      	pop	{r4, r5, r6, r7, pc}
  401686:	bf00      	nop
  401688:	00d59f7f 	.word	0x00d59f7f
  40168c:	00000000 	.word	0x00000000
  401690:	004015e5 	.word	0x004015e5
  401694:	00413c79 	.word	0x00413c79
  401698:	00d59f80 	.word	0x00d59f80
  40169c:	20000001 	.word	0x20000001

004016a0 <load_dmp3>:

int load_dmp3(void){
  4016a0:	b580      	push	{r7, lr}
  4016a2:	b082      	sub	sp, #8
  4016a4:	af00      	add	r7, sp, #0
	int rc = 0;
  4016a6:	2300      	movs	r3, #0
  4016a8:	607b      	str	r3, [r7, #4]
	INV_MSG(INV_MSG_LEVEL_INFO, "Load DMP3 image");
  4016aa:	4908      	ldr	r1, [pc, #32]	; (4016cc <load_dmp3+0x2c>)
  4016ac:	2003      	movs	r0, #3
  4016ae:	4b08      	ldr	r3, [pc, #32]	; (4016d0 <load_dmp3+0x30>)
  4016b0:	4798      	blx	r3
	rc = inv_icm20948_load(&icm_device, dmp3_image, sizeof(dmp3_image));
  4016b2:	f243 72dd 	movw	r2, #14301	; 0x37dd
  4016b6:	4907      	ldr	r1, [pc, #28]	; (4016d4 <load_dmp3+0x34>)
  4016b8:	4807      	ldr	r0, [pc, #28]	; (4016d8 <load_dmp3+0x38>)
  4016ba:	4b08      	ldr	r3, [pc, #32]	; (4016dc <load_dmp3+0x3c>)
  4016bc:	4798      	blx	r3
  4016be:	6078      	str	r0, [r7, #4]
	return rc;
  4016c0:	687b      	ldr	r3, [r7, #4]
}
  4016c2:	4618      	mov	r0, r3
  4016c4:	3708      	adds	r7, #8
  4016c6:	46bd      	mov	sp, r7
  4016c8:	bd80      	pop	{r7, pc}
  4016ca:	bf00      	nop
  4016cc:	0041b86c 	.word	0x0041b86c
  4016d0:	0040fd19 	.word	0x0040fd19
  4016d4:	00418068 	.word	0x00418068
  4016d8:	20001b30 	.word	0x20001b30
  4016dc:	0040ac45 	.word	0x0040ac45

004016e0 <icm20948_apply_mounting_matrix>:

static void icm20948_apply_mounting_matrix(void){
  4016e0:	b580      	push	{r7, lr}
  4016e2:	b082      	sub	sp, #8
  4016e4:	af00      	add	r7, sp, #0
	int ii;

	for (ii = 0; ii < INV_ICM20948_SENSOR_MAX; ii++) {
  4016e6:	2300      	movs	r3, #0
  4016e8:	607b      	str	r3, [r7, #4]
  4016ea:	e009      	b.n	401700 <icm20948_apply_mounting_matrix+0x20>
		inv_icm20948_set_matrix(&icm_device, cfg_mounting_matrix, ii);
  4016ec:	687b      	ldr	r3, [r7, #4]
  4016ee:	b2db      	uxtb	r3, r3
  4016f0:	461a      	mov	r2, r3
  4016f2:	4907      	ldr	r1, [pc, #28]	; (401710 <icm20948_apply_mounting_matrix+0x30>)
  4016f4:	4807      	ldr	r0, [pc, #28]	; (401714 <icm20948_apply_mounting_matrix+0x34>)
  4016f6:	4b08      	ldr	r3, [pc, #32]	; (401718 <icm20948_apply_mounting_matrix+0x38>)
  4016f8:	4798      	blx	r3
	for (ii = 0; ii < INV_ICM20948_SENSOR_MAX; ii++) {
  4016fa:	687b      	ldr	r3, [r7, #4]
  4016fc:	3301      	adds	r3, #1
  4016fe:	607b      	str	r3, [r7, #4]
  401700:	687b      	ldr	r3, [r7, #4]
  401702:	2b13      	cmp	r3, #19
  401704:	ddf2      	ble.n	4016ec <icm20948_apply_mounting_matrix+0xc>
	}
}
  401706:	bf00      	nop
  401708:	3708      	adds	r7, #8
  40170a:	46bd      	mov	sp, r7
  40170c:	bd80      	pop	{r7, pc}
  40170e:	bf00      	nop
  401710:	0041b848 	.word	0x0041b848
  401714:	20001b30 	.word	0x20001b30
  401718:	0040aa45 	.word	0x0040aa45

0040171c <icm20948_set_fsr>:

static void icm20948_set_fsr(void){
  40171c:	b580      	push	{r7, lr}
  40171e:	af00      	add	r7, sp, #0
	inv_icm20948_set_fsr(&icm_device, INV_ICM20948_SENSOR_RAW_ACCELEROMETER, (const void *)&cfg_acc_fsr);
  401720:	4a0d      	ldr	r2, [pc, #52]	; (401758 <icm20948_set_fsr+0x3c>)
  401722:	2102      	movs	r1, #2
  401724:	480d      	ldr	r0, [pc, #52]	; (40175c <icm20948_set_fsr+0x40>)
  401726:	4b0e      	ldr	r3, [pc, #56]	; (401760 <icm20948_set_fsr+0x44>)
  401728:	4798      	blx	r3
	inv_icm20948_set_fsr(&icm_device, INV_ICM20948_SENSOR_ACCELEROMETER, (const void *)&cfg_acc_fsr);
  40172a:	4a0b      	ldr	r2, [pc, #44]	; (401758 <icm20948_set_fsr+0x3c>)
  40172c:	2100      	movs	r1, #0
  40172e:	480b      	ldr	r0, [pc, #44]	; (40175c <icm20948_set_fsr+0x40>)
  401730:	4b0b      	ldr	r3, [pc, #44]	; (401760 <icm20948_set_fsr+0x44>)
  401732:	4798      	blx	r3
	inv_icm20948_set_fsr(&icm_device, INV_ICM20948_SENSOR_RAW_GYROSCOPE, (const void *)&cfg_gyr_fsr);
  401734:	4a0b      	ldr	r2, [pc, #44]	; (401764 <icm20948_set_fsr+0x48>)
  401736:	2103      	movs	r1, #3
  401738:	4808      	ldr	r0, [pc, #32]	; (40175c <icm20948_set_fsr+0x40>)
  40173a:	4b09      	ldr	r3, [pc, #36]	; (401760 <icm20948_set_fsr+0x44>)
  40173c:	4798      	blx	r3
	inv_icm20948_set_fsr(&icm_device, INV_ICM20948_SENSOR_GYROSCOPE, (const void *)&cfg_gyr_fsr);
  40173e:	4a09      	ldr	r2, [pc, #36]	; (401764 <icm20948_set_fsr+0x48>)
  401740:	2101      	movs	r1, #1
  401742:	4806      	ldr	r0, [pc, #24]	; (40175c <icm20948_set_fsr+0x40>)
  401744:	4b06      	ldr	r3, [pc, #24]	; (401760 <icm20948_set_fsr+0x44>)
  401746:	4798      	blx	r3
	inv_icm20948_set_fsr(&icm_device, INV_ICM20948_SENSOR_GYROSCOPE_UNCALIBRATED, (const void *)&cfg_gyr_fsr);
  401748:	4a06      	ldr	r2, [pc, #24]	; (401764 <icm20948_set_fsr+0x48>)
  40174a:	2105      	movs	r1, #5
  40174c:	4803      	ldr	r0, [pc, #12]	; (40175c <icm20948_set_fsr+0x40>)
  40174e:	4b04      	ldr	r3, [pc, #16]	; (401760 <icm20948_set_fsr+0x44>)
  401750:	4798      	blx	r3
}
  401752:	bf00      	nop
  401754:	bd80      	pop	{r7, pc}
  401756:	bf00      	nop
  401758:	200000fc 	.word	0x200000fc
  40175c:	20001b30 	.word	0x20001b30
  401760:	0040a8d9 	.word	0x0040a8d9
  401764:	20000100 	.word	0x20000100

00401768 <icm20948_sensor_setup>:

int icm20948_sensor_setup(void){
  401768:	b580      	push	{r7, lr}
  40176a:	b082      	sub	sp, #8
  40176c:	af00      	add	r7, sp, #0
	int rc;
	uint8_t i, whoami = 0xff;
  40176e:	23ff      	movs	r3, #255	; 0xff
  401770:	70bb      	strb	r3, [r7, #2]

	/*
	* Just get the whoami
	*/
	rc = inv_icm20948_get_whoami(&icm_device, &whoami);
  401772:	1cbb      	adds	r3, r7, #2
  401774:	4619      	mov	r1, r3
  401776:	4838      	ldr	r0, [pc, #224]	; (401858 <icm20948_sensor_setup+0xf0>)
  401778:	4b38      	ldr	r3, [pc, #224]	; (40185c <icm20948_sensor_setup+0xf4>)
  40177a:	4798      	blx	r3
  40177c:	6078      	str	r0, [r7, #4]
	if (interface_is_SPI() == 0)	{		// If we're using I2C
  40177e:	4b38      	ldr	r3, [pc, #224]	; (401860 <icm20948_sensor_setup+0xf8>)
  401780:	4798      	blx	r3
  401782:	4603      	mov	r3, r0
  401784:	2b00      	cmp	r3, #0
  401786:	d10a      	bne.n	40179e <icm20948_sensor_setup+0x36>
		if (whoami == 0xff) {				// if whoami fails try the other I2C Address
  401788:	78bb      	ldrb	r3, [r7, #2]
  40178a:	2bff      	cmp	r3, #255	; 0xff
  40178c:	d107      	bne.n	40179e <icm20948_sensor_setup+0x36>
			switch_I2C_to_revA();
  40178e:	4b35      	ldr	r3, [pc, #212]	; (401864 <icm20948_sensor_setup+0xfc>)
  401790:	4798      	blx	r3
			rc = inv_icm20948_get_whoami(&icm_device, &whoami);
  401792:	1cbb      	adds	r3, r7, #2
  401794:	4619      	mov	r1, r3
  401796:	4830      	ldr	r0, [pc, #192]	; (401858 <icm20948_sensor_setup+0xf0>)
  401798:	4b30      	ldr	r3, [pc, #192]	; (40185c <icm20948_sensor_setup+0xf4>)
  40179a:	4798      	blx	r3
  40179c:	6078      	str	r0, [r7, #4]
		}
	}
	INV_MSG(INV_MSG_LEVEL_INFO, "ICM20948 WHOAMI value=0x%02x", whoami);
  40179e:	78bb      	ldrb	r3, [r7, #2]
  4017a0:	461a      	mov	r2, r3
  4017a2:	4931      	ldr	r1, [pc, #196]	; (401868 <icm20948_sensor_setup+0x100>)
  4017a4:	2003      	movs	r0, #3
  4017a6:	4b31      	ldr	r3, [pc, #196]	; (40186c <icm20948_sensor_setup+0x104>)
  4017a8:	4798      	blx	r3

	/*
	* Check if WHOAMI value corresponds to any value from EXPECTED_WHOAMI array
	*/
	for(i = 0; i < sizeof(EXPECTED_WHOAMI)/sizeof(EXPECTED_WHOAMI[0]); ++i) {
  4017aa:	2300      	movs	r3, #0
  4017ac:	70fb      	strb	r3, [r7, #3]
  4017ae:	e006      	b.n	4017be <icm20948_sensor_setup+0x56>
		if(whoami == EXPECTED_WHOAMI[i]) {
  4017b0:	22ea      	movs	r2, #234	; 0xea
  4017b2:	78bb      	ldrb	r3, [r7, #2]
  4017b4:	429a      	cmp	r2, r3
  4017b6:	d006      	beq.n	4017c6 <icm20948_sensor_setup+0x5e>
	for(i = 0; i < sizeof(EXPECTED_WHOAMI)/sizeof(EXPECTED_WHOAMI[0]); ++i) {
  4017b8:	78fb      	ldrb	r3, [r7, #3]
  4017ba:	3301      	adds	r3, #1
  4017bc:	70fb      	strb	r3, [r7, #3]
  4017be:	78fb      	ldrb	r3, [r7, #3]
  4017c0:	2b00      	cmp	r3, #0
  4017c2:	d0f5      	beq.n	4017b0 <icm20948_sensor_setup+0x48>
  4017c4:	e000      	b.n	4017c8 <icm20948_sensor_setup+0x60>
			break;
  4017c6:	bf00      	nop
		}
	}

	if(i == sizeof(EXPECTED_WHOAMI)/sizeof(EXPECTED_WHOAMI[0])) {
  4017c8:	78fb      	ldrb	r3, [r7, #3]
  4017ca:	2b01      	cmp	r3, #1
  4017cc:	d107      	bne.n	4017de <icm20948_sensor_setup+0x76>
		INV_MSG(INV_MSG_LEVEL_ERROR, "Bad WHOAMI value. Got 0x%02x.", whoami);
  4017ce:	78bb      	ldrb	r3, [r7, #2]
  4017d0:	461a      	mov	r2, r3
  4017d2:	4927      	ldr	r1, [pc, #156]	; (401870 <icm20948_sensor_setup+0x108>)
  4017d4:	2001      	movs	r0, #1
  4017d6:	4b25      	ldr	r3, [pc, #148]	; (40186c <icm20948_sensor_setup+0x104>)
  4017d8:	4798      	blx	r3
		return rc;
  4017da:	687b      	ldr	r3, [r7, #4]
  4017dc:	e037      	b.n	40184e <icm20948_sensor_setup+0xe6>
	}

	/* Setup accel and gyro mounting matrix and associated angle for current board */
	inv_icm20948_init_matrix(&icm_device);
  4017de:	481e      	ldr	r0, [pc, #120]	; (401858 <icm20948_sensor_setup+0xf0>)
  4017e0:	4b24      	ldr	r3, [pc, #144]	; (401874 <icm20948_sensor_setup+0x10c>)
  4017e2:	4798      	blx	r3

	/* set default power mode */
	INV_MSG(INV_MSG_LEVEL_VERBOSE, "Putting Icm20948 in sleep mode...");
  4017e4:	4924      	ldr	r1, [pc, #144]	; (401878 <icm20948_sensor_setup+0x110>)
  4017e6:	2004      	movs	r0, #4
  4017e8:	4b20      	ldr	r3, [pc, #128]	; (40186c <icm20948_sensor_setup+0x104>)
  4017ea:	4798      	blx	r3
	rc = inv_icm20948_initialize(&icm_device, dmp3_image, sizeof(dmp3_image));
  4017ec:	f243 72dd 	movw	r2, #14301	; 0x37dd
  4017f0:	4922      	ldr	r1, [pc, #136]	; (40187c <icm20948_sensor_setup+0x114>)
  4017f2:	4819      	ldr	r0, [pc, #100]	; (401858 <icm20948_sensor_setup+0xf0>)
  4017f4:	4b22      	ldr	r3, [pc, #136]	; (401880 <icm20948_sensor_setup+0x118>)
  4017f6:	4798      	blx	r3
  4017f8:	6078      	str	r0, [r7, #4]
	if (rc != 0) {
  4017fa:	687b      	ldr	r3, [r7, #4]
  4017fc:	2b00      	cmp	r3, #0
  4017fe:	d005      	beq.n	40180c <icm20948_sensor_setup+0xa4>
		INV_MSG(INV_MSG_LEVEL_ERROR, "Initialization failed. Error loading DMP3...");
  401800:	4920      	ldr	r1, [pc, #128]	; (401884 <icm20948_sensor_setup+0x11c>)
  401802:	2001      	movs	r0, #1
  401804:	4b19      	ldr	r3, [pc, #100]	; (40186c <icm20948_sensor_setup+0x104>)
  401806:	4798      	blx	r3
		return rc;
  401808:	687b      	ldr	r3, [r7, #4]
  40180a:	e020      	b.n	40184e <icm20948_sensor_setup+0xe6>
	}

	/*
	* Configure and initialize the ICM20948 for normal use
	*/
	INV_MSG(INV_MSG_LEVEL_INFO, "Booting up icm20948...");
  40180c:	491e      	ldr	r1, [pc, #120]	; (401888 <icm20948_sensor_setup+0x120>)
  40180e:	2003      	movs	r0, #3
  401810:	4b16      	ldr	r3, [pc, #88]	; (40186c <icm20948_sensor_setup+0x104>)
  401812:	4798      	blx	r3

	/* Initialize auxiliary sensors */
	inv_icm20948_register_aux_compass( &icm_device, INV_ICM20948_COMPASS_ID_AK09916, AK0991x_DEFAULT_I2C_ADDR);
  401814:	220c      	movs	r2, #12
  401816:	2103      	movs	r1, #3
  401818:	480f      	ldr	r0, [pc, #60]	; (401858 <icm20948_sensor_setup+0xf0>)
  40181a:	4b1c      	ldr	r3, [pc, #112]	; (40188c <icm20948_sensor_setup+0x124>)
  40181c:	4798      	blx	r3
	rc = inv_icm20948_initialize_auxiliary(&icm_device);
  40181e:	480e      	ldr	r0, [pc, #56]	; (401858 <icm20948_sensor_setup+0xf0>)
  401820:	4b1b      	ldr	r3, [pc, #108]	; (401890 <icm20948_sensor_setup+0x128>)
  401822:	4798      	blx	r3
  401824:	6078      	str	r0, [r7, #4]
	if (rc == -1) {
  401826:	687b      	ldr	r3, [r7, #4]
  401828:	f1b3 3fff 	cmp.w	r3, #4294967295
  40182c:	d103      	bne.n	401836 <icm20948_sensor_setup+0xce>
		INV_MSG(INV_MSG_LEVEL_ERROR, "Compass not detected...");
  40182e:	4919      	ldr	r1, [pc, #100]	; (401894 <icm20948_sensor_setup+0x12c>)
  401830:	2001      	movs	r0, #1
  401832:	4b0e      	ldr	r3, [pc, #56]	; (40186c <icm20948_sensor_setup+0x104>)
  401834:	4798      	blx	r3
	}

	icm20948_apply_mounting_matrix();
  401836:	4b18      	ldr	r3, [pc, #96]	; (401898 <icm20948_sensor_setup+0x130>)
  401838:	4798      	blx	r3

	icm20948_set_fsr();
  40183a:	4b18      	ldr	r3, [pc, #96]	; (40189c <icm20948_sensor_setup+0x134>)
  40183c:	4798      	blx	r3

	/* re-initialize base state structure */
	inv_icm20948_init_structure(&icm_device);
  40183e:	4806      	ldr	r0, [pc, #24]	; (401858 <icm20948_sensor_setup+0xf0>)
  401840:	4b17      	ldr	r3, [pc, #92]	; (4018a0 <icm20948_sensor_setup+0x138>)
  401842:	4798      	blx	r3

	/* we should be good to go ! */
	INV_MSG(INV_MSG_LEVEL_VERBOSE, "We're good to go !");
  401844:	4917      	ldr	r1, [pc, #92]	; (4018a4 <icm20948_sensor_setup+0x13c>)
  401846:	2004      	movs	r0, #4
  401848:	4b08      	ldr	r3, [pc, #32]	; (40186c <icm20948_sensor_setup+0x104>)
  40184a:	4798      	blx	r3

	return 0;
  40184c:	2300      	movs	r3, #0
}
  40184e:	4618      	mov	r0, r3
  401850:	3708      	adds	r7, #8
  401852:	46bd      	mov	sp, r7
  401854:	bd80      	pop	{r7, pc}
  401856:	bf00      	nop
  401858:	20001b30 	.word	0x20001b30
  40185c:	0040a755 	.word	0x0040a755
  401860:	00403139 	.word	0x00403139
  401864:	00403159 	.word	0x00403159
  401868:	0041b87c 	.word	0x0041b87c
  40186c:	0040fd19 	.word	0x0040fd19
  401870:	0041b89c 	.word	0x0041b89c
  401874:	0040a779 	.word	0x0040a779
  401878:	0041b8bc 	.word	0x0041b8bc
  40187c:	00418068 	.word	0x00418068
  401880:	0040a885 	.word	0x0040a885
  401884:	0041b8e0 	.word	0x0041b8e0
  401888:	0041b910 	.word	0x0041b910
  40188c:	004048d9 	.word	0x004048d9
  401890:	0040ab09 	.word	0x0040ab09
  401894:	0041b928 	.word	0x0041b928
  401898:	004016e1 	.word	0x004016e1
  40189c:	0040171d 	.word	0x0040171d
  4018a0:	0040a811 	.word	0x0040a811
  4018a4:	0041b940 	.word	0x0041b940

004018a8 <check_rc>:

/*
* Helper function to check RC value and block program execution
*/
void check_rc(int rc, const char * msg_context){
  4018a8:	b590      	push	{r4, r7, lr}
  4018aa:	b085      	sub	sp, #20
  4018ac:	af02      	add	r7, sp, #8
  4018ae:	6078      	str	r0, [r7, #4]
  4018b0:	6039      	str	r1, [r7, #0]
	if(rc < 0) {
  4018b2:	687b      	ldr	r3, [r7, #4]
  4018b4:	2b00      	cmp	r3, #0
  4018b6:	da0b      	bge.n	4018d0 <check_rc+0x28>
		INV_MSG(INV_MSG_LEVEL_ERROR, "%s: error %d (%s)", msg_context, rc, inv_error_str(rc));
  4018b8:	6878      	ldr	r0, [r7, #4]
  4018ba:	4b07      	ldr	r3, [pc, #28]	; (4018d8 <check_rc+0x30>)
  4018bc:	4798      	blx	r3
  4018be:	4603      	mov	r3, r0
  4018c0:	9300      	str	r3, [sp, #0]
  4018c2:	687b      	ldr	r3, [r7, #4]
  4018c4:	683a      	ldr	r2, [r7, #0]
  4018c6:	4905      	ldr	r1, [pc, #20]	; (4018dc <check_rc+0x34>)
  4018c8:	2001      	movs	r0, #1
  4018ca:	4c05      	ldr	r4, [pc, #20]	; (4018e0 <check_rc+0x38>)
  4018cc:	47a0      	blx	r4
		while(1);
  4018ce:	e7fe      	b.n	4018ce <check_rc+0x26>
	}
}
  4018d0:	bf00      	nop
  4018d2:	370c      	adds	r7, #12
  4018d4:	46bd      	mov	sp, r7
  4018d6:	bd90      	pop	{r4, r7, pc}
  4018d8:	0040f919 	.word	0x0040f919
  4018dc:	0041b954 	.word	0x0041b954
  4018e0:	0040fd19 	.word	0x0040fd19

004018e4 <iddwrapper_protocol_event_cb>:
void iddwrapper_protocol_event_cb(
	enum DynProtocolEtype etype,
	enum DynProtocolEid eid,
	const DynProtocolEdata_t * edata,
	void * cookie
	){
  4018e4:	b590      	push	{r4, r7, lr}
  4018e6:	b089      	sub	sp, #36	; 0x24
  4018e8:	af02      	add	r7, sp, #8
  4018ea:	60ba      	str	r2, [r7, #8]
  4018ec:	607b      	str	r3, [r7, #4]
  4018ee:	4603      	mov	r3, r0
  4018f0:	73fb      	strb	r3, [r7, #15]
  4018f2:	460b      	mov	r3, r1
  4018f4:	73bb      	strb	r3, [r7, #14]

		static DynProtocolEdata_t resp_edata; /* static to take on .bss */
		static uint8_t respBuffer[256]; /* static to take on .bss */
		uint16_t respLen;

		switch(etype) {
  4018f6:	7bfb      	ldrb	r3, [r7, #15]
  4018f8:	2b00      	cmp	r3, #0
  4018fa:	d11e      	bne.n	40193a <iddwrapper_protocol_event_cb+0x56>
		case DYN_PROTOCOL_ETYPE_CMD:
			resp_edata.d.response.rc = handle_command(eid, edata, &resp_edata);
  4018fc:	7bbb      	ldrb	r3, [r7, #14]
  4018fe:	4a16      	ldr	r2, [pc, #88]	; (401958 <iddwrapper_protocol_event_cb+0x74>)
  401900:	68b9      	ldr	r1, [r7, #8]
  401902:	4618      	mov	r0, r3
  401904:	4b15      	ldr	r3, [pc, #84]	; (40195c <iddwrapper_protocol_event_cb+0x78>)
  401906:	4798      	blx	r3
  401908:	4602      	mov	r2, r0
  40190a:	4b13      	ldr	r3, [pc, #76]	; (401958 <iddwrapper_protocol_event_cb+0x74>)
  40190c:	605a      	str	r2, [r3, #4]

			/* send back response */
			if(DynProtocol_encodeResponse(&protocol, eid, &resp_edata,
  40190e:	7bb9      	ldrb	r1, [r7, #14]
  401910:	f107 0316 	add.w	r3, r7, #22
  401914:	9301      	str	r3, [sp, #4]
  401916:	f44f 7380 	mov.w	r3, #256	; 0x100
  40191a:	9300      	str	r3, [sp, #0]
  40191c:	4b10      	ldr	r3, [pc, #64]	; (401960 <iddwrapper_protocol_event_cb+0x7c>)
  40191e:	4a0e      	ldr	r2, [pc, #56]	; (401958 <iddwrapper_protocol_event_cb+0x74>)
  401920:	4810      	ldr	r0, [pc, #64]	; (401964 <iddwrapper_protocol_event_cb+0x80>)
  401922:	4c11      	ldr	r4, [pc, #68]	; (401968 <iddwrapper_protocol_event_cb+0x84>)
  401924:	47a0      	blx	r4
  401926:	4603      	mov	r3, r0
  401928:	2b00      	cmp	r3, #0
  40192a:	d10c      	bne.n	401946 <iddwrapper_protocol_event_cb+0x62>
				respBuffer, sizeof(respBuffer), &respLen) != 0) {
					goto error_dma_buffer;
			}

			DynProTransportUart_tx(&transport, respBuffer, respLen);
  40192c:	8afb      	ldrh	r3, [r7, #22]
  40192e:	461a      	mov	r2, r3
  401930:	490b      	ldr	r1, [pc, #44]	; (401960 <iddwrapper_protocol_event_cb+0x7c>)
  401932:	480e      	ldr	r0, [pc, #56]	; (40196c <iddwrapper_protocol_event_cb+0x88>)
  401934:	4b0e      	ldr	r3, [pc, #56]	; (401970 <iddwrapper_protocol_event_cb+0x8c>)
  401936:	4798      	blx	r3
			break;
  401938:	e004      	b.n	401944 <iddwrapper_protocol_event_cb+0x60>

		default:
			INV_MSG(INV_MSG_LEVEL_WARNING, "DeviceEmdWrapper: unexpected packet received. Ignored.");
  40193a:	490e      	ldr	r1, [pc, #56]	; (401974 <iddwrapper_protocol_event_cb+0x90>)
  40193c:	2002      	movs	r0, #2
  40193e:	4b0e      	ldr	r3, [pc, #56]	; (401978 <iddwrapper_protocol_event_cb+0x94>)
  401940:	4798      	blx	r3
			break; /* no suppose to happen */
  401942:	bf00      	nop
		}
		return;
  401944:	e005      	b.n	401952 <iddwrapper_protocol_event_cb+0x6e>
					goto error_dma_buffer;
  401946:	bf00      	nop

error_dma_buffer:
		INV_MSG(INV_MSG_LEVEL_WARNING, "iddwrapper_protocol_event_cb: encode error, response dropped");
  401948:	490c      	ldr	r1, [pc, #48]	; (40197c <iddwrapper_protocol_event_cb+0x98>)
  40194a:	2002      	movs	r0, #2
  40194c:	4b0a      	ldr	r3, [pc, #40]	; (401978 <iddwrapper_protocol_event_cb+0x94>)
  40194e:	4798      	blx	r3

		return;
  401950:	bf00      	nop
}
  401952:	371c      	adds	r7, #28
  401954:	46bd      	mov	sp, r7
  401956:	bd90      	pop	{r4, r7, pc}
  401958:	20000f00 	.word	0x20000f00
  40195c:	00402161 	.word	0x00402161
  401960:	20000f84 	.word	0x20000f84
  401964:	20001888 	.word	0x20001888
  401968:	0040f0f1 	.word	0x0040f0f1
  40196c:	20001b20 	.word	0x20001b20
  401970:	0040f6ed 	.word	0x0040f6ed
  401974:	0041b968 	.word	0x0041b968
  401978:	0040fd19 	.word	0x0040fd19
  40197c:	0041b9a0 	.word	0x0041b9a0

00401980 <iddwrapper_transport_event_cb>:
* This function will:
*  - feed the Dynamic protocol layer to analyze for incoming CMD packet
*  - forward byte coming from transport layer to be send over uart to the host
*/
void iddwrapper_transport_event_cb(enum DynProTransportEvent e,
union DynProTransportEventData data, void * cookie){
  401980:	b590      	push	{r4, r7, lr}
  401982:	b087      	sub	sp, #28
  401984:	af00      	add	r7, sp, #0
  401986:	4603      	mov	r3, r0
  401988:	60b9      	str	r1, [r7, #8]
  40198a:	607a      	str	r2, [r7, #4]
  40198c:	73fb      	strb	r3, [r7, #15]
	(void)cookie;

	int rc;
	int timeout = 5000; /* us */
  40198e:	f241 3388 	movw	r3, #5000	; 0x1388
  401992:	617b      	str	r3, [r7, #20]

	switch(e) {
  401994:	7bfb      	ldrb	r3, [r7, #15]
  401996:	2b07      	cmp	r3, #7
  401998:	d841      	bhi.n	401a1e <iddwrapper_transport_event_cb+0x9e>
  40199a:	a201      	add	r2, pc, #4	; (adr r2, 4019a0 <iddwrapper_transport_event_cb+0x20>)
  40199c:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
  4019a0:	004019c1 	.word	0x004019c1
  4019a4:	00401a15 	.word	0x00401a15
  4019a8:	004019cf 	.word	0x004019cf
  4019ac:	00401a15 	.word	0x00401a15
  4019b0:	00401a15 	.word	0x00401a15
  4019b4:	004019fd 	.word	0x004019fd
  4019b8:	00401a15 	.word	0x00401a15
  4019bc:	00401a15 	.word	0x00401a15
	case DYN_PRO_TRANSPORT_EVENT_ERROR:
		INV_MSG(INV_MSG_LEVEL_ERROR, "ERROR event with value %d received from IddWrapper transport", data.error);
  4019c0:	68bb      	ldr	r3, [r7, #8]
  4019c2:	461a      	mov	r2, r3
  4019c4:	4918      	ldr	r1, [pc, #96]	; (401a28 <iddwrapper_transport_event_cb+0xa8>)
  4019c6:	2001      	movs	r0, #1
  4019c8:	4b18      	ldr	r3, [pc, #96]	; (401a2c <iddwrapper_transport_event_cb+0xac>)
  4019ca:	4798      	blx	r3
		break;
  4019cc:	e027      	b.n	401a1e <iddwrapper_transport_event_cb+0x9e>
	case DYN_PRO_TRANSPORT_EVENT_PKT_SIZE:
		break;

	case DYN_PRO_TRANSPORT_EVENT_PKT_BYTE:
		/* Feed IddWrapperProtocol to look for packet */
		rc = DynProtocol_processPktByte(&protocol, data.pkt_byte);
  4019ce:	7a3b      	ldrb	r3, [r7, #8]
  4019d0:	4619      	mov	r1, r3
  4019d2:	4817      	ldr	r0, [pc, #92]	; (401a30 <iddwrapper_transport_event_cb+0xb0>)
  4019d4:	4b17      	ldr	r3, [pc, #92]	; (401a34 <iddwrapper_transport_event_cb+0xb4>)
  4019d6:	4798      	blx	r3
  4019d8:	6138      	str	r0, [r7, #16]
		if(rc < 0) {
  4019da:	693b      	ldr	r3, [r7, #16]
  4019dc:	2b00      	cmp	r3, #0
  4019de:	da1b      	bge.n	401a18 <iddwrapper_transport_event_cb+0x98>
			INV_MSG(INV_MSG_LEVEL_DEBUG, "DynProtocol_processPktByte(%02x) returned %d", data.pkt_byte, rc);
  4019e0:	7a3b      	ldrb	r3, [r7, #8]
  4019e2:	461a      	mov	r2, r3
  4019e4:	693b      	ldr	r3, [r7, #16]
  4019e6:	4914      	ldr	r1, [pc, #80]	; (401a38 <iddwrapper_transport_event_cb+0xb8>)
  4019e8:	2005      	movs	r0, #5
  4019ea:	4c10      	ldr	r4, [pc, #64]	; (401a2c <iddwrapper_transport_event_cb+0xac>)
  4019ec:	47a0      	blx	r4
		}
		break;
  4019ee:	e013      	b.n	401a18 <iddwrapper_transport_event_cb+0x98>
	case DYN_PRO_TRANSPORT_EVENT_TX_START:
		break;

	case DYN_PRO_TRANSPORT_EVENT_TX_BYTE:
		while ((InvEMDFrontEnd_putcharHook(data.tx_byte) == EOF) && (timeout > 0)) {
			InvEMDFrontEnd_busyWaitUsHook(10);
  4019f0:	200a      	movs	r0, #10
  4019f2:	4b12      	ldr	r3, [pc, #72]	; (401a3c <iddwrapper_transport_event_cb+0xbc>)
  4019f4:	4798      	blx	r3
			timeout -= 10;
  4019f6:	697b      	ldr	r3, [r7, #20]
  4019f8:	3b0a      	subs	r3, #10
  4019fa:	617b      	str	r3, [r7, #20]
		while ((InvEMDFrontEnd_putcharHook(data.tx_byte) == EOF) && (timeout > 0)) {
  4019fc:	7a3b      	ldrb	r3, [r7, #8]
  4019fe:	4618      	mov	r0, r3
  401a00:	4b0f      	ldr	r3, [pc, #60]	; (401a40 <iddwrapper_transport_event_cb+0xc0>)
  401a02:	4798      	blx	r3
  401a04:	4603      	mov	r3, r0
  401a06:	f1b3 3fff 	cmp.w	r3, #4294967295
  401a0a:	d107      	bne.n	401a1c <iddwrapper_transport_event_cb+0x9c>
  401a0c:	697b      	ldr	r3, [r7, #20]
  401a0e:	2b00      	cmp	r3, #0
  401a10:	dcee      	bgt.n	4019f0 <iddwrapper_transport_event_cb+0x70>
		}
		break;
  401a12:	e003      	b.n	401a1c <iddwrapper_transport_event_cb+0x9c>
		break;
  401a14:	bf00      	nop
  401a16:	e002      	b.n	401a1e <iddwrapper_transport_event_cb+0x9e>
		break;
  401a18:	bf00      	nop
  401a1a:	e000      	b.n	401a1e <iddwrapper_transport_event_cb+0x9e>
		break;
  401a1c:	bf00      	nop
		break;

	case DYN_PRO_TRANSPORT_EVENT_TX_START_DMA:
		break;
	}
}
  401a1e:	bf00      	nop
  401a20:	371c      	adds	r7, #28
  401a22:	46bd      	mov	sp, r7
  401a24:	bd90      	pop	{r4, r7, pc}
  401a26:	bf00      	nop
  401a28:	0041b9e0 	.word	0x0041b9e0
  401a2c:	0040fd19 	.word	0x0040fd19
  401a30:	20001888 	.word	0x20001888
  401a34:	0040efa5 	.word	0x0040efa5
  401a38:	0041ba20 	.word	0x0041ba20
  401a3c:	00401469 	.word	0x00401469
  401a40:	00401521 	.word	0x00401521

00401a44 <icm20948_get_grv_accuracy>:

static uint8_t icm20948_get_grv_accuracy(void){
  401a44:	b580      	push	{r7, lr}
  401a46:	b082      	sub	sp, #8
  401a48:	af00      	add	r7, sp, #0
	uint8_t accel_accuracy;
	uint8_t gyro_accuracy;

	accel_accuracy = (uint8_t)inv_icm20948_get_accel_accuracy();
  401a4a:	4b09      	ldr	r3, [pc, #36]	; (401a70 <icm20948_get_grv_accuracy+0x2c>)
  401a4c:	4798      	blx	r3
  401a4e:	4603      	mov	r3, r0
  401a50:	71fb      	strb	r3, [r7, #7]
	gyro_accuracy = (uint8_t)inv_icm20948_get_gyro_accuracy();
  401a52:	4b08      	ldr	r3, [pc, #32]	; (401a74 <icm20948_get_grv_accuracy+0x30>)
  401a54:	4798      	blx	r3
  401a56:	4603      	mov	r3, r0
  401a58:	71bb      	strb	r3, [r7, #6]
	return (min(accel_accuracy, gyro_accuracy));
  401a5a:	79ba      	ldrb	r2, [r7, #6]
  401a5c:	79fb      	ldrb	r3, [r7, #7]
  401a5e:	4293      	cmp	r3, r2
  401a60:	bf28      	it	cs
  401a62:	4613      	movcs	r3, r2
  401a64:	b2db      	uxtb	r3, r3
}
  401a66:	4618      	mov	r0, r3
  401a68:	3708      	adds	r7, #8
  401a6a:	46bd      	mov	sp, r7
  401a6c:	bd80      	pop	{r7, pc}
  401a6e:	bf00      	nop
  401a70:	0040996d 	.word	0x0040996d
  401a74:	00409985 	.word	0x00409985

00401a78 <build_sensor_event_data>:

void build_sensor_event_data(void * context, uint8_t sensortype, uint64_t timestamp, const void * data, const void *arg){
  401a78:	b590      	push	{r4, r7, lr}
  401a7a:	b0a1      	sub	sp, #132	; 0x84
  401a7c:	af00      	add	r7, sp, #0
  401a7e:	60f8      	str	r0, [r7, #12]
  401a80:	e9c7 2300 	strd	r2, r3, [r7]
  401a84:	460b      	mov	r3, r1
  401a86:	72fb      	strb	r3, [r7, #11]
	float raw_bias_data[6];
	inv_sensor_event_t event;
	(void)context;
	uint8_t sensor_id = convert_to_generic_ids[sensortype];
  401a88:	7afb      	ldrb	r3, [r7, #11]
  401a8a:	4a94      	ldr	r2, [pc, #592]	; (401cdc <build_sensor_event_data+0x264>)
  401a8c:	5cd3      	ldrb	r3, [r2, r3]
  401a8e:	f887 307f 	strb.w	r3, [r7, #127]	; 0x7f

	memset((void *)&event, 0, sizeof(event));
  401a92:	f107 0310 	add.w	r3, r7, #16
  401a96:	2250      	movs	r2, #80	; 0x50
  401a98:	2100      	movs	r1, #0
  401a9a:	4618      	mov	r0, r3
  401a9c:	4b90      	ldr	r3, [pc, #576]	; (401ce0 <build_sensor_event_data+0x268>)
  401a9e:	4798      	blx	r3
	event.sensor = sensor_id;
  401aa0:	f897 307f 	ldrb.w	r3, [r7, #127]	; 0x7f
  401aa4:	613b      	str	r3, [r7, #16]
	event.timestamp = timestamp;
  401aa6:	e9d7 3400 	ldrd	r3, r4, [r7]
  401aaa:	e9c7 3406 	strd	r3, r4, [r7, #24]
	switch(sensor_id) {
  401aae:	f897 307f 	ldrb.w	r3, [r7, #127]	; 0x7f
  401ab2:	3b01      	subs	r3, #1
  401ab4:	2b20      	cmp	r3, #32
  401ab6:	f200 810c 	bhi.w	401cd2 <build_sensor_event_data+0x25a>
  401aba:	a201      	add	r2, pc, #4	; (adr r2, 401ac0 <build_sensor_event_data+0x48>)
  401abc:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
  401ac0:	00401bf3 	.word	0x00401bf3
  401ac4:	00401c11 	.word	0x00401c11
  401ac8:	00401c9d 	.word	0x00401c9d
  401acc:	00401bb5 	.word	0x00401bb5
  401ad0:	00401cd3 	.word	0x00401cd3
  401ad4:	00401cd3 	.word	0x00401cd3
  401ad8:	00401cd3 	.word	0x00401cd3
  401adc:	00401cd3 	.word	0x00401cd3
  401ae0:	00401bd3 	.word	0x00401bd3
  401ae4:	00401bf3 	.word	0x00401bf3
  401ae8:	00401c2f 	.word	0x00401c2f
  401aec:	00401cd3 	.word	0x00401cd3
  401af0:	00401cd3 	.word	0x00401cd3
  401af4:	00401b7d 	.word	0x00401b7d
  401af8:	00401c4b 	.word	0x00401c4b
  401afc:	00401b45 	.word	0x00401b45
  401b00:	00401c73 	.word	0x00401c73
  401b04:	00401c73 	.word	0x00401c73
  401b08:	00401c89 	.word	0x00401c89
  401b0c:	00401c2f 	.word	0x00401c2f
  401b10:	00401cd3 	.word	0x00401cd3
  401b14:	00401c73 	.word	0x00401c73
  401b18:	00401cd3 	.word	0x00401cd3
  401b1c:	00401cd3 	.word	0x00401cd3
  401b20:	00401c73 	.word	0x00401c73
  401b24:	00401c69 	.word	0x00401c69
  401b28:	00401cd3 	.word	0x00401cd3
  401b2c:	00401c79 	.word	0x00401c79
  401b30:	00401cd3 	.word	0x00401cd3
  401b34:	00401cd3 	.word	0x00401cd3
  401b38:	00401cd3 	.word	0x00401cd3
  401b3c:	00401cb1 	.word	0x00401cb1
  401b40:	00401cb1 	.word	0x00401cb1
	case INV_SENSOR_TYPE_UNCAL_GYROSCOPE:
		memcpy(raw_bias_data, data, sizeof(raw_bias_data));
  401b44:	f107 0364 	add.w	r3, r7, #100	; 0x64
  401b48:	2218      	movs	r2, #24
  401b4a:	f8d7 1090 	ldr.w	r1, [r7, #144]	; 0x90
  401b4e:	4618      	mov	r0, r3
  401b50:	4b64      	ldr	r3, [pc, #400]	; (401ce4 <build_sensor_event_data+0x26c>)
  401b52:	4798      	blx	r3
		memcpy(event.data.gyr.vect, &raw_bias_data[0], sizeof(event.data.gyr.vect));
  401b54:	f107 0320 	add.w	r3, r7, #32
  401b58:	f107 0264 	add.w	r2, r7, #100	; 0x64
  401b5c:	ca07      	ldmia	r2, {r0, r1, r2}
  401b5e:	e883 0007 	stmia.w	r3, {r0, r1, r2}
		memcpy(event.data.gyr.bias, &raw_bias_data[3], sizeof(event.data.gyr.bias));
  401b62:	f107 032c 	add.w	r3, r7, #44	; 0x2c
  401b66:	f107 0270 	add.w	r2, r7, #112	; 0x70
  401b6a:	ca07      	ldmia	r2, {r0, r1, r2}
  401b6c:	e883 0007 	stmia.w	r3, {r0, r1, r2}
		memcpy(&(event.data.gyr.accuracy_flag), arg, sizeof(event.data.gyr.accuracy_flag));
  401b70:	f8d7 3094 	ldr.w	r3, [r7, #148]	; 0x94
  401b74:	781b      	ldrb	r3, [r3, #0]
  401b76:	f887 3038 	strb.w	r3, [r7, #56]	; 0x38
		break;
  401b7a:	e0a3      	b.n	401cc4 <build_sensor_event_data+0x24c>
	case INV_SENSOR_TYPE_UNCAL_MAGNETOMETER:
		memcpy(raw_bias_data, data, sizeof(raw_bias_data));
  401b7c:	f107 0364 	add.w	r3, r7, #100	; 0x64
  401b80:	2218      	movs	r2, #24
  401b82:	f8d7 1090 	ldr.w	r1, [r7, #144]	; 0x90
  401b86:	4618      	mov	r0, r3
  401b88:	4b56      	ldr	r3, [pc, #344]	; (401ce4 <build_sensor_event_data+0x26c>)
  401b8a:	4798      	blx	r3
		memcpy(event.data.mag.vect, &raw_bias_data[0], sizeof(event.data.mag.vect));
  401b8c:	f107 0320 	add.w	r3, r7, #32
  401b90:	f107 0264 	add.w	r2, r7, #100	; 0x64
  401b94:	ca07      	ldmia	r2, {r0, r1, r2}
  401b96:	e883 0007 	stmia.w	r3, {r0, r1, r2}
		memcpy(event.data.mag.bias, &raw_bias_data[3], sizeof(event.data.mag.bias));
  401b9a:	f107 032c 	add.w	r3, r7, #44	; 0x2c
  401b9e:	f107 0270 	add.w	r2, r7, #112	; 0x70
  401ba2:	ca07      	ldmia	r2, {r0, r1, r2}
  401ba4:	e883 0007 	stmia.w	r3, {r0, r1, r2}
		memcpy(&(event.data.gyr.accuracy_flag), arg, sizeof(event.data.gyr.accuracy_flag));
  401ba8:	f8d7 3094 	ldr.w	r3, [r7, #148]	; 0x94
  401bac:	781b      	ldrb	r3, [r3, #0]
  401bae:	f887 3038 	strb.w	r3, [r7, #56]	; 0x38
		break;
  401bb2:	e087      	b.n	401cc4 <build_sensor_event_data+0x24c>
	case INV_SENSOR_TYPE_GYROSCOPE:
		memcpy(event.data.gyr.vect, data, sizeof(event.data.gyr.vect));
  401bb4:	f107 0310 	add.w	r3, r7, #16
  401bb8:	3310      	adds	r3, #16
  401bba:	220c      	movs	r2, #12
  401bbc:	f8d7 1090 	ldr.w	r1, [r7, #144]	; 0x90
  401bc0:	4618      	mov	r0, r3
  401bc2:	4b48      	ldr	r3, [pc, #288]	; (401ce4 <build_sensor_event_data+0x26c>)
  401bc4:	4798      	blx	r3
		memcpy(&(event.data.gyr.accuracy_flag), arg, sizeof(event.data.gyr.accuracy_flag));
  401bc6:	f8d7 3094 	ldr.w	r3, [r7, #148]	; 0x94
  401bca:	781b      	ldrb	r3, [r3, #0]
  401bcc:	f887 3038 	strb.w	r3, [r7, #56]	; 0x38
		break;
  401bd0:	e078      	b.n	401cc4 <build_sensor_event_data+0x24c>
	case INV_SENSOR_TYPE_GRAVITY:
		memcpy(event.data.acc.vect, data, sizeof(event.data.acc.vect));
  401bd2:	f107 0310 	add.w	r3, r7, #16
  401bd6:	3310      	adds	r3, #16
  401bd8:	220c      	movs	r2, #12
  401bda:	f8d7 1090 	ldr.w	r1, [r7, #144]	; 0x90
  401bde:	4618      	mov	r0, r3
  401be0:	4b40      	ldr	r3, [pc, #256]	; (401ce4 <build_sensor_event_data+0x26c>)
  401be2:	4798      	blx	r3
		event.data.acc.accuracy_flag = inv_icm20948_get_accel_accuracy();
  401be4:	4b40      	ldr	r3, [pc, #256]	; (401ce8 <build_sensor_event_data+0x270>)
  401be6:	4798      	blx	r3
  401be8:	4603      	mov	r3, r0
  401bea:	b2db      	uxtb	r3, r3
  401bec:	f887 3038 	strb.w	r3, [r7, #56]	; 0x38
		break;
  401bf0:	e068      	b.n	401cc4 <build_sensor_event_data+0x24c>
	case INV_SENSOR_TYPE_LINEAR_ACCELERATION:
	case INV_SENSOR_TYPE_ACCELEROMETER:
		memcpy(event.data.acc.vect, data, sizeof(event.data.acc.vect));
  401bf2:	f107 0310 	add.w	r3, r7, #16
  401bf6:	3310      	adds	r3, #16
  401bf8:	220c      	movs	r2, #12
  401bfa:	f8d7 1090 	ldr.w	r1, [r7, #144]	; 0x90
  401bfe:	4618      	mov	r0, r3
  401c00:	4b38      	ldr	r3, [pc, #224]	; (401ce4 <build_sensor_event_data+0x26c>)
  401c02:	4798      	blx	r3
		memcpy(&(event.data.acc.accuracy_flag), arg, sizeof(event.data.acc.accuracy_flag));
  401c04:	f8d7 3094 	ldr.w	r3, [r7, #148]	; 0x94
  401c08:	781b      	ldrb	r3, [r3, #0]
  401c0a:	f887 3038 	strb.w	r3, [r7, #56]	; 0x38
		break;
  401c0e:	e059      	b.n	401cc4 <build_sensor_event_data+0x24c>
	case INV_SENSOR_TYPE_MAGNETOMETER:
		memcpy(event.data.mag.vect, data, sizeof(event.data.mag.vect));
  401c10:	f107 0310 	add.w	r3, r7, #16
  401c14:	3310      	adds	r3, #16
  401c16:	220c      	movs	r2, #12
  401c18:	f8d7 1090 	ldr.w	r1, [r7, #144]	; 0x90
  401c1c:	4618      	mov	r0, r3
  401c1e:	4b31      	ldr	r3, [pc, #196]	; (401ce4 <build_sensor_event_data+0x26c>)
  401c20:	4798      	blx	r3
		memcpy(&(event.data.mag.accuracy_flag), arg, sizeof(event.data.mag.accuracy_flag));
  401c22:	f8d7 3094 	ldr.w	r3, [r7, #148]	; 0x94
  401c26:	781b      	ldrb	r3, [r3, #0]
  401c28:	f887 3038 	strb.w	r3, [r7, #56]	; 0x38
		break;
  401c2c:	e04a      	b.n	401cc4 <build_sensor_event_data+0x24c>
	case INV_SENSOR_TYPE_GEOMAG_ROTATION_VECTOR:
	case INV_SENSOR_TYPE_ROTATION_VECTOR:
		memcpy(&(event.data.quaternion.accuracy), arg, sizeof(event.data.quaternion.accuracy));
  401c2e:	f8d7 3094 	ldr.w	r3, [r7, #148]	; 0x94
  401c32:	681b      	ldr	r3, [r3, #0]
  401c34:	633b      	str	r3, [r7, #48]	; 0x30
		memcpy(event.data.quaternion.quat, data, sizeof(event.data.quaternion.quat));
  401c36:	f107 0310 	add.w	r3, r7, #16
  401c3a:	3310      	adds	r3, #16
  401c3c:	2210      	movs	r2, #16
  401c3e:	f8d7 1090 	ldr.w	r1, [r7, #144]	; 0x90
  401c42:	4618      	mov	r0, r3
  401c44:	4b27      	ldr	r3, [pc, #156]	; (401ce4 <build_sensor_event_data+0x26c>)
  401c46:	4798      	blx	r3
		break;
  401c48:	e03c      	b.n	401cc4 <build_sensor_event_data+0x24c>
	case INV_SENSOR_TYPE_GAME_ROTATION_VECTOR:
		memcpy(event.data.quaternion.quat, data, sizeof(event.data.quaternion.quat));
  401c4a:	f107 0310 	add.w	r3, r7, #16
  401c4e:	3310      	adds	r3, #16
  401c50:	2210      	movs	r2, #16
  401c52:	f8d7 1090 	ldr.w	r1, [r7, #144]	; 0x90
  401c56:	4618      	mov	r0, r3
  401c58:	4b22      	ldr	r3, [pc, #136]	; (401ce4 <build_sensor_event_data+0x26c>)
  401c5a:	4798      	blx	r3
		event.data.quaternion.accuracy_flag = icm20948_get_grv_accuracy();
  401c5c:	4b23      	ldr	r3, [pc, #140]	; (401cec <build_sensor_event_data+0x274>)
  401c5e:	4798      	blx	r3
  401c60:	4603      	mov	r3, r0
  401c62:	f887 3034 	strb.w	r3, [r7, #52]	; 0x34
		break;
  401c66:	e02d      	b.n	401cc4 <build_sensor_event_data+0x24c>
	case INV_SENSOR_TYPE_BAC:
		memcpy(&(event.data.bac.event), data, sizeof(event.data.bac.event));
  401c68:	f8d7 3090 	ldr.w	r3, [r7, #144]	; 0x90
  401c6c:	681b      	ldr	r3, [r3, #0]
  401c6e:	623b      	str	r3, [r7, #32]
		break;
  401c70:	e028      	b.n	401cc4 <build_sensor_event_data+0x24c>
	case INV_SENSOR_TYPE_PICK_UP_GESTURE:
	case INV_SENSOR_TYPE_TILT_DETECTOR:
	case INV_SENSOR_TYPE_STEP_DETECTOR:
	case INV_SENSOR_TYPE_SMD:
		event.data.event = true;
  401c72:	2301      	movs	r3, #1
  401c74:	623b      	str	r3, [r7, #32]
		break;
  401c76:	e025      	b.n	401cc4 <build_sensor_event_data+0x24c>
	case INV_SENSOR_TYPE_B2S:
		event.data.event = true;
  401c78:	2301      	movs	r3, #1
  401c7a:	623b      	str	r3, [r7, #32]
		memcpy(&(event.data.b2s.direction), data, sizeof(event.data.b2s.direction));
  401c7c:	f8d7 3090 	ldr.w	r3, [r7, #144]	; 0x90
  401c80:	781b      	ldrb	r3, [r3, #0]
  401c82:	f887 3020 	strb.w	r3, [r7, #32]
		break;
  401c86:	e01d      	b.n	401cc4 <build_sensor_event_data+0x24c>
	case INV_SENSOR_TYPE_STEP_COUNTER:
		memcpy(&(event.data.step.count), data, sizeof(event.data.step.count));
  401c88:	f107 0310 	add.w	r3, r7, #16
  401c8c:	3310      	adds	r3, #16
  401c8e:	2208      	movs	r2, #8
  401c90:	f8d7 1090 	ldr.w	r1, [r7, #144]	; 0x90
  401c94:	4618      	mov	r0, r3
  401c96:	4b13      	ldr	r3, [pc, #76]	; (401ce4 <build_sensor_event_data+0x26c>)
  401c98:	4798      	blx	r3
		break;
  401c9a:	e013      	b.n	401cc4 <build_sensor_event_data+0x24c>
	case INV_SENSOR_TYPE_ORIENTATION:
		//we just want to copy x,y,z from orientation data
		memcpy(&(event.data.orientation), data, 3*sizeof(float));
  401c9c:	f107 0310 	add.w	r3, r7, #16
  401ca0:	3310      	adds	r3, #16
  401ca2:	220c      	movs	r2, #12
  401ca4:	f8d7 1090 	ldr.w	r1, [r7, #144]	; 0x90
  401ca8:	4618      	mov	r0, r3
  401caa:	4b0e      	ldr	r3, [pc, #56]	; (401ce4 <build_sensor_event_data+0x26c>)
  401cac:	4798      	blx	r3
		break;
  401cae:	e009      	b.n	401cc4 <build_sensor_event_data+0x24c>
	case INV_SENSOR_TYPE_RAW_ACCELEROMETER:
	case INV_SENSOR_TYPE_RAW_GYROSCOPE:
		memcpy(event.data.raw3d.vect, data, sizeof(event.data.raw3d.vect));
  401cb0:	f107 0310 	add.w	r3, r7, #16
  401cb4:	3310      	adds	r3, #16
  401cb6:	220c      	movs	r2, #12
  401cb8:	f8d7 1090 	ldr.w	r1, [r7, #144]	; 0x90
  401cbc:	4618      	mov	r0, r3
  401cbe:	4b09      	ldr	r3, [pc, #36]	; (401ce4 <build_sensor_event_data+0x26c>)
  401cc0:	4798      	blx	r3
		break;
  401cc2:	bf00      	nop
	default:
		return;
	}
	sensor_event(&event, NULL);
  401cc4:	f107 0310 	add.w	r3, r7, #16
  401cc8:	2100      	movs	r1, #0
  401cca:	4618      	mov	r0, r3
  401ccc:	4b08      	ldr	r3, [pc, #32]	; (401cf0 <build_sensor_event_data+0x278>)
  401cce:	4798      	blx	r3
  401cd0:	e000      	b.n	401cd4 <build_sensor_event_data+0x25c>
		return;
  401cd2:	bf00      	nop
}
  401cd4:	3784      	adds	r7, #132	; 0x84
  401cd6:	46bd      	mov	sp, r7
  401cd8:	bd90      	pop	{r4, r7, pc}
  401cda:	bf00      	nop
  401cdc:	20000104 	.word	0x20000104
  401ce0:	00414241 	.word	0x00414241
  401ce4:	00414045 	.word	0x00414045
  401ce8:	0040996d 	.word	0x0040996d
  401cec:	00401a45 	.word	0x00401a45
  401cf0:	00401cf5 	.word	0x00401cf5

00401cf4 <sensor_event>:

void sensor_event(const inv_sensor_event_t * event, void * arg){
  401cf4:	b590      	push	{r4, r7, lr}
  401cf6:	b087      	sub	sp, #28
  401cf8:	af02      	add	r7, sp, #8
  401cfa:	6078      	str	r0, [r7, #4]
  401cfc:	6039      	str	r1, [r7, #0]
	*/
	static DynProtocolEdata_t async_edata; /* static to take on .bss */
	static uint8_t async_buffer[256]; /* static to take on .bss */
	uint16_t async_bufferLen;

	async_edata.sensor_id = event->sensor;
  401cfe:	687b      	ldr	r3, [r7, #4]
  401d00:	681b      	ldr	r3, [r3, #0]
  401d02:	461a      	mov	r2, r3
  401d04:	4b13      	ldr	r3, [pc, #76]	; (401d54 <sensor_event+0x60>)
  401d06:	601a      	str	r2, [r3, #0]
	async_edata.d.async.sensorEvent.status = DYN_PRO_SENSOR_STATUS_DATA_UPDATED;
  401d08:	4b12      	ldr	r3, [pc, #72]	; (401d54 <sensor_event+0x60>)
  401d0a:	2200      	movs	r2, #0
  401d0c:	605a      	str	r2, [r3, #4]
	convert_sensor_event_to_dyn_prot_data(event, &async_edata.d.async.sensorEvent.vdata);
  401d0e:	4912      	ldr	r1, [pc, #72]	; (401d58 <sensor_event+0x64>)
  401d10:	6878      	ldr	r0, [r7, #4]
  401d12:	4b12      	ldr	r3, [pc, #72]	; (401d5c <sensor_event+0x68>)
  401d14:	4798      	blx	r3

	if(DynProtocol_encodeAsync(&protocol,
  401d16:	f107 030e 	add.w	r3, r7, #14
  401d1a:	9301      	str	r3, [sp, #4]
  401d1c:	f44f 7380 	mov.w	r3, #256	; 0x100
  401d20:	9300      	str	r3, [sp, #0]
  401d22:	4b0f      	ldr	r3, [pc, #60]	; (401d60 <sensor_event+0x6c>)
  401d24:	4a0b      	ldr	r2, [pc, #44]	; (401d54 <sensor_event+0x60>)
  401d26:	2130      	movs	r1, #48	; 0x30
  401d28:	480e      	ldr	r0, [pc, #56]	; (401d64 <sensor_event+0x70>)
  401d2a:	4c0f      	ldr	r4, [pc, #60]	; (401d68 <sensor_event+0x74>)
  401d2c:	47a0      	blx	r4
  401d2e:	4603      	mov	r3, r0
  401d30:	2b00      	cmp	r3, #0
  401d32:	d106      	bne.n	401d42 <sensor_event+0x4e>
		DYN_PROTOCOL_EID_NEW_SENSOR_DATA, &async_edata,
		async_buffer, sizeof(async_buffer), &async_bufferLen) != 0) {
			goto error_dma_buf;
	}

	DynProTransportUart_tx(&transport, async_buffer, async_bufferLen);
  401d34:	89fb      	ldrh	r3, [r7, #14]
  401d36:	461a      	mov	r2, r3
  401d38:	4909      	ldr	r1, [pc, #36]	; (401d60 <sensor_event+0x6c>)
  401d3a:	480c      	ldr	r0, [pc, #48]	; (401d6c <sensor_event+0x78>)
  401d3c:	4b0c      	ldr	r3, [pc, #48]	; (401d70 <sensor_event+0x7c>)
  401d3e:	4798      	blx	r3
	return;
  401d40:	e005      	b.n	401d4e <sensor_event+0x5a>
			goto error_dma_buf;
  401d42:	bf00      	nop

error_dma_buf:
	INV_MSG(INV_MSG_LEVEL_WARNING, "sensor_event_cb: encode error, frame dropped");
  401d44:	490b      	ldr	r1, [pc, #44]	; (401d74 <sensor_event+0x80>)
  401d46:	2002      	movs	r0, #2
  401d48:	4b0b      	ldr	r3, [pc, #44]	; (401d78 <sensor_event+0x84>)
  401d4a:	4798      	blx	r3

	return;
  401d4c:	bf00      	nop
}
  401d4e:	3714      	adds	r7, #20
  401d50:	46bd      	mov	sp, r7
  401d52:	bd90      	pop	{r4, r7, pc}
  401d54:	20001084 	.word	0x20001084
  401d58:	2000108c 	.word	0x2000108c
  401d5c:	00401d7d 	.word	0x00401d7d
  401d60:	20001108 	.word	0x20001108
  401d64:	20001888 	.word	0x20001888
  401d68:	0040f46d 	.word	0x0040f46d
  401d6c:	20001b20 	.word	0x20001b20
  401d70:	0040f6ed 	.word	0x0040f6ed
  401d74:	0041ba50 	.word	0x0041ba50
  401d78:	0040fd19 	.word	0x0040fd19

00401d7c <convert_sensor_event_to_dyn_prot_data>:

/*
* Convert sensor_event to VSensorData because dynamic protocol transports VSensorData
*/
static void convert_sensor_event_to_dyn_prot_data(const inv_sensor_event_t * event, VSensorDataAny * vsensor_data){
  401d7c:	b590      	push	{r4, r7, lr}
  401d7e:	b083      	sub	sp, #12
  401d80:	af00      	add	r7, sp, #0
  401d82:	6078      	str	r0, [r7, #4]
  401d84:	6039      	str	r1, [r7, #0]
	vsensor_data->base.timestamp = event->timestamp;
  401d86:	687b      	ldr	r3, [r7, #4]
  401d88:	e9d3 3402 	ldrd	r3, r4, [r3, #8]
  401d8c:	461a      	mov	r2, r3
  401d8e:	683b      	ldr	r3, [r7, #0]
  401d90:	601a      	str	r2, [r3, #0]

	switch(event->sensor) {
  401d92:	687b      	ldr	r3, [r7, #4]
  401d94:	681b      	ldr	r3, [r3, #0]
  401d96:	2b41      	cmp	r3, #65	; 0x41
  401d98:	f200 815d 	bhi.w	402056 <convert_sensor_event_to_dyn_prot_data+0x2da>
  401d9c:	a201      	add	r2, pc, #4	; (adr r2, 401da4 <convert_sensor_event_to_dyn_prot_data+0x28>)
  401d9e:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
  401da2:	bf00      	nop
  401da4:	00402057 	.word	0x00402057
  401da8:	00401ead 	.word	0x00401ead
  401dac:	00401f3f 	.word	0x00401f3f
  401db0:	00401fc3 	.word	0x00401fc3
  401db4:	00401ecd 	.word	0x00401ecd
  401db8:	00402057 	.word	0x00402057
  401dbc:	00402057 	.word	0x00402057
  401dc0:	00402057 	.word	0x00402057
  401dc4:	00402057 	.word	0x00402057
  401dc8:	00401ead 	.word	0x00401ead
  401dcc:	00401ead 	.word	0x00401ead
  401dd0:	00401f91 	.word	0x00401f91
  401dd4:	00402057 	.word	0x00402057
  401dd8:	00402057 	.word	0x00402057
  401ddc:	00401f5f 	.word	0x00401f5f
  401de0:	00401f1f 	.word	0x00401f1f
  401de4:	00401eed 	.word	0x00401eed
  401de8:	0040204b 	.word	0x0040204b
  401dec:	0040204b 	.word	0x0040204b
  401df0:	00402025 	.word	0x00402025
  401df4:	00401f91 	.word	0x00401f91
  401df8:	00402057 	.word	0x00402057
  401dfc:	0040204b 	.word	0x0040204b
  401e00:	00402057 	.word	0x00402057
  401e04:	00402057 	.word	0x00402057
  401e08:	0040204b 	.word	0x0040204b
  401e0c:	00402033 	.word	0x00402033
  401e10:	00402057 	.word	0x00402057
  401e14:	0040204b 	.word	0x0040204b
  401e18:	00402057 	.word	0x00402057
  401e1c:	00402057 	.word	0x00402057
  401e20:	00402057 	.word	0x00402057
  401e24:	00402005 	.word	0x00402005
  401e28:	00402005 	.word	0x00402005
  401e2c:	00402057 	.word	0x00402057
  401e30:	00402057 	.word	0x00402057
  401e34:	00402057 	.word	0x00402057
  401e38:	00402057 	.word	0x00402057
  401e3c:	00402057 	.word	0x00402057
  401e40:	00402057 	.word	0x00402057
  401e44:	00402057 	.word	0x00402057
  401e48:	00402057 	.word	0x00402057
  401e4c:	00402057 	.word	0x00402057
  401e50:	00402057 	.word	0x00402057
  401e54:	00402057 	.word	0x00402057
  401e58:	00402057 	.word	0x00402057
  401e5c:	00402057 	.word	0x00402057
  401e60:	00402057 	.word	0x00402057
  401e64:	00402057 	.word	0x00402057
  401e68:	00402057 	.word	0x00402057
  401e6c:	00402057 	.word	0x00402057
  401e70:	00402057 	.word	0x00402057
  401e74:	00402057 	.word	0x00402057
  401e78:	00402057 	.word	0x00402057
  401e7c:	00402057 	.word	0x00402057
  401e80:	00402057 	.word	0x00402057
  401e84:	00402057 	.word	0x00402057
  401e88:	0040203f 	.word	0x0040203f
  401e8c:	00402057 	.word	0x00402057
  401e90:	00402057 	.word	0x00402057
  401e94:	00402057 	.word	0x00402057
  401e98:	00402057 	.word	0x00402057
  401e9c:	00402057 	.word	0x00402057
  401ea0:	00402057 	.word	0x00402057
  401ea4:	00401f1f 	.word	0x00401f1f
  401ea8:	00401f1f 	.word	0x00401f1f
		case DYN_PRO_SENSOR_TYPE_RESERVED:
		break;
		case DYN_PRO_SENSOR_TYPE_GRAVITY:
		case DYN_PRO_SENSOR_TYPE_LINEAR_ACCELERATION:
		case DYN_PRO_SENSOR_TYPE_ACCELEROMETER:
		inv_dc_float_to_sfix32(&event->data.acc.vect[0], 3, 16, (int32_t *)&vsensor_data->data.u32[0]);
  401eac:	687b      	ldr	r3, [r7, #4]
  401eae:	f103 0010 	add.w	r0, r3, #16
  401eb2:	683b      	ldr	r3, [r7, #0]
  401eb4:	3308      	adds	r3, #8
  401eb6:	2210      	movs	r2, #16
  401eb8:	2103      	movs	r1, #3
  401eba:	4c69      	ldr	r4, [pc, #420]	; (402060 <convert_sensor_event_to_dyn_prot_data+0x2e4>)
  401ebc:	47a0      	blx	r4
		vsensor_data->base.meta_data = event->data.acc.accuracy_flag;
  401ebe:	687b      	ldr	r3, [r7, #4]
  401ec0:	f893 3028 	ldrb.w	r3, [r3, #40]	; 0x28
  401ec4:	461a      	mov	r2, r3
  401ec6:	683b      	ldr	r3, [r7, #0]
  401ec8:	605a      	str	r2, [r3, #4]
		break;
  401eca:	e0c5      	b.n	402058 <convert_sensor_event_to_dyn_prot_data+0x2dc>
		case DYN_PRO_SENSOR_TYPE_GYROSCOPE:
		inv_dc_float_to_sfix32(&event->data.gyr.vect[0], 3, 16, (int32_t *)&vsensor_data->data.u32[0]);
  401ecc:	687b      	ldr	r3, [r7, #4]
  401ece:	f103 0010 	add.w	r0, r3, #16
  401ed2:	683b      	ldr	r3, [r7, #0]
  401ed4:	3308      	adds	r3, #8
  401ed6:	2210      	movs	r2, #16
  401ed8:	2103      	movs	r1, #3
  401eda:	4c61      	ldr	r4, [pc, #388]	; (402060 <convert_sensor_event_to_dyn_prot_data+0x2e4>)
  401edc:	47a0      	blx	r4
		vsensor_data->base.meta_data = event->data.gyr.accuracy_flag;
  401ede:	687b      	ldr	r3, [r7, #4]
  401ee0:	f893 3028 	ldrb.w	r3, [r3, #40]	; 0x28
  401ee4:	461a      	mov	r2, r3
  401ee6:	683b      	ldr	r3, [r7, #0]
  401ee8:	605a      	str	r2, [r3, #4]
		break;
  401eea:	e0b5      	b.n	402058 <convert_sensor_event_to_dyn_prot_data+0x2dc>
		case DYN_PRO_SENSOR_TYPE_UNCAL_GYROSCOPE:
		inv_dc_float_to_sfix32(&event->data.gyr.vect[0], 3, 16, (int32_t *)&vsensor_data->data.u32[0]);
  401eec:	687b      	ldr	r3, [r7, #4]
  401eee:	f103 0010 	add.w	r0, r3, #16
  401ef2:	683b      	ldr	r3, [r7, #0]
  401ef4:	3308      	adds	r3, #8
  401ef6:	2210      	movs	r2, #16
  401ef8:	2103      	movs	r1, #3
  401efa:	4c59      	ldr	r4, [pc, #356]	; (402060 <convert_sensor_event_to_dyn_prot_data+0x2e4>)
  401efc:	47a0      	blx	r4
		inv_dc_float_to_sfix32(&event->data.gyr.bias[0], 3, 16, (int32_t *)&vsensor_data->data.u32[3]);
  401efe:	687b      	ldr	r3, [r7, #4]
  401f00:	f103 001c 	add.w	r0, r3, #28
  401f04:	683b      	ldr	r3, [r7, #0]
  401f06:	3314      	adds	r3, #20
  401f08:	2210      	movs	r2, #16
  401f0a:	2103      	movs	r1, #3
  401f0c:	4c54      	ldr	r4, [pc, #336]	; (402060 <convert_sensor_event_to_dyn_prot_data+0x2e4>)
  401f0e:	47a0      	blx	r4
		vsensor_data->base.meta_data = event->data.gyr.accuracy_flag;
  401f10:	687b      	ldr	r3, [r7, #4]
  401f12:	f893 3028 	ldrb.w	r3, [r3, #40]	; 0x28
  401f16:	461a      	mov	r2, r3
  401f18:	683b      	ldr	r3, [r7, #0]
  401f1a:	605a      	str	r2, [r3, #4]
		break;
  401f1c:	e09c      	b.n	402058 <convert_sensor_event_to_dyn_prot_data+0x2dc>
		case DYN_PRO_SENSOR_TYPE_PRED_QUAT_0:
		case DYN_PRO_SENSOR_TYPE_PRED_QUAT_1:
		case DYN_PRO_SENSOR_TYPE_GAME_ROTATION_VECTOR:
		inv_dc_float_to_sfix32(&event->data.quaternion.quat[0], 4, 30, (int32_t *)&vsensor_data->data.u32[0]);
  401f1e:	687b      	ldr	r3, [r7, #4]
  401f20:	f103 0010 	add.w	r0, r3, #16
  401f24:	683b      	ldr	r3, [r7, #0]
  401f26:	3308      	adds	r3, #8
  401f28:	221e      	movs	r2, #30
  401f2a:	2104      	movs	r1, #4
  401f2c:	4c4c      	ldr	r4, [pc, #304]	; (402060 <convert_sensor_event_to_dyn_prot_data+0x2e4>)
  401f2e:	47a0      	blx	r4
		vsensor_data->base.meta_data = event->data.quaternion.accuracy_flag;
  401f30:	687b      	ldr	r3, [r7, #4]
  401f32:	f893 3024 	ldrb.w	r3, [r3, #36]	; 0x24
  401f36:	461a      	mov	r2, r3
  401f38:	683b      	ldr	r3, [r7, #0]
  401f3a:	605a      	str	r2, [r3, #4]
		break;
  401f3c:	e08c      	b.n	402058 <convert_sensor_event_to_dyn_prot_data+0x2dc>
		case DYN_PRO_SENSOR_TYPE_MAGNETOMETER:
		inv_dc_float_to_sfix32(&event->data.mag.vect[0], 3, 16, (int32_t *)&vsensor_data->data.u32[0]);
  401f3e:	687b      	ldr	r3, [r7, #4]
  401f40:	f103 0010 	add.w	r0, r3, #16
  401f44:	683b      	ldr	r3, [r7, #0]
  401f46:	3308      	adds	r3, #8
  401f48:	2210      	movs	r2, #16
  401f4a:	2103      	movs	r1, #3
  401f4c:	4c44      	ldr	r4, [pc, #272]	; (402060 <convert_sensor_event_to_dyn_prot_data+0x2e4>)
  401f4e:	47a0      	blx	r4
		vsensor_data->base.meta_data = event->data.mag.accuracy_flag;
  401f50:	687b      	ldr	r3, [r7, #4]
  401f52:	f893 3028 	ldrb.w	r3, [r3, #40]	; 0x28
  401f56:	461a      	mov	r2, r3
  401f58:	683b      	ldr	r3, [r7, #0]
  401f5a:	605a      	str	r2, [r3, #4]
		break;
  401f5c:	e07c      	b.n	402058 <convert_sensor_event_to_dyn_prot_data+0x2dc>
		case DYN_PRO_SENSOR_TYPE_UNCAL_MAGNETOMETER:
		inv_dc_float_to_sfix32(&event->data.mag.vect[0], 3, 16, (int32_t *)&vsensor_data->data.u32[0]);
  401f5e:	687b      	ldr	r3, [r7, #4]
  401f60:	f103 0010 	add.w	r0, r3, #16
  401f64:	683b      	ldr	r3, [r7, #0]
  401f66:	3308      	adds	r3, #8
  401f68:	2210      	movs	r2, #16
  401f6a:	2103      	movs	r1, #3
  401f6c:	4c3c      	ldr	r4, [pc, #240]	; (402060 <convert_sensor_event_to_dyn_prot_data+0x2e4>)
  401f6e:	47a0      	blx	r4
		inv_dc_float_to_sfix32(&event->data.mag.bias[0], 3, 16, (int32_t *)&vsensor_data->data.u32[3]);
  401f70:	687b      	ldr	r3, [r7, #4]
  401f72:	f103 001c 	add.w	r0, r3, #28
  401f76:	683b      	ldr	r3, [r7, #0]
  401f78:	3314      	adds	r3, #20
  401f7a:	2210      	movs	r2, #16
  401f7c:	2103      	movs	r1, #3
  401f7e:	4c38      	ldr	r4, [pc, #224]	; (402060 <convert_sensor_event_to_dyn_prot_data+0x2e4>)
  401f80:	47a0      	blx	r4
		vsensor_data->base.meta_data = event->data.mag.accuracy_flag;
  401f82:	687b      	ldr	r3, [r7, #4]
  401f84:	f893 3028 	ldrb.w	r3, [r3, #40]	; 0x28
  401f88:	461a      	mov	r2, r3
  401f8a:	683b      	ldr	r3, [r7, #0]
  401f8c:	605a      	str	r2, [r3, #4]
		break;
  401f8e:	e063      	b.n	402058 <convert_sensor_event_to_dyn_prot_data+0x2dc>
		case DYN_PRO_SENSOR_TYPE_ROTATION_VECTOR:
		case DYN_PRO_SENSOR_TYPE_GEOMAG_ROTATION_VECTOR:
		inv_dc_float_to_sfix32(&event->data.quaternion.quat[0], 4, 30, (int32_t *)&vsensor_data->data.u32[0]);
  401f90:	687b      	ldr	r3, [r7, #4]
  401f92:	f103 0010 	add.w	r0, r3, #16
  401f96:	683b      	ldr	r3, [r7, #0]
  401f98:	3308      	adds	r3, #8
  401f9a:	221e      	movs	r2, #30
  401f9c:	2104      	movs	r1, #4
  401f9e:	4c30      	ldr	r4, [pc, #192]	; (402060 <convert_sensor_event_to_dyn_prot_data+0x2e4>)
  401fa0:	47a0      	blx	r4
		inv_dc_float_to_sfix32(&event->data.quaternion.accuracy, 1, 16, (int32_t *)&vsensor_data->data.u32[4]);
  401fa2:	687b      	ldr	r3, [r7, #4]
  401fa4:	f103 0020 	add.w	r0, r3, #32
  401fa8:	683b      	ldr	r3, [r7, #0]
  401faa:	3318      	adds	r3, #24
  401fac:	2210      	movs	r2, #16
  401fae:	2101      	movs	r1, #1
  401fb0:	4c2b      	ldr	r4, [pc, #172]	; (402060 <convert_sensor_event_to_dyn_prot_data+0x2e4>)
  401fb2:	47a0      	blx	r4
		vsensor_data->base.meta_data = event->data.quaternion.accuracy_flag;
  401fb4:	687b      	ldr	r3, [r7, #4]
  401fb6:	f893 3024 	ldrb.w	r3, [r3, #36]	; 0x24
  401fba:	461a      	mov	r2, r3
  401fbc:	683b      	ldr	r3, [r7, #0]
  401fbe:	605a      	str	r2, [r3, #4]
		break;
  401fc0:	e04a      	b.n	402058 <convert_sensor_event_to_dyn_prot_data+0x2dc>
		case DYN_PRO_SENSOR_TYPE_ORIENTATION:
		inv_dc_float_to_sfix32(&event->data.orientation.x, 1, 16, (int32_t *)&vsensor_data->data.u32[0]);
  401fc2:	687b      	ldr	r3, [r7, #4]
  401fc4:	f103 0010 	add.w	r0, r3, #16
  401fc8:	683b      	ldr	r3, [r7, #0]
  401fca:	3308      	adds	r3, #8
  401fcc:	2210      	movs	r2, #16
  401fce:	2101      	movs	r1, #1
  401fd0:	4c23      	ldr	r4, [pc, #140]	; (402060 <convert_sensor_event_to_dyn_prot_data+0x2e4>)
  401fd2:	47a0      	blx	r4
		inv_dc_float_to_sfix32(&event->data.orientation.y, 1, 16, (int32_t *)&vsensor_data->data.u32[1]);
  401fd4:	687b      	ldr	r3, [r7, #4]
  401fd6:	f103 0014 	add.w	r0, r3, #20
  401fda:	683b      	ldr	r3, [r7, #0]
  401fdc:	330c      	adds	r3, #12
  401fde:	2210      	movs	r2, #16
  401fe0:	2101      	movs	r1, #1
  401fe2:	4c1f      	ldr	r4, [pc, #124]	; (402060 <convert_sensor_event_to_dyn_prot_data+0x2e4>)
  401fe4:	47a0      	blx	r4
		inv_dc_float_to_sfix32(&event->data.orientation.z, 1, 16, (int32_t *)&vsensor_data->data.u32[2]);
  401fe6:	687b      	ldr	r3, [r7, #4]
  401fe8:	f103 0018 	add.w	r0, r3, #24
  401fec:	683b      	ldr	r3, [r7, #0]
  401fee:	3310      	adds	r3, #16
  401ff0:	2210      	movs	r2, #16
  401ff2:	2101      	movs	r1, #1
  401ff4:	4c1a      	ldr	r4, [pc, #104]	; (402060 <convert_sensor_event_to_dyn_prot_data+0x2e4>)
  401ff6:	47a0      	blx	r4
		vsensor_data->base.meta_data = event->data.orientation.accuracy_flag;
  401ff8:	687b      	ldr	r3, [r7, #4]
  401ffa:	7f1b      	ldrb	r3, [r3, #28]
  401ffc:	461a      	mov	r2, r3
  401ffe:	683b      	ldr	r3, [r7, #0]
  402000:	605a      	str	r2, [r3, #4]
		break;
  402002:	e029      	b.n	402058 <convert_sensor_event_to_dyn_prot_data+0x2dc>
		case DYN_PRO_SENSOR_TYPE_RAW_ACCELEROMETER:
		case DYN_PRO_SENSOR_TYPE_RAW_GYROSCOPE:
		vsensor_data->data.u32[0] = event->data.raw3d.vect[0];
  402004:	687b      	ldr	r3, [r7, #4]
  402006:	691b      	ldr	r3, [r3, #16]
  402008:	461a      	mov	r2, r3
  40200a:	683b      	ldr	r3, [r7, #0]
  40200c:	609a      	str	r2, [r3, #8]
		vsensor_data->data.u32[1] = event->data.raw3d.vect[1];
  40200e:	687b      	ldr	r3, [r7, #4]
  402010:	695b      	ldr	r3, [r3, #20]
  402012:	461a      	mov	r2, r3
  402014:	683b      	ldr	r3, [r7, #0]
  402016:	60da      	str	r2, [r3, #12]
		vsensor_data->data.u32[2] = event->data.raw3d.vect[2];
  402018:	687b      	ldr	r3, [r7, #4]
  40201a:	699b      	ldr	r3, [r3, #24]
  40201c:	461a      	mov	r2, r3
  40201e:	683b      	ldr	r3, [r7, #0]
  402020:	611a      	str	r2, [r3, #16]
		break;
  402022:	e019      	b.n	402058 <convert_sensor_event_to_dyn_prot_data+0x2dc>
		case DYN_PRO_SENSOR_TYPE_STEP_COUNTER:
		vsensor_data->data.u32[0] = (uint32_t)event->data.step.count;
  402024:	687b      	ldr	r3, [r7, #4]
  402026:	e9d3 3404 	ldrd	r3, r4, [r3, #16]
  40202a:	461a      	mov	r2, r3
  40202c:	683b      	ldr	r3, [r7, #0]
  40202e:	609a      	str	r2, [r3, #8]
		break;
  402030:	e012      	b.n	402058 <convert_sensor_event_to_dyn_prot_data+0x2dc>
		case DYN_PRO_SENSOR_TYPE_BAC:
		vsensor_data->data.u8[0] = (uint8_t)(int8_t)event->data.bac.event;
  402032:	687b      	ldr	r3, [r7, #4]
  402034:	691b      	ldr	r3, [r3, #16]
  402036:	b2da      	uxtb	r2, r3
  402038:	683b      	ldr	r3, [r7, #0]
  40203a:	721a      	strb	r2, [r3, #8]
		break;
  40203c:	e00c      	b.n	402058 <convert_sensor_event_to_dyn_prot_data+0x2dc>
		case DYN_PRO_SENSOR_TYPE_WOM:
		vsensor_data->data.u8[0] = event->data.wom.flags;
  40203e:	687b      	ldr	r3, [r7, #4]
  402040:	691b      	ldr	r3, [r3, #16]
  402042:	b2da      	uxtb	r2, r3
  402044:	683b      	ldr	r3, [r7, #0]
  402046:	721a      	strb	r2, [r3, #8]
		break;
  402048:	e006      	b.n	402058 <convert_sensor_event_to_dyn_prot_data+0x2dc>
		case DYN_PRO_SENSOR_TYPE_B2S:
		case DYN_PRO_SENSOR_TYPE_SMD:
		case DYN_PRO_SENSOR_TYPE_STEP_DETECTOR:
		case DYN_PRO_SENSOR_TYPE_TILT_DETECTOR:
		case DYN_PRO_SENSOR_TYPE_PICK_UP_GESTURE:
		vsensor_data->data.u8[0] = event->data.event;
  40204a:	687b      	ldr	r3, [r7, #4]
  40204c:	691b      	ldr	r3, [r3, #16]
  40204e:	b2da      	uxtb	r2, r3
  402050:	683b      	ldr	r3, [r7, #0]
  402052:	721a      	strb	r2, [r3, #8]
		break;
  402054:	e000      	b.n	402058 <convert_sensor_event_to_dyn_prot_data+0x2dc>
		default:
		break;
  402056:	bf00      	nop
	}
}
  402058:	bf00      	nop
  40205a:	370c      	adds	r7, #12
  40205c:	46bd      	mov	sp, r7
  40205e:	bd90      	pop	{r4, r7, pc}
  402060:	0040f893 	.word	0x0040f893

00402064 <idd_sensortype_conversion>:

static enum inv_icm20948_sensor idd_sensortype_conversion(int sensor){
  402064:	b480      	push	{r7}
  402066:	b083      	sub	sp, #12
  402068:	af00      	add	r7, sp, #0
  40206a:	6078      	str	r0, [r7, #4]
	switch(sensor) {
  40206c:	687b      	ldr	r3, [r7, #4]
  40206e:	3b01      	subs	r3, #1
  402070:	2b20      	cmp	r3, #32
  402072:	d86d      	bhi.n	402150 <idd_sensortype_conversion+0xec>
  402074:	a201      	add	r2, pc, #4	; (adr r2, 40207c <idd_sensortype_conversion+0x18>)
  402076:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
  40207a:	bf00      	nop
  40207c:	00402109 	.word	0x00402109
  402080:	00402131 	.word	0x00402131
  402084:	00402149 	.word	0x00402149
  402088:	0040210d 	.word	0x0040210d
  40208c:	00402151 	.word	0x00402151
  402090:	00402151 	.word	0x00402151
  402094:	00402151 	.word	0x00402151
  402098:	00402151 	.word	0x00402151
  40209c:	00402141 	.word	0x00402141
  4020a0:	00402145 	.word	0x00402145
  4020a4:	00402129 	.word	0x00402129
  4020a8:	00402151 	.word	0x00402151
  4020ac:	00402151 	.word	0x00402151
  4020b0:	00402111 	.word	0x00402111
  4020b4:	00402125 	.word	0x00402125
  4020b8:	00402115 	.word	0x00402115
  4020bc:	00402135 	.word	0x00402135
  4020c0:	0040211d 	.word	0x0040211d
  4020c4:	00402121 	.word	0x00402121
  4020c8:	0040212d 	.word	0x0040212d
  4020cc:	00402151 	.word	0x00402151
  4020d0:	0040213d 	.word	0x0040213d
  4020d4:	00402151 	.word	0x00402151
  4020d8:	00402151 	.word	0x00402151
  4020dc:	00402139 	.word	0x00402139
  4020e0:	00402119 	.word	0x00402119
  4020e4:	00402151 	.word	0x00402151
  4020e8:	0040214d 	.word	0x0040214d
  4020ec:	00402151 	.word	0x00402151
  4020f0:	00402151 	.word	0x00402151
  4020f4:	00402151 	.word	0x00402151
  4020f8:	00402101 	.word	0x00402101
  4020fc:	00402105 	.word	0x00402105
	case INV_SENSOR_TYPE_RAW_ACCELEROMETER:       return INV_ICM20948_SENSOR_RAW_ACCELEROMETER;
  402100:	2302      	movs	r3, #2
  402102:	e026      	b.n	402152 <idd_sensortype_conversion+0xee>
	case INV_SENSOR_TYPE_RAW_GYROSCOPE:           return INV_ICM20948_SENSOR_RAW_GYROSCOPE;
  402104:	2303      	movs	r3, #3
  402106:	e024      	b.n	402152 <idd_sensortype_conversion+0xee>
	case INV_SENSOR_TYPE_ACCELEROMETER:           return INV_ICM20948_SENSOR_ACCELEROMETER;
  402108:	2300      	movs	r3, #0
  40210a:	e022      	b.n	402152 <idd_sensortype_conversion+0xee>
	case INV_SENSOR_TYPE_GYROSCOPE:               return INV_ICM20948_SENSOR_GYROSCOPE;
  40210c:	2301      	movs	r3, #1
  40210e:	e020      	b.n	402152 <idd_sensortype_conversion+0xee>
	case INV_SENSOR_TYPE_UNCAL_MAGNETOMETER:      return INV_ICM20948_SENSOR_MAGNETIC_FIELD_UNCALIBRATED;
  402110:	2304      	movs	r3, #4
  402112:	e01e      	b.n	402152 <idd_sensortype_conversion+0xee>
	case INV_SENSOR_TYPE_UNCAL_GYROSCOPE:         return INV_ICM20948_SENSOR_GYROSCOPE_UNCALIBRATED;
  402114:	2305      	movs	r3, #5
  402116:	e01c      	b.n	402152 <idd_sensortype_conversion+0xee>
	case INV_SENSOR_TYPE_BAC:                     return INV_ICM20948_SENSOR_ACTIVITY_CLASSIFICATON;
  402118:	2306      	movs	r3, #6
  40211a:	e01a      	b.n	402152 <idd_sensortype_conversion+0xee>
	case INV_SENSOR_TYPE_STEP_DETECTOR:           return INV_ICM20948_SENSOR_STEP_DETECTOR;
  40211c:	2307      	movs	r3, #7
  40211e:	e018      	b.n	402152 <idd_sensortype_conversion+0xee>
	case INV_SENSOR_TYPE_STEP_COUNTER:            return INV_ICM20948_SENSOR_STEP_COUNTER;
  402120:	2308      	movs	r3, #8
  402122:	e016      	b.n	402152 <idd_sensortype_conversion+0xee>
	case INV_SENSOR_TYPE_GAME_ROTATION_VECTOR:    return INV_ICM20948_SENSOR_GAME_ROTATION_VECTOR;
  402124:	2309      	movs	r3, #9
  402126:	e014      	b.n	402152 <idd_sensortype_conversion+0xee>
	case INV_SENSOR_TYPE_ROTATION_VECTOR:         return INV_ICM20948_SENSOR_ROTATION_VECTOR;
  402128:	230a      	movs	r3, #10
  40212a:	e012      	b.n	402152 <idd_sensortype_conversion+0xee>
	case INV_SENSOR_TYPE_GEOMAG_ROTATION_VECTOR:  return INV_ICM20948_SENSOR_GEOMAGNETIC_ROTATION_VECTOR;
  40212c:	230b      	movs	r3, #11
  40212e:	e010      	b.n	402152 <idd_sensortype_conversion+0xee>
	case INV_SENSOR_TYPE_MAGNETOMETER:            return INV_ICM20948_SENSOR_GEOMAGNETIC_FIELD;
  402130:	230c      	movs	r3, #12
  402132:	e00e      	b.n	402152 <idd_sensortype_conversion+0xee>
	case INV_SENSOR_TYPE_SMD:                     return INV_ICM20948_SENSOR_WAKEUP_SIGNIFICANT_MOTION;
  402134:	230d      	movs	r3, #13
  402136:	e00c      	b.n	402152 <idd_sensortype_conversion+0xee>
	case INV_SENSOR_TYPE_PICK_UP_GESTURE:         return INV_ICM20948_SENSOR_FLIP_PICKUP;
  402138:	230e      	movs	r3, #14
  40213a:	e00a      	b.n	402152 <idd_sensortype_conversion+0xee>
	case INV_SENSOR_TYPE_TILT_DETECTOR:           return INV_ICM20948_SENSOR_WAKEUP_TILT_DETECTOR;
  40213c:	230f      	movs	r3, #15
  40213e:	e008      	b.n	402152 <idd_sensortype_conversion+0xee>
	case INV_SENSOR_TYPE_GRAVITY:                 return INV_ICM20948_SENSOR_GRAVITY;
  402140:	2310      	movs	r3, #16
  402142:	e006      	b.n	402152 <idd_sensortype_conversion+0xee>
	case INV_SENSOR_TYPE_LINEAR_ACCELERATION:     return INV_ICM20948_SENSOR_LINEAR_ACCELERATION;
  402144:	2311      	movs	r3, #17
  402146:	e004      	b.n	402152 <idd_sensortype_conversion+0xee>
	case INV_SENSOR_TYPE_ORIENTATION:             return INV_ICM20948_SENSOR_ORIENTATION;
  402148:	2312      	movs	r3, #18
  40214a:	e002      	b.n	402152 <idd_sensortype_conversion+0xee>
	case INV_SENSOR_TYPE_B2S:                     return INV_ICM20948_SENSOR_B2S;
  40214c:	2313      	movs	r3, #19
  40214e:	e000      	b.n	402152 <idd_sensortype_conversion+0xee>
	default:                                      return INV_ICM20948_SENSOR_MAX;
  402150:	2314      	movs	r3, #20
	}
}
  402152:	4618      	mov	r0, r3
  402154:	370c      	adds	r7, #12
  402156:	46bd      	mov	sp, r7
  402158:	f85d 7b04 	ldr.w	r7, [sp], #4
  40215c:	4770      	bx	lr
  40215e:	bf00      	nop

00402160 <handle_command>:

int handle_command(enum DynProtocolEid eid, const DynProtocolEdata_t * edata, DynProtocolEdata_t * respdata){
  402160:	b580      	push	{r7, lr}
  402162:	b08a      	sub	sp, #40	; 0x28
  402164:	af00      	add	r7, sp, #0
  402166:	4603      	mov	r3, r0
  402168:	60b9      	str	r1, [r7, #8]
  40216a:	607a      	str	r2, [r7, #4]
  40216c:	73fb      	strb	r3, [r7, #15]
	int rc = 0;
  40216e:	2300      	movs	r3, #0
  402170:	627b      	str	r3, [r7, #36]	; 0x24
	uint8_t whoami;
	const int sensor = edata->sensor_id;
  402172:	68bb      	ldr	r3, [r7, #8]
  402174:	681b      	ldr	r3, [r3, #0]
  402176:	617b      	str	r3, [r7, #20]

	switch(eid) {
  402178:	7bfb      	ldrb	r3, [r7, #15]
  40217a:	3b10      	subs	r3, #16
  40217c:	2b13      	cmp	r3, #19
  40217e:	f200 81ed 	bhi.w	40255c <handle_command+0x3fc>
  402182:	a201      	add	r2, pc, #4	; (adr r2, 402188 <handle_command+0x28>)
  402184:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
  402188:	00402243 	.word	0x00402243
  40218c:	0040225f 	.word	0x0040225f
  402190:	004021ed 	.word	0x004021ed
  402194:	00402511 	.word	0x00402511
  402198:	0040255d 	.word	0x0040255d
  40219c:	00402355 	.word	0x00402355
  4021a0:	0040255d 	.word	0x0040255d
  4021a4:	004022c3 	.word	0x004022c3
  4021a8:	0040255d 	.word	0x0040255d
  4021ac:	00402393 	.word	0x00402393
  4021b0:	00402469 	.word	0x00402469
  4021b4:	004024c7 	.word	0x004024c7
  4021b8:	0040255d 	.word	0x0040255d
  4021bc:	0040255d 	.word	0x0040255d
  4021c0:	0040255d 	.word	0x0040255d
  4021c4:	0040255d 	.word	0x0040255d
  4021c8:	0040255d 	.word	0x0040255d
  4021cc:	0040255d 	.word	0x0040255d
  4021d0:	004021d9 	.word	0x004021d9
  4021d4:	004024f9 	.word	0x004024f9

	case DYN_PROTOCOL_EID_GET_SW_REG:
		if(edata->d.command.regAddr == DYN_PROTOCOL_EREG_HANDSHAKE_SUPPORT)
  4021d8:	68bb      	ldr	r3, [r7, #8]
  4021da:	791b      	ldrb	r3, [r3, #4]
  4021dc:	2b04      	cmp	r3, #4
  4021de:	d103      	bne.n	4021e8 <handle_command+0x88>
			return InvEMDFrontEnd_isHwFlowCtrlSupportedHook();
  4021e0:	4b8c      	ldr	r3, [pc, #560]	; (402414 <handle_command+0x2b4>)
  4021e2:	4798      	blx	r3
  4021e4:	4603      	mov	r3, r0
  4021e6:	e1bb      	b.n	402560 <handle_command+0x400>
		return 0;
  4021e8:	2300      	movs	r3, #0
  4021ea:	e1b9      	b.n	402560 <handle_command+0x400>

	case DYN_PROTOCOL_EID_SETUP:
	{
		int i_sensor = INV_SENSOR_TYPE_MAX;
  4021ec:	2344      	movs	r3, #68	; 0x44
  4021ee:	623b      	str	r3, [r7, #32]
		INV_MSG(INV_MSG_LEVEL_DEBUG, "DeviceEmdWrapper: received command setup");
  4021f0:	4989      	ldr	r1, [pc, #548]	; (402418 <handle_command+0x2b8>)
  4021f2:	2005      	movs	r0, #5
  4021f4:	4b89      	ldr	r3, [pc, #548]	; (40241c <handle_command+0x2bc>)
  4021f6:	4798      	blx	r3

		/* Disable all sensors */
		while(i_sensor-- > 0) {
  4021f8:	e009      	b.n	40220e <handle_command+0xae>
			rc = inv_icm20948_enable_sensor(&icm_device, idd_sensortype_conversion(i_sensor), 0);
  4021fa:	6a38      	ldr	r0, [r7, #32]
  4021fc:	4b88      	ldr	r3, [pc, #544]	; (402420 <handle_command+0x2c0>)
  4021fe:	4798      	blx	r3
  402200:	4603      	mov	r3, r0
  402202:	2200      	movs	r2, #0
  402204:	4619      	mov	r1, r3
  402206:	4887      	ldr	r0, [pc, #540]	; (402424 <handle_command+0x2c4>)
  402208:	4b87      	ldr	r3, [pc, #540]	; (402428 <handle_command+0x2c8>)
  40220a:	4798      	blx	r3
  40220c:	6278      	str	r0, [r7, #36]	; 0x24
		while(i_sensor-- > 0) {
  40220e:	6a3b      	ldr	r3, [r7, #32]
  402210:	1e5a      	subs	r2, r3, #1
  402212:	623a      	str	r2, [r7, #32]
  402214:	2b00      	cmp	r3, #0
  402216:	dcf0      	bgt.n	4021fa <handle_command+0x9a>
		}

		/* Clear pio interrupt */
		pio_clear(PIN_EXT_INTERRUPT_PIO, PIN_EXT_INTERRUPT_MASK);
  402218:	2108      	movs	r1, #8
  40221a:	4884      	ldr	r0, [pc, #528]	; (40242c <handle_command+0x2cc>)
  40221c:	4b84      	ldr	r3, [pc, #528]	; (402430 <handle_command+0x2d0>)
  40221e:	4798      	blx	r3

		/* Re-init the device */
		rc += icm20948_sensor_setup();
  402220:	4b84      	ldr	r3, [pc, #528]	; (402434 <handle_command+0x2d4>)
  402222:	4798      	blx	r3
  402224:	4602      	mov	r2, r0
  402226:	6a7b      	ldr	r3, [r7, #36]	; 0x24
  402228:	4413      	add	r3, r2
  40222a:	627b      	str	r3, [r7, #36]	; 0x24
		rc += load_dmp3();
  40222c:	4b82      	ldr	r3, [pc, #520]	; (402438 <handle_command+0x2d8>)
  40222e:	4798      	blx	r3
  402230:	4602      	mov	r2, r0
  402232:	6a7b      	ldr	r3, [r7, #36]	; 0x24
  402234:	4413      	add	r3, r2
  402236:	627b      	str	r3, [r7, #36]	; 0x24

		/* .. no sensors are reporting on setup */
		enabled_sensor_mask = 0;
  402238:	4b80      	ldr	r3, [pc, #512]	; (40243c <handle_command+0x2dc>)
  40223a:	2200      	movs	r2, #0
  40223c:	601a      	str	r2, [r3, #0]
		return rc;
  40223e:	6a7b      	ldr	r3, [r7, #36]	; 0x24
  402240:	e18e      	b.n	402560 <handle_command+0x400>
	}

	case DYN_PROTOCOL_EID_WHO_AM_I:
		rc = inv_icm20948_get_whoami(&icm_device, &whoami);
  402242:	f107 0313 	add.w	r3, r7, #19
  402246:	4619      	mov	r1, r3
  402248:	4876      	ldr	r0, [pc, #472]	; (402424 <handle_command+0x2c4>)
  40224a:	4b7d      	ldr	r3, [pc, #500]	; (402440 <handle_command+0x2e0>)
  40224c:	4798      	blx	r3
  40224e:	6278      	str	r0, [r7, #36]	; 0x24
		return (rc == 0) ? whoami : rc;
  402250:	6a7b      	ldr	r3, [r7, #36]	; 0x24
  402252:	2b00      	cmp	r3, #0
  402254:	d101      	bne.n	40225a <handle_command+0xfa>
  402256:	7cfb      	ldrb	r3, [r7, #19]
  402258:	e182      	b.n	402560 <handle_command+0x400>
  40225a:	6a7b      	ldr	r3, [r7, #36]	; 0x24
  40225c:	e180      	b.n	402560 <handle_command+0x400>

	case DYN_PROTOCOL_EID_RESET:
	{
		int i_sensor = INV_SENSOR_TYPE_MAX;
  40225e:	2344      	movs	r3, #68	; 0x44
  402260:	61fb      	str	r3, [r7, #28]
		INV_MSG(INV_MSG_LEVEL_DEBUG, "DeviceEmdWrapper: received command reset");
  402262:	4978      	ldr	r1, [pc, #480]	; (402444 <handle_command+0x2e4>)
  402264:	2005      	movs	r0, #5
  402266:	4b6d      	ldr	r3, [pc, #436]	; (40241c <handle_command+0x2bc>)
  402268:	4798      	blx	r3

		/* Disable all sensors */
		while(i_sensor-- > 0) {
  40226a:	e009      	b.n	402280 <handle_command+0x120>
			rc = inv_icm20948_enable_sensor(&icm_device, idd_sensortype_conversion(i_sensor), 0);
  40226c:	69f8      	ldr	r0, [r7, #28]
  40226e:	4b6c      	ldr	r3, [pc, #432]	; (402420 <handle_command+0x2c0>)
  402270:	4798      	blx	r3
  402272:	4603      	mov	r3, r0
  402274:	2200      	movs	r2, #0
  402276:	4619      	mov	r1, r3
  402278:	486a      	ldr	r0, [pc, #424]	; (402424 <handle_command+0x2c4>)
  40227a:	4b6b      	ldr	r3, [pc, #428]	; (402428 <handle_command+0x2c8>)
  40227c:	4798      	blx	r3
  40227e:	6278      	str	r0, [r7, #36]	; 0x24
		while(i_sensor-- > 0) {
  402280:	69fb      	ldr	r3, [r7, #28]
  402282:	1e5a      	subs	r2, r3, #1
  402284:	61fa      	str	r2, [r7, #28]
  402286:	2b00      	cmp	r3, #0
  402288:	dcf0      	bgt.n	40226c <handle_command+0x10c>
		}

		/* Clear pio interrupt */
		pio_clear(PIN_EXT_INTERRUPT_PIO, PIN_EXT_INTERRUPT_MASK);
  40228a:	2108      	movs	r1, #8
  40228c:	4867      	ldr	r0, [pc, #412]	; (40242c <handle_command+0x2cc>)
  40228e:	4b68      	ldr	r3, [pc, #416]	; (402430 <handle_command+0x2d0>)
  402290:	4798      	blx	r3
		/* Soft reset */
		rc += inv_icm20948_soft_reset(&icm_device);
  402292:	4864      	ldr	r0, [pc, #400]	; (402424 <handle_command+0x2c4>)
  402294:	4b6c      	ldr	r3, [pc, #432]	; (402448 <handle_command+0x2e8>)
  402296:	4798      	blx	r3
  402298:	4602      	mov	r2, r0
  40229a:	6a7b      	ldr	r3, [r7, #36]	; 0x24
  40229c:	4413      	add	r3, r2
  40229e:	627b      	str	r3, [r7, #36]	; 0x24

		/* --- Setup --- */
		/* Re-init the device */
		rc += icm20948_sensor_setup();
  4022a0:	4b64      	ldr	r3, [pc, #400]	; (402434 <handle_command+0x2d4>)
  4022a2:	4798      	blx	r3
  4022a4:	4602      	mov	r2, r0
  4022a6:	6a7b      	ldr	r3, [r7, #36]	; 0x24
  4022a8:	4413      	add	r3, r2
  4022aa:	627b      	str	r3, [r7, #36]	; 0x24
		rc += load_dmp3();
  4022ac:	4b62      	ldr	r3, [pc, #392]	; (402438 <handle_command+0x2d8>)
  4022ae:	4798      	blx	r3
  4022b0:	4602      	mov	r2, r0
  4022b2:	6a7b      	ldr	r3, [r7, #36]	; 0x24
  4022b4:	4413      	add	r3, r2
  4022b6:	627b      	str	r3, [r7, #36]	; 0x24

		/* All sensors stop reporting on reset */
		enabled_sensor_mask = 0;
  4022b8:	4b60      	ldr	r3, [pc, #384]	; (40243c <handle_command+0x2dc>)
  4022ba:	2200      	movs	r2, #0
  4022bc:	601a      	str	r2, [r3, #0]
		return rc;
  4022be:	6a7b      	ldr	r3, [r7, #36]	; 0x24
  4022c0:	e14e      	b.n	402560 <handle_command+0x400>
	}

	case DYN_PROTOCOL_EID_PING_SENSOR:
		INV_MSG(INV_MSG_LEVEL_DEBUG, "DeviceEmdWrapper: received command ping(%s)", inv_sensor_2str(sensor));
  4022c2:	6978      	ldr	r0, [r7, #20]
  4022c4:	4b61      	ldr	r3, [pc, #388]	; (40244c <handle_command+0x2ec>)
  4022c6:	4798      	blx	r3
  4022c8:	4603      	mov	r3, r0
  4022ca:	461a      	mov	r2, r3
  4022cc:	4960      	ldr	r1, [pc, #384]	; (402450 <handle_command+0x2f0>)
  4022ce:	2005      	movs	r0, #5
  4022d0:	4b52      	ldr	r3, [pc, #328]	; (40241c <handle_command+0x2bc>)
  4022d2:	4798      	blx	r3
		if((sensor == INV_SENSOR_TYPE_RAW_ACCELEROMETER)
  4022d4:	697b      	ldr	r3, [r7, #20]
  4022d6:	2b20      	cmp	r3, #32
  4022d8:	d029      	beq.n	40232e <handle_command+0x1ce>
			|| (sensor == INV_SENSOR_TYPE_RAW_GYROSCOPE)
  4022da:	697b      	ldr	r3, [r7, #20]
  4022dc:	2b21      	cmp	r3, #33	; 0x21
  4022de:	d026      	beq.n	40232e <handle_command+0x1ce>
			|| (sensor == INV_SENSOR_TYPE_ACCELEROMETER)
  4022e0:	697b      	ldr	r3, [r7, #20]
  4022e2:	2b01      	cmp	r3, #1
  4022e4:	d023      	beq.n	40232e <handle_command+0x1ce>
			|| (sensor == INV_SENSOR_TYPE_GYROSCOPE)
  4022e6:	697b      	ldr	r3, [r7, #20]
  4022e8:	2b04      	cmp	r3, #4
  4022ea:	d020      	beq.n	40232e <handle_command+0x1ce>
			|| (sensor == INV_SENSOR_TYPE_UNCAL_GYROSCOPE)
  4022ec:	697b      	ldr	r3, [r7, #20]
  4022ee:	2b10      	cmp	r3, #16
  4022f0:	d01d      	beq.n	40232e <handle_command+0x1ce>
			|| (sensor == INV_SENSOR_TYPE_GAME_ROTATION_VECTOR)
  4022f2:	697b      	ldr	r3, [r7, #20]
  4022f4:	2b0f      	cmp	r3, #15
  4022f6:	d01a      	beq.n	40232e <handle_command+0x1ce>
			|| (sensor == INV_SENSOR_TYPE_GRAVITY)
  4022f8:	697b      	ldr	r3, [r7, #20]
  4022fa:	2b09      	cmp	r3, #9
  4022fc:	d017      	beq.n	40232e <handle_command+0x1ce>
			|| (sensor == INV_SENSOR_TYPE_LINEAR_ACCELERATION)
  4022fe:	697b      	ldr	r3, [r7, #20]
  402300:	2b0a      	cmp	r3, #10
  402302:	d014      	beq.n	40232e <handle_command+0x1ce>
			|| (sensor == INV_SENSOR_TYPE_STEP_COUNTER)
  402304:	697b      	ldr	r3, [r7, #20]
  402306:	2b13      	cmp	r3, #19
  402308:	d011      	beq.n	40232e <handle_command+0x1ce>
			|| (sensor == INV_SENSOR_TYPE_BAC)
  40230a:	697b      	ldr	r3, [r7, #20]
  40230c:	2b1a      	cmp	r3, #26
  40230e:	d00e      	beq.n	40232e <handle_command+0x1ce>
			|| (sensor == INV_SENSOR_TYPE_B2S)
  402310:	697b      	ldr	r3, [r7, #20]
  402312:	2b1c      	cmp	r3, #28
  402314:	d00b      	beq.n	40232e <handle_command+0x1ce>
			|| (sensor == INV_SENSOR_TYPE_SMD)
  402316:	697b      	ldr	r3, [r7, #20]
  402318:	2b11      	cmp	r3, #17
  40231a:	d008      	beq.n	40232e <handle_command+0x1ce>
			|| (sensor == INV_SENSOR_TYPE_STEP_DETECTOR)
  40231c:	697b      	ldr	r3, [r7, #20]
  40231e:	2b12      	cmp	r3, #18
  402320:	d005      	beq.n	40232e <handle_command+0x1ce>
			|| (sensor == INV_SENSOR_TYPE_TILT_DETECTOR)
  402322:	697b      	ldr	r3, [r7, #20]
  402324:	2b16      	cmp	r3, #22
  402326:	d002      	beq.n	40232e <handle_command+0x1ce>
			|| (sensor == INV_SENSOR_TYPE_PICK_UP_GESTURE)
  402328:	697b      	ldr	r3, [r7, #20]
  40232a:	2b19      	cmp	r3, #25
  40232c:	d101      	bne.n	402332 <handle_command+0x1d2>
			) {
				return 0;
  40232e:	2300      	movs	r3, #0
  402330:	e116      	b.n	402560 <handle_command+0x400>
		} else if((sensor == INV_SENSOR_TYPE_MAGNETOMETER)
  402332:	697b      	ldr	r3, [r7, #20]
  402334:	2b02      	cmp	r3, #2
  402336:	d008      	beq.n	40234a <handle_command+0x1ea>
			|| (sensor == INV_SENSOR_TYPE_UNCAL_MAGNETOMETER)
  402338:	697b      	ldr	r3, [r7, #20]
  40233a:	2b0e      	cmp	r3, #14
  40233c:	d005      	beq.n	40234a <handle_command+0x1ea>
			|| (sensor == INV_SENSOR_TYPE_ROTATION_VECTOR)
  40233e:	697b      	ldr	r3, [r7, #20]
  402340:	2b0b      	cmp	r3, #11
  402342:	d002      	beq.n	40234a <handle_command+0x1ea>
			|| (sensor == INV_SENSOR_TYPE_GEOMAG_ROTATION_VECTOR)){
  402344:	697b      	ldr	r3, [r7, #20]
  402346:	2b14      	cmp	r3, #20
  402348:	d101      	bne.n	40234e <handle_command+0x1ee>
				return 0;
  40234a:	2300      	movs	r3, #0
  40234c:	e108      	b.n	402560 <handle_command+0x400>
		} else
			return INV_ERROR_BAD_ARG;
  40234e:	f06f 030a 	mvn.w	r3, #10
  402352:	e105      	b.n	402560 <handle_command+0x400>

	case DYN_PROTOCOL_EID_SELF_TEST:
		INV_MSG(INV_MSG_LEVEL_DEBUG, "DeviceEmdWrapper: received command self_test(%s)", inv_sensor_2str(sensor));
  402354:	6978      	ldr	r0, [r7, #20]
  402356:	4b3d      	ldr	r3, [pc, #244]	; (40244c <handle_command+0x2ec>)
  402358:	4798      	blx	r3
  40235a:	4603      	mov	r3, r0
  40235c:	461a      	mov	r2, r3
  40235e:	493d      	ldr	r1, [pc, #244]	; (402454 <handle_command+0x2f4>)
  402360:	2005      	movs	r0, #5
  402362:	4b2e      	ldr	r3, [pc, #184]	; (40241c <handle_command+0x2bc>)
  402364:	4798      	blx	r3
		if( (sensor == INV_SENSOR_TYPE_RAW_ACCELEROMETER || sensor == INV_SENSOR_TYPE_ACCELEROMETER) ||
  402366:	697b      	ldr	r3, [r7, #20]
  402368:	2b20      	cmp	r3, #32
  40236a:	d00b      	beq.n	402384 <handle_command+0x224>
  40236c:	697b      	ldr	r3, [r7, #20]
  40236e:	2b01      	cmp	r3, #1
  402370:	d008      	beq.n	402384 <handle_command+0x224>
  402372:	697b      	ldr	r3, [r7, #20]
  402374:	2b21      	cmp	r3, #33	; 0x21
  402376:	d005      	beq.n	402384 <handle_command+0x224>
			(sensor == INV_SENSOR_TYPE_RAW_GYROSCOPE || sensor == INV_SENSOR_TYPE_GYROSCOPE) ||
  402378:	697b      	ldr	r3, [r7, #20]
  40237a:	2b04      	cmp	r3, #4
  40237c:	d002      	beq.n	402384 <handle_command+0x224>
  40237e:	697b      	ldr	r3, [r7, #20]
  402380:	2b02      	cmp	r3, #2
  402382:	d103      	bne.n	40238c <handle_command+0x22c>
			(sensor == INV_SENSOR_TYPE_MAGNETOMETER)) {
				return icm20948_run_selftest();
  402384:	4b34      	ldr	r3, [pc, #208]	; (402458 <handle_command+0x2f8>)
  402386:	4798      	blx	r3
  402388:	4603      	mov	r3, r0
  40238a:	e0e9      	b.n	402560 <handle_command+0x400>
		}
		else
			return INV_ERROR_BAD_ARG;
  40238c:	f06f 030a 	mvn.w	r3, #10
  402390:	e0e6      	b.n	402560 <handle_command+0x400>
		break;
	case DYN_PROTOCOL_EID_START_SENSOR:
		INV_MSG(INV_MSG_LEVEL_DEBUG, "DeviceEmdWrapper: received command start(%s)", inv_sensor_2str(sensor));
  402392:	6978      	ldr	r0, [r7, #20]
  402394:	4b2d      	ldr	r3, [pc, #180]	; (40244c <handle_command+0x2ec>)
  402396:	4798      	blx	r3
  402398:	4603      	mov	r3, r0
  40239a:	461a      	mov	r2, r3
  40239c:	492f      	ldr	r1, [pc, #188]	; (40245c <handle_command+0x2fc>)
  40239e:	2005      	movs	r0, #5
  4023a0:	4b1e      	ldr	r3, [pc, #120]	; (40241c <handle_command+0x2bc>)
  4023a2:	4798      	blx	r3
		if (sensor > 0 && idd_sensortype_conversion(sensor) < INV_ICM20948_SENSOR_MAX) {
  4023a4:	697b      	ldr	r3, [r7, #20]
  4023a6:	2b00      	cmp	r3, #0
  4023a8:	dd30      	ble.n	40240c <handle_command+0x2ac>
  4023aa:	6978      	ldr	r0, [r7, #20]
  4023ac:	4b1c      	ldr	r3, [pc, #112]	; (402420 <handle_command+0x2c0>)
  4023ae:	4798      	blx	r3
  4023b0:	4603      	mov	r3, r0
  4023b2:	2b13      	cmp	r3, #19
  4023b4:	d82a      	bhi.n	40240c <handle_command+0x2ac>
			if (icm_device.selftest_done && !icm_device.offset_done) {			// If we've run selftes and not already set the offset.
  4023b6:	4b1b      	ldr	r3, [pc, #108]	; (402424 <handle_command+0x2c4>)
  4023b8:	f893 3090 	ldrb.w	r3, [r3, #144]	; 0x90
  4023bc:	2b00      	cmp	r3, #0
  4023be:	d00c      	beq.n	4023da <handle_command+0x27a>
  4023c0:	4b18      	ldr	r3, [pc, #96]	; (402424 <handle_command+0x2c4>)
  4023c2:	f893 3091 	ldrb.w	r3, [r3, #145]	; 0x91
  4023c6:	2b00      	cmp	r3, #0
  4023c8:	d107      	bne.n	4023da <handle_command+0x27a>
				inv_icm20948_set_offset(&icm_device, unscaled_bias);
  4023ca:	4925      	ldr	r1, [pc, #148]	; (402460 <handle_command+0x300>)
  4023cc:	4815      	ldr	r0, [pc, #84]	; (402424 <handle_command+0x2c4>)
  4023ce:	4b25      	ldr	r3, [pc, #148]	; (402464 <handle_command+0x304>)
  4023d0:	4798      	blx	r3
				icm_device.offset_done = 1;
  4023d2:	4b14      	ldr	r3, [pc, #80]	; (402424 <handle_command+0x2c4>)
  4023d4:	2201      	movs	r2, #1
  4023d6:	f883 2091 	strb.w	r2, [r3, #145]	; 0x91
			}
			/* Sensor data will be notified */
			rc = inv_icm20948_enable_sensor(&icm_device, idd_sensortype_conversion(sensor), 1);
  4023da:	6978      	ldr	r0, [r7, #20]
  4023dc:	4b10      	ldr	r3, [pc, #64]	; (402420 <handle_command+0x2c0>)
  4023de:	4798      	blx	r3
  4023e0:	4603      	mov	r3, r0
  4023e2:	2201      	movs	r2, #1
  4023e4:	4619      	mov	r1, r3
  4023e6:	480f      	ldr	r0, [pc, #60]	; (402424 <handle_command+0x2c4>)
  4023e8:	4b0f      	ldr	r3, [pc, #60]	; (402428 <handle_command+0x2c8>)
  4023ea:	4798      	blx	r3
  4023ec:	6278      	str	r0, [r7, #36]	; 0x24
			enabled_sensor_mask |= (1 << idd_sensortype_conversion(sensor));
  4023ee:	6978      	ldr	r0, [r7, #20]
  4023f0:	4b0b      	ldr	r3, [pc, #44]	; (402420 <handle_command+0x2c0>)
  4023f2:	4798      	blx	r3
  4023f4:	4603      	mov	r3, r0
  4023f6:	461a      	mov	r2, r3
  4023f8:	2301      	movs	r3, #1
  4023fa:	4093      	lsls	r3, r2
  4023fc:	461a      	mov	r2, r3
  4023fe:	4b0f      	ldr	r3, [pc, #60]	; (40243c <handle_command+0x2dc>)
  402400:	681b      	ldr	r3, [r3, #0]
  402402:	4313      	orrs	r3, r2
  402404:	4a0d      	ldr	r2, [pc, #52]	; (40243c <handle_command+0x2dc>)
  402406:	6013      	str	r3, [r2, #0]
			return rc;
  402408:	6a7b      	ldr	r3, [r7, #36]	; 0x24
  40240a:	e0a9      	b.n	402560 <handle_command+0x400>
		} else
			return INV_ERROR_NIMPL; /*this sensor is not supported*/
  40240c:	f06f 0301 	mvn.w	r3, #1
  402410:	e0a6      	b.n	402560 <handle_command+0x400>
  402412:	bf00      	nop
  402414:	00401511 	.word	0x00401511
  402418:	0041ba80 	.word	0x0041ba80
  40241c:	0040fd19 	.word	0x0040fd19
  402420:	00402065 	.word	0x00402065
  402424:	20001b30 	.word	0x20001b30
  402428:	0040ab69 	.word	0x0040ab69
  40242c:	400e1000 	.word	0x400e1000
  402430:	004001e1 	.word	0x004001e1
  402434:	00401769 	.word	0x00401769
  402438:	004016a1 	.word	0x004016a1
  40243c:	20000efc 	.word	0x20000efc
  402440:	0040a755 	.word	0x0040a755
  402444:	0041baac 	.word	0x0041baac
  402448:	0040ab39 	.word	0x0040ab39
  40244c:	0040cc51 	.word	0x0040cc51
  402450:	0041bad8 	.word	0x0041bad8
  402454:	0041bb04 	.word	0x0041bb04
  402458:	0040277d 	.word	0x0040277d
  40245c:	0041bb38 	.word	0x0041bb38
  402460:	20000ee4 	.word	0x20000ee4
  402464:	0040a399 	.word	0x0040a399

	case DYN_PROTOCOL_EID_STOP_SENSOR:
		INV_MSG(INV_MSG_LEVEL_DEBUG, "DeviceEmdWrapper: received command stop(%s)", inv_sensor_2str(sensor));
  402468:	6978      	ldr	r0, [r7, #20]
  40246a:	4b3f      	ldr	r3, [pc, #252]	; (402568 <handle_command+0x408>)
  40246c:	4798      	blx	r3
  40246e:	4603      	mov	r3, r0
  402470:	461a      	mov	r2, r3
  402472:	493e      	ldr	r1, [pc, #248]	; (40256c <handle_command+0x40c>)
  402474:	2005      	movs	r0, #5
  402476:	4b3e      	ldr	r3, [pc, #248]	; (402570 <handle_command+0x410>)
  402478:	4798      	blx	r3
		if (sensor > 0 && idd_sensortype_conversion(sensor) < INV_ICM20948_SENSOR_MAX) {
  40247a:	697b      	ldr	r3, [r7, #20]
  40247c:	2b00      	cmp	r3, #0
  40247e:	dd1f      	ble.n	4024c0 <handle_command+0x360>
  402480:	6978      	ldr	r0, [r7, #20]
  402482:	4b3c      	ldr	r3, [pc, #240]	; (402574 <handle_command+0x414>)
  402484:	4798      	blx	r3
  402486:	4603      	mov	r3, r0
  402488:	2b13      	cmp	r3, #19
  40248a:	d819      	bhi.n	4024c0 <handle_command+0x360>
			/* Sensor data will not be notified anymore */
			rc = inv_icm20948_enable_sensor(&icm_device, idd_sensortype_conversion(sensor), 0);
  40248c:	6978      	ldr	r0, [r7, #20]
  40248e:	4b39      	ldr	r3, [pc, #228]	; (402574 <handle_command+0x414>)
  402490:	4798      	blx	r3
  402492:	4603      	mov	r3, r0
  402494:	2200      	movs	r2, #0
  402496:	4619      	mov	r1, r3
  402498:	4837      	ldr	r0, [pc, #220]	; (402578 <handle_command+0x418>)
  40249a:	4b38      	ldr	r3, [pc, #224]	; (40257c <handle_command+0x41c>)
  40249c:	4798      	blx	r3
  40249e:	6278      	str	r0, [r7, #36]	; 0x24
			enabled_sensor_mask &= ~(1 << idd_sensortype_conversion(sensor));
  4024a0:	6978      	ldr	r0, [r7, #20]
  4024a2:	4b34      	ldr	r3, [pc, #208]	; (402574 <handle_command+0x414>)
  4024a4:	4798      	blx	r3
  4024a6:	4603      	mov	r3, r0
  4024a8:	461a      	mov	r2, r3
  4024aa:	2301      	movs	r3, #1
  4024ac:	4093      	lsls	r3, r2
  4024ae:	43db      	mvns	r3, r3
  4024b0:	461a      	mov	r2, r3
  4024b2:	4b33      	ldr	r3, [pc, #204]	; (402580 <handle_command+0x420>)
  4024b4:	681b      	ldr	r3, [r3, #0]
  4024b6:	4013      	ands	r3, r2
  4024b8:	4a31      	ldr	r2, [pc, #196]	; (402580 <handle_command+0x420>)
  4024ba:	6013      	str	r3, [r2, #0]
			return rc;
  4024bc:	6a7b      	ldr	r3, [r7, #36]	; 0x24
  4024be:	e04f      	b.n	402560 <handle_command+0x400>
		} else
			return INV_ERROR_NIMPL; /*this sensor is not supported*/
  4024c0:	f06f 0301 	mvn.w	r3, #1
  4024c4:	e04c      	b.n	402560 <handle_command+0x400>

	case DYN_PROTOCOL_EID_SET_SENSOR_PERIOD:
		INV_MSG(INV_MSG_LEVEL_DEBUG, "DeviceEmdWrapper: received command set_period(%d us)",edata->d.command.period);
  4024c6:	68bb      	ldr	r3, [r7, #8]
  4024c8:	685b      	ldr	r3, [r3, #4]
  4024ca:	461a      	mov	r2, r3
  4024cc:	492d      	ldr	r1, [pc, #180]	; (402584 <handle_command+0x424>)
  4024ce:	2005      	movs	r0, #5
  4024d0:	4b27      	ldr	r3, [pc, #156]	; (402570 <handle_command+0x410>)
  4024d2:	4798      	blx	r3
		rc = inv_icm20948_set_sensor_period(&icm_device, idd_sensortype_conversion(sensor), edata->d.command.period / 1000);
  4024d4:	6978      	ldr	r0, [r7, #20]
  4024d6:	4b27      	ldr	r3, [pc, #156]	; (402574 <handle_command+0x414>)
  4024d8:	4798      	blx	r3
  4024da:	4603      	mov	r3, r0
  4024dc:	4619      	mov	r1, r3
  4024de:	68bb      	ldr	r3, [r7, #8]
  4024e0:	685b      	ldr	r3, [r3, #4]
  4024e2:	4a29      	ldr	r2, [pc, #164]	; (402588 <handle_command+0x428>)
  4024e4:	fba2 2303 	umull	r2, r3, r2, r3
  4024e8:	099b      	lsrs	r3, r3, #6
  4024ea:	461a      	mov	r2, r3
  4024ec:	4822      	ldr	r0, [pc, #136]	; (402578 <handle_command+0x418>)
  4024ee:	4b27      	ldr	r3, [pc, #156]	; (40258c <handle_command+0x42c>)
  4024f0:	4798      	blx	r3
  4024f2:	6278      	str	r0, [r7, #36]	; 0x24
		return rc;
  4024f4:	6a7b      	ldr	r3, [r7, #36]	; 0x24
  4024f6:	e033      	b.n	402560 <handle_command+0x400>

	case DYN_PROTOCOL_EID_SET_SENSOR_CFG:
		INV_MSG(INV_MSG_LEVEL_DEBUG, "DeviceEmdWrapper: received command set_sensor_config(%s)", inv_sensor_2str(sensor));
  4024f8:	6978      	ldr	r0, [r7, #20]
  4024fa:	4b1b      	ldr	r3, [pc, #108]	; (402568 <handle_command+0x408>)
  4024fc:	4798      	blx	r3
  4024fe:	4603      	mov	r3, r0
  402500:	461a      	mov	r2, r3
  402502:	4923      	ldr	r1, [pc, #140]	; (402590 <handle_command+0x430>)
  402504:	2005      	movs	r0, #5
  402506:	4b1a      	ldr	r3, [pc, #104]	; (402570 <handle_command+0x410>)
  402508:	4798      	blx	r3
		return INV_ERROR_NIMPL;
  40250a:	f06f 0301 	mvn.w	r3, #1
  40250e:	e027      	b.n	402560 <handle_command+0x400>

	case DYN_PROTOCOL_EID_CLEANUP:
	{
		int i_sensor = INV_SENSOR_TYPE_MAX;
  402510:	2344      	movs	r3, #68	; 0x44
  402512:	61bb      	str	r3, [r7, #24]
		INV_MSG(INV_MSG_LEVEL_DEBUG, "DeviceEmdWrapper: received command cleanup");
  402514:	491f      	ldr	r1, [pc, #124]	; (402594 <handle_command+0x434>)
  402516:	2005      	movs	r0, #5
  402518:	4b15      	ldr	r3, [pc, #84]	; (402570 <handle_command+0x410>)
  40251a:	4798      	blx	r3

		/* Disable all sensors on cleanup */
		while(i_sensor-- > 0) {
  40251c:	e009      	b.n	402532 <handle_command+0x3d2>
			rc = inv_icm20948_enable_sensor(&icm_device, idd_sensortype_conversion(i_sensor), 0);
  40251e:	69b8      	ldr	r0, [r7, #24]
  402520:	4b14      	ldr	r3, [pc, #80]	; (402574 <handle_command+0x414>)
  402522:	4798      	blx	r3
  402524:	4603      	mov	r3, r0
  402526:	2200      	movs	r2, #0
  402528:	4619      	mov	r1, r3
  40252a:	4813      	ldr	r0, [pc, #76]	; (402578 <handle_command+0x418>)
  40252c:	4b13      	ldr	r3, [pc, #76]	; (40257c <handle_command+0x41c>)
  40252e:	4798      	blx	r3
  402530:	6278      	str	r0, [r7, #36]	; 0x24
		while(i_sensor-- > 0) {
  402532:	69bb      	ldr	r3, [r7, #24]
  402534:	1e5a      	subs	r2, r3, #1
  402536:	61ba      	str	r2, [r7, #24]
  402538:	2b00      	cmp	r3, #0
  40253a:	dcf0      	bgt.n	40251e <handle_command+0x3be>
		}

		/* Clear pio interrupt */
		pio_clear(PIN_EXT_INTERRUPT_PIO, PIN_EXT_INTERRUPT_MASK);
  40253c:	2108      	movs	r1, #8
  40253e:	4816      	ldr	r0, [pc, #88]	; (402598 <handle_command+0x438>)
  402540:	4b16      	ldr	r3, [pc, #88]	; (40259c <handle_command+0x43c>)
  402542:	4798      	blx	r3

		/* Soft reset */
		rc += inv_icm20948_soft_reset(&icm_device);
  402544:	480c      	ldr	r0, [pc, #48]	; (402578 <handle_command+0x418>)
  402546:	4b16      	ldr	r3, [pc, #88]	; (4025a0 <handle_command+0x440>)
  402548:	4798      	blx	r3
  40254a:	4602      	mov	r2, r0
  40254c:	6a7b      	ldr	r3, [r7, #36]	; 0x24
  40254e:	4413      	add	r3, r2
  402550:	627b      	str	r3, [r7, #36]	; 0x24
		/* All sensors stop reporting on cleanup */
		enabled_sensor_mask = 0;
  402552:	4b0b      	ldr	r3, [pc, #44]	; (402580 <handle_command+0x420>)
  402554:	2200      	movs	r2, #0
  402556:	601a      	str	r2, [r3, #0]
		return rc;
  402558:	6a7b      	ldr	r3, [r7, #36]	; 0x24
  40255a:	e001      	b.n	402560 <handle_command+0x400>
	}

	default:
		return INV_ERROR_NIMPL;
  40255c:	f06f 0301 	mvn.w	r3, #1
	}
}
  402560:	4618      	mov	r0, r3
  402562:	3728      	adds	r7, #40	; 0x28
  402564:	46bd      	mov	sp, r7
  402566:	bd80      	pop	{r7, pc}
  402568:	0040cc51 	.word	0x0040cc51
  40256c:	0041bb68 	.word	0x0041bb68
  402570:	0040fd19 	.word	0x0040fd19
  402574:	00402065 	.word	0x00402065
  402578:	20001b30 	.word	0x20001b30
  40257c:	0040ab69 	.word	0x0040ab69
  402580:	20000efc 	.word	0x20000efc
  402584:	0041bb94 	.word	0x0041bb94
  402588:	10624dd3 	.word	0x10624dd3
  40258c:	0040abcd 	.word	0x0040abcd
  402590:	0041bbcc 	.word	0x0041bbcc
  402594:	0041bc08 	.word	0x0041bc08
  402598:	400e1000 	.word	0x400e1000
  40259c:	004001e1 	.word	0x004001e1
  4025a0:	0040ab39 	.word	0x0040ab39

004025a4 <inv_icm20948_get_st_bias>:

void inv_icm20948_get_st_bias(struct inv_icm20948 * s, int *gyro_bias, int *accel_bias, int * st_bias, int * unscaled){
  4025a4:	b480      	push	{r7}
  4025a6:	b08d      	sub	sp, #52	; 0x34
  4025a8:	af00      	add	r7, sp, #0
  4025aa:	60f8      	str	r0, [r7, #12]
  4025ac:	60b9      	str	r1, [r7, #8]
  4025ae:	607a      	str	r2, [r7, #4]
  4025b0:	603b      	str	r3, [r7, #0]
	int i, t;
	int check;
	int scale;

	/* check bias there ? */
	check = 0;
  4025b2:	2300      	movs	r3, #0
  4025b4:	623b      	str	r3, [r7, #32]
	for (i = 0; i < 3; i++) {
  4025b6:	2300      	movs	r3, #0
  4025b8:	627b      	str	r3, [r7, #36]	; 0x24
  4025ba:	e014      	b.n	4025e6 <inv_icm20948_get_st_bias+0x42>
		if (gyro_bias[i] != 0)
  4025bc:	6a7b      	ldr	r3, [r7, #36]	; 0x24
  4025be:	009b      	lsls	r3, r3, #2
  4025c0:	68ba      	ldr	r2, [r7, #8]
  4025c2:	4413      	add	r3, r2
  4025c4:	681b      	ldr	r3, [r3, #0]
  4025c6:	2b00      	cmp	r3, #0
  4025c8:	d001      	beq.n	4025ce <inv_icm20948_get_st_bias+0x2a>
			check = 1;
  4025ca:	2301      	movs	r3, #1
  4025cc:	623b      	str	r3, [r7, #32]
		if (accel_bias[i] != 0)
  4025ce:	6a7b      	ldr	r3, [r7, #36]	; 0x24
  4025d0:	009b      	lsls	r3, r3, #2
  4025d2:	687a      	ldr	r2, [r7, #4]
  4025d4:	4413      	add	r3, r2
  4025d6:	681b      	ldr	r3, [r3, #0]
  4025d8:	2b00      	cmp	r3, #0
  4025da:	d001      	beq.n	4025e0 <inv_icm20948_get_st_bias+0x3c>
			check = 1;
  4025dc:	2301      	movs	r3, #1
  4025de:	623b      	str	r3, [r7, #32]
	for (i = 0; i < 3; i++) {
  4025e0:	6a7b      	ldr	r3, [r7, #36]	; 0x24
  4025e2:	3301      	adds	r3, #1
  4025e4:	627b      	str	r3, [r7, #36]	; 0x24
  4025e6:	6a7b      	ldr	r3, [r7, #36]	; 0x24
  4025e8:	2b02      	cmp	r3, #2
  4025ea:	dde7      	ble.n	4025bc <inv_icm20948_get_st_bias+0x18>
	}

	/* if no bias, return all 0 */
	if (check == 0) {
  4025ec:	6a3b      	ldr	r3, [r7, #32]
  4025ee:	2b00      	cmp	r3, #0
  4025f0:	d10f      	bne.n	402612 <inv_icm20948_get_st_bias+0x6e>
		for (i = 0; i < 12; i++)
  4025f2:	2300      	movs	r3, #0
  4025f4:	627b      	str	r3, [r7, #36]	; 0x24
  4025f6:	e008      	b.n	40260a <inv_icm20948_get_st_bias+0x66>
			st_bias[i] = 0;
  4025f8:	6a7b      	ldr	r3, [r7, #36]	; 0x24
  4025fa:	009b      	lsls	r3, r3, #2
  4025fc:	683a      	ldr	r2, [r7, #0]
  4025fe:	4413      	add	r3, r2
  402600:	2200      	movs	r2, #0
  402602:	601a      	str	r2, [r3, #0]
		for (i = 0; i < 12; i++)
  402604:	6a7b      	ldr	r3, [r7, #36]	; 0x24
  402606:	3301      	adds	r3, #1
  402608:	627b      	str	r3, [r7, #36]	; 0x24
  40260a:	6a7b      	ldr	r3, [r7, #36]	; 0x24
  40260c:	2b0b      	cmp	r3, #11
  40260e:	ddf3      	ble.n	4025f8 <inv_icm20948_get_st_bias+0x54>
		return;
  402610:	e0ae      	b.n	402770 <inv_icm20948_get_st_bias+0x1cc>
	}

	/* dps scaled by 2^16 */
	scale = 65536 / DEF_SELFTEST_GYRO_SENS;
  402612:	f44f 73fa 	mov.w	r3, #500	; 0x1f4
  402616:	61fb      	str	r3, [r7, #28]

	/* Gyro normal mode */
	t = 0;
  402618:	2300      	movs	r3, #0
  40261a:	61bb      	str	r3, [r7, #24]
	for (i = 0; i < 3; i++) {
  40261c:	2300      	movs	r3, #0
  40261e:	627b      	str	r3, [r7, #36]	; 0x24
  402620:	e01d      	b.n	40265e <inv_icm20948_get_st_bias+0xba>
		st_bias[i + t] = gyro_bias[i] * scale;
  402622:	6a7a      	ldr	r2, [r7, #36]	; 0x24
  402624:	69bb      	ldr	r3, [r7, #24]
  402626:	4413      	add	r3, r2
  402628:	009b      	lsls	r3, r3, #2
  40262a:	683a      	ldr	r2, [r7, #0]
  40262c:	4413      	add	r3, r2
  40262e:	6a7a      	ldr	r2, [r7, #36]	; 0x24
  402630:	0092      	lsls	r2, r2, #2
  402632:	68b9      	ldr	r1, [r7, #8]
  402634:	440a      	add	r2, r1
  402636:	6812      	ldr	r2, [r2, #0]
  402638:	69f9      	ldr	r1, [r7, #28]
  40263a:	fb01 f202 	mul.w	r2, r1, r2
  40263e:	601a      	str	r2, [r3, #0]
		unscaled[i + t] = gyro_bias[i];
  402640:	6a7a      	ldr	r2, [r7, #36]	; 0x24
  402642:	69bb      	ldr	r3, [r7, #24]
  402644:	4413      	add	r3, r2
  402646:	009b      	lsls	r3, r3, #2
  402648:	6bba      	ldr	r2, [r7, #56]	; 0x38
  40264a:	4413      	add	r3, r2
  40264c:	6a7a      	ldr	r2, [r7, #36]	; 0x24
  40264e:	0092      	lsls	r2, r2, #2
  402650:	68b9      	ldr	r1, [r7, #8]
  402652:	440a      	add	r2, r1
  402654:	6812      	ldr	r2, [r2, #0]
  402656:	601a      	str	r2, [r3, #0]
	for (i = 0; i < 3; i++) {
  402658:	6a7b      	ldr	r3, [r7, #36]	; 0x24
  40265a:	3301      	adds	r3, #1
  40265c:	627b      	str	r3, [r7, #36]	; 0x24
  40265e:	6a7b      	ldr	r3, [r7, #36]	; 0x24
  402660:	2b02      	cmp	r3, #2
  402662:	ddde      	ble.n	402622 <inv_icm20948_get_st_bias+0x7e>
	}
	axis = 0;
  402664:	2300      	movs	r3, #0
  402666:	62fb      	str	r3, [r7, #44]	; 0x2c
	axis_sign = 1;
  402668:	2301      	movs	r3, #1
  40266a:	62bb      	str	r3, [r7, #40]	; 0x28
	if (INV20948_ABS(accel_bias[1]) > INV20948_ABS(accel_bias[0]))
  40266c:	687b      	ldr	r3, [r7, #4]
  40266e:	3304      	adds	r3, #4
  402670:	681b      	ldr	r3, [r3, #0]
  402672:	ea83 72e3 	eor.w	r2, r3, r3, asr #31
  402676:	eba2 72e3 	sub.w	r2, r2, r3, asr #31
  40267a:	687b      	ldr	r3, [r7, #4]
  40267c:	681b      	ldr	r3, [r3, #0]
  40267e:	2b00      	cmp	r3, #0
  402680:	bfb8      	it	lt
  402682:	425b      	neglt	r3, r3
  402684:	429a      	cmp	r2, r3
  402686:	dd01      	ble.n	40268c <inv_icm20948_get_st_bias+0xe8>
		axis = 1;
  402688:	2301      	movs	r3, #1
  40268a:	62fb      	str	r3, [r7, #44]	; 0x2c
	if (INV20948_ABS(accel_bias[2]) > INV20948_ABS(accel_bias[axis]))
  40268c:	687b      	ldr	r3, [r7, #4]
  40268e:	3308      	adds	r3, #8
  402690:	681b      	ldr	r3, [r3, #0]
  402692:	ea83 72e3 	eor.w	r2, r3, r3, asr #31
  402696:	eba2 72e3 	sub.w	r2, r2, r3, asr #31
  40269a:	6afb      	ldr	r3, [r7, #44]	; 0x2c
  40269c:	009b      	lsls	r3, r3, #2
  40269e:	6879      	ldr	r1, [r7, #4]
  4026a0:	440b      	add	r3, r1
  4026a2:	681b      	ldr	r3, [r3, #0]
  4026a4:	2b00      	cmp	r3, #0
  4026a6:	bfb8      	it	lt
  4026a8:	425b      	neglt	r3, r3
  4026aa:	429a      	cmp	r2, r3
  4026ac:	dd01      	ble.n	4026b2 <inv_icm20948_get_st_bias+0x10e>
		axis = 2;
  4026ae:	2302      	movs	r3, #2
  4026b0:	62fb      	str	r3, [r7, #44]	; 0x2c
	if (accel_bias[axis] < 0)
  4026b2:	6afb      	ldr	r3, [r7, #44]	; 0x2c
  4026b4:	009b      	lsls	r3, r3, #2
  4026b6:	687a      	ldr	r2, [r7, #4]
  4026b8:	4413      	add	r3, r2
  4026ba:	681b      	ldr	r3, [r3, #0]
  4026bc:	2b00      	cmp	r3, #0
  4026be:	da02      	bge.n	4026c6 <inv_icm20948_get_st_bias+0x122>
		axis_sign = -1;
  4026c0:	f04f 33ff 	mov.w	r3, #4294967295
  4026c4:	62bb      	str	r3, [r7, #40]	; 0x28

	/* gee scaled by 2^16 */
	scale = 65536 / (DEF_ST_SCALE / (DEF_ST_ACCEL_FS_MG / 1000));
  4026c6:	2304      	movs	r3, #4
  4026c8:	61fb      	str	r3, [r7, #28]

	gravity = 32768 / (DEF_ST_ACCEL_FS_MG / 1000) * axis_sign;
  4026ca:	6abb      	ldr	r3, [r7, #40]	; 0x28
  4026cc:	039b      	lsls	r3, r3, #14
  4026ce:	617b      	str	r3, [r7, #20]
	gravity_scaled = gravity * scale;
  4026d0:	697b      	ldr	r3, [r7, #20]
  4026d2:	69fa      	ldr	r2, [r7, #28]
  4026d4:	fb02 f303 	mul.w	r3, r2, r3
  4026d8:	613b      	str	r3, [r7, #16]

	/* Accel normal mode */
	t += 3;
  4026da:	69bb      	ldr	r3, [r7, #24]
  4026dc:	3303      	adds	r3, #3
  4026de:	61bb      	str	r3, [r7, #24]
	for (i = 0; i < 3; i++) {
  4026e0:	2300      	movs	r3, #0
  4026e2:	627b      	str	r3, [r7, #36]	; 0x24
  4026e4:	e041      	b.n	40276a <inv_icm20948_get_st_bias+0x1c6>
		st_bias[i + t] = accel_bias[i] * scale;
  4026e6:	6a7a      	ldr	r2, [r7, #36]	; 0x24
  4026e8:	69bb      	ldr	r3, [r7, #24]
  4026ea:	4413      	add	r3, r2
  4026ec:	009b      	lsls	r3, r3, #2
  4026ee:	683a      	ldr	r2, [r7, #0]
  4026f0:	4413      	add	r3, r2
  4026f2:	6a7a      	ldr	r2, [r7, #36]	; 0x24
  4026f4:	0092      	lsls	r2, r2, #2
  4026f6:	6879      	ldr	r1, [r7, #4]
  4026f8:	440a      	add	r2, r1
  4026fa:	6812      	ldr	r2, [r2, #0]
  4026fc:	69f9      	ldr	r1, [r7, #28]
  4026fe:	fb01 f202 	mul.w	r2, r1, r2
  402702:	601a      	str	r2, [r3, #0]
		unscaled[i + t] = accel_bias[i];
  402704:	6a7a      	ldr	r2, [r7, #36]	; 0x24
  402706:	69bb      	ldr	r3, [r7, #24]
  402708:	4413      	add	r3, r2
  40270a:	009b      	lsls	r3, r3, #2
  40270c:	6bba      	ldr	r2, [r7, #56]	; 0x38
  40270e:	4413      	add	r3, r2
  402710:	6a7a      	ldr	r2, [r7, #36]	; 0x24
  402712:	0092      	lsls	r2, r2, #2
  402714:	6879      	ldr	r1, [r7, #4]
  402716:	440a      	add	r2, r1
  402718:	6812      	ldr	r2, [r2, #0]
  40271a:	601a      	str	r2, [r3, #0]
		if (axis == i) {
  40271c:	6afa      	ldr	r2, [r7, #44]	; 0x2c
  40271e:	6a7b      	ldr	r3, [r7, #36]	; 0x24
  402720:	429a      	cmp	r2, r3
  402722:	d11f      	bne.n	402764 <inv_icm20948_get_st_bias+0x1c0>
			st_bias[i + t] -= gravity_scaled;
  402724:	6a7a      	ldr	r2, [r7, #36]	; 0x24
  402726:	69bb      	ldr	r3, [r7, #24]
  402728:	4413      	add	r3, r2
  40272a:	009b      	lsls	r3, r3, #2
  40272c:	683a      	ldr	r2, [r7, #0]
  40272e:	4413      	add	r3, r2
  402730:	6a79      	ldr	r1, [r7, #36]	; 0x24
  402732:	69ba      	ldr	r2, [r7, #24]
  402734:	440a      	add	r2, r1
  402736:	0092      	lsls	r2, r2, #2
  402738:	6839      	ldr	r1, [r7, #0]
  40273a:	440a      	add	r2, r1
  40273c:	6811      	ldr	r1, [r2, #0]
  40273e:	693a      	ldr	r2, [r7, #16]
  402740:	1a8a      	subs	r2, r1, r2
  402742:	601a      	str	r2, [r3, #0]
			unscaled[i + t] -= gravity;
  402744:	6a7a      	ldr	r2, [r7, #36]	; 0x24
  402746:	69bb      	ldr	r3, [r7, #24]
  402748:	4413      	add	r3, r2
  40274a:	009b      	lsls	r3, r3, #2
  40274c:	6bba      	ldr	r2, [r7, #56]	; 0x38
  40274e:	4413      	add	r3, r2
  402750:	6a79      	ldr	r1, [r7, #36]	; 0x24
  402752:	69ba      	ldr	r2, [r7, #24]
  402754:	440a      	add	r2, r1
  402756:	0092      	lsls	r2, r2, #2
  402758:	6bb9      	ldr	r1, [r7, #56]	; 0x38
  40275a:	440a      	add	r2, r1
  40275c:	6811      	ldr	r1, [r2, #0]
  40275e:	697a      	ldr	r2, [r7, #20]
  402760:	1a8a      	subs	r2, r1, r2
  402762:	601a      	str	r2, [r3, #0]
	for (i = 0; i < 3; i++) {
  402764:	6a7b      	ldr	r3, [r7, #36]	; 0x24
  402766:	3301      	adds	r3, #1
  402768:	627b      	str	r3, [r7, #36]	; 0x24
  40276a:	6a7b      	ldr	r3, [r7, #36]	; 0x24
  40276c:	2b02      	cmp	r3, #2
  40276e:	ddba      	ble.n	4026e6 <inv_icm20948_get_st_bias+0x142>
		}
	}
}
  402770:	3734      	adds	r7, #52	; 0x34
  402772:	46bd      	mov	sp, r7
  402774:	f85d 7b04 	ldr.w	r7, [sp], #4
  402778:	4770      	bx	lr
	...

0040277c <icm20948_run_selftest>:

int icm20948_run_selftest(void){
  40277c:	e92d 43b0 	stmdb	sp!, {r4, r5, r7, r8, r9, lr}
  402780:	b08a      	sub	sp, #40	; 0x28
  402782:	af04      	add	r7, sp, #16
	static int rc = 0;		// Keep this value as we're only going to do this once.
	int gyro_bias_regular[THREE_AXES];
	int accel_bias_regular[THREE_AXES];
	static int raw_bias[THREE_AXES * 2];

	if (icm_device.selftest_done == 1) {
  402784:	4b5b      	ldr	r3, [pc, #364]	; (4028f4 <icm20948_run_selftest+0x178>)
  402786:	f893 3090 	ldrb.w	r3, [r3, #144]	; 0x90
  40278a:	2b01      	cmp	r3, #1
  40278c:	d104      	bne.n	402798 <icm20948_run_selftest+0x1c>
		INV_MSG(INV_MSG_LEVEL_INFO, "Self-test has already run. Skipping.");
  40278e:	495a      	ldr	r1, [pc, #360]	; (4028f8 <icm20948_run_selftest+0x17c>)
  402790:	2003      	movs	r0, #3
  402792:	4b5a      	ldr	r3, [pc, #360]	; (4028fc <icm20948_run_selftest+0x180>)
  402794:	4798      	blx	r3
  402796:	e0a6      	b.n	4028e6 <icm20948_run_selftest+0x16a>
	else {
		/*
		* Perform self-test
		* For ICM20948 self-test is performed for both RAW_ACC/RAW_GYR
		*/
		INV_MSG(INV_MSG_LEVEL_INFO, "Running self-test...");
  402798:	4959      	ldr	r1, [pc, #356]	; (402900 <icm20948_run_selftest+0x184>)
  40279a:	2003      	movs	r0, #3
  40279c:	4b57      	ldr	r3, [pc, #348]	; (4028fc <icm20948_run_selftest+0x180>)
  40279e:	4798      	blx	r3

		/* Run the self-test */
		rc = inv_icm20948_run_selftest(&icm_device, gyro_bias_regular, accel_bias_regular);
  4027a0:	463a      	mov	r2, r7
  4027a2:	f107 030c 	add.w	r3, r7, #12
  4027a6:	4619      	mov	r1, r3
  4027a8:	4852      	ldr	r0, [pc, #328]	; (4028f4 <icm20948_run_selftest+0x178>)
  4027aa:	4b56      	ldr	r3, [pc, #344]	; (402904 <icm20948_run_selftest+0x188>)
  4027ac:	4798      	blx	r3
  4027ae:	4602      	mov	r2, r0
  4027b0:	4b55      	ldr	r3, [pc, #340]	; (402908 <icm20948_run_selftest+0x18c>)
  4027b2:	601a      	str	r2, [r3, #0]
		if ((rc & INV_ICM20948_SELF_TEST_OK) == INV_ICM20948_SELF_TEST_OK) {
  4027b4:	4b54      	ldr	r3, [pc, #336]	; (402908 <icm20948_run_selftest+0x18c>)
  4027b6:	681b      	ldr	r3, [r3, #0]
  4027b8:	f003 0307 	and.w	r3, r3, #7
  4027bc:	2b07      	cmp	r3, #7
  4027be:	d10b      	bne.n	4027d8 <icm20948_run_selftest+0x5c>
			/* On A+G+M self-test success, offset will be kept until reset */
			icm_device.selftest_done = 1;
  4027c0:	4b4c      	ldr	r3, [pc, #304]	; (4028f4 <icm20948_run_selftest+0x178>)
  4027c2:	2201      	movs	r2, #1
  4027c4:	f883 2090 	strb.w	r2, [r3, #144]	; 0x90
			icm_device.offset_done = 0;
  4027c8:	4b4a      	ldr	r3, [pc, #296]	; (4028f4 <icm20948_run_selftest+0x178>)
  4027ca:	2200      	movs	r2, #0
  4027cc:	f883 2091 	strb.w	r2, [r3, #145]	; 0x91
			rc = 0;
  4027d0:	4b4d      	ldr	r3, [pc, #308]	; (402908 <icm20948_run_selftest+0x18c>)
  4027d2:	2200      	movs	r2, #0
  4027d4:	601a      	str	r2, [r3, #0]
  4027d6:	e007      	b.n	4027e8 <icm20948_run_selftest+0x6c>
		} else {
			/* On A|G|M self-test failure, return Error */
			INV_MSG(INV_MSG_LEVEL_ERROR, "Self-test failure !");
  4027d8:	494c      	ldr	r1, [pc, #304]	; (40290c <icm20948_run_selftest+0x190>)
  4027da:	2001      	movs	r0, #1
  4027dc:	4b47      	ldr	r3, [pc, #284]	; (4028fc <icm20948_run_selftest+0x180>)
  4027de:	4798      	blx	r3
			/* 0 would be considered OK, we want KO */
			rc = INV_ERROR;
  4027e0:	4b49      	ldr	r3, [pc, #292]	; (402908 <icm20948_run_selftest+0x18c>)
  4027e2:	f04f 32ff 	mov.w	r2, #4294967295
  4027e6:	601a      	str	r2, [r3, #0]
		}

		/* It's advised to re-init the icm20948 device after self-test for normal use */
		icm20948_sensor_setup();
  4027e8:	4b49      	ldr	r3, [pc, #292]	; (402910 <icm20948_run_selftest+0x194>)
  4027ea:	4798      	blx	r3
		inv_icm20948_get_st_bias(&icm_device, gyro_bias_regular, accel_bias_regular, raw_bias, unscaled_bias);
  4027ec:	463a      	mov	r2, r7
  4027ee:	f107 010c 	add.w	r1, r7, #12
  4027f2:	4b48      	ldr	r3, [pc, #288]	; (402914 <icm20948_run_selftest+0x198>)
  4027f4:	9300      	str	r3, [sp, #0]
  4027f6:	4b48      	ldr	r3, [pc, #288]	; (402918 <icm20948_run_selftest+0x19c>)
  4027f8:	483e      	ldr	r0, [pc, #248]	; (4028f4 <icm20948_run_selftest+0x178>)
  4027fa:	4c48      	ldr	r4, [pc, #288]	; (40291c <icm20948_run_selftest+0x1a0>)
  4027fc:	47a0      	blx	r4
		INV_MSG(INV_MSG_LEVEL_INFO, "GYR bias (FS=250dps) (dps): x=%f, y=%f, z=%f", (float)(raw_bias[0] / (float)(1 << 16)), (float)(raw_bias[1] / (float)(1 << 16)), (float)(raw_bias[2] / (float)(1 << 16)));
  4027fe:	4b46      	ldr	r3, [pc, #280]	; (402918 <icm20948_run_selftest+0x19c>)
  402800:	681b      	ldr	r3, [r3, #0]
  402802:	ee07 3a90 	vmov	s15, r3
  402806:	eef8 7ae7 	vcvt.f32.s32	s15, s15
  40280a:	ed9f 7a45 	vldr	s14, [pc, #276]	; 402920 <icm20948_run_selftest+0x1a4>
  40280e:	eec7 6a87 	vdiv.f32	s13, s15, s14
  402812:	4b44      	ldr	r3, [pc, #272]	; (402924 <icm20948_run_selftest+0x1a8>)
  402814:	ee16 0a90 	vmov	r0, s13
  402818:	4798      	blx	r3
  40281a:	4680      	mov	r8, r0
  40281c:	4689      	mov	r9, r1
  40281e:	4b3e      	ldr	r3, [pc, #248]	; (402918 <icm20948_run_selftest+0x19c>)
  402820:	685b      	ldr	r3, [r3, #4]
  402822:	ee07 3a90 	vmov	s15, r3
  402826:	eef8 7ae7 	vcvt.f32.s32	s15, s15
  40282a:	ed9f 7a3d 	vldr	s14, [pc, #244]	; 402920 <icm20948_run_selftest+0x1a4>
  40282e:	eec7 6a87 	vdiv.f32	s13, s15, s14
  402832:	4b3c      	ldr	r3, [pc, #240]	; (402924 <icm20948_run_selftest+0x1a8>)
  402834:	ee16 0a90 	vmov	r0, s13
  402838:	4798      	blx	r3
  40283a:	4604      	mov	r4, r0
  40283c:	460d      	mov	r5, r1
  40283e:	4b36      	ldr	r3, [pc, #216]	; (402918 <icm20948_run_selftest+0x19c>)
  402840:	689b      	ldr	r3, [r3, #8]
  402842:	ee07 3a90 	vmov	s15, r3
  402846:	eef8 7ae7 	vcvt.f32.s32	s15, s15
  40284a:	ed9f 7a35 	vldr	s14, [pc, #212]	; 402920 <icm20948_run_selftest+0x1a4>
  40284e:	eec7 6a87 	vdiv.f32	s13, s15, s14
  402852:	4b34      	ldr	r3, [pc, #208]	; (402924 <icm20948_run_selftest+0x1a8>)
  402854:	ee16 0a90 	vmov	r0, s13
  402858:	4798      	blx	r3
  40285a:	4602      	mov	r2, r0
  40285c:	460b      	mov	r3, r1
  40285e:	e9cd 2302 	strd	r2, r3, [sp, #8]
  402862:	e9cd 4500 	strd	r4, r5, [sp]
  402866:	4642      	mov	r2, r8
  402868:	464b      	mov	r3, r9
  40286a:	492f      	ldr	r1, [pc, #188]	; (402928 <icm20948_run_selftest+0x1ac>)
  40286c:	2003      	movs	r0, #3
  40286e:	4c23      	ldr	r4, [pc, #140]	; (4028fc <icm20948_run_selftest+0x180>)
  402870:	47a0      	blx	r4
		INV_MSG(INV_MSG_LEVEL_INFO, "ACC bias (FS=2g) (g): x=%f, y=%f, z=%f", (float)(raw_bias[0 + 3] / (float)(1 << 16)), (float)(raw_bias[1 + 3] / (float)(1 << 16)), (float)(raw_bias[2 + 3] / (float)(1 << 16)));
  402872:	4b29      	ldr	r3, [pc, #164]	; (402918 <icm20948_run_selftest+0x19c>)
  402874:	68db      	ldr	r3, [r3, #12]
  402876:	ee07 3a90 	vmov	s15, r3
  40287a:	eef8 7ae7 	vcvt.f32.s32	s15, s15
  40287e:	ed9f 7a28 	vldr	s14, [pc, #160]	; 402920 <icm20948_run_selftest+0x1a4>
  402882:	eec7 6a87 	vdiv.f32	s13, s15, s14
  402886:	4b27      	ldr	r3, [pc, #156]	; (402924 <icm20948_run_selftest+0x1a8>)
  402888:	ee16 0a90 	vmov	r0, s13
  40288c:	4798      	blx	r3
  40288e:	4680      	mov	r8, r0
  402890:	4689      	mov	r9, r1
  402892:	4b21      	ldr	r3, [pc, #132]	; (402918 <icm20948_run_selftest+0x19c>)
  402894:	691b      	ldr	r3, [r3, #16]
  402896:	ee07 3a90 	vmov	s15, r3
  40289a:	eef8 7ae7 	vcvt.f32.s32	s15, s15
  40289e:	ed9f 7a20 	vldr	s14, [pc, #128]	; 402920 <icm20948_run_selftest+0x1a4>
  4028a2:	eec7 6a87 	vdiv.f32	s13, s15, s14
  4028a6:	4b1f      	ldr	r3, [pc, #124]	; (402924 <icm20948_run_selftest+0x1a8>)
  4028a8:	ee16 0a90 	vmov	r0, s13
  4028ac:	4798      	blx	r3
  4028ae:	4604      	mov	r4, r0
  4028b0:	460d      	mov	r5, r1
  4028b2:	4b19      	ldr	r3, [pc, #100]	; (402918 <icm20948_run_selftest+0x19c>)
  4028b4:	695b      	ldr	r3, [r3, #20]
  4028b6:	ee07 3a90 	vmov	s15, r3
  4028ba:	eef8 7ae7 	vcvt.f32.s32	s15, s15
  4028be:	ed9f 7a18 	vldr	s14, [pc, #96]	; 402920 <icm20948_run_selftest+0x1a4>
  4028c2:	eec7 6a87 	vdiv.f32	s13, s15, s14
  4028c6:	4b17      	ldr	r3, [pc, #92]	; (402924 <icm20948_run_selftest+0x1a8>)
  4028c8:	ee16 0a90 	vmov	r0, s13
  4028cc:	4798      	blx	r3
  4028ce:	4602      	mov	r2, r0
  4028d0:	460b      	mov	r3, r1
  4028d2:	e9cd 2302 	strd	r2, r3, [sp, #8]
  4028d6:	e9cd 4500 	strd	r4, r5, [sp]
  4028da:	4642      	mov	r2, r8
  4028dc:	464b      	mov	r3, r9
  4028de:	4913      	ldr	r1, [pc, #76]	; (40292c <icm20948_run_selftest+0x1b0>)
  4028e0:	2003      	movs	r0, #3
  4028e2:	4c06      	ldr	r4, [pc, #24]	; (4028fc <icm20948_run_selftest+0x180>)
  4028e4:	47a0      	blx	r4
	}

	return rc;
  4028e6:	4b08      	ldr	r3, [pc, #32]	; (402908 <icm20948_run_selftest+0x18c>)
  4028e8:	681b      	ldr	r3, [r3, #0]
}
  4028ea:	4618      	mov	r0, r3
  4028ec:	3718      	adds	r7, #24
  4028ee:	46bd      	mov	sp, r7
  4028f0:	e8bd 83b0 	ldmia.w	sp!, {r4, r5, r7, r8, r9, pc}
  4028f4:	20001b30 	.word	0x20001b30
  4028f8:	0041bc34 	.word	0x0041bc34
  4028fc:	0040fd19 	.word	0x0040fd19
  402900:	0041bc5c 	.word	0x0041bc5c
  402904:	0040a261 	.word	0x0040a261
  402908:	20001208 	.word	0x20001208
  40290c:	0041bc74 	.word	0x0041bc74
  402910:	00401769 	.word	0x00401769
  402914:	20000ee4 	.word	0x20000ee4
  402918:	2000120c 	.word	0x2000120c
  40291c:	004025a5 	.word	0x004025a5
  402920:	47800000 	.word	0x47800000
  402924:	0041370d 	.word	0x0041370d
  402928:	0041bc88 	.word	0x0041bc88
  40292c:	0041bcb8 	.word	0x0041bcb8

00402930 <NVIC_EnableIRQ>:
{
  402930:	b480      	push	{r7}
  402932:	b083      	sub	sp, #12
  402934:	af00      	add	r7, sp, #0
  402936:	4603      	mov	r3, r0
  402938:	71fb      	strb	r3, [r7, #7]
  NVIC->ISER[(uint32_t)((int32_t)IRQn) >> 5] = (uint32_t)(1 << ((uint32_t)((int32_t)IRQn) & (uint32_t)0x1F)); /* enable interrupt */
  40293a:	4909      	ldr	r1, [pc, #36]	; (402960 <NVIC_EnableIRQ+0x30>)
  40293c:	f997 3007 	ldrsb.w	r3, [r7, #7]
  402940:	095b      	lsrs	r3, r3, #5
  402942:	79fa      	ldrb	r2, [r7, #7]
  402944:	f002 021f 	and.w	r2, r2, #31
  402948:	2001      	movs	r0, #1
  40294a:	fa00 f202 	lsl.w	r2, r0, r2
  40294e:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
  402952:	bf00      	nop
  402954:	370c      	adds	r7, #12
  402956:	46bd      	mov	sp, r7
  402958:	f85d 7b04 	ldr.w	r7, [sp], #4
  40295c:	4770      	bx	lr
  40295e:	bf00      	nop
  402960:	e000e100 	.word	0xe000e100

00402964 <NVIC_DisableIRQ>:
{
  402964:	b480      	push	{r7}
  402966:	b083      	sub	sp, #12
  402968:	af00      	add	r7, sp, #0
  40296a:	4603      	mov	r3, r0
  40296c:	71fb      	strb	r3, [r7, #7]
  NVIC->ICER[((uint32_t)(IRQn) >> 5)] = (1 << ((uint32_t)(IRQn) & 0x1F)); /* disable interrupt */
  40296e:	4909      	ldr	r1, [pc, #36]	; (402994 <NVIC_DisableIRQ+0x30>)
  402970:	f997 3007 	ldrsb.w	r3, [r7, #7]
  402974:	095b      	lsrs	r3, r3, #5
  402976:	79fa      	ldrb	r2, [r7, #7]
  402978:	f002 021f 	and.w	r2, r2, #31
  40297c:	2001      	movs	r0, #1
  40297e:	fa00 f202 	lsl.w	r2, r0, r2
  402982:	3320      	adds	r3, #32
  402984:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
  402988:	bf00      	nop
  40298a:	370c      	adds	r7, #12
  40298c:	46bd      	mov	sp, r7
  40298e:	f85d 7b04 	ldr.w	r7, [sp], #4
  402992:	4770      	bx	lr
  402994:	e000e100 	.word	0xe000e100

00402998 <NVIC_ClearPendingIRQ>:
{
  402998:	b480      	push	{r7}
  40299a:	b083      	sub	sp, #12
  40299c:	af00      	add	r7, sp, #0
  40299e:	4603      	mov	r3, r0
  4029a0:	71fb      	strb	r3, [r7, #7]
  NVIC->ICPR[((uint32_t)(IRQn) >> 5)] = (1 << ((uint32_t)(IRQn) & 0x1F)); /* Clear pending interrupt */
  4029a2:	4909      	ldr	r1, [pc, #36]	; (4029c8 <NVIC_ClearPendingIRQ+0x30>)
  4029a4:	f997 3007 	ldrsb.w	r3, [r7, #7]
  4029a8:	095b      	lsrs	r3, r3, #5
  4029aa:	79fa      	ldrb	r2, [r7, #7]
  4029ac:	f002 021f 	and.w	r2, r2, #31
  4029b0:	2001      	movs	r0, #1
  4029b2:	fa00 f202 	lsl.w	r2, r0, r2
  4029b6:	3360      	adds	r3, #96	; 0x60
  4029b8:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
  4029bc:	bf00      	nop
  4029be:	370c      	adds	r7, #12
  4029c0:	46bd      	mov	sp, r7
  4029c2:	f85d 7b04 	ldr.w	r7, [sp], #4
  4029c6:	4770      	bx	lr
  4029c8:	e000e100 	.word	0xe000e100

004029cc <NVIC_SetPriority>:
{
  4029cc:	b480      	push	{r7}
  4029ce:	b083      	sub	sp, #12
  4029d0:	af00      	add	r7, sp, #0
  4029d2:	4603      	mov	r3, r0
  4029d4:	6039      	str	r1, [r7, #0]
  4029d6:	71fb      	strb	r3, [r7, #7]
  if(IRQn < 0) {
  4029d8:	f997 3007 	ldrsb.w	r3, [r7, #7]
  4029dc:	2b00      	cmp	r3, #0
  4029de:	da0b      	bge.n	4029f8 <NVIC_SetPriority+0x2c>
    SCB->SHP[((uint32_t)(IRQn) & 0xF)-4] = ((priority << (8 - __NVIC_PRIO_BITS)) & 0xff); } /* set Priority for Cortex-M  System Interrupts */
  4029e0:	490d      	ldr	r1, [pc, #52]	; (402a18 <NVIC_SetPriority+0x4c>)
  4029e2:	79fb      	ldrb	r3, [r7, #7]
  4029e4:	f003 030f 	and.w	r3, r3, #15
  4029e8:	3b04      	subs	r3, #4
  4029ea:	683a      	ldr	r2, [r7, #0]
  4029ec:	b2d2      	uxtb	r2, r2
  4029ee:	0112      	lsls	r2, r2, #4
  4029f0:	b2d2      	uxtb	r2, r2
  4029f2:	440b      	add	r3, r1
  4029f4:	761a      	strb	r2, [r3, #24]
}
  4029f6:	e009      	b.n	402a0c <NVIC_SetPriority+0x40>
    NVIC->IP[(uint32_t)(IRQn)] = ((priority << (8 - __NVIC_PRIO_BITS)) & 0xff);    }        /* set Priority for device specific Interrupts  */
  4029f8:	4908      	ldr	r1, [pc, #32]	; (402a1c <NVIC_SetPriority+0x50>)
  4029fa:	f997 3007 	ldrsb.w	r3, [r7, #7]
  4029fe:	683a      	ldr	r2, [r7, #0]
  402a00:	b2d2      	uxtb	r2, r2
  402a02:	0112      	lsls	r2, r2, #4
  402a04:	b2d2      	uxtb	r2, r2
  402a06:	440b      	add	r3, r1
  402a08:	f883 2300 	strb.w	r2, [r3, #768]	; 0x300
}
  402a0c:	bf00      	nop
  402a0e:	370c      	adds	r7, #12
  402a10:	46bd      	mov	sp, r7
  402a12:	f85d 7b04 	ldr.w	r7, [sp], #4
  402a16:	4770      	bx	lr
  402a18:	e000ed00 	.word	0xe000ed00
  402a1c:	e000e100 	.word	0xe000e100

00402a20 <osc_get_rate>:
{
  402a20:	b480      	push	{r7}
  402a22:	b083      	sub	sp, #12
  402a24:	af00      	add	r7, sp, #0
  402a26:	6078      	str	r0, [r7, #4]
	switch (ul_id) {
  402a28:	687b      	ldr	r3, [r7, #4]
  402a2a:	2b07      	cmp	r3, #7
  402a2c:	d825      	bhi.n	402a7a <osc_get_rate+0x5a>
  402a2e:	a201      	add	r2, pc, #4	; (adr r2, 402a34 <osc_get_rate+0x14>)
  402a30:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
  402a34:	00402a55 	.word	0x00402a55
  402a38:	00402a5b 	.word	0x00402a5b
  402a3c:	00402a61 	.word	0x00402a61
  402a40:	00402a67 	.word	0x00402a67
  402a44:	00402a6b 	.word	0x00402a6b
  402a48:	00402a6f 	.word	0x00402a6f
  402a4c:	00402a73 	.word	0x00402a73
  402a50:	00402a77 	.word	0x00402a77
		return OSC_SLCK_32K_RC_HZ;
  402a54:	f44f 43fa 	mov.w	r3, #32000	; 0x7d00
  402a58:	e010      	b.n	402a7c <osc_get_rate+0x5c>
		return BOARD_FREQ_SLCK_XTAL;
  402a5a:	f44f 4300 	mov.w	r3, #32768	; 0x8000
  402a5e:	e00d      	b.n	402a7c <osc_get_rate+0x5c>
		return BOARD_FREQ_SLCK_BYPASS;
  402a60:	f44f 4300 	mov.w	r3, #32768	; 0x8000
  402a64:	e00a      	b.n	402a7c <osc_get_rate+0x5c>
		return OSC_MAINCK_8M_RC_HZ;
  402a66:	4b08      	ldr	r3, [pc, #32]	; (402a88 <osc_get_rate+0x68>)
  402a68:	e008      	b.n	402a7c <osc_get_rate+0x5c>
		return OSC_MAINCK_16M_RC_HZ;
  402a6a:	4b08      	ldr	r3, [pc, #32]	; (402a8c <osc_get_rate+0x6c>)
  402a6c:	e006      	b.n	402a7c <osc_get_rate+0x5c>
		return OSC_MAINCK_24M_RC_HZ;
  402a6e:	4b08      	ldr	r3, [pc, #32]	; (402a90 <osc_get_rate+0x70>)
  402a70:	e004      	b.n	402a7c <osc_get_rate+0x5c>
		return BOARD_FREQ_MAINCK_XTAL;
  402a72:	2300      	movs	r3, #0
  402a74:	e002      	b.n	402a7c <osc_get_rate+0x5c>
		return BOARD_FREQ_MAINCK_BYPASS;
  402a76:	2300      	movs	r3, #0
  402a78:	e000      	b.n	402a7c <osc_get_rate+0x5c>
	return 0;
  402a7a:	2300      	movs	r3, #0
}
  402a7c:	4618      	mov	r0, r3
  402a7e:	370c      	adds	r7, #12
  402a80:	46bd      	mov	sp, r7
  402a82:	f85d 7b04 	ldr.w	r7, [sp], #4
  402a86:	4770      	bx	lr
  402a88:	007a1200 	.word	0x007a1200
  402a8c:	00f42400 	.word	0x00f42400
  402a90:	016e3600 	.word	0x016e3600

00402a94 <sysclk_get_main_hz>:
{
  402a94:	b580      	push	{r7, lr}
  402a96:	af00      	add	r7, sp, #0
		return pll_get_default_rate(0);
  402a98:	2001      	movs	r0, #1
  402a9a:	4b04      	ldr	r3, [pc, #16]	; (402aac <sysclk_get_main_hz+0x18>)
  402a9c:	4798      	blx	r3
  402a9e:	4602      	mov	r2, r0
  402aa0:	f640 634e 	movw	r3, #3662	; 0xe4e
  402aa4:	fb03 f302 	mul.w	r3, r3, r2
}
  402aa8:	4618      	mov	r0, r3
  402aaa:	bd80      	pop	{r7, pc}
  402aac:	00402a21 	.word	0x00402a21

00402ab0 <sysclk_get_cpu_hz>:
{
  402ab0:	b580      	push	{r7, lr}
  402ab2:	af00      	add	r7, sp, #0
	return sysclk_get_main_hz() /
  402ab4:	4b02      	ldr	r3, [pc, #8]	; (402ac0 <sysclk_get_cpu_hz+0x10>)
  402ab6:	4798      	blx	r3
  402ab8:	4603      	mov	r3, r0
}
  402aba:	4618      	mov	r0, r3
  402abc:	bd80      	pop	{r7, pc}
  402abe:	bf00      	nop
  402ac0:	00402a95 	.word	0x00402a95

00402ac4 <sysclk_get_peripheral_hz>:
{
  402ac4:	b580      	push	{r7, lr}
  402ac6:	af00      	add	r7, sp, #0
	return sysclk_get_main_hz() /
  402ac8:	4b02      	ldr	r3, [pc, #8]	; (402ad4 <sysclk_get_peripheral_hz+0x10>)
  402aca:	4798      	blx	r3
  402acc:	4603      	mov	r3, r0
}
  402ace:	4618      	mov	r0, r3
  402ad0:	bd80      	pop	{r7, pc}
  402ad2:	bf00      	nop
  402ad4:	00402a95 	.word	0x00402a95

00402ad8 <sysclk_enable_peripheral_clock>:
{
  402ad8:	b580      	push	{r7, lr}
  402ada:	b082      	sub	sp, #8
  402adc:	af00      	add	r7, sp, #0
  402ade:	6078      	str	r0, [r7, #4]
	pmc_enable_periph_clk(ul_id);
  402ae0:	6878      	ldr	r0, [r7, #4]
  402ae2:	4b03      	ldr	r3, [pc, #12]	; (402af0 <sysclk_enable_peripheral_clock+0x18>)
  402ae4:	4798      	blx	r3
}
  402ae6:	bf00      	nop
  402ae8:	3708      	adds	r7, #8
  402aea:	46bd      	mov	sp, r7
  402aec:	bd80      	pop	{r7, pc}
  402aee:	bf00      	nop
  402af0:	00404401 	.word	0x00404401

00402af4 <usart_serial_init>:
{
  402af4:	b580      	push	{r7, lr}
  402af6:	b088      	sub	sp, #32
  402af8:	af00      	add	r7, sp, #0
  402afa:	6078      	str	r0, [r7, #4]
  402afc:	6039      	str	r1, [r7, #0]
	usart_settings.baudrate = opt->baudrate;
  402afe:	683b      	ldr	r3, [r7, #0]
  402b00:	681b      	ldr	r3, [r3, #0]
  402b02:	60bb      	str	r3, [r7, #8]
	usart_settings.char_length = opt->charlength;
  402b04:	683b      	ldr	r3, [r7, #0]
  402b06:	685b      	ldr	r3, [r3, #4]
  402b08:	60fb      	str	r3, [r7, #12]
	usart_settings.parity_type = opt->paritytype;
  402b0a:	683b      	ldr	r3, [r7, #0]
  402b0c:	689b      	ldr	r3, [r3, #8]
  402b0e:	613b      	str	r3, [r7, #16]
	usart_settings.stop_bits= opt->stopbits;
  402b10:	683b      	ldr	r3, [r7, #0]
  402b12:	68db      	ldr	r3, [r3, #12]
  402b14:	617b      	str	r3, [r7, #20]
	usart_settings.channel_mode= US_MR_CHMODE_NORMAL;
  402b16:	2300      	movs	r3, #0
  402b18:	61bb      	str	r3, [r7, #24]
	if (USART0 == p_usart) {
  402b1a:	687b      	ldr	r3, [r7, #4]
  402b1c:	4a69      	ldr	r2, [pc, #420]	; (402cc4 <usart_serial_init+0x1d0>)
  402b1e:	4293      	cmp	r3, r2
  402b20:	d115      	bne.n	402b4e <usart_serial_init+0x5a>
		flexcom_enable(FLEXCOM0);
  402b22:	4869      	ldr	r0, [pc, #420]	; (402cc8 <usart_serial_init+0x1d4>)
  402b24:	4b69      	ldr	r3, [pc, #420]	; (402ccc <usart_serial_init+0x1d8>)
  402b26:	4798      	blx	r3
		flexcom_set_opmode(FLEXCOM0, FLEXCOM_USART);
  402b28:	2101      	movs	r1, #1
  402b2a:	4867      	ldr	r0, [pc, #412]	; (402cc8 <usart_serial_init+0x1d4>)
  402b2c:	4b68      	ldr	r3, [pc, #416]	; (402cd0 <usart_serial_init+0x1dc>)
  402b2e:	4798      	blx	r3
		usart_init_rs232(p_usart, &usart_settings,
  402b30:	4b68      	ldr	r3, [pc, #416]	; (402cd4 <usart_serial_init+0x1e0>)
  402b32:	4798      	blx	r3
  402b34:	4602      	mov	r2, r0
  402b36:	f107 0308 	add.w	r3, r7, #8
  402b3a:	4619      	mov	r1, r3
  402b3c:	6878      	ldr	r0, [r7, #4]
  402b3e:	4b66      	ldr	r3, [pc, #408]	; (402cd8 <usart_serial_init+0x1e4>)
  402b40:	4798      	blx	r3
		usart_enable_tx(p_usart);
  402b42:	6878      	ldr	r0, [r7, #4]
  402b44:	4b65      	ldr	r3, [pc, #404]	; (402cdc <usart_serial_init+0x1e8>)
  402b46:	4798      	blx	r3
		usart_enable_rx(p_usart);
  402b48:	6878      	ldr	r0, [r7, #4]
  402b4a:	4b65      	ldr	r3, [pc, #404]	; (402ce0 <usart_serial_init+0x1ec>)
  402b4c:	4798      	blx	r3
	if (USART1 == p_usart) {
  402b4e:	687b      	ldr	r3, [r7, #4]
  402b50:	4a64      	ldr	r2, [pc, #400]	; (402ce4 <usart_serial_init+0x1f0>)
  402b52:	4293      	cmp	r3, r2
  402b54:	d115      	bne.n	402b82 <usart_serial_init+0x8e>
		flexcom_enable(FLEXCOM1);
  402b56:	4864      	ldr	r0, [pc, #400]	; (402ce8 <usart_serial_init+0x1f4>)
  402b58:	4b5c      	ldr	r3, [pc, #368]	; (402ccc <usart_serial_init+0x1d8>)
  402b5a:	4798      	blx	r3
		flexcom_set_opmode(FLEXCOM1, FLEXCOM_USART);
  402b5c:	2101      	movs	r1, #1
  402b5e:	4862      	ldr	r0, [pc, #392]	; (402ce8 <usart_serial_init+0x1f4>)
  402b60:	4b5b      	ldr	r3, [pc, #364]	; (402cd0 <usart_serial_init+0x1dc>)
  402b62:	4798      	blx	r3
		usart_init_rs232(p_usart, &usart_settings,
  402b64:	4b5b      	ldr	r3, [pc, #364]	; (402cd4 <usart_serial_init+0x1e0>)
  402b66:	4798      	blx	r3
  402b68:	4602      	mov	r2, r0
  402b6a:	f107 0308 	add.w	r3, r7, #8
  402b6e:	4619      	mov	r1, r3
  402b70:	6878      	ldr	r0, [r7, #4]
  402b72:	4b59      	ldr	r3, [pc, #356]	; (402cd8 <usart_serial_init+0x1e4>)
  402b74:	4798      	blx	r3
		usart_enable_tx(p_usart);
  402b76:	6878      	ldr	r0, [r7, #4]
  402b78:	4b58      	ldr	r3, [pc, #352]	; (402cdc <usart_serial_init+0x1e8>)
  402b7a:	4798      	blx	r3
		usart_enable_rx(p_usart);
  402b7c:	6878      	ldr	r0, [r7, #4]
  402b7e:	4b58      	ldr	r3, [pc, #352]	; (402ce0 <usart_serial_init+0x1ec>)
  402b80:	4798      	blx	r3
	if (USART2 == p_usart) {
  402b82:	687b      	ldr	r3, [r7, #4]
  402b84:	4a59      	ldr	r2, [pc, #356]	; (402cec <usart_serial_init+0x1f8>)
  402b86:	4293      	cmp	r3, r2
  402b88:	d115      	bne.n	402bb6 <usart_serial_init+0xc2>
		flexcom_enable(FLEXCOM2);
  402b8a:	4859      	ldr	r0, [pc, #356]	; (402cf0 <usart_serial_init+0x1fc>)
  402b8c:	4b4f      	ldr	r3, [pc, #316]	; (402ccc <usart_serial_init+0x1d8>)
  402b8e:	4798      	blx	r3
		flexcom_set_opmode(FLEXCOM2, FLEXCOM_USART);
  402b90:	2101      	movs	r1, #1
  402b92:	4857      	ldr	r0, [pc, #348]	; (402cf0 <usart_serial_init+0x1fc>)
  402b94:	4b4e      	ldr	r3, [pc, #312]	; (402cd0 <usart_serial_init+0x1dc>)
  402b96:	4798      	blx	r3
		usart_init_rs232(p_usart, &usart_settings,
  402b98:	4b4e      	ldr	r3, [pc, #312]	; (402cd4 <usart_serial_init+0x1e0>)
  402b9a:	4798      	blx	r3
  402b9c:	4602      	mov	r2, r0
  402b9e:	f107 0308 	add.w	r3, r7, #8
  402ba2:	4619      	mov	r1, r3
  402ba4:	6878      	ldr	r0, [r7, #4]
  402ba6:	4b4c      	ldr	r3, [pc, #304]	; (402cd8 <usart_serial_init+0x1e4>)
  402ba8:	4798      	blx	r3
		usart_enable_tx(p_usart);
  402baa:	6878      	ldr	r0, [r7, #4]
  402bac:	4b4b      	ldr	r3, [pc, #300]	; (402cdc <usart_serial_init+0x1e8>)
  402bae:	4798      	blx	r3
		usart_enable_rx(p_usart);
  402bb0:	6878      	ldr	r0, [r7, #4]
  402bb2:	4b4b      	ldr	r3, [pc, #300]	; (402ce0 <usart_serial_init+0x1ec>)
  402bb4:	4798      	blx	r3
	if (USART3 == p_usart) {
  402bb6:	687b      	ldr	r3, [r7, #4]
  402bb8:	4a4e      	ldr	r2, [pc, #312]	; (402cf4 <usart_serial_init+0x200>)
  402bba:	4293      	cmp	r3, r2
  402bbc:	d115      	bne.n	402bea <usart_serial_init+0xf6>
		flexcom_enable(FLEXCOM3);
  402bbe:	484e      	ldr	r0, [pc, #312]	; (402cf8 <usart_serial_init+0x204>)
  402bc0:	4b42      	ldr	r3, [pc, #264]	; (402ccc <usart_serial_init+0x1d8>)
  402bc2:	4798      	blx	r3
		flexcom_set_opmode(FLEXCOM3, FLEXCOM_USART);
  402bc4:	2101      	movs	r1, #1
  402bc6:	484c      	ldr	r0, [pc, #304]	; (402cf8 <usart_serial_init+0x204>)
  402bc8:	4b41      	ldr	r3, [pc, #260]	; (402cd0 <usart_serial_init+0x1dc>)
  402bca:	4798      	blx	r3
		usart_init_rs232(p_usart, &usart_settings,
  402bcc:	4b41      	ldr	r3, [pc, #260]	; (402cd4 <usart_serial_init+0x1e0>)
  402bce:	4798      	blx	r3
  402bd0:	4602      	mov	r2, r0
  402bd2:	f107 0308 	add.w	r3, r7, #8
  402bd6:	4619      	mov	r1, r3
  402bd8:	6878      	ldr	r0, [r7, #4]
  402bda:	4b3f      	ldr	r3, [pc, #252]	; (402cd8 <usart_serial_init+0x1e4>)
  402bdc:	4798      	blx	r3
		usart_enable_tx(p_usart);
  402bde:	6878      	ldr	r0, [r7, #4]
  402be0:	4b3e      	ldr	r3, [pc, #248]	; (402cdc <usart_serial_init+0x1e8>)
  402be2:	4798      	blx	r3
		usart_enable_rx(p_usart);
  402be4:	6878      	ldr	r0, [r7, #4]
  402be6:	4b3e      	ldr	r3, [pc, #248]	; (402ce0 <usart_serial_init+0x1ec>)
  402be8:	4798      	blx	r3
	if (USART4 == p_usart) {
  402bea:	687b      	ldr	r3, [r7, #4]
  402bec:	4a43      	ldr	r2, [pc, #268]	; (402cfc <usart_serial_init+0x208>)
  402bee:	4293      	cmp	r3, r2
  402bf0:	d115      	bne.n	402c1e <usart_serial_init+0x12a>
		flexcom_enable(FLEXCOM4);
  402bf2:	4843      	ldr	r0, [pc, #268]	; (402d00 <usart_serial_init+0x20c>)
  402bf4:	4b35      	ldr	r3, [pc, #212]	; (402ccc <usart_serial_init+0x1d8>)
  402bf6:	4798      	blx	r3
		flexcom_set_opmode(FLEXCOM4, FLEXCOM_USART);
  402bf8:	2101      	movs	r1, #1
  402bfa:	4841      	ldr	r0, [pc, #260]	; (402d00 <usart_serial_init+0x20c>)
  402bfc:	4b34      	ldr	r3, [pc, #208]	; (402cd0 <usart_serial_init+0x1dc>)
  402bfe:	4798      	blx	r3
		usart_init_rs232(p_usart, &usart_settings,
  402c00:	4b34      	ldr	r3, [pc, #208]	; (402cd4 <usart_serial_init+0x1e0>)
  402c02:	4798      	blx	r3
  402c04:	4602      	mov	r2, r0
  402c06:	f107 0308 	add.w	r3, r7, #8
  402c0a:	4619      	mov	r1, r3
  402c0c:	6878      	ldr	r0, [r7, #4]
  402c0e:	4b32      	ldr	r3, [pc, #200]	; (402cd8 <usart_serial_init+0x1e4>)
  402c10:	4798      	blx	r3
		usart_enable_tx(p_usart);
  402c12:	6878      	ldr	r0, [r7, #4]
  402c14:	4b31      	ldr	r3, [pc, #196]	; (402cdc <usart_serial_init+0x1e8>)
  402c16:	4798      	blx	r3
		usart_enable_rx(p_usart);
  402c18:	6878      	ldr	r0, [r7, #4]
  402c1a:	4b31      	ldr	r3, [pc, #196]	; (402ce0 <usart_serial_init+0x1ec>)
  402c1c:	4798      	blx	r3
	if (USART5 == p_usart) {
  402c1e:	687b      	ldr	r3, [r7, #4]
  402c20:	4a38      	ldr	r2, [pc, #224]	; (402d04 <usart_serial_init+0x210>)
  402c22:	4293      	cmp	r3, r2
  402c24:	d115      	bne.n	402c52 <usart_serial_init+0x15e>
		flexcom_enable(FLEXCOM5);
  402c26:	4838      	ldr	r0, [pc, #224]	; (402d08 <usart_serial_init+0x214>)
  402c28:	4b28      	ldr	r3, [pc, #160]	; (402ccc <usart_serial_init+0x1d8>)
  402c2a:	4798      	blx	r3
		flexcom_set_opmode(FLEXCOM5, FLEXCOM_USART);
  402c2c:	2101      	movs	r1, #1
  402c2e:	4836      	ldr	r0, [pc, #216]	; (402d08 <usart_serial_init+0x214>)
  402c30:	4b27      	ldr	r3, [pc, #156]	; (402cd0 <usart_serial_init+0x1dc>)
  402c32:	4798      	blx	r3
		usart_init_rs232(p_usart, &usart_settings,
  402c34:	4b27      	ldr	r3, [pc, #156]	; (402cd4 <usart_serial_init+0x1e0>)
  402c36:	4798      	blx	r3
  402c38:	4602      	mov	r2, r0
  402c3a:	f107 0308 	add.w	r3, r7, #8
  402c3e:	4619      	mov	r1, r3
  402c40:	6878      	ldr	r0, [r7, #4]
  402c42:	4b25      	ldr	r3, [pc, #148]	; (402cd8 <usart_serial_init+0x1e4>)
  402c44:	4798      	blx	r3
		usart_enable_tx(p_usart);
  402c46:	6878      	ldr	r0, [r7, #4]
  402c48:	4b24      	ldr	r3, [pc, #144]	; (402cdc <usart_serial_init+0x1e8>)
  402c4a:	4798      	blx	r3
		usart_enable_rx(p_usart);
  402c4c:	6878      	ldr	r0, [r7, #4]
  402c4e:	4b24      	ldr	r3, [pc, #144]	; (402ce0 <usart_serial_init+0x1ec>)
  402c50:	4798      	blx	r3
	if (USART6 == p_usart) {
  402c52:	687b      	ldr	r3, [r7, #4]
  402c54:	4a2d      	ldr	r2, [pc, #180]	; (402d0c <usart_serial_init+0x218>)
  402c56:	4293      	cmp	r3, r2
  402c58:	d115      	bne.n	402c86 <usart_serial_init+0x192>
		flexcom_enable(FLEXCOM6);
  402c5a:	482d      	ldr	r0, [pc, #180]	; (402d10 <usart_serial_init+0x21c>)
  402c5c:	4b1b      	ldr	r3, [pc, #108]	; (402ccc <usart_serial_init+0x1d8>)
  402c5e:	4798      	blx	r3
		flexcom_set_opmode(FLEXCOM6, FLEXCOM_USART);
  402c60:	2101      	movs	r1, #1
  402c62:	482b      	ldr	r0, [pc, #172]	; (402d10 <usart_serial_init+0x21c>)
  402c64:	4b1a      	ldr	r3, [pc, #104]	; (402cd0 <usart_serial_init+0x1dc>)
  402c66:	4798      	blx	r3
		usart_init_rs232(p_usart, &usart_settings,
  402c68:	4b1a      	ldr	r3, [pc, #104]	; (402cd4 <usart_serial_init+0x1e0>)
  402c6a:	4798      	blx	r3
  402c6c:	4602      	mov	r2, r0
  402c6e:	f107 0308 	add.w	r3, r7, #8
  402c72:	4619      	mov	r1, r3
  402c74:	6878      	ldr	r0, [r7, #4]
  402c76:	4b18      	ldr	r3, [pc, #96]	; (402cd8 <usart_serial_init+0x1e4>)
  402c78:	4798      	blx	r3
		usart_enable_tx(p_usart);
  402c7a:	6878      	ldr	r0, [r7, #4]
  402c7c:	4b17      	ldr	r3, [pc, #92]	; (402cdc <usart_serial_init+0x1e8>)
  402c7e:	4798      	blx	r3
		usart_enable_rx(p_usart);
  402c80:	6878      	ldr	r0, [r7, #4]
  402c82:	4b17      	ldr	r3, [pc, #92]	; (402ce0 <usart_serial_init+0x1ec>)
  402c84:	4798      	blx	r3
	if (USART7 == p_usart) {
  402c86:	687b      	ldr	r3, [r7, #4]
  402c88:	4a22      	ldr	r2, [pc, #136]	; (402d14 <usart_serial_init+0x220>)
  402c8a:	4293      	cmp	r3, r2
  402c8c:	d115      	bne.n	402cba <usart_serial_init+0x1c6>
		flexcom_enable(FLEXCOM7);
  402c8e:	4822      	ldr	r0, [pc, #136]	; (402d18 <usart_serial_init+0x224>)
  402c90:	4b0e      	ldr	r3, [pc, #56]	; (402ccc <usart_serial_init+0x1d8>)
  402c92:	4798      	blx	r3
		flexcom_set_opmode(FLEXCOM7, FLEXCOM_USART);
  402c94:	2101      	movs	r1, #1
  402c96:	4820      	ldr	r0, [pc, #128]	; (402d18 <usart_serial_init+0x224>)
  402c98:	4b0d      	ldr	r3, [pc, #52]	; (402cd0 <usart_serial_init+0x1dc>)
  402c9a:	4798      	blx	r3
		usart_init_rs232(p_usart, &usart_settings,
  402c9c:	4b0d      	ldr	r3, [pc, #52]	; (402cd4 <usart_serial_init+0x1e0>)
  402c9e:	4798      	blx	r3
  402ca0:	4602      	mov	r2, r0
  402ca2:	f107 0308 	add.w	r3, r7, #8
  402ca6:	4619      	mov	r1, r3
  402ca8:	6878      	ldr	r0, [r7, #4]
  402caa:	4b0b      	ldr	r3, [pc, #44]	; (402cd8 <usart_serial_init+0x1e4>)
  402cac:	4798      	blx	r3
		usart_enable_tx(p_usart);
  402cae:	6878      	ldr	r0, [r7, #4]
  402cb0:	4b0a      	ldr	r3, [pc, #40]	; (402cdc <usart_serial_init+0x1e8>)
  402cb2:	4798      	blx	r3
		usart_enable_rx(p_usart);
  402cb4:	6878      	ldr	r0, [r7, #4]
  402cb6:	4b0a      	ldr	r3, [pc, #40]	; (402ce0 <usart_serial_init+0x1ec>)
  402cb8:	4798      	blx	r3
}
  402cba:	bf00      	nop
  402cbc:	3720      	adds	r7, #32
  402cbe:	46bd      	mov	sp, r7
  402cc0:	bd80      	pop	{r7, pc}
  402cc2:	bf00      	nop
  402cc4:	4000c200 	.word	0x4000c200
  402cc8:	4000c000 	.word	0x4000c000
  402ccc:	00403749 	.word	0x00403749
  402cd0:	004038b1 	.word	0x004038b1
  402cd4:	00402ac5 	.word	0x00402ac5
  402cd8:	00403481 	.word	0x00403481
  402cdc:	00403505 	.word	0x00403505
  402ce0:	00403539 	.word	0x00403539
  402ce4:	40020200 	.word	0x40020200
  402ce8:	40020000 	.word	0x40020000
  402cec:	40024200 	.word	0x40024200
  402cf0:	40024000 	.word	0x40024000
  402cf4:	40018200 	.word	0x40018200
  402cf8:	40018000 	.word	0x40018000
  402cfc:	4001c200 	.word	0x4001c200
  402d00:	4001c000 	.word	0x4001c000
  402d04:	40008200 	.word	0x40008200
  402d08:	40008000 	.word	0x40008000
  402d0c:	40040200 	.word	0x40040200
  402d10:	40040000 	.word	0x40040000
  402d14:	40034200 	.word	0x40034200
  402d18:	40034000 	.word	0x40034000

00402d1c <usart_serial_getchar>:
 * \param p_usart   Base address of the USART instance.
 * \param data   Data to read
 *
 */
static inline void usart_serial_getchar(usart_if p_usart, uint8_t *data)
{
  402d1c:	b580      	push	{r7, lr}
  402d1e:	b084      	sub	sp, #16
  402d20:	af00      	add	r7, sp, #0
  402d22:	6078      	str	r0, [r7, #4]
  402d24:	6039      	str	r1, [r7, #0]
	uint32_t val = 0;
  402d26:	2300      	movs	r3, #0
  402d28:	60fb      	str	r3, [r7, #12]
		while (usart_read(p_usart, &val));
		*data = (uint8_t)(val & 0xFF);
	}
#else
# ifdef USART0
	if (USART0 == p_usart) {
  402d2a:	687b      	ldr	r3, [r7, #4]
  402d2c:	4a49      	ldr	r2, [pc, #292]	; (402e54 <usart_serial_getchar+0x138>)
  402d2e:	4293      	cmp	r3, r2
  402d30:	d10d      	bne.n	402d4e <usart_serial_getchar+0x32>
		while (usart_read(p_usart, &val));
  402d32:	bf00      	nop
  402d34:	f107 030c 	add.w	r3, r7, #12
  402d38:	4619      	mov	r1, r3
  402d3a:	6878      	ldr	r0, [r7, #4]
  402d3c:	4b46      	ldr	r3, [pc, #280]	; (402e58 <usart_serial_getchar+0x13c>)
  402d3e:	4798      	blx	r3
  402d40:	4603      	mov	r3, r0
  402d42:	2b00      	cmp	r3, #0
  402d44:	d1f6      	bne.n	402d34 <usart_serial_getchar+0x18>
		*data = (uint8_t)(val & 0xFF);
  402d46:	68fb      	ldr	r3, [r7, #12]
  402d48:	b2da      	uxtb	r2, r3
  402d4a:	683b      	ldr	r3, [r7, #0]
  402d4c:	701a      	strb	r2, [r3, #0]
	}
# endif
# ifdef USART1
	if (USART1 == p_usart) {
  402d4e:	687b      	ldr	r3, [r7, #4]
  402d50:	4a42      	ldr	r2, [pc, #264]	; (402e5c <usart_serial_getchar+0x140>)
  402d52:	4293      	cmp	r3, r2
  402d54:	d10d      	bne.n	402d72 <usart_serial_getchar+0x56>
		while (usart_read(p_usart, &val));
  402d56:	bf00      	nop
  402d58:	f107 030c 	add.w	r3, r7, #12
  402d5c:	4619      	mov	r1, r3
  402d5e:	6878      	ldr	r0, [r7, #4]
  402d60:	4b3d      	ldr	r3, [pc, #244]	; (402e58 <usart_serial_getchar+0x13c>)
  402d62:	4798      	blx	r3
  402d64:	4603      	mov	r3, r0
  402d66:	2b00      	cmp	r3, #0
  402d68:	d1f6      	bne.n	402d58 <usart_serial_getchar+0x3c>
		*data = (uint8_t)(val & 0xFF);
  402d6a:	68fb      	ldr	r3, [r7, #12]
  402d6c:	b2da      	uxtb	r2, r3
  402d6e:	683b      	ldr	r3, [r7, #0]
  402d70:	701a      	strb	r2, [r3, #0]
	}
# endif
# ifdef USART2
	if (USART2 == p_usart) {
  402d72:	687b      	ldr	r3, [r7, #4]
  402d74:	4a3a      	ldr	r2, [pc, #232]	; (402e60 <usart_serial_getchar+0x144>)
  402d76:	4293      	cmp	r3, r2
  402d78:	d10d      	bne.n	402d96 <usart_serial_getchar+0x7a>
		while (usart_read(p_usart, &val));
  402d7a:	bf00      	nop
  402d7c:	f107 030c 	add.w	r3, r7, #12
  402d80:	4619      	mov	r1, r3
  402d82:	6878      	ldr	r0, [r7, #4]
  402d84:	4b34      	ldr	r3, [pc, #208]	; (402e58 <usart_serial_getchar+0x13c>)
  402d86:	4798      	blx	r3
  402d88:	4603      	mov	r3, r0
  402d8a:	2b00      	cmp	r3, #0
  402d8c:	d1f6      	bne.n	402d7c <usart_serial_getchar+0x60>
		*data = (uint8_t)(val & 0xFF);
  402d8e:	68fb      	ldr	r3, [r7, #12]
  402d90:	b2da      	uxtb	r2, r3
  402d92:	683b      	ldr	r3, [r7, #0]
  402d94:	701a      	strb	r2, [r3, #0]
	}
# endif
# ifdef USART3
	if (USART3 == p_usart) {
  402d96:	687b      	ldr	r3, [r7, #4]
  402d98:	4a32      	ldr	r2, [pc, #200]	; (402e64 <usart_serial_getchar+0x148>)
  402d9a:	4293      	cmp	r3, r2
  402d9c:	d10d      	bne.n	402dba <usart_serial_getchar+0x9e>
		while (usart_read(p_usart, &val));
  402d9e:	bf00      	nop
  402da0:	f107 030c 	add.w	r3, r7, #12
  402da4:	4619      	mov	r1, r3
  402da6:	6878      	ldr	r0, [r7, #4]
  402da8:	4b2b      	ldr	r3, [pc, #172]	; (402e58 <usart_serial_getchar+0x13c>)
  402daa:	4798      	blx	r3
  402dac:	4603      	mov	r3, r0
  402dae:	2b00      	cmp	r3, #0
  402db0:	d1f6      	bne.n	402da0 <usart_serial_getchar+0x84>
		*data = (uint8_t)(val & 0xFF);
  402db2:	68fb      	ldr	r3, [r7, #12]
  402db4:	b2da      	uxtb	r2, r3
  402db6:	683b      	ldr	r3, [r7, #0]
  402db8:	701a      	strb	r2, [r3, #0]
	}
# endif
# ifdef USART4
	if (USART4 == p_usart) {
  402dba:	687b      	ldr	r3, [r7, #4]
  402dbc:	4a2a      	ldr	r2, [pc, #168]	; (402e68 <usart_serial_getchar+0x14c>)
  402dbe:	4293      	cmp	r3, r2
  402dc0:	d10d      	bne.n	402dde <usart_serial_getchar+0xc2>
		while (usart_read(p_usart, &val));
  402dc2:	bf00      	nop
  402dc4:	f107 030c 	add.w	r3, r7, #12
  402dc8:	4619      	mov	r1, r3
  402dca:	6878      	ldr	r0, [r7, #4]
  402dcc:	4b22      	ldr	r3, [pc, #136]	; (402e58 <usart_serial_getchar+0x13c>)
  402dce:	4798      	blx	r3
  402dd0:	4603      	mov	r3, r0
  402dd2:	2b00      	cmp	r3, #0
  402dd4:	d1f6      	bne.n	402dc4 <usart_serial_getchar+0xa8>
		*data = (uint8_t)(val & 0xFF);
  402dd6:	68fb      	ldr	r3, [r7, #12]
  402dd8:	b2da      	uxtb	r2, r3
  402dda:	683b      	ldr	r3, [r7, #0]
  402ddc:	701a      	strb	r2, [r3, #0]
	}
# endif
# ifdef USART5
	if (USART5 == p_usart) {
  402dde:	687b      	ldr	r3, [r7, #4]
  402de0:	4a22      	ldr	r2, [pc, #136]	; (402e6c <usart_serial_getchar+0x150>)
  402de2:	4293      	cmp	r3, r2
  402de4:	d10d      	bne.n	402e02 <usart_serial_getchar+0xe6>
		while (usart_read(p_usart, &val));
  402de6:	bf00      	nop
  402de8:	f107 030c 	add.w	r3, r7, #12
  402dec:	4619      	mov	r1, r3
  402dee:	6878      	ldr	r0, [r7, #4]
  402df0:	4b19      	ldr	r3, [pc, #100]	; (402e58 <usart_serial_getchar+0x13c>)
  402df2:	4798      	blx	r3
  402df4:	4603      	mov	r3, r0
  402df6:	2b00      	cmp	r3, #0
  402df8:	d1f6      	bne.n	402de8 <usart_serial_getchar+0xcc>
		*data = (uint8_t)(val & 0xFF);
  402dfa:	68fb      	ldr	r3, [r7, #12]
  402dfc:	b2da      	uxtb	r2, r3
  402dfe:	683b      	ldr	r3, [r7, #0]
  402e00:	701a      	strb	r2, [r3, #0]
	}
# endif
# ifdef USART6
	if (USART6 == p_usart) {
  402e02:	687b      	ldr	r3, [r7, #4]
  402e04:	4a1a      	ldr	r2, [pc, #104]	; (402e70 <usart_serial_getchar+0x154>)
  402e06:	4293      	cmp	r3, r2
  402e08:	d10d      	bne.n	402e26 <usart_serial_getchar+0x10a>
		while (usart_read(p_usart, &val));
  402e0a:	bf00      	nop
  402e0c:	f107 030c 	add.w	r3, r7, #12
  402e10:	4619      	mov	r1, r3
  402e12:	6878      	ldr	r0, [r7, #4]
  402e14:	4b10      	ldr	r3, [pc, #64]	; (402e58 <usart_serial_getchar+0x13c>)
  402e16:	4798      	blx	r3
  402e18:	4603      	mov	r3, r0
  402e1a:	2b00      	cmp	r3, #0
  402e1c:	d1f6      	bne.n	402e0c <usart_serial_getchar+0xf0>
		*data = (uint8_t)(val & 0xFF);
  402e1e:	68fb      	ldr	r3, [r7, #12]
  402e20:	b2da      	uxtb	r2, r3
  402e22:	683b      	ldr	r3, [r7, #0]
  402e24:	701a      	strb	r2, [r3, #0]
	}
# endif
# ifdef USART7
	if (USART7 == p_usart) {
  402e26:	687b      	ldr	r3, [r7, #4]
  402e28:	4a12      	ldr	r2, [pc, #72]	; (402e74 <usart_serial_getchar+0x158>)
  402e2a:	4293      	cmp	r3, r2
  402e2c:	d10d      	bne.n	402e4a <usart_serial_getchar+0x12e>
		while (usart_read(p_usart, &val));
  402e2e:	bf00      	nop
  402e30:	f107 030c 	add.w	r3, r7, #12
  402e34:	4619      	mov	r1, r3
  402e36:	6878      	ldr	r0, [r7, #4]
  402e38:	4b07      	ldr	r3, [pc, #28]	; (402e58 <usart_serial_getchar+0x13c>)
  402e3a:	4798      	blx	r3
  402e3c:	4603      	mov	r3, r0
  402e3e:	2b00      	cmp	r3, #0
  402e40:	d1f6      	bne.n	402e30 <usart_serial_getchar+0x114>
		*data = (uint8_t)(val & 0xFF);
  402e42:	68fb      	ldr	r3, [r7, #12]
  402e44:	b2da      	uxtb	r2, r3
  402e46:	683b      	ldr	r3, [r7, #0]
  402e48:	701a      	strb	r2, [r3, #0]
	}
# endif
#endif /* ifdef USART */

}
  402e4a:	bf00      	nop
  402e4c:	3710      	adds	r7, #16
  402e4e:	46bd      	mov	sp, r7
  402e50:	bd80      	pop	{r7, pc}
  402e52:	bf00      	nop
  402e54:	4000c200 	.word	0x4000c200
  402e58:	0040360b 	.word	0x0040360b
  402e5c:	40020200 	.word	0x40020200
  402e60:	40024200 	.word	0x40024200
  402e64:	40018200 	.word	0x40018200
  402e68:	4001c200 	.word	0x4001c200
  402e6c:	40008200 	.word	0x40008200
  402e70:	40040200 	.word	0x40040200
  402e74:	40034200 	.word	0x40034200

00402e78 <InvScheduler_updateTime>:
{
  402e78:	b480      	push	{r7}
  402e7a:	b083      	sub	sp, #12
  402e7c:	af00      	add	r7, sp, #0
  402e7e:	6078      	str	r0, [r7, #4]
	++scheduler->currentTime;
  402e80:	687b      	ldr	r3, [r7, #4]
  402e82:	681b      	ldr	r3, [r3, #0]
  402e84:	1c5a      	adds	r2, r3, #1
  402e86:	687b      	ldr	r3, [r7, #4]
  402e88:	601a      	str	r2, [r3, #0]
}
  402e8a:	bf00      	nop
  402e8c:	370c      	adds	r7, #12
  402e8e:	46bd      	mov	sp, r7
  402e90:	f85d 7b04 	ldr.w	r7, [sp], #4
  402e94:	4770      	bx	lr

00402e96 <RingByteBuffer_isFull>:
{
  402e96:	b480      	push	{r7}
  402e98:	b083      	sub	sp, #12
  402e9a:	af00      	add	r7, sp, #0
  402e9c:	6078      	str	r0, [r7, #4]
	return (self->end == self->start && self->msbEnd != self->msbStart);
  402e9e:	687b      	ldr	r3, [r7, #4]
  402ea0:	891a      	ldrh	r2, [r3, #8]
  402ea2:	687b      	ldr	r3, [r7, #4]
  402ea4:	88db      	ldrh	r3, [r3, #6]
  402ea6:	429a      	cmp	r2, r3
  402ea8:	d107      	bne.n	402eba <RingByteBuffer_isFull+0x24>
  402eaa:	687b      	ldr	r3, [r7, #4]
  402eac:	7ada      	ldrb	r2, [r3, #11]
  402eae:	687b      	ldr	r3, [r7, #4]
  402eb0:	7a9b      	ldrb	r3, [r3, #10]
  402eb2:	429a      	cmp	r2, r3
  402eb4:	d001      	beq.n	402eba <RingByteBuffer_isFull+0x24>
  402eb6:	2301      	movs	r3, #1
  402eb8:	e000      	b.n	402ebc <RingByteBuffer_isFull+0x26>
  402eba:	2300      	movs	r3, #0
}
  402ebc:	4618      	mov	r0, r3
  402ebe:	370c      	adds	r7, #12
  402ec0:	46bd      	mov	sp, r7
  402ec2:	f85d 7b04 	ldr.w	r7, [sp], #4
  402ec6:	4770      	bx	lr

00402ec8 <ext_interrupt_handler>:
* @param[out]	NULL
*
* @return		NULL
*
*/
void ext_interrupt_handler(void){
  402ec8:	b480      	push	{r7}
  402eca:	af00      	add	r7, sp, #0
	irq_from_device = 1;
  402ecc:	4b03      	ldr	r3, [pc, #12]	; (402edc <ext_interrupt_handler+0x14>)
  402ece:	2201      	movs	r2, #1
  402ed0:	601a      	str	r2, [r3, #0]
}	
  402ed2:	bf00      	nop
  402ed4:	46bd      	mov	sp, r7
  402ed6:	f85d 7b04 	ldr.w	r7, [sp], #4
  402eda:	4770      	bx	lr
  402edc:	20000d98 	.word	0x20000d98

00402ee0 <ext_int_initialize>:

void ext_int_initialize(void (*handler_function)(void)){
  402ee0:	b590      	push	{r4, r7, lr}
  402ee2:	b085      	sub	sp, #20
  402ee4:	af02      	add	r7, sp, #8
  402ee6:	6078      	str	r0, [r7, #4]
	/* Enable the peripheral clock for the board interrupt pin. */
	pmc_enable_periph_clk(PIN_EXT_INTERRUPT_ID);	
  402ee8:	200c      	movs	r0, #12
  402eea:	4b0f      	ldr	r3, [pc, #60]	; (402f28 <ext_int_initialize+0x48>)
  402eec:	4798      	blx	r3

	/* Configure PIOs as input pins. */
	pio_configure(PIN_EXT_INTERRUPT_PIO, PIN_EXT_INTERRUPT_TYPE, PIN_EXT_INTERRUPT_MASK, PIN_EXT_INTERRUPT_ATTR);
  402eee:	2370      	movs	r3, #112	; 0x70
  402ef0:	2208      	movs	r2, #8
  402ef2:	f04f 5120 	mov.w	r1, #671088640	; 0x28000000
  402ef6:	480d      	ldr	r0, [pc, #52]	; (402f2c <ext_int_initialize+0x4c>)
  402ef8:	4c0d      	ldr	r4, [pc, #52]	; (402f30 <ext_int_initialize+0x50>)
  402efa:	47a0      	blx	r4

	/* Initialize PIO interrupt handler, interrupt on rising edge. */
	pio_handler_set(PIN_EXT_INTERRUPT_PIO, PIN_EXT_INTERRUPT_ID, PIN_EXT_INTERRUPT_MASK, 
  402efc:	687b      	ldr	r3, [r7, #4]
  402efe:	9300      	str	r3, [sp, #0]
  402f00:	2370      	movs	r3, #112	; 0x70
  402f02:	2208      	movs	r2, #8
  402f04:	210c      	movs	r1, #12
  402f06:	4809      	ldr	r0, [pc, #36]	; (402f2c <ext_int_initialize+0x4c>)
  402f08:	4c0a      	ldr	r4, [pc, #40]	; (402f34 <ext_int_initialize+0x54>)
  402f0a:	47a0      	blx	r4
		PIN_EXT_INTERRUPT_ATTR, (void (*) (uint32_t, uint32_t))handler_function);

	/* Initialize and enable push button (PIO) interrupt. */
	pio_handler_set_priority(PIN_EXT_INTERRUPT_PIO, PIN_EXT_INTERRUPT_IRQn, 0);
  402f0c:	2200      	movs	r2, #0
  402f0e:	210c      	movs	r1, #12
  402f10:	4806      	ldr	r0, [pc, #24]	; (402f2c <ext_int_initialize+0x4c>)
  402f12:	4b09      	ldr	r3, [pc, #36]	; (402f38 <ext_int_initialize+0x58>)
  402f14:	4798      	blx	r3
	pio_enable_interrupt(PIN_EXT_INTERRUPT_PIO, PIN_EXT_INTERRUPT_MASK);
  402f16:	2108      	movs	r1, #8
  402f18:	4804      	ldr	r0, [pc, #16]	; (402f2c <ext_int_initialize+0x4c>)
  402f1a:	4b08      	ldr	r3, [pc, #32]	; (402f3c <ext_int_initialize+0x5c>)
  402f1c:	4798      	blx	r3
}
  402f1e:	bf00      	nop
  402f20:	370c      	adds	r7, #12
  402f22:	46bd      	mov	sp, r7
  402f24:	bd90      	pop	{r4, r7, pc}
  402f26:	bf00      	nop
  402f28:	00404401 	.word	0x00404401
  402f2c:	400e1000 	.word	0x400e1000
  402f30:	00400391 	.word	0x00400391
  402f34:	004006cd 	.word	0x004006cd
  402f38:	00400765 	.word	0x00400765
  402f3c:	004004bd 	.word	0x004004bd

00402f40 <configure_console>:
#define console_uart_irq_handler    FLEXCOM0_Handler

static uint8_t uart_rx_rb_buffer[512];
RingByteBuffer uart_rx_rb;

void configure_console(void){
  402f40:	b590      	push	{r4, r7, lr}
  402f42:	b089      	sub	sp, #36	; 0x24
  402f44:	af00      	add	r7, sp, #0
	const usart_serial_options_t uart_serial_options_debug = {
  402f46:	4b18      	ldr	r3, [pc, #96]	; (402fa8 <configure_console+0x68>)
  402f48:	f107 0410 	add.w	r4, r7, #16
  402f4c:	cb0f      	ldmia	r3, {r0, r1, r2, r3}
  402f4e:	e884 000f 	stmia.w	r4, {r0, r1, r2, r3}
		.paritytype = CONF_UART_PARITY,
		.stopbits = CONF_UART_STOP_BITS,
	};

	/* Configure debug UART. */
	sysclk_enable_peripheral_clock(DEBUG_UART_ID);
  402f52:	2007      	movs	r0, #7
  402f54:	4b15      	ldr	r3, [pc, #84]	; (402fac <configure_console+0x6c>)
  402f56:	4798      	blx	r3
	usart_serial_init(DEBUG_UART, (usart_serial_options_t *)&uart_serial_options_debug);
  402f58:	f107 0310 	add.w	r3, r7, #16
  402f5c:	4619      	mov	r1, r3
  402f5e:	4814      	ldr	r0, [pc, #80]	; (402fb0 <configure_console+0x70>)
  402f60:	4b14      	ldr	r3, [pc, #80]	; (402fb4 <configure_console+0x74>)
  402f62:	4798      	blx	r3

	const usart_serial_options_t uart_serial_options = {
  402f64:	4b14      	ldr	r3, [pc, #80]	; (402fb8 <configure_console+0x78>)
  402f66:	463c      	mov	r4, r7
  402f68:	cb0f      	ldmia	r3, {r0, r1, r2, r3}
  402f6a:	e884 000f 	stmia.w	r4, {r0, r1, r2, r3}
		.paritytype = CONF_UART_PARITY,
		.stopbits = CONF_UART_STOP_BITS,
	};

	/* Configure console UART. */
	sysclk_enable_peripheral_clock(CONSOLE_UART_ID);
  402f6e:	2008      	movs	r0, #8
  402f70:	4b0e      	ldr	r3, [pc, #56]	; (402fac <configure_console+0x6c>)
  402f72:	4798      	blx	r3
	usart_serial_init(CONF_UART, (usart_serial_options_t *)&uart_serial_options);
  402f74:	463b      	mov	r3, r7
  402f76:	4619      	mov	r1, r3
  402f78:	4810      	ldr	r0, [pc, #64]	; (402fbc <configure_console+0x7c>)
  402f7a:	4b0e      	ldr	r3, [pc, #56]	; (402fb4 <configure_console+0x74>)
  402f7c:	4798      	blx	r3

	RingByteBuffer_init(&uart_rx_rb, uart_rx_rb_buffer, sizeof(uart_rx_rb_buffer));
  402f7e:	f44f 7200 	mov.w	r2, #512	; 0x200
  402f82:	490f      	ldr	r1, [pc, #60]	; (402fc0 <configure_console+0x80>)
  402f84:	480f      	ldr	r0, [pc, #60]	; (402fc4 <configure_console+0x84>)
  402f86:	4b10      	ldr	r3, [pc, #64]	; (402fc8 <configure_console+0x88>)
  402f88:	4798      	blx	r3

	/* Enable UART IRQ */
	usart_enable_interrupt(CONSOLE_UART, US_IER_RXRDY);
  402f8a:	2101      	movs	r1, #1
  402f8c:	480b      	ldr	r0, [pc, #44]	; (402fbc <configure_console+0x7c>)
  402f8e:	4b0f      	ldr	r3, [pc, #60]	; (402fcc <configure_console+0x8c>)
  402f90:	4798      	blx	r3

	/* Enable UART interrupt */
	NVIC_SetPriority(CONSOLE_UART_IRQn, 0);
  402f92:	2100      	movs	r1, #0
  402f94:	2008      	movs	r0, #8
  402f96:	4b0e      	ldr	r3, [pc, #56]	; (402fd0 <configure_console+0x90>)
  402f98:	4798      	blx	r3

	/* Enable UART interrupt */
	NVIC_EnableIRQ(CONSOLE_UART_IRQn);
  402f9a:	2008      	movs	r0, #8
  402f9c:	4b0d      	ldr	r3, [pc, #52]	; (402fd4 <configure_console+0x94>)
  402f9e:	4798      	blx	r3
}
  402fa0:	bf00      	nop
  402fa2:	3724      	adds	r7, #36	; 0x24
  402fa4:	46bd      	mov	sp, r7
  402fa6:	bd90      	pop	{r4, r7, pc}
  402fa8:	0041bce0 	.word	0x0041bce0
  402fac:	00402ad9 	.word	0x00402ad9
  402fb0:	40034200 	.word	0x40034200
  402fb4:	00402af5 	.word	0x00402af5
  402fb8:	0041bcf0 	.word	0x0041bcf0
  402fbc:	4000c200 	.word	0x4000c200
  402fc0:	20001224 	.word	0x20001224
  402fc4:	20002068 	.word	0x20002068
  402fc8:	0040fd65 	.word	0x0040fd65
  402fcc:	0040356d 	.word	0x0040356d
  402fd0:	004029cd 	.word	0x004029cd
  402fd4:	00402931 	.word	0x00402931

00402fd8 <FLEXCOM0_Handler>:

/**
* \brief Interrupt handler for USART interrupt.
*/
void console_uart_irq_handler(void){
  402fd8:	b580      	push	{r7, lr}
  402fda:	b082      	sub	sp, #8
  402fdc:	af00      	add	r7, sp, #0
	uint32_t ul_status;

	/* Read USART Status. */
	ul_status = usart_get_status(CONSOLE_UART);
  402fde:	480e      	ldr	r0, [pc, #56]	; (403018 <FLEXCOM0_Handler+0x40>)
  402fe0:	4b0e      	ldr	r3, [pc, #56]	; (40301c <FLEXCOM0_Handler+0x44>)
  402fe2:	4798      	blx	r3
  402fe4:	6078      	str	r0, [r7, #4]

	if((ul_status &  US_CSR_RXRDY ))
  402fe6:	687b      	ldr	r3, [r7, #4]
  402fe8:	f003 0301 	and.w	r3, r3, #1
  402fec:	2b00      	cmp	r3, #0
  402fee:	d00f      	beq.n	403010 <FLEXCOM0_Handler+0x38>
	{
		uint8_t rxbyte;
		usart_serial_getchar(CONSOLE_UART, &rxbyte);
  402ff0:	1cfb      	adds	r3, r7, #3
  402ff2:	4619      	mov	r1, r3
  402ff4:	4808      	ldr	r0, [pc, #32]	; (403018 <FLEXCOM0_Handler+0x40>)
  402ff6:	4b0a      	ldr	r3, [pc, #40]	; (403020 <FLEXCOM0_Handler+0x48>)
  402ff8:	4798      	blx	r3
		if(!RingByteBuffer_isFull(&uart_rx_rb))
  402ffa:	480a      	ldr	r0, [pc, #40]	; (403024 <FLEXCOM0_Handler+0x4c>)
  402ffc:	4b0a      	ldr	r3, [pc, #40]	; (403028 <FLEXCOM0_Handler+0x50>)
  402ffe:	4798      	blx	r3
  403000:	4603      	mov	r3, r0
  403002:	2b00      	cmp	r3, #0
  403004:	d104      	bne.n	403010 <FLEXCOM0_Handler+0x38>
			RingByteBuffer_pushByte(&uart_rx_rb, rxbyte);
  403006:	78fb      	ldrb	r3, [r7, #3]
  403008:	4619      	mov	r1, r3
  40300a:	4806      	ldr	r0, [pc, #24]	; (403024 <FLEXCOM0_Handler+0x4c>)
  40300c:	4b07      	ldr	r3, [pc, #28]	; (40302c <FLEXCOM0_Handler+0x54>)
  40300e:	4798      	blx	r3
	}
}
  403010:	bf00      	nop
  403012:	3708      	adds	r7, #8
  403014:	46bd      	mov	sp, r7
  403016:	bd80      	pop	{r7, pc}
  403018:	4000c200 	.word	0x4000c200
  40301c:	00403589 	.word	0x00403589
  403020:	00402d1d 	.word	0x00402d1d
  403024:	20002068 	.word	0x20002068
  403028:	00402e97 	.word	0x00402e97
  40302c:	0040fdbd 	.word	0x0040fdbd

00403030 <i2c_master_initialize>:

#if SERIF_TYPE_I2C
twi_options_t opt;
twi_packet_t packet_tx, packet_rx;

static void i2c_master_initialize(void){
  403030:	b580      	push	{r7, lr}
  403032:	af00      	add	r7, sp, #0
	/* Insert application code here, after the board has been initialized. */
	/* Enable the peripheral and set TWI mode. */
	flexcom_enable(BOARD_FLEXCOM_TWI);
  403034:	480a      	ldr	r0, [pc, #40]	; (403060 <i2c_master_initialize+0x30>)
  403036:	4b0b      	ldr	r3, [pc, #44]	; (403064 <i2c_master_initialize+0x34>)
  403038:	4798      	blx	r3
	flexcom_set_opmode(BOARD_FLEXCOM_TWI, FLEXCOM_TWI);
  40303a:	2103      	movs	r1, #3
  40303c:	4808      	ldr	r0, [pc, #32]	; (403060 <i2c_master_initialize+0x30>)
  40303e:	4b0a      	ldr	r3, [pc, #40]	; (403068 <i2c_master_initialize+0x38>)
  403040:	4798      	blx	r3

	/* Configure the options of TWI driver */
	opt.master_clk = sysclk_get_peripheral_hz();
  403042:	4b0a      	ldr	r3, [pc, #40]	; (40306c <i2c_master_initialize+0x3c>)
  403044:	4798      	blx	r3
  403046:	4602      	mov	r2, r0
  403048:	4b09      	ldr	r3, [pc, #36]	; (403070 <i2c_master_initialize+0x40>)
  40304a:	601a      	str	r2, [r3, #0]
	opt.speed = TWI_CLK;
  40304c:	4b08      	ldr	r3, [pc, #32]	; (403070 <i2c_master_initialize+0x40>)
  40304e:	4a09      	ldr	r2, [pc, #36]	; (403074 <i2c_master_initialize+0x44>)
  403050:	605a      	str	r2, [r3, #4]

	twi_master_init(BOARD_BASE_TWI, &opt);
  403052:	4907      	ldr	r1, [pc, #28]	; (403070 <i2c_master_initialize+0x40>)
  403054:	4808      	ldr	r0, [pc, #32]	; (403078 <i2c_master_initialize+0x48>)
  403056:	4b09      	ldr	r3, [pc, #36]	; (40307c <i2c_master_initialize+0x4c>)
  403058:	4798      	blx	r3
}
  40305a:	bf00      	nop
  40305c:	bd80      	pop	{r7, pc}
  40305e:	bf00      	nop
  403060:	4001c000 	.word	0x4001c000
  403064:	00403749 	.word	0x00403749
  403068:	004038b1 	.word	0x004038b1
  40306c:	00402ac5 	.word	0x00402ac5
  403070:	2000203c 	.word	0x2000203c
  403074:	00061a80 	.word	0x00061a80
  403078:	4001c600 	.word	0x4001c600
  40307c:	004009ed 	.word	0x004009ed

00403080 <i2c_master_read_register>:

static unsigned long i2c_master_read_register(unsigned char Address, unsigned char RegisterAddr, unsigned short RegisterLen, unsigned char *RegisterValue){
  403080:	b580      	push	{r7, lr}
  403082:	b088      	sub	sp, #32
  403084:	af00      	add	r7, sp, #0
  403086:	603b      	str	r3, [r7, #0]
  403088:	4603      	mov	r3, r0
  40308a:	71fb      	strb	r3, [r7, #7]
  40308c:	460b      	mov	r3, r1
  40308e:	71bb      	strb	r3, [r7, #6]
  403090:	4613      	mov	r3, r2
  403092:	80bb      	strh	r3, [r7, #4]
	twi_packet_t packet_read;

	if(Address == 0){
  403094:	79fb      	ldrb	r3, [r7, #7]
  403096:	2b00      	cmp	r3, #0
  403098:	d102      	bne.n	4030a0 <i2c_master_read_register+0x20>
		Address = I2C_Address;	// Slave Address is 0x69 for on-board sensors, 0x68 for external sensors
  40309a:	4b0e      	ldr	r3, [pc, #56]	; (4030d4 <i2c_master_read_register+0x54>)
  40309c:	781b      	ldrb	r3, [r3, #0]
  40309e:	71fb      	strb	r3, [r7, #7]
	}

	packet_read.chip = Address;
  4030a0:	79fb      	ldrb	r3, [r7, #7]
  4030a2:	773b      	strb	r3, [r7, #28]
	packet_read.addr[0] = RegisterAddr;
  4030a4:	79bb      	ldrb	r3, [r7, #6]
  4030a6:	733b      	strb	r3, [r7, #12]
	packet_read.addr_length = 1;
  4030a8:	2301      	movs	r3, #1
  4030aa:	613b      	str	r3, [r7, #16]
	packet_read.buffer = RegisterValue;
  4030ac:	683b      	ldr	r3, [r7, #0]
  4030ae:	617b      	str	r3, [r7, #20]
	packet_read.length = RegisterLen;
  4030b0:	88bb      	ldrh	r3, [r7, #4]
  4030b2:	61bb      	str	r3, [r7, #24]

	if(twi_master_read((Twi*)BOARD_BASE_TWI, &packet_read) == TWI_SUCCESS){
  4030b4:	f107 030c 	add.w	r3, r7, #12
  4030b8:	4619      	mov	r1, r3
  4030ba:	4807      	ldr	r0, [pc, #28]	; (4030d8 <i2c_master_read_register+0x58>)
  4030bc:	4b07      	ldr	r3, [pc, #28]	; (4030dc <i2c_master_read_register+0x5c>)
  4030be:	4798      	blx	r3
  4030c0:	4603      	mov	r3, r0
  4030c2:	2b00      	cmp	r3, #0
  4030c4:	d101      	bne.n	4030ca <i2c_master_read_register+0x4a>
		return TWI_SUCCESS;
  4030c6:	2300      	movs	r3, #0
  4030c8:	e000      	b.n	4030cc <i2c_master_read_register+0x4c>
	}
	return TWI_BUSY;
  4030ca:	2308      	movs	r3, #8
}
  4030cc:	4618      	mov	r0, r3
  4030ce:	3720      	adds	r7, #32
  4030d0:	46bd      	mov	sp, r7
  4030d2:	bd80      	pop	{r7, pc}
  4030d4:	20000118 	.word	0x20000118
  4030d8:	4001c600 	.word	0x4001c600
  4030dc:	00400b1d 	.word	0x00400b1d

004030e0 <i2c_master_write_register>:

static unsigned long i2c_master_write_register(unsigned char Address, unsigned char RegisterAddr, unsigned short RegisterLen, const unsigned char *RegisterValue){
  4030e0:	b580      	push	{r7, lr}
  4030e2:	b088      	sub	sp, #32
  4030e4:	af00      	add	r7, sp, #0
  4030e6:	603b      	str	r3, [r7, #0]
  4030e8:	4603      	mov	r3, r0
  4030ea:	71fb      	strb	r3, [r7, #7]
  4030ec:	460b      	mov	r3, r1
  4030ee:	71bb      	strb	r3, [r7, #6]
  4030f0:	4613      	mov	r3, r2
  4030f2:	80bb      	strh	r3, [r7, #4]
	twi_packet_t packet_write;

	if(Address == 0){
  4030f4:	79fb      	ldrb	r3, [r7, #7]
  4030f6:	2b00      	cmp	r3, #0
  4030f8:	d102      	bne.n	403100 <i2c_master_write_register+0x20>
		Address = I2C_Address; // Slave Address is 0x69 for on-board sensors, 0x68 for external sensors
  4030fa:	4b0c      	ldr	r3, [pc, #48]	; (40312c <i2c_master_write_register+0x4c>)
  4030fc:	781b      	ldrb	r3, [r3, #0]
  4030fe:	71fb      	strb	r3, [r7, #7]
	}
	packet_write.chip = Address;
  403100:	79fb      	ldrb	r3, [r7, #7]
  403102:	773b      	strb	r3, [r7, #28]
	packet_write.addr[0] = RegisterAddr;
  403104:	79bb      	ldrb	r3, [r7, #6]
  403106:	733b      	strb	r3, [r7, #12]
	packet_write.addr_length = 1;
  403108:	2301      	movs	r3, #1
  40310a:	613b      	str	r3, [r7, #16]
	packet_write.buffer = (void *)RegisterValue;
  40310c:	683b      	ldr	r3, [r7, #0]
  40310e:	617b      	str	r3, [r7, #20]
	packet_write.length = RegisterLen;
  403110:	88bb      	ldrh	r3, [r7, #4]
  403112:	61bb      	str	r3, [r7, #24]

	return twi_master_write((Twi*)BOARD_BASE_TWI, &packet_write);
  403114:	f107 030c 	add.w	r3, r7, #12
  403118:	4619      	mov	r1, r3
  40311a:	4805      	ldr	r0, [pc, #20]	; (403130 <i2c_master_write_register+0x50>)
  40311c:	4b05      	ldr	r3, [pc, #20]	; (403134 <i2c_master_write_register+0x54>)
  40311e:	4798      	blx	r3
  403120:	4603      	mov	r3, r0
}
  403122:	4618      	mov	r0, r3
  403124:	3720      	adds	r7, #32
  403126:	46bd      	mov	sp, r7
  403128:	bd80      	pop	{r7, pc}
  40312a:	bf00      	nop
  40312c:	20000118 	.word	0x20000118
  403130:	4001c600 	.word	0x4001c600
  403134:	00400c29 	.word	0x00400c29

00403138 <interface_is_SPI>:

	return 0;
}
#endif

inv_bool_t interface_is_SPI(void){
  403138:	b480      	push	{r7}
  40313a:	af00      	add	r7, sp, #0
#if SERIF_TYPE_SPI
	return true;
#else
	return false;
  40313c:	2300      	movs	r3, #0
#endif	
}
  40313e:	4618      	mov	r0, r3
  403140:	46bd      	mov	sp, r7
  403142:	f85d 7b04 	ldr.w	r7, [sp], #4
  403146:	4770      	bx	lr

00403148 <interface_initialize>:
void interface_initialize(void){
  403148:	b580      	push	{r7, lr}
  40314a:	af00      	add	r7, sp, #0
#if SERIF_TYPE_SPI
	spi_master_initialize();
#endif

#if SERIF_TYPE_I2C
	i2c_master_initialize();
  40314c:	4b01      	ldr	r3, [pc, #4]	; (403154 <interface_initialize+0xc>)
  40314e:	4798      	blx	r3
#endif
}
  403150:	bf00      	nop
  403152:	bd80      	pop	{r7, pc}
  403154:	00403031 	.word	0x00403031

00403158 <switch_I2C_to_revA>:

void switch_I2C_to_revA(void){
  403158:	b480      	push	{r7}
  40315a:	af00      	add	r7, sp, #0
#if SERIF_TYPE_I2C
	I2C_Address = ICM_I2C_ADDR_REVA;
  40315c:	4b03      	ldr	r3, [pc, #12]	; (40316c <switch_I2C_to_revA+0x14>)
  40315e:	2268      	movs	r2, #104	; 0x68
  403160:	701a      	strb	r2, [r3, #0]
#endif	
}
  403162:	bf00      	nop
  403164:	46bd      	mov	sp, r7
  403166:	f85d 7b04 	ldr.w	r7, [sp], #4
  40316a:	4770      	bx	lr
  40316c:	20000118 	.word	0x20000118

00403170 <hw_timer_start>:

InvScheduler 	scheduler;

void hw_timer_start(uint32_t timer_freq){
  403170:	b590      	push	{r4, r7, lr}
  403172:	b089      	sub	sp, #36	; 0x24
  403174:	af02      	add	r7, sp, #8
  403176:	6078      	str	r0, [r7, #4]
	uint32_t counts;
	uint32_t ul_div;
	uint32_t ul_tcclks;
	uint32_t ul_sysclk = sysclk_get_cpu_hz();
  403178:	4b20      	ldr	r3, [pc, #128]	; (4031fc <hw_timer_start+0x8c>)
  40317a:	4798      	blx	r3
  40317c:	6178      	str	r0, [r7, #20]

	NVIC_DisableIRQ(TC0_IRQn);
  40317e:	2017      	movs	r0, #23
  403180:	4b1f      	ldr	r3, [pc, #124]	; (403200 <hw_timer_start+0x90>)
  403182:	4798      	blx	r3
	NVIC_ClearPendingIRQ(TC0_IRQn);
  403184:	2017      	movs	r0, #23
  403186:	4b1f      	ldr	r3, [pc, #124]	; (403204 <hw_timer_start+0x94>)
  403188:	4798      	blx	r3
	tc_find_mck_divisor((uint32_t)(timer_freq),		// The desired frequency as a uint32.
  40318a:	f107 0108 	add.w	r1, r7, #8
  40318e:	f107 020c 	add.w	r2, r7, #12
  403192:	697b      	ldr	r3, [r7, #20]
  403194:	9300      	str	r3, [sp, #0]
  403196:	460b      	mov	r3, r1
  403198:	6979      	ldr	r1, [r7, #20]
  40319a:	6878      	ldr	r0, [r7, #4]
  40319c:	4c1a      	ldr	r4, [pc, #104]	; (403208 <hw_timer_start+0x98>)
  40319e:	47a0      	blx	r4
		&ul_div,					// Pointer to register where divisor will be stored.
		&ul_tcclks,					// Pointer to reg where clock selection number is stored.
		ul_sysclk);					// Board clock freq in Hz.


	tc_init(TC0, 0, ul_tcclks | TC_CMR_CPCTRG);
  4031a0:	68bb      	ldr	r3, [r7, #8]
  4031a2:	f443 4380 	orr.w	r3, r3, #16384	; 0x4000
  4031a6:	461a      	mov	r2, r3
  4031a8:	2100      	movs	r1, #0
  4031aa:	4818      	ldr	r0, [pc, #96]	; (40320c <hw_timer_start+0x9c>)
  4031ac:	4b18      	ldr	r3, [pc, #96]	; (403210 <hw_timer_start+0xa0>)
  4031ae:	4798      	blx	r3

	/* Find the best estimate of counts, then write it to TC register C. */
	counts = (ul_sysclk/ul_div)/timer_freq;
  4031b0:	68fb      	ldr	r3, [r7, #12]
  4031b2:	697a      	ldr	r2, [r7, #20]
  4031b4:	fbb2 f2f3 	udiv	r2, r2, r3
  4031b8:	687b      	ldr	r3, [r7, #4]
  4031ba:	fbb2 f3f3 	udiv	r3, r2, r3
  4031be:	613b      	str	r3, [r7, #16]

	tc_write_rc(TC0, 0, counts);
  4031c0:	693a      	ldr	r2, [r7, #16]
  4031c2:	2100      	movs	r1, #0
  4031c4:	4811      	ldr	r0, [pc, #68]	; (40320c <hw_timer_start+0x9c>)
  4031c6:	4b13      	ldr	r3, [pc, #76]	; (403214 <hw_timer_start+0xa4>)
  4031c8:	4798      	blx	r3
	tc_get_status(TC0, 0);
  4031ca:	2100      	movs	r1, #0
  4031cc:	480f      	ldr	r0, [pc, #60]	; (40320c <hw_timer_start+0x9c>)
  4031ce:	4b12      	ldr	r3, [pc, #72]	; (403218 <hw_timer_start+0xa8>)
  4031d0:	4798      	blx	r3
	tc_enable_interrupt(TC0, 0, TC_IER_CPCS);
  4031d2:	2210      	movs	r2, #16
  4031d4:	2100      	movs	r1, #0
  4031d6:	480d      	ldr	r0, [pc, #52]	; (40320c <hw_timer_start+0x9c>)
  4031d8:	4b10      	ldr	r3, [pc, #64]	; (40321c <hw_timer_start+0xac>)
  4031da:	4798      	blx	r3
	tc_start(TC0, 0);
  4031dc:	2100      	movs	r1, #0
  4031de:	480b      	ldr	r0, [pc, #44]	; (40320c <hw_timer_start+0x9c>)
  4031e0:	4b0f      	ldr	r3, [pc, #60]	; (403220 <hw_timer_start+0xb0>)
  4031e2:	4798      	blx	r3
	NVIC_SetPriority(TC0_IRQn,0);
  4031e4:	2100      	movs	r1, #0
  4031e6:	2017      	movs	r0, #23
  4031e8:	4b0e      	ldr	r3, [pc, #56]	; (403224 <hw_timer_start+0xb4>)
  4031ea:	4798      	blx	r3
	NVIC_EnableIRQ(TC0_IRQn);
  4031ec:	2017      	movs	r0, #23
  4031ee:	4b0e      	ldr	r3, [pc, #56]	; (403228 <hw_timer_start+0xb8>)
  4031f0:	4798      	blx	r3
}
  4031f2:	bf00      	nop
  4031f4:	371c      	adds	r7, #28
  4031f6:	46bd      	mov	sp, r7
  4031f8:	bd90      	pop	{r4, r7, pc}
  4031fa:	bf00      	nop
  4031fc:	00402ab1 	.word	0x00402ab1
  403200:	00402965 	.word	0x00402965
  403204:	00402999 	.word	0x00402999
  403208:	0040091f 	.word	0x0040091f
  40320c:	40010000 	.word	0x40010000
  403210:	004007e9 	.word	0x004007e9
  403214:	00400889 	.word	0x00400889
  403218:	004008fb 	.word	0x004008fb
  40321c:	004008af 	.word	0x004008af
  403220:	00400823 	.word	0x00400823
  403224:	004029cd 	.word	0x004029cd
  403228:	00402931 	.word	0x00402931

0040322c <InvEMDFrontEnd_getTimestampUs>:
	NVIC_ClearPendingIRQ(TC0_IRQn);
}

static uint32_t Num50msTicks = 0;				// The timestamp timer ticks over every 50 ms.

uint64_t InvEMDFrontEnd_getTimestampUs(void){
  40322c:	b5f0      	push	{r4, r5, r6, r7, lr}
  40322e:	b085      	sub	sp, #20
  403230:	af00      	add	r7, sp, #0
	uint32_t timer_counter_value = tc_read_cv(TC0, 0);		// Read the timer counter
  403232:	2100      	movs	r1, #0
  403234:	481f      	ldr	r0, [pc, #124]	; (4032b4 <InvEMDFrontEnd_getTimestampUs+0x88>)
  403236:	4b20      	ldr	r3, [pc, #128]	; (4032b8 <InvEMDFrontEnd_getTimestampUs+0x8c>)
  403238:	4798      	blx	r3
  40323a:	60f8      	str	r0, [r7, #12]
	uint32_t max_counter_value = tc_read_rc(TC0, 0);		// read the timer limit
  40323c:	2100      	movs	r1, #0
  40323e:	481d      	ldr	r0, [pc, #116]	; (4032b4 <InvEMDFrontEnd_getTimestampUs+0x88>)
  403240:	4b1e      	ldr	r3, [pc, #120]	; (4032bc <InvEMDFrontEnd_getTimestampUs+0x90>)
  403242:	4798      	blx	r3
  403244:	60b8      	str	r0, [r7, #8]

	// In order to get a micro-second timestamp, we track the number of 50 ms intervals since startup or rollover.
	// This value is multiplied by the number of microseconds in 50 ms, and then add the number of microseconds since
	// the last 50 ms tick.
	// timer_counter_value / max_counter_value is the fraction of the current 50 ms interval that has already expired.
	return ((uint64_t)Num50msTicks * MICROSECONDS_PER_50ms) + (((uint64_t)timer_counter_value * MICROSECONDS_PER_50ms) / max_counter_value);
  403246:	4b1e      	ldr	r3, [pc, #120]	; (4032c0 <InvEMDFrontEnd_getTimestampUs+0x94>)
  403248:	681b      	ldr	r3, [r3, #0]
  40324a:	f04f 0400 	mov.w	r4, #0
  40324e:	f24c 3250 	movw	r2, #50000	; 0xc350
  403252:	fb02 f104 	mul.w	r1, r2, r4
  403256:	2200      	movs	r2, #0
  403258:	fb02 f203 	mul.w	r2, r2, r3
  40325c:	440a      	add	r2, r1
  40325e:	f24c 3150 	movw	r1, #50000	; 0xc350
  403262:	fba3 5601 	umull	r5, r6, r3, r1
  403266:	1993      	adds	r3, r2, r6
  403268:	461e      	mov	r6, r3
  40326a:	68fb      	ldr	r3, [r7, #12]
  40326c:	f04f 0400 	mov.w	r4, #0
  403270:	f24c 3250 	movw	r2, #50000	; 0xc350
  403274:	fb02 f104 	mul.w	r1, r2, r4
  403278:	2200      	movs	r2, #0
  40327a:	fb02 f203 	mul.w	r2, r2, r3
  40327e:	440a      	add	r2, r1
  403280:	f24c 3150 	movw	r1, #50000	; 0xc350
  403284:	fba3 0101 	umull	r0, r1, r3, r1
  403288:	1853      	adds	r3, r2, r1
  40328a:	4619      	mov	r1, r3
  40328c:	68bb      	ldr	r3, [r7, #8]
  40328e:	f04f 0400 	mov.w	r4, #0
  403292:	4a0c      	ldr	r2, [pc, #48]	; (4032c4 <InvEMDFrontEnd_getTimestampUs+0x98>)
  403294:	607a      	str	r2, [r7, #4]
  403296:	461a      	mov	r2, r3
  403298:	4623      	mov	r3, r4
  40329a:	687c      	ldr	r4, [r7, #4]
  40329c:	47a0      	blx	r4
  40329e:	4603      	mov	r3, r0
  4032a0:	460c      	mov	r4, r1
  4032a2:	195b      	adds	r3, r3, r5
  4032a4:	eb44 0406 	adc.w	r4, r4, r6
}
  4032a8:	4618      	mov	r0, r3
  4032aa:	4621      	mov	r1, r4
  4032ac:	3714      	adds	r7, #20
  4032ae:	46bd      	mov	sp, r7
  4032b0:	bdf0      	pop	{r4, r5, r6, r7, pc}
  4032b2:	bf00      	nop
  4032b4:	40010000 	.word	0x40010000
  4032b8:	00400845 	.word	0x00400845
  4032bc:	00400867 	.word	0x00400867
  4032c0:	20001424 	.word	0x20001424
  4032c4:	00413c79 	.word	0x00413c79

004032c8 <TC0_Handler>:

void TC0_Handler(void){
  4032c8:	b580      	push	{r7, lr}
  4032ca:	b082      	sub	sp, #8
  4032cc:	af00      	add	r7, sp, #0
	uint32_t ul_status;

	ul_status = tc_get_status(TC0, 0);
  4032ce:	2100      	movs	r1, #0
  4032d0:	480c      	ldr	r0, [pc, #48]	; (403304 <TC0_Handler+0x3c>)
  4032d2:	4b0d      	ldr	r3, [pc, #52]	; (403308 <TC0_Handler+0x40>)
  4032d4:	4798      	blx	r3
  4032d6:	6078      	str	r0, [r7, #4]
	ul_status &= tc_get_interrupt_mask(TC0, 0);
  4032d8:	2100      	movs	r1, #0
  4032da:	480a      	ldr	r0, [pc, #40]	; (403304 <TC0_Handler+0x3c>)
  4032dc:	4b0b      	ldr	r3, [pc, #44]	; (40330c <TC0_Handler+0x44>)
  4032de:	4798      	blx	r3
  4032e0:	4602      	mov	r2, r0
  4032e2:	687b      	ldr	r3, [r7, #4]
  4032e4:	4013      	ands	r3, r2
  4032e6:	607b      	str	r3, [r7, #4]

	if (ul_status & TC_SR_CPCS)
  4032e8:	687b      	ldr	r3, [r7, #4]
  4032ea:	f003 0310 	and.w	r3, r3, #16
  4032ee:	2b00      	cmp	r3, #0
  4032f0:	d004      	beq.n	4032fc <TC0_Handler+0x34>
		Num50msTicks++;
  4032f2:	4b07      	ldr	r3, [pc, #28]	; (403310 <TC0_Handler+0x48>)
  4032f4:	681b      	ldr	r3, [r3, #0]
  4032f6:	3301      	adds	r3, #1
  4032f8:	4a05      	ldr	r2, [pc, #20]	; (403310 <TC0_Handler+0x48>)
  4032fa:	6013      	str	r3, [r2, #0]
}
  4032fc:	bf00      	nop
  4032fe:	3708      	adds	r7, #8
  403300:	46bd      	mov	sp, r7
  403302:	bd80      	pop	{r7, pc}
  403304:	40010000 	.word	0x40010000
  403308:	004008fb 	.word	0x004008fb
  40330c:	004008d7 	.word	0x004008d7
  403310:	20001424 	.word	0x20001424

00403314 <SysTick_Handler>:

volatile uint32_t ul_ticks = 0;

void SysTick_Handler(void){
  403314:	b580      	push	{r7, lr}
  403316:	af00      	add	r7, sp, #0
	ul_ticks++;
  403318:	4b04      	ldr	r3, [pc, #16]	; (40332c <SysTick_Handler+0x18>)
  40331a:	681b      	ldr	r3, [r3, #0]
  40331c:	3301      	adds	r3, #1
  40331e:	4a03      	ldr	r2, [pc, #12]	; (40332c <SysTick_Handler+0x18>)
  403320:	6013      	str	r3, [r2, #0]
	InvScheduler_updateTime(&scheduler);
  403322:	4803      	ldr	r0, [pc, #12]	; (403330 <SysTick_Handler+0x1c>)
  403324:	4b03      	ldr	r3, [pc, #12]	; (403334 <SysTick_Handler+0x20>)
  403326:	4798      	blx	r3
}
  403328:	bf00      	nop
  40332a:	bd80      	pop	{r7, pc}
  40332c:	20001428 	.word	0x20001428
  403330:	20002048 	.word	0x20002048
  403334:	00402e79 	.word	0x00402e79

00403338 <idd_io_hal_read_reg>:

int idd_io_hal_read_reg(void * context, uint8_t reg, uint8_t * rbuffer, uint32_t rlen){
  403338:	b590      	push	{r4, r7, lr}
  40333a:	b085      	sub	sp, #20
  40333c:	af00      	add	r7, sp, #0
  40333e:	60f8      	str	r0, [r7, #12]
  403340:	607a      	str	r2, [r7, #4]
  403342:	603b      	str	r3, [r7, #0]
  403344:	460b      	mov	r3, r1
  403346:	72fb      	strb	r3, [r7, #11]
	(void)context;
#if SERIF_TYPE_SPI
	return spi_master_transfer_rx(NULL, reg, rbuffer, rlen);
#else /* SERIF_TYPE_I2C */
	return i2c_master_read_register(I2C_Address, reg, rlen, rbuffer);
  403348:	4b06      	ldr	r3, [pc, #24]	; (403364 <idd_io_hal_read_reg+0x2c>)
  40334a:	7818      	ldrb	r0, [r3, #0]
  40334c:	683b      	ldr	r3, [r7, #0]
  40334e:	b29a      	uxth	r2, r3
  403350:	7af9      	ldrb	r1, [r7, #11]
  403352:	687b      	ldr	r3, [r7, #4]
  403354:	4c04      	ldr	r4, [pc, #16]	; (403368 <idd_io_hal_read_reg+0x30>)
  403356:	47a0      	blx	r4
  403358:	4603      	mov	r3, r0
#endif	
}
  40335a:	4618      	mov	r0, r3
  40335c:	3714      	adds	r7, #20
  40335e:	46bd      	mov	sp, r7
  403360:	bd90      	pop	{r4, r7, pc}
  403362:	bf00      	nop
  403364:	20000118 	.word	0x20000118
  403368:	00403081 	.word	0x00403081

0040336c <idd_io_hal_write_reg>:

int idd_io_hal_write_reg(void * context, uint8_t reg, const uint8_t * wbuffer, uint32_t wlen){
  40336c:	b590      	push	{r4, r7, lr}
  40336e:	b085      	sub	sp, #20
  403370:	af00      	add	r7, sp, #0
  403372:	60f8      	str	r0, [r7, #12]
  403374:	607a      	str	r2, [r7, #4]
  403376:	603b      	str	r3, [r7, #0]
  403378:	460b      	mov	r3, r1
  40337a:	72fb      	strb	r3, [r7, #11]
	(void)context;
#if SERIF_TYPE_SPI
	return spi_master_transfer_tx(NULL, reg, wbuffer, wlen);
#else /* SERIF_TYPE_I2C */
	return i2c_master_write_register(I2C_Address, reg, wlen, wbuffer);
  40337c:	4b06      	ldr	r3, [pc, #24]	; (403398 <idd_io_hal_write_reg+0x2c>)
  40337e:	7818      	ldrb	r0, [r3, #0]
  403380:	683b      	ldr	r3, [r7, #0]
  403382:	b29a      	uxth	r2, r3
  403384:	7af9      	ldrb	r1, [r7, #11]
  403386:	687b      	ldr	r3, [r7, #4]
  403388:	4c04      	ldr	r4, [pc, #16]	; (40339c <idd_io_hal_write_reg+0x30>)
  40338a:	47a0      	blx	r4
  40338c:	4603      	mov	r3, r0
#endif	
}
  40338e:	4618      	mov	r0, r3
  403390:	3714      	adds	r7, #20
  403392:	46bd      	mov	sp, r7
  403394:	bd90      	pop	{r4, r7, pc}
  403396:	bf00      	nop
  403398:	20000118 	.word	0x20000118
  40339c:	004030e1 	.word	0x004030e1

004033a0 <usart_set_async_baudrate>:
 * \retval 1 Baud rate set point is out of range for the given input clock
 * frequency.
 */
uint32_t usart_set_async_baudrate(Usart *p_usart,
		uint32_t baudrate, uint32_t ul_mck)
{
  4033a0:	b480      	push	{r7}
  4033a2:	b089      	sub	sp, #36	; 0x24
  4033a4:	af00      	add	r7, sp, #0
  4033a6:	60f8      	str	r0, [r7, #12]
  4033a8:	60b9      	str	r1, [r7, #8]
  4033aa:	607a      	str	r2, [r7, #4]
	uint32_t cd_fp;
	uint32_t cd;
	uint32_t fp;

	/* Calculate the receiver sampling divide of baudrate clock. */
	if (ul_mck >= HIGH_FRQ_SAMPLE_DIV * baudrate) {
  4033ac:	68bb      	ldr	r3, [r7, #8]
  4033ae:	011a      	lsls	r2, r3, #4
  4033b0:	687b      	ldr	r3, [r7, #4]
  4033b2:	429a      	cmp	r2, r3
  4033b4:	d802      	bhi.n	4033bc <usart_set_async_baudrate+0x1c>
		over = HIGH_FRQ_SAMPLE_DIV;
  4033b6:	2310      	movs	r3, #16
  4033b8:	61fb      	str	r3, [r7, #28]
  4033ba:	e001      	b.n	4033c0 <usart_set_async_baudrate+0x20>
	} else {
		over = LOW_FRQ_SAMPLE_DIV;
  4033bc:	2308      	movs	r3, #8
  4033be:	61fb      	str	r3, [r7, #28]
	}

	/* Calculate clock divider according to the fraction calculated formula. */
	cd_fp = (8 * ul_mck + (over * baudrate) / 2) / (over * baudrate);
  4033c0:	687b      	ldr	r3, [r7, #4]
  4033c2:	00da      	lsls	r2, r3, #3
  4033c4:	69fb      	ldr	r3, [r7, #28]
  4033c6:	68b9      	ldr	r1, [r7, #8]
  4033c8:	fb01 f303 	mul.w	r3, r1, r3
  4033cc:	085b      	lsrs	r3, r3, #1
  4033ce:	441a      	add	r2, r3
  4033d0:	69fb      	ldr	r3, [r7, #28]
  4033d2:	68b9      	ldr	r1, [r7, #8]
  4033d4:	fb01 f303 	mul.w	r3, r1, r3
  4033d8:	fbb2 f3f3 	udiv	r3, r2, r3
  4033dc:	61bb      	str	r3, [r7, #24]
	cd = cd_fp >> 3;
  4033de:	69bb      	ldr	r3, [r7, #24]
  4033e0:	08db      	lsrs	r3, r3, #3
  4033e2:	617b      	str	r3, [r7, #20]
	fp = cd_fp & 0x07;
  4033e4:	69bb      	ldr	r3, [r7, #24]
  4033e6:	f003 0307 	and.w	r3, r3, #7
  4033ea:	613b      	str	r3, [r7, #16]
	if (cd < MIN_CD_VALUE || cd > MAX_CD_VALUE) {
  4033ec:	697b      	ldr	r3, [r7, #20]
  4033ee:	2b00      	cmp	r3, #0
  4033f0:	d003      	beq.n	4033fa <usart_set_async_baudrate+0x5a>
  4033f2:	697b      	ldr	r3, [r7, #20]
  4033f4:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
  4033f8:	d301      	bcc.n	4033fe <usart_set_async_baudrate+0x5e>
		return 1;
  4033fa:	2301      	movs	r3, #1
  4033fc:	e00f      	b.n	40341e <usart_set_async_baudrate+0x7e>
	}

	/* Configure the OVER bit in MR register. */
	if (over == 8) {
  4033fe:	69fb      	ldr	r3, [r7, #28]
  403400:	2b08      	cmp	r3, #8
  403402:	d105      	bne.n	403410 <usart_set_async_baudrate+0x70>
		p_usart->US_MR |= US_MR_OVER;
  403404:	68fb      	ldr	r3, [r7, #12]
  403406:	685b      	ldr	r3, [r3, #4]
  403408:	f443 2200 	orr.w	r2, r3, #524288	; 0x80000
  40340c:	68fb      	ldr	r3, [r7, #12]
  40340e:	605a      	str	r2, [r3, #4]
	}

	/* Configure the baudrate generate register. */
	p_usart->US_BRGR = (cd << US_BRGR_CD_Pos) | (fp << US_BRGR_FP_Pos);
  403410:	693b      	ldr	r3, [r7, #16]
  403412:	041a      	lsls	r2, r3, #16
  403414:	697b      	ldr	r3, [r7, #20]
  403416:	431a      	orrs	r2, r3
  403418:	68fb      	ldr	r3, [r7, #12]
  40341a:	621a      	str	r2, [r3, #32]

	return 0;
  40341c:	2300      	movs	r3, #0
}
  40341e:	4618      	mov	r0, r3
  403420:	3724      	adds	r7, #36	; 0x24
  403422:	46bd      	mov	sp, r7
  403424:	f85d 7b04 	ldr.w	r7, [sp], #4
  403428:	4770      	bx	lr
	...

0040342c <usart_reset>:
 * \brief Reset the USART and disable TX and RX.
 *
 * \param p_usart Pointer to a USART instance.
 */
void usart_reset(Usart *p_usart)
{
  40342c:	b580      	push	{r7, lr}
  40342e:	b082      	sub	sp, #8
  403430:	af00      	add	r7, sp, #0
  403432:	6078      	str	r0, [r7, #4]
	/* Disable the Write Protect. */
	usart_disable_writeprotect(p_usart);
  403434:	6878      	ldr	r0, [r7, #4]
  403436:	4b0d      	ldr	r3, [pc, #52]	; (40346c <usart_reset+0x40>)
  403438:	4798      	blx	r3

	/* Reset registers that could cause unpredictable behavior after reset. */
	p_usart->US_MR = 0;
  40343a:	687b      	ldr	r3, [r7, #4]
  40343c:	2200      	movs	r2, #0
  40343e:	605a      	str	r2, [r3, #4]
	p_usart->US_RTOR = 0;
  403440:	687b      	ldr	r3, [r7, #4]
  403442:	2200      	movs	r2, #0
  403444:	625a      	str	r2, [r3, #36]	; 0x24
	p_usart->US_TTGR = 0;
  403446:	687b      	ldr	r3, [r7, #4]
  403448:	2200      	movs	r2, #0
  40344a:	629a      	str	r2, [r3, #40]	; 0x28

	/* Disable TX and RX. */
	usart_reset_tx(p_usart);
  40344c:	6878      	ldr	r0, [r7, #4]
  40344e:	4b08      	ldr	r3, [pc, #32]	; (403470 <usart_reset+0x44>)
  403450:	4798      	blx	r3
	usart_reset_rx(p_usart);
  403452:	6878      	ldr	r0, [r7, #4]
  403454:	4b07      	ldr	r3, [pc, #28]	; (403474 <usart_reset+0x48>)
  403456:	4798      	blx	r3
	/* Reset status bits. */
	usart_reset_status(p_usart);
  403458:	6878      	ldr	r0, [r7, #4]
  40345a:	4b07      	ldr	r3, [pc, #28]	; (403478 <usart_reset+0x4c>)
  40345c:	4798      	blx	r3
	/* Turn off RTS and DTR if exist. */
	usart_drive_RTS_pin_high(p_usart);
  40345e:	6878      	ldr	r0, [r7, #4]
  403460:	4b06      	ldr	r3, [pc, #24]	; (40347c <usart_reset+0x50>)
  403462:	4798      	blx	r3
#if (SAM3S || SAM4S || SAM3U || SAM4L || SAM4E)
	usart_drive_DTR_pin_high(p_usart);
#endif
}
  403464:	bf00      	nop
  403466:	3708      	adds	r7, #8
  403468:	46bd      	mov	sp, r7
  40346a:	bd80      	pop	{r7, pc}
  40346c:	00403641 	.word	0x00403641
  403470:	0040351f 	.word	0x0040351f
  403474:	00403553 	.word	0x00403553
  403478:	004035a1 	.word	0x004035a1
  40347c:	004035bd 	.word	0x004035bd

00403480 <usart_init_rs232>:
 * \retval 0 on success.
 * \retval 1 on failure.
 */
uint32_t usart_init_rs232(Usart *p_usart,
		const sam_usart_opt_t *p_usart_opt, uint32_t ul_mck)
{
  403480:	b580      	push	{r7, lr}
  403482:	b084      	sub	sp, #16
  403484:	af00      	add	r7, sp, #0
  403486:	60f8      	str	r0, [r7, #12]
  403488:	60b9      	str	r1, [r7, #8]
  40348a:	607a      	str	r2, [r7, #4]
	static uint32_t ul_reg_val;

	/* Reset the USART and shut down TX and RX. */
	usart_reset(p_usart);
  40348c:	68f8      	ldr	r0, [r7, #12]
  40348e:	4b1a      	ldr	r3, [pc, #104]	; (4034f8 <usart_init_rs232+0x78>)
  403490:	4798      	blx	r3

	ul_reg_val = 0;
  403492:	4b1a      	ldr	r3, [pc, #104]	; (4034fc <usart_init_rs232+0x7c>)
  403494:	2200      	movs	r2, #0
  403496:	601a      	str	r2, [r3, #0]
	/* Check whether the input values are legal. */
	if (!p_usart_opt || usart_set_async_baudrate(p_usart,
  403498:	68bb      	ldr	r3, [r7, #8]
  40349a:	2b00      	cmp	r3, #0
  40349c:	d009      	beq.n	4034b2 <usart_init_rs232+0x32>
  40349e:	68bb      	ldr	r3, [r7, #8]
  4034a0:	681b      	ldr	r3, [r3, #0]
  4034a2:	687a      	ldr	r2, [r7, #4]
  4034a4:	4619      	mov	r1, r3
  4034a6:	68f8      	ldr	r0, [r7, #12]
  4034a8:	4b15      	ldr	r3, [pc, #84]	; (403500 <usart_init_rs232+0x80>)
  4034aa:	4798      	blx	r3
  4034ac:	4603      	mov	r3, r0
  4034ae:	2b00      	cmp	r3, #0
  4034b0:	d001      	beq.n	4034b6 <usart_init_rs232+0x36>
			p_usart_opt->baudrate, ul_mck)) {
		return 1;
  4034b2:	2301      	movs	r3, #1
  4034b4:	e01b      	b.n	4034ee <usart_init_rs232+0x6e>
	}

	/* Configure the USART option. */
	ul_reg_val |= p_usart_opt->char_length | p_usart_opt->parity_type |
  4034b6:	68bb      	ldr	r3, [r7, #8]
  4034b8:	685a      	ldr	r2, [r3, #4]
  4034ba:	68bb      	ldr	r3, [r7, #8]
  4034bc:	689b      	ldr	r3, [r3, #8]
  4034be:	431a      	orrs	r2, r3
			p_usart_opt->channel_mode | p_usart_opt->stop_bits;
  4034c0:	68bb      	ldr	r3, [r7, #8]
  4034c2:	691b      	ldr	r3, [r3, #16]
	ul_reg_val |= p_usart_opt->char_length | p_usart_opt->parity_type |
  4034c4:	431a      	orrs	r2, r3
			p_usart_opt->channel_mode | p_usart_opt->stop_bits;
  4034c6:	68bb      	ldr	r3, [r7, #8]
  4034c8:	68db      	ldr	r3, [r3, #12]
  4034ca:	431a      	orrs	r2, r3
	ul_reg_val |= p_usart_opt->char_length | p_usart_opt->parity_type |
  4034cc:	4b0b      	ldr	r3, [pc, #44]	; (4034fc <usart_init_rs232+0x7c>)
  4034ce:	681b      	ldr	r3, [r3, #0]
  4034d0:	4313      	orrs	r3, r2
  4034d2:	4a0a      	ldr	r2, [pc, #40]	; (4034fc <usart_init_rs232+0x7c>)
  4034d4:	6013      	str	r3, [r2, #0]

	/* Configure the USART mode as normal mode. */
	ul_reg_val |= US_MR_USART_MODE_NORMAL;
  4034d6:	4b09      	ldr	r3, [pc, #36]	; (4034fc <usart_init_rs232+0x7c>)
  4034d8:	681b      	ldr	r3, [r3, #0]
  4034da:	4a08      	ldr	r2, [pc, #32]	; (4034fc <usart_init_rs232+0x7c>)
  4034dc:	6013      	str	r3, [r2, #0]

	p_usart->US_MR |= ul_reg_val;
  4034de:	68fb      	ldr	r3, [r7, #12]
  4034e0:	685a      	ldr	r2, [r3, #4]
  4034e2:	4b06      	ldr	r3, [pc, #24]	; (4034fc <usart_init_rs232+0x7c>)
  4034e4:	681b      	ldr	r3, [r3, #0]
  4034e6:	431a      	orrs	r2, r3
  4034e8:	68fb      	ldr	r3, [r7, #12]
  4034ea:	605a      	str	r2, [r3, #4]

	return 0;
  4034ec:	2300      	movs	r3, #0
}
  4034ee:	4618      	mov	r0, r3
  4034f0:	3710      	adds	r7, #16
  4034f2:	46bd      	mov	sp, r7
  4034f4:	bd80      	pop	{r7, pc}
  4034f6:	bf00      	nop
  4034f8:	0040342d 	.word	0x0040342d
  4034fc:	2000142c 	.word	0x2000142c
  403500:	004033a1 	.word	0x004033a1

00403504 <usart_enable_tx>:
 * \brief Enable USART transmitter.
 *
 * \param p_usart Pointer to a USART instance.
 */
void usart_enable_tx(Usart *p_usart)
{
  403504:	b480      	push	{r7}
  403506:	b083      	sub	sp, #12
  403508:	af00      	add	r7, sp, #0
  40350a:	6078      	str	r0, [r7, #4]
	p_usart->US_CR = US_CR_TXEN;
  40350c:	687b      	ldr	r3, [r7, #4]
  40350e:	2240      	movs	r2, #64	; 0x40
  403510:	601a      	str	r2, [r3, #0]
}
  403512:	bf00      	nop
  403514:	370c      	adds	r7, #12
  403516:	46bd      	mov	sp, r7
  403518:	f85d 7b04 	ldr.w	r7, [sp], #4
  40351c:	4770      	bx	lr

0040351e <usart_reset_tx>:
 * \brief Immediately stop and disable USART transmitter.
 *
 * \param p_usart Pointer to a USART instance.
 */
void usart_reset_tx(Usart *p_usart)
{
  40351e:	b480      	push	{r7}
  403520:	b083      	sub	sp, #12
  403522:	af00      	add	r7, sp, #0
  403524:	6078      	str	r0, [r7, #4]
	/* Reset transmitter */
	p_usart->US_CR = US_CR_RSTTX | US_CR_TXDIS;
  403526:	687b      	ldr	r3, [r7, #4]
  403528:	2288      	movs	r2, #136	; 0x88
  40352a:	601a      	str	r2, [r3, #0]
}
  40352c:	bf00      	nop
  40352e:	370c      	adds	r7, #12
  403530:	46bd      	mov	sp, r7
  403532:	f85d 7b04 	ldr.w	r7, [sp], #4
  403536:	4770      	bx	lr

00403538 <usart_enable_rx>:
 * \brief Enable USART receiver.
 *
 * \param p_usart Pointer to a USART instance.
 */
void usart_enable_rx(Usart *p_usart)
{
  403538:	b480      	push	{r7}
  40353a:	b083      	sub	sp, #12
  40353c:	af00      	add	r7, sp, #0
  40353e:	6078      	str	r0, [r7, #4]
	p_usart->US_CR = US_CR_RXEN;
  403540:	687b      	ldr	r3, [r7, #4]
  403542:	2210      	movs	r2, #16
  403544:	601a      	str	r2, [r3, #0]
}
  403546:	bf00      	nop
  403548:	370c      	adds	r7, #12
  40354a:	46bd      	mov	sp, r7
  40354c:	f85d 7b04 	ldr.w	r7, [sp], #4
  403550:	4770      	bx	lr

00403552 <usart_reset_rx>:
 * \brief Immediately stop and disable USART receiver.
 *
 * \param p_usart Pointer to a USART instance.
 */
void usart_reset_rx(Usart *p_usart)
{
  403552:	b480      	push	{r7}
  403554:	b083      	sub	sp, #12
  403556:	af00      	add	r7, sp, #0
  403558:	6078      	str	r0, [r7, #4]
	/* Reset Receiver */
	p_usart->US_CR = US_CR_RSTRX | US_CR_RXDIS;
  40355a:	687b      	ldr	r3, [r7, #4]
  40355c:	2224      	movs	r2, #36	; 0x24
  40355e:	601a      	str	r2, [r3, #0]
}
  403560:	bf00      	nop
  403562:	370c      	adds	r7, #12
  403564:	46bd      	mov	sp, r7
  403566:	f85d 7b04 	ldr.w	r7, [sp], #4
  40356a:	4770      	bx	lr

0040356c <usart_enable_interrupt>:
 *
 * \param p_usart Pointer to a USART peripheral.
 * \param ul_sources Interrupt sources bit map.
 */
void usart_enable_interrupt(Usart *p_usart, uint32_t ul_sources)
{
  40356c:	b480      	push	{r7}
  40356e:	b083      	sub	sp, #12
  403570:	af00      	add	r7, sp, #0
  403572:	6078      	str	r0, [r7, #4]
  403574:	6039      	str	r1, [r7, #0]
	p_usart->US_IER = ul_sources;
  403576:	687b      	ldr	r3, [r7, #4]
  403578:	683a      	ldr	r2, [r7, #0]
  40357a:	609a      	str	r2, [r3, #8]
}
  40357c:	bf00      	nop
  40357e:	370c      	adds	r7, #12
  403580:	46bd      	mov	sp, r7
  403582:	f85d 7b04 	ldr.w	r7, [sp], #4
  403586:	4770      	bx	lr

00403588 <usart_get_status>:
 * \param p_usart Pointer to a USART instance.
 *
 * \return The current USART status.
 */
uint32_t usart_get_status(Usart *p_usart)
{
  403588:	b480      	push	{r7}
  40358a:	b083      	sub	sp, #12
  40358c:	af00      	add	r7, sp, #0
  40358e:	6078      	str	r0, [r7, #4]
	return p_usart->US_CSR;
  403590:	687b      	ldr	r3, [r7, #4]
  403592:	695b      	ldr	r3, [r3, #20]
}
  403594:	4618      	mov	r0, r3
  403596:	370c      	adds	r7, #12
  403598:	46bd      	mov	sp, r7
  40359a:	f85d 7b04 	ldr.w	r7, [sp], #4
  40359e:	4770      	bx	lr

004035a0 <usart_reset_status>:
 * \brief Reset status bits (PARE, OVER, MANERR, UNRE and PXBRK in US_CSR).
 *
 * \param p_usart Pointer to a USART instance.
 */
void usart_reset_status(Usart *p_usart)
{
  4035a0:	b480      	push	{r7}
  4035a2:	b083      	sub	sp, #12
  4035a4:	af00      	add	r7, sp, #0
  4035a6:	6078      	str	r0, [r7, #4]
	p_usart->US_CR = US_CR_RSTSTA;
  4035a8:	687b      	ldr	r3, [r7, #4]
  4035aa:	f44f 7280 	mov.w	r2, #256	; 0x100
  4035ae:	601a      	str	r2, [r3, #0]
}
  4035b0:	bf00      	nop
  4035b2:	370c      	adds	r7, #12
  4035b4:	46bd      	mov	sp, r7
  4035b6:	f85d 7b04 	ldr.w	r7, [sp], #4
  4035ba:	4770      	bx	lr

004035bc <usart_drive_RTS_pin_high>:
 * \brief Drive the pin RTS to 1.
 *
 * \param p_usart Pointer to a USART instance.
 */
void usart_drive_RTS_pin_high(Usart *p_usart)
{
  4035bc:	b480      	push	{r7}
  4035be:	b083      	sub	sp, #12
  4035c0:	af00      	add	r7, sp, #0
  4035c2:	6078      	str	r0, [r7, #4]
	p_usart->US_CR = US_CR_RTSDIS;
  4035c4:	687b      	ldr	r3, [r7, #4]
  4035c6:	f44f 2200 	mov.w	r2, #524288	; 0x80000
  4035ca:	601a      	str	r2, [r3, #0]
}
  4035cc:	bf00      	nop
  4035ce:	370c      	adds	r7, #12
  4035d0:	46bd      	mov	sp, r7
  4035d2:	f85d 7b04 	ldr.w	r7, [sp], #4
  4035d6:	4770      	bx	lr

004035d8 <usart_write>:
 *
 * \retval 0 on success.
 * \retval 1 on failure.
 */
uint32_t usart_write(Usart *p_usart, uint32_t c)
{
  4035d8:	b480      	push	{r7}
  4035da:	b083      	sub	sp, #12
  4035dc:	af00      	add	r7, sp, #0
  4035de:	6078      	str	r0, [r7, #4]
  4035e0:	6039      	str	r1, [r7, #0]
	if (!(p_usart->US_CSR & US_CSR_TXRDY)) {
  4035e2:	687b      	ldr	r3, [r7, #4]
  4035e4:	695b      	ldr	r3, [r3, #20]
  4035e6:	f003 0302 	and.w	r3, r3, #2
  4035ea:	2b00      	cmp	r3, #0
  4035ec:	d101      	bne.n	4035f2 <usart_write+0x1a>
		return 1;
  4035ee:	2301      	movs	r3, #1
  4035f0:	e005      	b.n	4035fe <usart_write+0x26>
	}

	p_usart->US_THR = US_THR_TXCHR(c);
  4035f2:	683b      	ldr	r3, [r7, #0]
  4035f4:	f3c3 0208 	ubfx	r2, r3, #0, #9
  4035f8:	687b      	ldr	r3, [r7, #4]
  4035fa:	61da      	str	r2, [r3, #28]
	return 0;
  4035fc:	2300      	movs	r3, #0
}
  4035fe:	4618      	mov	r0, r3
  403600:	370c      	adds	r7, #12
  403602:	46bd      	mov	sp, r7
  403604:	f85d 7b04 	ldr.w	r7, [sp], #4
  403608:	4770      	bx	lr

0040360a <usart_read>:
 *
 * \retval 0 on success.
 * \retval 1 if no data is available or errors.
 */
uint32_t usart_read(Usart *p_usart, uint32_t *c)
{
  40360a:	b480      	push	{r7}
  40360c:	b083      	sub	sp, #12
  40360e:	af00      	add	r7, sp, #0
  403610:	6078      	str	r0, [r7, #4]
  403612:	6039      	str	r1, [r7, #0]
	if (!(p_usart->US_CSR & US_CSR_RXRDY)) {
  403614:	687b      	ldr	r3, [r7, #4]
  403616:	695b      	ldr	r3, [r3, #20]
  403618:	f003 0301 	and.w	r3, r3, #1
  40361c:	2b00      	cmp	r3, #0
  40361e:	d101      	bne.n	403624 <usart_read+0x1a>
		return 1;
  403620:	2301      	movs	r3, #1
  403622:	e006      	b.n	403632 <usart_read+0x28>
	}

	/* Read character */
	*c = p_usart->US_RHR & US_RHR_RXCHR_Msk;
  403624:	687b      	ldr	r3, [r7, #4]
  403626:	699b      	ldr	r3, [r3, #24]
  403628:	f3c3 0208 	ubfx	r2, r3, #0, #9
  40362c:	683b      	ldr	r3, [r7, #0]
  40362e:	601a      	str	r2, [r3, #0]

	return 0;
  403630:	2300      	movs	r3, #0
}
  403632:	4618      	mov	r0, r3
  403634:	370c      	adds	r7, #12
  403636:	46bd      	mov	sp, r7
  403638:	f85d 7b04 	ldr.w	r7, [sp], #4
  40363c:	4770      	bx	lr
	...

00403640 <usart_disable_writeprotect>:
 * \brief Disable write protect of USART registers.
 *
 * \param p_usart Pointer to a USART instance.
 */
void usart_disable_writeprotect(Usart *p_usart)
{
  403640:	b480      	push	{r7}
  403642:	b083      	sub	sp, #12
  403644:	af00      	add	r7, sp, #0
  403646:	6078      	str	r0, [r7, #4]
	p_usart->US_WPMR = US_WPMR_WPKEY_PASSWD;
  403648:	687b      	ldr	r3, [r7, #4]
  40364a:	4a04      	ldr	r2, [pc, #16]	; (40365c <usart_disable_writeprotect+0x1c>)
  40364c:	f8c3 20e4 	str.w	r2, [r3, #228]	; 0xe4
}
  403650:	bf00      	nop
  403652:	370c      	adds	r7, #12
  403654:	46bd      	mov	sp, r7
  403656:	f85d 7b04 	ldr.w	r7, [sp], #4
  40365a:	4770      	bx	lr
  40365c:	55534100 	.word	0x55534100

00403660 <cpu_irq_save>:

static volatile uint32_t cpu_irq_critical_section_counter;
static volatile bool     cpu_irq_prev_interrupt_state;

static inline irqflags_t cpu_irq_save(void)
{
  403660:	b480      	push	{r7}
  403662:	b083      	sub	sp, #12
  403664:	af00      	add	r7, sp, #0
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_PRIMASK(void)
{
  uint32_t result;

  __ASM volatile ("MRS %0, primask" : "=r" (result) );
  403666:	f3ef 8310 	mrs	r3, PRIMASK
  40366a:	607b      	str	r3, [r7, #4]
  return(result);
  40366c:	687b      	ldr	r3, [r7, #4]
	volatile irqflags_t flags = cpu_irq_is_enabled();
  40366e:	2b00      	cmp	r3, #0
  403670:	bf0c      	ite	eq
  403672:	2301      	moveq	r3, #1
  403674:	2300      	movne	r3, #0
  403676:	b2db      	uxtb	r3, r3
  403678:	603b      	str	r3, [r7, #0]
  __ASM volatile ("cpsid i" : : : "memory");
  40367a:	b672      	cpsid	i
    This function ensures the apparent order of the explicit memory operations before
    and after the instruction, without ensuring their completion.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __DMB(void)
{
  __ASM volatile ("dmb");
  40367c:	f3bf 8f5f 	dmb	sy
	cpu_irq_disable();
  403680:	4b04      	ldr	r3, [pc, #16]	; (403694 <cpu_irq_save+0x34>)
  403682:	2200      	movs	r2, #0
  403684:	701a      	strb	r2, [r3, #0]
	return flags;
  403686:	683b      	ldr	r3, [r7, #0]
}
  403688:	4618      	mov	r0, r3
  40368a:	370c      	adds	r7, #12
  40368c:	46bd      	mov	sp, r7
  40368e:	f85d 7b04 	ldr.w	r7, [sp], #4
  403692:	4770      	bx	lr
  403694:	20000119 	.word	0x20000119

00403698 <cpu_irq_is_enabled_flags>:

static inline bool cpu_irq_is_enabled_flags(irqflags_t flags)
{
  403698:	b480      	push	{r7}
  40369a:	b083      	sub	sp, #12
  40369c:	af00      	add	r7, sp, #0
  40369e:	6078      	str	r0, [r7, #4]
	return (flags);
  4036a0:	687b      	ldr	r3, [r7, #4]
  4036a2:	2b00      	cmp	r3, #0
  4036a4:	bf14      	ite	ne
  4036a6:	2301      	movne	r3, #1
  4036a8:	2300      	moveq	r3, #0
  4036aa:	b2db      	uxtb	r3, r3
}
  4036ac:	4618      	mov	r0, r3
  4036ae:	370c      	adds	r7, #12
  4036b0:	46bd      	mov	sp, r7
  4036b2:	f85d 7b04 	ldr.w	r7, [sp], #4
  4036b6:	4770      	bx	lr

004036b8 <cpu_irq_restore>:

static inline void cpu_irq_restore(irqflags_t flags)
{
  4036b8:	b580      	push	{r7, lr}
  4036ba:	b082      	sub	sp, #8
  4036bc:	af00      	add	r7, sp, #0
  4036be:	6078      	str	r0, [r7, #4]
	if (cpu_irq_is_enabled_flags(flags))
  4036c0:	6878      	ldr	r0, [r7, #4]
  4036c2:	4b07      	ldr	r3, [pc, #28]	; (4036e0 <cpu_irq_restore+0x28>)
  4036c4:	4798      	blx	r3
  4036c6:	4603      	mov	r3, r0
  4036c8:	2b00      	cmp	r3, #0
  4036ca:	d005      	beq.n	4036d8 <cpu_irq_restore+0x20>
		cpu_irq_enable();
  4036cc:	4b05      	ldr	r3, [pc, #20]	; (4036e4 <cpu_irq_restore+0x2c>)
  4036ce:	2201      	movs	r2, #1
  4036d0:	701a      	strb	r2, [r3, #0]
  4036d2:	f3bf 8f5f 	dmb	sy
  __ASM volatile ("cpsie i" : : : "memory");
  4036d6:	b662      	cpsie	i
}
  4036d8:	bf00      	nop
  4036da:	3708      	adds	r7, #8
  4036dc:	46bd      	mov	sp, r7
  4036de:	bd80      	pop	{r7, pc}
  4036e0:	00403699 	.word	0x00403699
  4036e4:	20000119 	.word	0x20000119

004036e8 <sysclk_enable_peripheral_clock>:
{
  4036e8:	b580      	push	{r7, lr}
  4036ea:	b082      	sub	sp, #8
  4036ec:	af00      	add	r7, sp, #0
  4036ee:	6078      	str	r0, [r7, #4]
	pmc_enable_periph_clk(ul_id);
  4036f0:	6878      	ldr	r0, [r7, #4]
  4036f2:	4b03      	ldr	r3, [pc, #12]	; (403700 <sysclk_enable_peripheral_clock+0x18>)
  4036f4:	4798      	blx	r3
}
  4036f6:	bf00      	nop
  4036f8:	3708      	adds	r7, #8
  4036fa:	46bd      	mov	sp, r7
  4036fc:	bd80      	pop	{r7, pc}
  4036fe:	bf00      	nop
  403700:	00404401 	.word	0x00404401

00403704 <sleepmgr_lock_mode>:
 * not put the device to sleep in the deeper sleep modes.
 *
 * \param mode Sleep mode to lock.
 */
static inline void sleepmgr_lock_mode(enum sleepmgr_mode mode)
{
  403704:	b580      	push	{r7, lr}
  403706:	b084      	sub	sp, #16
  403708:	af00      	add	r7, sp, #0
  40370a:	4603      	mov	r3, r0
  40370c:	71fb      	strb	r3, [r7, #7]
#ifdef CONFIG_SLEEPMGR_ENABLE
	irqflags_t flags;

	if(sleepmgr_locks[mode] >= 0xff) {
  40370e:	79fb      	ldrb	r3, [r7, #7]
  403710:	4a0a      	ldr	r2, [pc, #40]	; (40373c <sleepmgr_lock_mode+0x38>)
  403712:	5cd3      	ldrb	r3, [r2, r3]
  403714:	2bff      	cmp	r3, #255	; 0xff
  403716:	d100      	bne.n	40371a <sleepmgr_lock_mode+0x16>
		while (true) {
  403718:	e7fe      	b.n	403718 <sleepmgr_lock_mode+0x14>
			// Check APP or change the data type to uint16_t.
		}
	}

	// Enter a critical section
	flags = cpu_irq_save();
  40371a:	4b09      	ldr	r3, [pc, #36]	; (403740 <sleepmgr_lock_mode+0x3c>)
  40371c:	4798      	blx	r3
  40371e:	60f8      	str	r0, [r7, #12]

	++sleepmgr_locks[mode];
  403720:	79fb      	ldrb	r3, [r7, #7]
  403722:	4a06      	ldr	r2, [pc, #24]	; (40373c <sleepmgr_lock_mode+0x38>)
  403724:	5cd2      	ldrb	r2, [r2, r3]
  403726:	3201      	adds	r2, #1
  403728:	b2d1      	uxtb	r1, r2
  40372a:	4a04      	ldr	r2, [pc, #16]	; (40373c <sleepmgr_lock_mode+0x38>)
  40372c:	54d1      	strb	r1, [r2, r3]

	// Leave the critical section
	cpu_irq_restore(flags);
  40372e:	68f8      	ldr	r0, [r7, #12]
  403730:	4b04      	ldr	r3, [pc, #16]	; (403744 <sleepmgr_lock_mode+0x40>)
  403732:	4798      	blx	r3
#else
	UNUSED(mode);
#endif /* CONFIG_SLEEPMGR_ENABLE */
}
  403734:	bf00      	nop
  403736:	3710      	adds	r7, #16
  403738:	46bd      	mov	sp, r7
  40373a:	bd80      	pop	{r7, pc}
  40373c:	2000187c 	.word	0x2000187c
  403740:	00403661 	.word	0x00403661
  403744:	004036b9 	.word	0x004036b9

00403748 <flexcom_enable>:
 *
 * \param p_flexcom  Pointer to a FLEXCOM instance.
 *
 */
void flexcom_enable(Flexcom *p_flexcom)
{
  403748:	b580      	push	{r7, lr}
  40374a:	b082      	sub	sp, #8
  40374c:	af00      	add	r7, sp, #0
  40374e:	6078      	str	r0, [r7, #4]
#if SAMG55
    #define PMC_PCK_PRES_CLK_1  PMC_PCK_PRES(0)
#endif

	sleepmgr_lock_mode(SLEEPMGR_ACTIVE);
  403750:	2000      	movs	r0, #0
  403752:	4b4a      	ldr	r3, [pc, #296]	; (40387c <flexcom_enable+0x134>)
  403754:	4798      	blx	r3
	/* Enable PMC clock for FLEXCOM */
#ifdef ID_FLEXCOM7
	 if (p_flexcom == FLEXCOM7) {
  403756:	687b      	ldr	r3, [r7, #4]
  403758:	4a49      	ldr	r2, [pc, #292]	; (403880 <flexcom_enable+0x138>)
  40375a:	4293      	cmp	r3, r2
  40375c:	d10d      	bne.n	40377a <flexcom_enable+0x32>
		sysclk_enable_peripheral_clock(ID_FLEXCOM7);
  40375e:	2007      	movs	r0, #7
  403760:	4b48      	ldr	r3, [pc, #288]	; (403884 <flexcom_enable+0x13c>)
  403762:	4798      	blx	r3
		/* Enable PCK output */
		pmc_disable_pck(PMC_PCK_7);
  403764:	2007      	movs	r0, #7
  403766:	4b48      	ldr	r3, [pc, #288]	; (403888 <flexcom_enable+0x140>)
  403768:	4798      	blx	r3
		pmc_switch_pck_to_mck(PMC_PCK_7, PMC_PCK_PRES_CLK_1);
  40376a:	2100      	movs	r1, #0
  40376c:	2007      	movs	r0, #7
  40376e:	4b47      	ldr	r3, [pc, #284]	; (40388c <flexcom_enable+0x144>)
  403770:	4798      	blx	r3
		pmc_enable_pck(PMC_PCK_7);
  403772:	2007      	movs	r0, #7
  403774:	4b46      	ldr	r3, [pc, #280]	; (403890 <flexcom_enable+0x148>)
  403776:	4798      	blx	r3
	} else
#endif
	{
		Assert(false);
	}
}
  403778:	e07c      	b.n	403874 <flexcom_enable+0x12c>
	if (p_flexcom == FLEXCOM6) {
  40377a:	687b      	ldr	r3, [r7, #4]
  40377c:	4a45      	ldr	r2, [pc, #276]	; (403894 <flexcom_enable+0x14c>)
  40377e:	4293      	cmp	r3, r2
  403780:	d10d      	bne.n	40379e <flexcom_enable+0x56>
		sysclk_enable_peripheral_clock(ID_FLEXCOM6);
  403782:	2016      	movs	r0, #22
  403784:	4b3f      	ldr	r3, [pc, #252]	; (403884 <flexcom_enable+0x13c>)
  403786:	4798      	blx	r3
		pmc_disable_pck(PMC_PCK_7);
  403788:	2007      	movs	r0, #7
  40378a:	4b3f      	ldr	r3, [pc, #252]	; (403888 <flexcom_enable+0x140>)
  40378c:	4798      	blx	r3
		pmc_switch_pck_to_mck(PMC_PCK_7, PMC_PCK_PRES_CLK_1);
  40378e:	2100      	movs	r1, #0
  403790:	2007      	movs	r0, #7
  403792:	4b3e      	ldr	r3, [pc, #248]	; (40388c <flexcom_enable+0x144>)
  403794:	4798      	blx	r3
		pmc_enable_pck(PMC_PCK_7);
  403796:	2007      	movs	r0, #7
  403798:	4b3d      	ldr	r3, [pc, #244]	; (403890 <flexcom_enable+0x148>)
  40379a:	4798      	blx	r3
}
  40379c:	e06a      	b.n	403874 <flexcom_enable+0x12c>
	if (p_flexcom == FLEXCOM5) {
  40379e:	687b      	ldr	r3, [r7, #4]
  4037a0:	4a3d      	ldr	r2, [pc, #244]	; (403898 <flexcom_enable+0x150>)
  4037a2:	4293      	cmp	r3, r2
  4037a4:	d10d      	bne.n	4037c2 <flexcom_enable+0x7a>
		sysclk_enable_peripheral_clock(ID_FLEXCOM5);
  4037a6:	2015      	movs	r0, #21
  4037a8:	4b36      	ldr	r3, [pc, #216]	; (403884 <flexcom_enable+0x13c>)
  4037aa:	4798      	blx	r3
		pmc_disable_pck(PMC_PCK_7);
  4037ac:	2007      	movs	r0, #7
  4037ae:	4b36      	ldr	r3, [pc, #216]	; (403888 <flexcom_enable+0x140>)
  4037b0:	4798      	blx	r3
		pmc_switch_pck_to_mck(PMC_PCK_7, PMC_PCK_PRES_CLK_1);
  4037b2:	2100      	movs	r1, #0
  4037b4:	2007      	movs	r0, #7
  4037b6:	4b35      	ldr	r3, [pc, #212]	; (40388c <flexcom_enable+0x144>)
  4037b8:	4798      	blx	r3
		pmc_enable_pck(PMC_PCK_7);
  4037ba:	2007      	movs	r0, #7
  4037bc:	4b34      	ldr	r3, [pc, #208]	; (403890 <flexcom_enable+0x148>)
  4037be:	4798      	blx	r3
}
  4037c0:	e058      	b.n	403874 <flexcom_enable+0x12c>
	if (p_flexcom == FLEXCOM4) {
  4037c2:	687b      	ldr	r3, [r7, #4]
  4037c4:	4a35      	ldr	r2, [pc, #212]	; (40389c <flexcom_enable+0x154>)
  4037c6:	4293      	cmp	r3, r2
  4037c8:	d10d      	bne.n	4037e6 <flexcom_enable+0x9e>
		sysclk_enable_peripheral_clock(ID_FLEXCOM4);
  4037ca:	2014      	movs	r0, #20
  4037cc:	4b2d      	ldr	r3, [pc, #180]	; (403884 <flexcom_enable+0x13c>)
  4037ce:	4798      	blx	r3
		pmc_disable_pck(PMC_PCK_7);
  4037d0:	2007      	movs	r0, #7
  4037d2:	4b2d      	ldr	r3, [pc, #180]	; (403888 <flexcom_enable+0x140>)
  4037d4:	4798      	blx	r3
		pmc_switch_pck_to_mck(PMC_PCK_7, PMC_PCK_PRES_CLK_1);
  4037d6:	2100      	movs	r1, #0
  4037d8:	2007      	movs	r0, #7
  4037da:	4b2c      	ldr	r3, [pc, #176]	; (40388c <flexcom_enable+0x144>)
  4037dc:	4798      	blx	r3
		pmc_enable_pck(PMC_PCK_7);
  4037de:	2007      	movs	r0, #7
  4037e0:	4b2b      	ldr	r3, [pc, #172]	; (403890 <flexcom_enable+0x148>)
  4037e2:	4798      	blx	r3
}
  4037e4:	e046      	b.n	403874 <flexcom_enable+0x12c>
	if (p_flexcom == FLEXCOM3) {
  4037e6:	687b      	ldr	r3, [r7, #4]
  4037e8:	4a2d      	ldr	r2, [pc, #180]	; (4038a0 <flexcom_enable+0x158>)
  4037ea:	4293      	cmp	r3, r2
  4037ec:	d10d      	bne.n	40380a <flexcom_enable+0xc2>
		sysclk_enable_peripheral_clock(ID_FLEXCOM3);
  4037ee:	2013      	movs	r0, #19
  4037f0:	4b24      	ldr	r3, [pc, #144]	; (403884 <flexcom_enable+0x13c>)
  4037f2:	4798      	blx	r3
		pmc_disable_pck(PMC_PCK_6);
  4037f4:	2006      	movs	r0, #6
  4037f6:	4b24      	ldr	r3, [pc, #144]	; (403888 <flexcom_enable+0x140>)
  4037f8:	4798      	blx	r3
		pmc_switch_pck_to_mck(PMC_PCK_6, PMC_PCK_PRES_CLK_1);
  4037fa:	2100      	movs	r1, #0
  4037fc:	2006      	movs	r0, #6
  4037fe:	4b23      	ldr	r3, [pc, #140]	; (40388c <flexcom_enable+0x144>)
  403800:	4798      	blx	r3
		pmc_enable_pck(PMC_PCK_6);
  403802:	2006      	movs	r0, #6
  403804:	4b22      	ldr	r3, [pc, #136]	; (403890 <flexcom_enable+0x148>)
  403806:	4798      	blx	r3
}
  403808:	e034      	b.n	403874 <flexcom_enable+0x12c>
	if (p_flexcom == FLEXCOM2) {
  40380a:	687b      	ldr	r3, [r7, #4]
  40380c:	4a25      	ldr	r2, [pc, #148]	; (4038a4 <flexcom_enable+0x15c>)
  40380e:	4293      	cmp	r3, r2
  403810:	d10d      	bne.n	40382e <flexcom_enable+0xe6>
		sysclk_enable_peripheral_clock(ID_FLEXCOM2);
  403812:	200e      	movs	r0, #14
  403814:	4b1b      	ldr	r3, [pc, #108]	; (403884 <flexcom_enable+0x13c>)
  403816:	4798      	blx	r3
		pmc_disable_pck(PMC_PCK_6);
  403818:	2006      	movs	r0, #6
  40381a:	4b1b      	ldr	r3, [pc, #108]	; (403888 <flexcom_enable+0x140>)
  40381c:	4798      	blx	r3
		pmc_switch_pck_to_mck(PMC_PCK_6, PMC_PCK_PRES_CLK_1);
  40381e:	2100      	movs	r1, #0
  403820:	2006      	movs	r0, #6
  403822:	4b1a      	ldr	r3, [pc, #104]	; (40388c <flexcom_enable+0x144>)
  403824:	4798      	blx	r3
		pmc_enable_pck(PMC_PCK_6);
  403826:	2006      	movs	r0, #6
  403828:	4b19      	ldr	r3, [pc, #100]	; (403890 <flexcom_enable+0x148>)
  40382a:	4798      	blx	r3
}
  40382c:	e022      	b.n	403874 <flexcom_enable+0x12c>
	if (p_flexcom == FLEXCOM1) {
  40382e:	687b      	ldr	r3, [r7, #4]
  403830:	4a1d      	ldr	r2, [pc, #116]	; (4038a8 <flexcom_enable+0x160>)
  403832:	4293      	cmp	r3, r2
  403834:	d10d      	bne.n	403852 <flexcom_enable+0x10a>
		sysclk_enable_peripheral_clock(ID_FLEXCOM1);
  403836:	2009      	movs	r0, #9
  403838:	4b12      	ldr	r3, [pc, #72]	; (403884 <flexcom_enable+0x13c>)
  40383a:	4798      	blx	r3
		pmc_disable_pck(PMC_PCK_6);
  40383c:	2006      	movs	r0, #6
  40383e:	4b12      	ldr	r3, [pc, #72]	; (403888 <flexcom_enable+0x140>)
  403840:	4798      	blx	r3
		pmc_switch_pck_to_mck(PMC_PCK_6, PMC_PCK_PRES_CLK_1);
  403842:	2100      	movs	r1, #0
  403844:	2006      	movs	r0, #6
  403846:	4b11      	ldr	r3, [pc, #68]	; (40388c <flexcom_enable+0x144>)
  403848:	4798      	blx	r3
		pmc_enable_pck(PMC_PCK_6);
  40384a:	2006      	movs	r0, #6
  40384c:	4b10      	ldr	r3, [pc, #64]	; (403890 <flexcom_enable+0x148>)
  40384e:	4798      	blx	r3
}
  403850:	e010      	b.n	403874 <flexcom_enable+0x12c>
	if (p_flexcom == FLEXCOM0) {
  403852:	687b      	ldr	r3, [r7, #4]
  403854:	4a15      	ldr	r2, [pc, #84]	; (4038ac <flexcom_enable+0x164>)
  403856:	4293      	cmp	r3, r2
  403858:	d10c      	bne.n	403874 <flexcom_enable+0x12c>
		sysclk_enable_peripheral_clock(ID_FLEXCOM0);
  40385a:	2008      	movs	r0, #8
  40385c:	4b09      	ldr	r3, [pc, #36]	; (403884 <flexcom_enable+0x13c>)
  40385e:	4798      	blx	r3
		pmc_disable_pck(PMC_PCK_6);
  403860:	2006      	movs	r0, #6
  403862:	4b09      	ldr	r3, [pc, #36]	; (403888 <flexcom_enable+0x140>)
  403864:	4798      	blx	r3
		pmc_switch_pck_to_mck(PMC_PCK_6, PMC_PCK_PRES_CLK_1);
  403866:	2100      	movs	r1, #0
  403868:	2006      	movs	r0, #6
  40386a:	4b08      	ldr	r3, [pc, #32]	; (40388c <flexcom_enable+0x144>)
  40386c:	4798      	blx	r3
		pmc_enable_pck(PMC_PCK_6);
  40386e:	2006      	movs	r0, #6
  403870:	4b07      	ldr	r3, [pc, #28]	; (403890 <flexcom_enable+0x148>)
  403872:	4798      	blx	r3
}
  403874:	bf00      	nop
  403876:	3708      	adds	r7, #8
  403878:	46bd      	mov	sp, r7
  40387a:	bd80      	pop	{r7, pc}
  40387c:	00403705 	.word	0x00403705
  403880:	40034000 	.word	0x40034000
  403884:	004036e9 	.word	0x004036e9
  403888:	00404505 	.word	0x00404505
  40388c:	00404485 	.word	0x00404485
  403890:	004044dd 	.word	0x004044dd
  403894:	40040000 	.word	0x40040000
  403898:	40008000 	.word	0x40008000
  40389c:	4001c000 	.word	0x4001c000
  4038a0:	40018000 	.word	0x40018000
  4038a4:	40024000 	.word	0x40024000
  4038a8:	40020000 	.word	0x40020000
  4038ac:	4000c000 	.word	0x4000c000

004038b0 <flexcom_set_opmode>:
 * \param p_flexcom  Pointer to a FLEXCOM instance.
 * \param opmode  Opration mode.
 *
 */
void flexcom_set_opmode(Flexcom *p_flexcom, enum flexcom_opmode opmode)
{
  4038b0:	b480      	push	{r7}
  4038b2:	b083      	sub	sp, #12
  4038b4:	af00      	add	r7, sp, #0
  4038b6:	6078      	str	r0, [r7, #4]
  4038b8:	460b      	mov	r3, r1
  4038ba:	70fb      	strb	r3, [r7, #3]
	p_flexcom->FLEXCOM_MR = opmode;
  4038bc:	78fa      	ldrb	r2, [r7, #3]
  4038be:	687b      	ldr	r3, [r7, #4]
  4038c0:	601a      	str	r2, [r3, #0]
}
  4038c2:	bf00      	nop
  4038c4:	370c      	adds	r7, #12
  4038c6:	46bd      	mov	sp, r7
  4038c8:	f85d 7b04 	ldr.w	r7, [sp], #4
  4038cc:	4770      	bx	lr
	...

004038d0 <osc_enable>:
{
  4038d0:	b580      	push	{r7, lr}
  4038d2:	b082      	sub	sp, #8
  4038d4:	af00      	add	r7, sp, #0
  4038d6:	6078      	str	r0, [r7, #4]
	switch (ul_id) {
  4038d8:	687b      	ldr	r3, [r7, #4]
  4038da:	2b07      	cmp	r3, #7
  4038dc:	d831      	bhi.n	403942 <osc_enable+0x72>
  4038de:	a201      	add	r2, pc, #4	; (adr r2, 4038e4 <osc_enable+0x14>)
  4038e0:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
  4038e4:	00403941 	.word	0x00403941
  4038e8:	00403905 	.word	0x00403905
  4038ec:	0040390d 	.word	0x0040390d
  4038f0:	00403915 	.word	0x00403915
  4038f4:	0040391d 	.word	0x0040391d
  4038f8:	00403925 	.word	0x00403925
  4038fc:	0040392d 	.word	0x0040392d
  403900:	00403937 	.word	0x00403937
		pmc_switch_sclk_to_32kxtal(PMC_OSC_XTAL);
  403904:	2000      	movs	r0, #0
  403906:	4b11      	ldr	r3, [pc, #68]	; (40394c <osc_enable+0x7c>)
  403908:	4798      	blx	r3
		break;
  40390a:	e01a      	b.n	403942 <osc_enable+0x72>
		pmc_switch_sclk_to_32kxtal(PMC_OSC_BYPASS);
  40390c:	2001      	movs	r0, #1
  40390e:	4b0f      	ldr	r3, [pc, #60]	; (40394c <osc_enable+0x7c>)
  403910:	4798      	blx	r3
		break;
  403912:	e016      	b.n	403942 <osc_enable+0x72>
		pmc_switch_mainck_to_fastrc(CKGR_MOR_MOSCRCF_8_MHz);
  403914:	2000      	movs	r0, #0
  403916:	4b0e      	ldr	r3, [pc, #56]	; (403950 <osc_enable+0x80>)
  403918:	4798      	blx	r3
		break;
  40391a:	e012      	b.n	403942 <osc_enable+0x72>
		pmc_switch_mainck_to_fastrc(CKGR_MOR_MOSCRCF_16_MHz);
  40391c:	2010      	movs	r0, #16
  40391e:	4b0c      	ldr	r3, [pc, #48]	; (403950 <osc_enable+0x80>)
  403920:	4798      	blx	r3
		break;
  403922:	e00e      	b.n	403942 <osc_enable+0x72>
		pmc_switch_mainck_to_fastrc(CKGR_MOR_MOSCRCF_24_MHz);
  403924:	2020      	movs	r0, #32
  403926:	4b0a      	ldr	r3, [pc, #40]	; (403950 <osc_enable+0x80>)
  403928:	4798      	blx	r3
		break;
  40392a:	e00a      	b.n	403942 <osc_enable+0x72>
		pmc_switch_mainck_to_xtal(PMC_OSC_XTAL,
  40392c:	213e      	movs	r1, #62	; 0x3e
  40392e:	2000      	movs	r0, #0
  403930:	4b08      	ldr	r3, [pc, #32]	; (403954 <osc_enable+0x84>)
  403932:	4798      	blx	r3
		break;
  403934:	e005      	b.n	403942 <osc_enable+0x72>
		pmc_switch_mainck_to_xtal(PMC_OSC_BYPASS,
  403936:	213e      	movs	r1, #62	; 0x3e
  403938:	2001      	movs	r0, #1
  40393a:	4b06      	ldr	r3, [pc, #24]	; (403954 <osc_enable+0x84>)
  40393c:	4798      	blx	r3
		break;
  40393e:	e000      	b.n	403942 <osc_enable+0x72>
		break;
  403940:	bf00      	nop
}
  403942:	bf00      	nop
  403944:	3708      	adds	r7, #8
  403946:	46bd      	mov	sp, r7
  403948:	bd80      	pop	{r7, pc}
  40394a:	bf00      	nop
  40394c:	00404229 	.word	0x00404229
  403950:	00404295 	.word	0x00404295
  403954:	00404305 	.word	0x00404305

00403958 <osc_is_ready>:
{
  403958:	b580      	push	{r7, lr}
  40395a:	b082      	sub	sp, #8
  40395c:	af00      	add	r7, sp, #0
  40395e:	6078      	str	r0, [r7, #4]
	switch (ul_id) {
  403960:	687b      	ldr	r3, [r7, #4]
  403962:	2b07      	cmp	r3, #7
  403964:	d826      	bhi.n	4039b4 <osc_is_ready+0x5c>
  403966:	a201      	add	r2, pc, #4	; (adr r2, 40396c <osc_is_ready+0x14>)
  403968:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
  40396c:	0040398d 	.word	0x0040398d
  403970:	00403991 	.word	0x00403991
  403974:	00403991 	.word	0x00403991
  403978:	004039a3 	.word	0x004039a3
  40397c:	004039a3 	.word	0x004039a3
  403980:	004039a3 	.word	0x004039a3
  403984:	004039a3 	.word	0x004039a3
  403988:	004039a3 	.word	0x004039a3
		return 1;
  40398c:	2301      	movs	r3, #1
  40398e:	e012      	b.n	4039b6 <osc_is_ready+0x5e>
		return pmc_osc_is_ready_32kxtal();
  403990:	4b0b      	ldr	r3, [pc, #44]	; (4039c0 <osc_is_ready+0x68>)
  403992:	4798      	blx	r3
  403994:	4603      	mov	r3, r0
  403996:	2b00      	cmp	r3, #0
  403998:	bf14      	ite	ne
  40399a:	2301      	movne	r3, #1
  40399c:	2300      	moveq	r3, #0
  40399e:	b2db      	uxtb	r3, r3
  4039a0:	e009      	b.n	4039b6 <osc_is_ready+0x5e>
		return pmc_osc_is_ready_mainck();
  4039a2:	4b08      	ldr	r3, [pc, #32]	; (4039c4 <osc_is_ready+0x6c>)
  4039a4:	4798      	blx	r3
  4039a6:	4603      	mov	r3, r0
  4039a8:	2b00      	cmp	r3, #0
  4039aa:	bf14      	ite	ne
  4039ac:	2301      	movne	r3, #1
  4039ae:	2300      	moveq	r3, #0
  4039b0:	b2db      	uxtb	r3, r3
  4039b2:	e000      	b.n	4039b6 <osc_is_ready+0x5e>
	return 0;
  4039b4:	2300      	movs	r3, #0
}
  4039b6:	4618      	mov	r0, r3
  4039b8:	3708      	adds	r7, #8
  4039ba:	46bd      	mov	sp, r7
  4039bc:	bd80      	pop	{r7, pc}
  4039be:	bf00      	nop
  4039c0:	00404261 	.word	0x00404261
  4039c4:	0040437d 	.word	0x0040437d

004039c8 <osc_get_rate>:
{
  4039c8:	b480      	push	{r7}
  4039ca:	b083      	sub	sp, #12
  4039cc:	af00      	add	r7, sp, #0
  4039ce:	6078      	str	r0, [r7, #4]
	switch (ul_id) {
  4039d0:	687b      	ldr	r3, [r7, #4]
  4039d2:	2b07      	cmp	r3, #7
  4039d4:	d825      	bhi.n	403a22 <osc_get_rate+0x5a>
  4039d6:	a201      	add	r2, pc, #4	; (adr r2, 4039dc <osc_get_rate+0x14>)
  4039d8:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
  4039dc:	004039fd 	.word	0x004039fd
  4039e0:	00403a03 	.word	0x00403a03
  4039e4:	00403a09 	.word	0x00403a09
  4039e8:	00403a0f 	.word	0x00403a0f
  4039ec:	00403a13 	.word	0x00403a13
  4039f0:	00403a17 	.word	0x00403a17
  4039f4:	00403a1b 	.word	0x00403a1b
  4039f8:	00403a1f 	.word	0x00403a1f
		return OSC_SLCK_32K_RC_HZ;
  4039fc:	f44f 43fa 	mov.w	r3, #32000	; 0x7d00
  403a00:	e010      	b.n	403a24 <osc_get_rate+0x5c>
		return BOARD_FREQ_SLCK_XTAL;
  403a02:	f44f 4300 	mov.w	r3, #32768	; 0x8000
  403a06:	e00d      	b.n	403a24 <osc_get_rate+0x5c>
		return BOARD_FREQ_SLCK_BYPASS;
  403a08:	f44f 4300 	mov.w	r3, #32768	; 0x8000
  403a0c:	e00a      	b.n	403a24 <osc_get_rate+0x5c>
		return OSC_MAINCK_8M_RC_HZ;
  403a0e:	4b08      	ldr	r3, [pc, #32]	; (403a30 <osc_get_rate+0x68>)
  403a10:	e008      	b.n	403a24 <osc_get_rate+0x5c>
		return OSC_MAINCK_16M_RC_HZ;
  403a12:	4b08      	ldr	r3, [pc, #32]	; (403a34 <osc_get_rate+0x6c>)
  403a14:	e006      	b.n	403a24 <osc_get_rate+0x5c>
		return OSC_MAINCK_24M_RC_HZ;
  403a16:	4b08      	ldr	r3, [pc, #32]	; (403a38 <osc_get_rate+0x70>)
  403a18:	e004      	b.n	403a24 <osc_get_rate+0x5c>
		return BOARD_FREQ_MAINCK_XTAL;
  403a1a:	2300      	movs	r3, #0
  403a1c:	e002      	b.n	403a24 <osc_get_rate+0x5c>
		return BOARD_FREQ_MAINCK_BYPASS;
  403a1e:	2300      	movs	r3, #0
  403a20:	e000      	b.n	403a24 <osc_get_rate+0x5c>
	return 0;
  403a22:	2300      	movs	r3, #0
}
  403a24:	4618      	mov	r0, r3
  403a26:	370c      	adds	r7, #12
  403a28:	46bd      	mov	sp, r7
  403a2a:	f85d 7b04 	ldr.w	r7, [sp], #4
  403a2e:	4770      	bx	lr
  403a30:	007a1200 	.word	0x007a1200
  403a34:	00f42400 	.word	0x00f42400
  403a38:	016e3600 	.word	0x016e3600

00403a3c <osc_wait_ready>:
 * to become stable and ready to use as a clock source.
 *
 * \param id A number identifying the oscillator to wait for.
 */
static inline void osc_wait_ready(uint8_t id)
{
  403a3c:	b580      	push	{r7, lr}
  403a3e:	b082      	sub	sp, #8
  403a40:	af00      	add	r7, sp, #0
  403a42:	4603      	mov	r3, r0
  403a44:	71fb      	strb	r3, [r7, #7]
	while (!osc_is_ready(id)) {
  403a46:	bf00      	nop
  403a48:	79fb      	ldrb	r3, [r7, #7]
  403a4a:	4618      	mov	r0, r3
  403a4c:	4b05      	ldr	r3, [pc, #20]	; (403a64 <osc_wait_ready+0x28>)
  403a4e:	4798      	blx	r3
  403a50:	4603      	mov	r3, r0
  403a52:	f083 0301 	eor.w	r3, r3, #1
  403a56:	b2db      	uxtb	r3, r3
  403a58:	2b00      	cmp	r3, #0
  403a5a:	d1f5      	bne.n	403a48 <osc_wait_ready+0xc>
		/* Do nothing */
	}
}
  403a5c:	bf00      	nop
  403a5e:	3708      	adds	r7, #8
  403a60:	46bd      	mov	sp, r7
  403a62:	bd80      	pop	{r7, pc}
  403a64:	00403959 	.word	0x00403959

00403a68 <pll_config_init>:
 * \note The SAMG PLL hardware interprets mul as mul+1. For readability the hardware mul+1
 * is hidden in this implementation. Use mul as mul effective value.
 */
static inline void pll_config_init(struct pll_config *p_cfg,
		enum pll_source e_src, uint32_t ul_div, uint32_t ul_mul)
{
  403a68:	b580      	push	{r7, lr}
  403a6a:	b086      	sub	sp, #24
  403a6c:	af00      	add	r7, sp, #0
  403a6e:	60f8      	str	r0, [r7, #12]
  403a70:	607a      	str	r2, [r7, #4]
  403a72:	603b      	str	r3, [r7, #0]
  403a74:	460b      	mov	r3, r1
  403a76:	72fb      	strb	r3, [r7, #11]

	Assert(e_src < PLL_NR_SOURCES);
	Assert(ul_div < 2);

	/* Calculate internal VCO frequency */
	vco_hz = osc_get_rate(e_src) / ul_div;
  403a78:	7afb      	ldrb	r3, [r7, #11]
  403a7a:	4618      	mov	r0, r3
  403a7c:	4b0d      	ldr	r3, [pc, #52]	; (403ab4 <pll_config_init+0x4c>)
  403a7e:	4798      	blx	r3
  403a80:	4602      	mov	r2, r0
  403a82:	687b      	ldr	r3, [r7, #4]
  403a84:	fbb2 f3f3 	udiv	r3, r2, r3
  403a88:	617b      	str	r3, [r7, #20]

	vco_hz *= ul_mul;
  403a8a:	697b      	ldr	r3, [r7, #20]
  403a8c:	683a      	ldr	r2, [r7, #0]
  403a8e:	fb02 f303 	mul.w	r3, r2, r3
  403a92:	617b      	str	r3, [r7, #20]
	Assert(vco_hz >= (PLL_OUTPUT_MIN_HZ - (PLL_OUTPUT_MIN_HZ >> 6)));
	Assert(vco_hz <= (PLL_OUTPUT_MAX_HZ + (PLL_OUTPUT_MAX_HZ >> 6)));

	/* PMC hardware will automatically make it mul+1 */
	p_cfg->ctrl = CKGR_PLLAR_MULA(ul_mul - 1) | CKGR_PLLAR_PLLAEN(ul_div) | CKGR_PLLAR_PLLACOUNT(PLL_COUNT);
  403a94:	683b      	ldr	r3, [r7, #0]
  403a96:	3b01      	subs	r3, #1
  403a98:	041a      	lsls	r2, r3, #16
  403a9a:	4b07      	ldr	r3, [pc, #28]	; (403ab8 <pll_config_init+0x50>)
  403a9c:	4013      	ands	r3, r2
  403a9e:	687a      	ldr	r2, [r7, #4]
  403aa0:	b2d2      	uxtb	r2, r2
  403aa2:	4313      	orrs	r3, r2
  403aa4:	f443 527c 	orr.w	r2, r3, #16128	; 0x3f00
  403aa8:	68fb      	ldr	r3, [r7, #12]
  403aaa:	601a      	str	r2, [r3, #0]
}
  403aac:	bf00      	nop
  403aae:	3718      	adds	r7, #24
  403ab0:	46bd      	mov	sp, r7
  403ab2:	bd80      	pop	{r7, pc}
  403ab4:	004039c9 	.word	0x004039c9
  403ab8:	1fff0000 	.word	0x1fff0000

00403abc <pll_enable>:
#endif
	}
}

static inline void pll_enable(const struct pll_config *p_cfg, uint32_t ul_pll_id)
{
  403abc:	b580      	push	{r7, lr}
  403abe:	b082      	sub	sp, #8
  403ac0:	af00      	add	r7, sp, #0
  403ac2:	6078      	str	r0, [r7, #4]
  403ac4:	6039      	str	r1, [r7, #0]
	Assert(ul_pll_id < NR_PLLS);

	if (ul_pll_id == PLLA_ID) {
  403ac6:	683b      	ldr	r3, [r7, #0]
  403ac8:	2b00      	cmp	r3, #0
  403aca:	d106      	bne.n	403ada <pll_enable+0x1e>
		pmc_disable_pllack(); // Always stop PLL first!
  403acc:	4b08      	ldr	r3, [pc, #32]	; (403af0 <pll_enable+0x34>)
  403ace:	4798      	blx	r3
		PMC->CKGR_PLLAR = p_cfg->ctrl;
  403ad0:	4a08      	ldr	r2, [pc, #32]	; (403af4 <pll_enable+0x38>)
  403ad2:	687b      	ldr	r3, [r7, #4]
  403ad4:	681b      	ldr	r3, [r3, #0]
  403ad6:	6293      	str	r3, [r2, #40]	; 0x28
	} else {
		pmc_disable_pllbck(); // Always stop PLL first!
		PMC->CKGR_PLLBR = p_cfg->ctrl;
#endif
	}
}
  403ad8:	e005      	b.n	403ae6 <pll_enable+0x2a>
		pmc_disable_pllbck(); // Always stop PLL first!
  403ada:	4b07      	ldr	r3, [pc, #28]	; (403af8 <pll_enable+0x3c>)
  403adc:	4798      	blx	r3
		PMC->CKGR_PLLBR = p_cfg->ctrl;
  403ade:	4a05      	ldr	r2, [pc, #20]	; (403af4 <pll_enable+0x38>)
  403ae0:	687b      	ldr	r3, [r7, #4]
  403ae2:	681b      	ldr	r3, [r3, #0]
  403ae4:	62d3      	str	r3, [r2, #44]	; 0x2c
}
  403ae6:	bf00      	nop
  403ae8:	3708      	adds	r7, #8
  403aea:	46bd      	mov	sp, r7
  403aec:	bd80      	pop	{r7, pc}
  403aee:	bf00      	nop
  403af0:	00404399 	.word	0x00404399
  403af4:	400e0400 	.word	0x400e0400
  403af8:	004043cd 	.word	0x004043cd

00403afc <pll_is_locked>:
#endif
	}
}

static inline uint32_t pll_is_locked(uint32_t ul_pll_id)
{
  403afc:	b580      	push	{r7, lr}
  403afe:	b082      	sub	sp, #8
  403b00:	af00      	add	r7, sp, #0
  403b02:	6078      	str	r0, [r7, #4]
	Assert(ul_pll_id < NR_PLLS);

	if (ul_pll_id == PLLA_ID) {
  403b04:	687b      	ldr	r3, [r7, #4]
  403b06:	2b00      	cmp	r3, #0
  403b08:	d103      	bne.n	403b12 <pll_is_locked+0x16>
		return pmc_is_locked_pllack();
  403b0a:	4b08      	ldr	r3, [pc, #32]	; (403b2c <pll_is_locked+0x30>)
  403b0c:	4798      	blx	r3
  403b0e:	4603      	mov	r3, r0
  403b10:	e007      	b.n	403b22 <pll_is_locked+0x26>
#if SAMG55
	} else if (ul_pll_id == PLLB_ID) {
  403b12:	687b      	ldr	r3, [r7, #4]
  403b14:	2b01      	cmp	r3, #1
  403b16:	d103      	bne.n	403b20 <pll_is_locked+0x24>
		return pmc_is_locked_pllbck();
  403b18:	4b05      	ldr	r3, [pc, #20]	; (403b30 <pll_is_locked+0x34>)
  403b1a:	4798      	blx	r3
  403b1c:	4603      	mov	r3, r0
  403b1e:	e000      	b.n	403b22 <pll_is_locked+0x26>
#endif
	} else {
		return 0;
  403b20:	2300      	movs	r3, #0
	}
}
  403b22:	4618      	mov	r0, r3
  403b24:	3708      	adds	r7, #8
  403b26:	46bd      	mov	sp, r7
  403b28:	bd80      	pop	{r7, pc}
  403b2a:	bf00      	nop
  403b2c:	004043b1 	.word	0x004043b1
  403b30:	004043e5 	.word	0x004043e5

00403b34 <pll_enable_source>:

static inline void pll_enable_source(enum pll_source e_src)
{
  403b34:	b580      	push	{r7, lr}
  403b36:	b082      	sub	sp, #8
  403b38:	af00      	add	r7, sp, #0
  403b3a:	4603      	mov	r3, r0
  403b3c:	71fb      	strb	r3, [r7, #7]
	switch (e_src) {
  403b3e:	79fb      	ldrb	r3, [r7, #7]
  403b40:	3300      	adds	r3, #0
  403b42:	2b01      	cmp	r3, #1
  403b44:	d808      	bhi.n	403b58 <pll_enable_source+0x24>
	case PLL_SRC_SLCK_RC:
	case PLL_SRC_SLCK_XTAL:
		osc_enable(e_src);
  403b46:	79fb      	ldrb	r3, [r7, #7]
  403b48:	4618      	mov	r0, r3
  403b4a:	4b06      	ldr	r3, [pc, #24]	; (403b64 <pll_enable_source+0x30>)
  403b4c:	4798      	blx	r3
		osc_wait_ready(e_src);
  403b4e:	79fb      	ldrb	r3, [r7, #7]
  403b50:	4618      	mov	r0, r3
  403b52:	4b05      	ldr	r3, [pc, #20]	; (403b68 <pll_enable_source+0x34>)
  403b54:	4798      	blx	r3
		break;
  403b56:	e000      	b.n	403b5a <pll_enable_source+0x26>

	default:
		Assert(false);
		break;
  403b58:	bf00      	nop
	}
}
  403b5a:	bf00      	nop
  403b5c:	3708      	adds	r7, #8
  403b5e:	46bd      	mov	sp, r7
  403b60:	bd80      	pop	{r7, pc}
  403b62:	bf00      	nop
  403b64:	004038d1 	.word	0x004038d1
  403b68:	00403a3d 	.word	0x00403a3d

00403b6c <pll_wait_for_lock>:
 *
 * \retval STATUS_OK The PLL is now locked.
 * \retval ERR_TIMEOUT Timed out waiting for PLL to become locked.
 */
static inline int pll_wait_for_lock(unsigned int pll_id)
{
  403b6c:	b580      	push	{r7, lr}
  403b6e:	b082      	sub	sp, #8
  403b70:	af00      	add	r7, sp, #0
  403b72:	6078      	str	r0, [r7, #4]
	Assert(pll_id < NR_PLLS);

	while (!pll_is_locked(pll_id)) {
  403b74:	bf00      	nop
  403b76:	6878      	ldr	r0, [r7, #4]
  403b78:	4b04      	ldr	r3, [pc, #16]	; (403b8c <pll_wait_for_lock+0x20>)
  403b7a:	4798      	blx	r3
  403b7c:	4603      	mov	r3, r0
  403b7e:	2b00      	cmp	r3, #0
  403b80:	d0f9      	beq.n	403b76 <pll_wait_for_lock+0xa>
		/* Do nothing */
	}

	return 0;
  403b82:	2300      	movs	r3, #0
}
  403b84:	4618      	mov	r0, r3
  403b86:	3708      	adds	r7, #8
  403b88:	46bd      	mov	sp, r7
  403b8a:	bd80      	pop	{r7, pc}
  403b8c:	00403afd 	.word	0x00403afd

00403b90 <sysclk_get_main_hz>:
{
  403b90:	b580      	push	{r7, lr}
  403b92:	af00      	add	r7, sp, #0
		return pll_get_default_rate(0);
  403b94:	2001      	movs	r0, #1
  403b96:	4b04      	ldr	r3, [pc, #16]	; (403ba8 <sysclk_get_main_hz+0x18>)
  403b98:	4798      	blx	r3
  403b9a:	4602      	mov	r2, r0
  403b9c:	f640 634e 	movw	r3, #3662	; 0xe4e
  403ba0:	fb03 f302 	mul.w	r3, r3, r2
}
  403ba4:	4618      	mov	r0, r3
  403ba6:	bd80      	pop	{r7, pc}
  403ba8:	004039c9 	.word	0x004039c9

00403bac <sysclk_get_cpu_hz>:
{
  403bac:	b580      	push	{r7, lr}
  403bae:	af00      	add	r7, sp, #0
	return sysclk_get_main_hz() /
  403bb0:	4b02      	ldr	r3, [pc, #8]	; (403bbc <sysclk_get_cpu_hz+0x10>)
  403bb2:	4798      	blx	r3
  403bb4:	4603      	mov	r3, r0
}
  403bb6:	4618      	mov	r0, r3
  403bb8:	bd80      	pop	{r7, pc}
  403bba:	bf00      	nop
  403bbc:	00403b91 	.word	0x00403b91

00403bc0 <sysclk_init>:
}
#endif // CONFIG_USBCLK_SOURCE
#endif

void sysclk_init(void)
{
  403bc0:	b590      	push	{r4, r7, lr}
  403bc2:	b0a5      	sub	sp, #148	; 0x94
  403bc4:	af02      	add	r7, sp, #8
	uint32_t unique_id[32];
	uint32_t trim_value;
#endif

	/* Set flash wait state to max in case the below clock switching. */
	system_init_flash(CHIP_FREQ_CPU_MAX);
  403bc6:	4820      	ldr	r0, [pc, #128]	; (403c48 <sysclk_init+0x88>)
  403bc8:	4b20      	ldr	r3, [pc, #128]	; (403c4c <sysclk_init+0x8c>)
  403bca:	4798      	blx	r3

#ifdef CONFIG_PLL0_SOURCE
	else if (CONFIG_SYSCLK_SOURCE == SYSCLK_SRC_PLLACK) {
		struct pll_config pllcfg;

		pll_enable_source(CONFIG_PLL0_SOURCE);
  403bcc:	2001      	movs	r0, #1
  403bce:	4b20      	ldr	r3, [pc, #128]	; (403c50 <sysclk_init+0x90>)
  403bd0:	4798      	blx	r3
		pll_config_defaults(&pllcfg, 0);
  403bd2:	4638      	mov	r0, r7
  403bd4:	f640 634e 	movw	r3, #3662	; 0xe4e
  403bd8:	2201      	movs	r2, #1
  403bda:	2101      	movs	r1, #1
  403bdc:	4c1d      	ldr	r4, [pc, #116]	; (403c54 <sysclk_init+0x94>)
  403bde:	47a0      	blx	r4
		pll_enable(&pllcfg, 0);
  403be0:	463b      	mov	r3, r7
  403be2:	2100      	movs	r1, #0
  403be4:	4618      	mov	r0, r3
  403be6:	4b1c      	ldr	r3, [pc, #112]	; (403c58 <sysclk_init+0x98>)
  403be8:	4798      	blx	r3
		pll_wait_for_lock(0);
  403bea:	2000      	movs	r0, #0
  403bec:	4b1b      	ldr	r3, [pc, #108]	; (403c5c <sysclk_init+0x9c>)
  403bee:	4798      	blx	r3
		pmc_switch_mck_to_pllack(CONFIG_SYSCLK_PRES);
  403bf0:	2000      	movs	r0, #0
  403bf2:	4b1b      	ldr	r3, [pc, #108]	; (403c60 <sysclk_init+0xa0>)
  403bf4:	4798      	blx	r3
	}
#endif
#endif

	/* Update the SystemFrequency variable */
	SystemCoreClockUpdate();
  403bf6:	4b1b      	ldr	r3, [pc, #108]	; (403c64 <sysclk_init+0xa4>)
  403bf8:	4798      	blx	r3

	/* Set a flash wait state depending on the new cpu frequency */
	system_init_flash(sysclk_get_cpu_hz());
  403bfa:	4b1b      	ldr	r3, [pc, #108]	; (403c68 <sysclk_init+0xa8>)
  403bfc:	4798      	blx	r3
  403bfe:	4603      	mov	r3, r0
  403c00:	4618      	mov	r0, r3
  403c02:	4b12      	ldr	r3, [pc, #72]	; (403c4c <sysclk_init+0x8c>)
  403c04:	4798      	blx	r3
	}
#endif

#if SAMG55
	/* Set the trim value when system run near 120M */
	if ((SystemCoreClock <= (CHIP_FREQ_CPU_MAX + (CHIP_FREQ_CPU_MAX >> 3))) &&
  403c06:	4b19      	ldr	r3, [pc, #100]	; (403c6c <sysclk_init+0xac>)
  403c08:	681b      	ldr	r3, [r3, #0]
  403c0a:	4a19      	ldr	r2, [pc, #100]	; (403c70 <sysclk_init+0xb0>)
  403c0c:	4293      	cmp	r3, r2
  403c0e:	d816      	bhi.n	403c3e <sysclk_init+0x7e>
	(SystemCoreClock >= (CHIP_FREQ_CPU_MAX - (CHIP_FREQ_CPU_MAX >> 3)))) {
  403c10:	4b16      	ldr	r3, [pc, #88]	; (403c6c <sysclk_init+0xac>)
  403c12:	681b      	ldr	r3, [r3, #0]
	if ((SystemCoreClock <= (CHIP_FREQ_CPU_MAX + (CHIP_FREQ_CPU_MAX >> 3))) &&
  403c14:	4a17      	ldr	r2, [pc, #92]	; (403c74 <sysclk_init+0xb4>)
  403c16:	4293      	cmp	r3, r2
  403c18:	d911      	bls.n	403c3e <sysclk_init+0x7e>
		/* Get the trim value from unique ID area */
		efc_perform_read_sequence(EFC, EFC_FCMD_STUI, EFC_FCMD_SPUI,
  403c1a:	1d3a      	adds	r2, r7, #4
  403c1c:	2320      	movs	r3, #32
  403c1e:	9300      	str	r3, [sp, #0]
  403c20:	4613      	mov	r3, r2
  403c22:	220f      	movs	r2, #15
  403c24:	210e      	movs	r1, #14
  403c26:	4814      	ldr	r0, [pc, #80]	; (403c78 <sysclk_init+0xb8>)
  403c28:	4c14      	ldr	r4, [pc, #80]	; (403c7c <sysclk_init+0xbc>)
  403c2a:	47a0      	blx	r4
		unique_id, 32);

		trim_value = unique_id[16] & 0x0000FFFF;
  403c2c:	6c7b      	ldr	r3, [r7, #68]	; 0x44
  403c2e:	b29b      	uxth	r3, r3
  403c30:	f8c7 3084 	str.w	r3, [r7, #132]	; 0x84
		supc_set_regulator_trim_user(SUPC, trim_value);
  403c34:	f8d7 1084 	ldr.w	r1, [r7, #132]	; 0x84
  403c38:	4811      	ldr	r0, [pc, #68]	; (403c80 <sysclk_init+0xc0>)
  403c3a:	4b12      	ldr	r3, [pc, #72]	; (403c84 <sysclk_init+0xc4>)
  403c3c:	4798      	blx	r3

#if (defined CONFIG_SYSCLK_DEFAULT_RETURNS_SLOW_OSC)
	/* Signal that the internal frequencies are setup */
	sysclk_initialized = 1;
#endif
}
  403c3e:	bf00      	nop
  403c40:	378c      	adds	r7, #140	; 0x8c
  403c42:	46bd      	mov	sp, r7
  403c44:	bd90      	pop	{r4, r7, pc}
  403c46:	bf00      	nop
  403c48:	07270e00 	.word	0x07270e00
  403c4c:	004047e9 	.word	0x004047e9
  403c50:	00403b35 	.word	0x00403b35
  403c54:	00403a69 	.word	0x00403a69
  403c58:	00403abd 	.word	0x00403abd
  403c5c:	00403b6d 	.word	0x00403b6d
  403c60:	004041a5 	.word	0x004041a5
  403c64:	004046c5 	.word	0x004046c5
  403c68:	00403bad 	.word	0x00403bad
  403c6c:	2000011c 	.word	0x2000011c
  403c70:	080befc0 	.word	0x080befc0
  403c74:	06422c3f 	.word	0x06422c3f
  403c78:	400e0a00 	.word	0x400e0a00
  403c7c:	2000000b 	.word	0x2000000b
  403c80:	400e1410 	.word	0x400e1410
  403c84:	0040452d 	.word	0x0040452d

00403c88 <sysclk_enable_peripheral_clock>:
{
  403c88:	b580      	push	{r7, lr}
  403c8a:	b082      	sub	sp, #8
  403c8c:	af00      	add	r7, sp, #0
  403c8e:	6078      	str	r0, [r7, #4]
	pmc_enable_periph_clk(ul_id);
  403c90:	6878      	ldr	r0, [r7, #4]
  403c92:	4b03      	ldr	r3, [pc, #12]	; (403ca0 <sysclk_enable_peripheral_clock+0x18>)
  403c94:	4798      	blx	r3
}
  403c96:	bf00      	nop
  403c98:	3708      	adds	r7, #8
  403c9a:	46bd      	mov	sp, r7
  403c9c:	bd80      	pop	{r7, pc}
  403c9e:	bf00      	nop
  403ca0:	00404401 	.word	0x00404401

00403ca4 <ioport_init>:
{
  403ca4:	b580      	push	{r7, lr}
  403ca6:	af00      	add	r7, sp, #0
	sysclk_enable_peripheral_clock(ID_PIOA);
  403ca8:	200b      	movs	r0, #11
  403caa:	4b03      	ldr	r3, [pc, #12]	; (403cb8 <ioport_init+0x14>)
  403cac:	4798      	blx	r3
	sysclk_enable_peripheral_clock(ID_PIOB);
  403cae:	200c      	movs	r0, #12
  403cb0:	4b01      	ldr	r3, [pc, #4]	; (403cb8 <ioport_init+0x14>)
  403cb2:	4798      	blx	r3
}
  403cb4:	bf00      	nop
  403cb6:	bd80      	pop	{r7, pc}
  403cb8:	00403c89 	.word	0x00403c89

00403cbc <ioport_disable_pin>:
{
  403cbc:	b480      	push	{r7}
  403cbe:	b089      	sub	sp, #36	; 0x24
  403cc0:	af00      	add	r7, sp, #0
  403cc2:	6078      	str	r0, [r7, #4]
  403cc4:	687b      	ldr	r3, [r7, #4]
  403cc6:	61fb      	str	r3, [r7, #28]
  403cc8:	69fb      	ldr	r3, [r7, #28]
  403cca:	61bb      	str	r3, [r7, #24]
	return pin >> 5;
  403ccc:	69bb      	ldr	r3, [r7, #24]
  403cce:	095a      	lsrs	r2, r3, #5
  403cd0:	69fb      	ldr	r3, [r7, #28]
  403cd2:	617b      	str	r3, [r7, #20]
	return 1U << (pin & 0x1F);
  403cd4:	697b      	ldr	r3, [r7, #20]
  403cd6:	f003 031f 	and.w	r3, r3, #31
  403cda:	2101      	movs	r1, #1
  403cdc:	fa01 f303 	lsl.w	r3, r1, r3
  403ce0:	613a      	str	r2, [r7, #16]
  403ce2:	60fb      	str	r3, [r7, #12]
  403ce4:	693b      	ldr	r3, [r7, #16]
  403ce6:	60bb      	str	r3, [r7, #8]
	return (Pio *)((uintptr_t)IOPORT_BASE_ADDRESS +
  403ce8:	68bb      	ldr	r3, [r7, #8]
  403cea:	f503 1300 	add.w	r3, r3, #2097152	; 0x200000
  403cee:	f203 7307 	addw	r3, r3, #1799	; 0x707
  403cf2:	025b      	lsls	r3, r3, #9
  403cf4:	461a      	mov	r2, r3
	arch_ioport_port_to_base(port)->PIO_PDR = mask;
  403cf6:	68fb      	ldr	r3, [r7, #12]
  403cf8:	6053      	str	r3, [r2, #4]
}
  403cfa:	bf00      	nop
  403cfc:	3724      	adds	r7, #36	; 0x24
  403cfe:	46bd      	mov	sp, r7
  403d00:	f85d 7b04 	ldr.w	r7, [sp], #4
  403d04:	4770      	bx	lr

00403d06 <ioport_disable_port>:
{
  403d06:	b480      	push	{r7}
  403d08:	b087      	sub	sp, #28
  403d0a:	af00      	add	r7, sp, #0
  403d0c:	6078      	str	r0, [r7, #4]
  403d0e:	6039      	str	r1, [r7, #0]
  403d10:	687b      	ldr	r3, [r7, #4]
  403d12:	617b      	str	r3, [r7, #20]
  403d14:	683b      	ldr	r3, [r7, #0]
  403d16:	613b      	str	r3, [r7, #16]
  403d18:	697b      	ldr	r3, [r7, #20]
  403d1a:	60fb      	str	r3, [r7, #12]
	return (Pio *)((uintptr_t)IOPORT_BASE_ADDRESS +
  403d1c:	68fb      	ldr	r3, [r7, #12]
  403d1e:	f503 1300 	add.w	r3, r3, #2097152	; 0x200000
  403d22:	f203 7307 	addw	r3, r3, #1799	; 0x707
  403d26:	025b      	lsls	r3, r3, #9
  403d28:	461a      	mov	r2, r3
	arch_ioport_port_to_base(port)->PIO_PDR = mask;
  403d2a:	693b      	ldr	r3, [r7, #16]
  403d2c:	6053      	str	r3, [r2, #4]
}
  403d2e:	bf00      	nop
  403d30:	371c      	adds	r7, #28
  403d32:	46bd      	mov	sp, r7
  403d34:	f85d 7b04 	ldr.w	r7, [sp], #4
  403d38:	4770      	bx	lr

00403d3a <ioport_set_port_mode>:
{
  403d3a:	b480      	push	{r7}
  403d3c:	b08b      	sub	sp, #44	; 0x2c
  403d3e:	af00      	add	r7, sp, #0
  403d40:	60f8      	str	r0, [r7, #12]
  403d42:	60b9      	str	r1, [r7, #8]
  403d44:	607a      	str	r2, [r7, #4]
  403d46:	68fb      	ldr	r3, [r7, #12]
  403d48:	627b      	str	r3, [r7, #36]	; 0x24
  403d4a:	68bb      	ldr	r3, [r7, #8]
  403d4c:	623b      	str	r3, [r7, #32]
  403d4e:	687b      	ldr	r3, [r7, #4]
  403d50:	61fb      	str	r3, [r7, #28]
  403d52:	6a7b      	ldr	r3, [r7, #36]	; 0x24
  403d54:	61bb      	str	r3, [r7, #24]
	return (Pio *)((uintptr_t)IOPORT_BASE_ADDRESS +
  403d56:	69bb      	ldr	r3, [r7, #24]
  403d58:	f503 1300 	add.w	r3, r3, #2097152	; 0x200000
  403d5c:	f203 7307 	addw	r3, r3, #1799	; 0x707
  403d60:	025b      	lsls	r3, r3, #9
	Pio *base = arch_ioport_port_to_base(port);
  403d62:	617b      	str	r3, [r7, #20]
	if (mode & IOPORT_MODE_PULLUP) {
  403d64:	69fb      	ldr	r3, [r7, #28]
  403d66:	f003 0308 	and.w	r3, r3, #8
  403d6a:	2b00      	cmp	r3, #0
  403d6c:	d003      	beq.n	403d76 <ioport_set_port_mode+0x3c>
		base->PIO_PUER = mask;
  403d6e:	697b      	ldr	r3, [r7, #20]
  403d70:	6a3a      	ldr	r2, [r7, #32]
  403d72:	665a      	str	r2, [r3, #100]	; 0x64
  403d74:	e002      	b.n	403d7c <ioport_set_port_mode+0x42>
		base->PIO_PUDR = mask;
  403d76:	697b      	ldr	r3, [r7, #20]
  403d78:	6a3a      	ldr	r2, [r7, #32]
  403d7a:	661a      	str	r2, [r3, #96]	; 0x60
	if (mode & IOPORT_MODE_PULLDOWN) {
  403d7c:	69fb      	ldr	r3, [r7, #28]
  403d7e:	f003 0310 	and.w	r3, r3, #16
  403d82:	2b00      	cmp	r3, #0
  403d84:	d004      	beq.n	403d90 <ioport_set_port_mode+0x56>
		base->PIO_PPDER = mask;
  403d86:	697b      	ldr	r3, [r7, #20]
  403d88:	6a3a      	ldr	r2, [r7, #32]
  403d8a:	f8c3 2094 	str.w	r2, [r3, #148]	; 0x94
  403d8e:	e003      	b.n	403d98 <ioport_set_port_mode+0x5e>
		base->PIO_PPDDR = mask;
  403d90:	697b      	ldr	r3, [r7, #20]
  403d92:	6a3a      	ldr	r2, [r7, #32]
  403d94:	f8c3 2090 	str.w	r2, [r3, #144]	; 0x90
	if (mode & IOPORT_MODE_OPEN_DRAIN) {
  403d98:	69fb      	ldr	r3, [r7, #28]
  403d9a:	f003 0320 	and.w	r3, r3, #32
  403d9e:	2b00      	cmp	r3, #0
  403da0:	d003      	beq.n	403daa <ioport_set_port_mode+0x70>
		base->PIO_MDER = mask;
  403da2:	697b      	ldr	r3, [r7, #20]
  403da4:	6a3a      	ldr	r2, [r7, #32]
  403da6:	651a      	str	r2, [r3, #80]	; 0x50
  403da8:	e002      	b.n	403db0 <ioport_set_port_mode+0x76>
		base->PIO_MDDR = mask;
  403daa:	697b      	ldr	r3, [r7, #20]
  403dac:	6a3a      	ldr	r2, [r7, #32]
  403dae:	655a      	str	r2, [r3, #84]	; 0x54
	if (mode & (IOPORT_MODE_GLITCH_FILTER | IOPORT_MODE_DEBOUNCE)) {
  403db0:	69fb      	ldr	r3, [r7, #28]
  403db2:	f003 03c0 	and.w	r3, r3, #192	; 0xc0
  403db6:	2b00      	cmp	r3, #0
  403db8:	d003      	beq.n	403dc2 <ioport_set_port_mode+0x88>
		base->PIO_IFER = mask;
  403dba:	697b      	ldr	r3, [r7, #20]
  403dbc:	6a3a      	ldr	r2, [r7, #32]
  403dbe:	621a      	str	r2, [r3, #32]
  403dc0:	e002      	b.n	403dc8 <ioport_set_port_mode+0x8e>
		base->PIO_IFDR = mask;
  403dc2:	697b      	ldr	r3, [r7, #20]
  403dc4:	6a3a      	ldr	r2, [r7, #32]
  403dc6:	625a      	str	r2, [r3, #36]	; 0x24
	if (mode & IOPORT_MODE_DEBOUNCE) {
  403dc8:	69fb      	ldr	r3, [r7, #28]
  403dca:	f003 0380 	and.w	r3, r3, #128	; 0x80
  403dce:	2b00      	cmp	r3, #0
  403dd0:	d004      	beq.n	403ddc <ioport_set_port_mode+0xa2>
		base->PIO_IFSCER = mask;
  403dd2:	697b      	ldr	r3, [r7, #20]
  403dd4:	6a3a      	ldr	r2, [r7, #32]
  403dd6:	f8c3 2084 	str.w	r2, [r3, #132]	; 0x84
  403dda:	e003      	b.n	403de4 <ioport_set_port_mode+0xaa>
		base->PIO_IFSCDR = mask;
  403ddc:	697b      	ldr	r3, [r7, #20]
  403dde:	6a3a      	ldr	r2, [r7, #32]
  403de0:	f8c3 2080 	str.w	r2, [r3, #128]	; 0x80
	if (mode & IOPORT_MODE_MUX_BIT0) {
  403de4:	69fb      	ldr	r3, [r7, #28]
  403de6:	f003 0301 	and.w	r3, r3, #1
  403dea:	2b00      	cmp	r3, #0
  403dec:	d006      	beq.n	403dfc <ioport_set_port_mode+0xc2>
		base->PIO_ABCDSR[0] |= mask;
  403dee:	697b      	ldr	r3, [r7, #20]
  403df0:	6f1a      	ldr	r2, [r3, #112]	; 0x70
  403df2:	6a3b      	ldr	r3, [r7, #32]
  403df4:	431a      	orrs	r2, r3
  403df6:	697b      	ldr	r3, [r7, #20]
  403df8:	671a      	str	r2, [r3, #112]	; 0x70
  403dfa:	e006      	b.n	403e0a <ioport_set_port_mode+0xd0>
		base->PIO_ABCDSR[0] &= ~mask;
  403dfc:	697b      	ldr	r3, [r7, #20]
  403dfe:	6f1a      	ldr	r2, [r3, #112]	; 0x70
  403e00:	6a3b      	ldr	r3, [r7, #32]
  403e02:	43db      	mvns	r3, r3
  403e04:	401a      	ands	r2, r3
  403e06:	697b      	ldr	r3, [r7, #20]
  403e08:	671a      	str	r2, [r3, #112]	; 0x70
	if (mode & IOPORT_MODE_MUX_BIT1) {
  403e0a:	69fb      	ldr	r3, [r7, #28]
  403e0c:	f003 0302 	and.w	r3, r3, #2
  403e10:	2b00      	cmp	r3, #0
  403e12:	d006      	beq.n	403e22 <ioport_set_port_mode+0xe8>
		base->PIO_ABCDSR[1] |= mask;
  403e14:	697b      	ldr	r3, [r7, #20]
  403e16:	6f5a      	ldr	r2, [r3, #116]	; 0x74
  403e18:	6a3b      	ldr	r3, [r7, #32]
  403e1a:	431a      	orrs	r2, r3
  403e1c:	697b      	ldr	r3, [r7, #20]
  403e1e:	675a      	str	r2, [r3, #116]	; 0x74
}
  403e20:	e006      	b.n	403e30 <ioport_set_port_mode+0xf6>
		base->PIO_ABCDSR[1] &= ~mask;
  403e22:	697b      	ldr	r3, [r7, #20]
  403e24:	6f5a      	ldr	r2, [r3, #116]	; 0x74
  403e26:	6a3b      	ldr	r3, [r7, #32]
  403e28:	43db      	mvns	r3, r3
  403e2a:	401a      	ands	r2, r3
  403e2c:	697b      	ldr	r3, [r7, #20]
  403e2e:	675a      	str	r2, [r3, #116]	; 0x74
  403e30:	bf00      	nop
  403e32:	372c      	adds	r7, #44	; 0x2c
  403e34:	46bd      	mov	sp, r7
  403e36:	f85d 7b04 	ldr.w	r7, [sp], #4
  403e3a:	4770      	bx	lr

00403e3c <ioport_set_pin_mode>:
{
  403e3c:	b480      	push	{r7}
  403e3e:	b08d      	sub	sp, #52	; 0x34
  403e40:	af00      	add	r7, sp, #0
  403e42:	6078      	str	r0, [r7, #4]
  403e44:	6039      	str	r1, [r7, #0]
  403e46:	687b      	ldr	r3, [r7, #4]
  403e48:	62fb      	str	r3, [r7, #44]	; 0x2c
  403e4a:	683b      	ldr	r3, [r7, #0]
  403e4c:	62bb      	str	r3, [r7, #40]	; 0x28
  403e4e:	6afb      	ldr	r3, [r7, #44]	; 0x2c
  403e50:	627b      	str	r3, [r7, #36]	; 0x24
	return pin >> 5;
  403e52:	6a7b      	ldr	r3, [r7, #36]	; 0x24
  403e54:	095a      	lsrs	r2, r3, #5
  403e56:	6afb      	ldr	r3, [r7, #44]	; 0x2c
  403e58:	623b      	str	r3, [r7, #32]
	return 1U << (pin & 0x1F);
  403e5a:	6a3b      	ldr	r3, [r7, #32]
  403e5c:	f003 031f 	and.w	r3, r3, #31
  403e60:	2101      	movs	r1, #1
  403e62:	fa01 f303 	lsl.w	r3, r1, r3
  403e66:	61fa      	str	r2, [r7, #28]
  403e68:	61bb      	str	r3, [r7, #24]
  403e6a:	6abb      	ldr	r3, [r7, #40]	; 0x28
  403e6c:	617b      	str	r3, [r7, #20]
  403e6e:	69fb      	ldr	r3, [r7, #28]
  403e70:	613b      	str	r3, [r7, #16]
	return (Pio *)((uintptr_t)IOPORT_BASE_ADDRESS +
  403e72:	693b      	ldr	r3, [r7, #16]
  403e74:	f503 1300 	add.w	r3, r3, #2097152	; 0x200000
  403e78:	f203 7307 	addw	r3, r3, #1799	; 0x707
  403e7c:	025b      	lsls	r3, r3, #9
	Pio *base = arch_ioport_port_to_base(port);
  403e7e:	60fb      	str	r3, [r7, #12]
	if (mode & IOPORT_MODE_PULLUP) {
  403e80:	697b      	ldr	r3, [r7, #20]
  403e82:	f003 0308 	and.w	r3, r3, #8
  403e86:	2b00      	cmp	r3, #0
  403e88:	d003      	beq.n	403e92 <ioport_set_pin_mode+0x56>
		base->PIO_PUER = mask;
  403e8a:	68fb      	ldr	r3, [r7, #12]
  403e8c:	69ba      	ldr	r2, [r7, #24]
  403e8e:	665a      	str	r2, [r3, #100]	; 0x64
  403e90:	e002      	b.n	403e98 <ioport_set_pin_mode+0x5c>
		base->PIO_PUDR = mask;
  403e92:	68fb      	ldr	r3, [r7, #12]
  403e94:	69ba      	ldr	r2, [r7, #24]
  403e96:	661a      	str	r2, [r3, #96]	; 0x60
	if (mode & IOPORT_MODE_PULLDOWN) {
  403e98:	697b      	ldr	r3, [r7, #20]
  403e9a:	f003 0310 	and.w	r3, r3, #16
  403e9e:	2b00      	cmp	r3, #0
  403ea0:	d004      	beq.n	403eac <ioport_set_pin_mode+0x70>
		base->PIO_PPDER = mask;
  403ea2:	68fb      	ldr	r3, [r7, #12]
  403ea4:	69ba      	ldr	r2, [r7, #24]
  403ea6:	f8c3 2094 	str.w	r2, [r3, #148]	; 0x94
  403eaa:	e003      	b.n	403eb4 <ioport_set_pin_mode+0x78>
		base->PIO_PPDDR = mask;
  403eac:	68fb      	ldr	r3, [r7, #12]
  403eae:	69ba      	ldr	r2, [r7, #24]
  403eb0:	f8c3 2090 	str.w	r2, [r3, #144]	; 0x90
	if (mode & IOPORT_MODE_OPEN_DRAIN) {
  403eb4:	697b      	ldr	r3, [r7, #20]
  403eb6:	f003 0320 	and.w	r3, r3, #32
  403eba:	2b00      	cmp	r3, #0
  403ebc:	d003      	beq.n	403ec6 <ioport_set_pin_mode+0x8a>
		base->PIO_MDER = mask;
  403ebe:	68fb      	ldr	r3, [r7, #12]
  403ec0:	69ba      	ldr	r2, [r7, #24]
  403ec2:	651a      	str	r2, [r3, #80]	; 0x50
  403ec4:	e002      	b.n	403ecc <ioport_set_pin_mode+0x90>
		base->PIO_MDDR = mask;
  403ec6:	68fb      	ldr	r3, [r7, #12]
  403ec8:	69ba      	ldr	r2, [r7, #24]
  403eca:	655a      	str	r2, [r3, #84]	; 0x54
	if (mode & (IOPORT_MODE_GLITCH_FILTER | IOPORT_MODE_DEBOUNCE)) {
  403ecc:	697b      	ldr	r3, [r7, #20]
  403ece:	f003 03c0 	and.w	r3, r3, #192	; 0xc0
  403ed2:	2b00      	cmp	r3, #0
  403ed4:	d003      	beq.n	403ede <ioport_set_pin_mode+0xa2>
		base->PIO_IFER = mask;
  403ed6:	68fb      	ldr	r3, [r7, #12]
  403ed8:	69ba      	ldr	r2, [r7, #24]
  403eda:	621a      	str	r2, [r3, #32]
  403edc:	e002      	b.n	403ee4 <ioport_set_pin_mode+0xa8>
		base->PIO_IFDR = mask;
  403ede:	68fb      	ldr	r3, [r7, #12]
  403ee0:	69ba      	ldr	r2, [r7, #24]
  403ee2:	625a      	str	r2, [r3, #36]	; 0x24
	if (mode & IOPORT_MODE_DEBOUNCE) {
  403ee4:	697b      	ldr	r3, [r7, #20]
  403ee6:	f003 0380 	and.w	r3, r3, #128	; 0x80
  403eea:	2b00      	cmp	r3, #0
  403eec:	d004      	beq.n	403ef8 <ioport_set_pin_mode+0xbc>
		base->PIO_IFSCER = mask;
  403eee:	68fb      	ldr	r3, [r7, #12]
  403ef0:	69ba      	ldr	r2, [r7, #24]
  403ef2:	f8c3 2084 	str.w	r2, [r3, #132]	; 0x84
  403ef6:	e003      	b.n	403f00 <ioport_set_pin_mode+0xc4>
		base->PIO_IFSCDR = mask;
  403ef8:	68fb      	ldr	r3, [r7, #12]
  403efa:	69ba      	ldr	r2, [r7, #24]
  403efc:	f8c3 2080 	str.w	r2, [r3, #128]	; 0x80
	if (mode & IOPORT_MODE_MUX_BIT0) {
  403f00:	697b      	ldr	r3, [r7, #20]
  403f02:	f003 0301 	and.w	r3, r3, #1
  403f06:	2b00      	cmp	r3, #0
  403f08:	d006      	beq.n	403f18 <ioport_set_pin_mode+0xdc>
		base->PIO_ABCDSR[0] |= mask;
  403f0a:	68fb      	ldr	r3, [r7, #12]
  403f0c:	6f1a      	ldr	r2, [r3, #112]	; 0x70
  403f0e:	69bb      	ldr	r3, [r7, #24]
  403f10:	431a      	orrs	r2, r3
  403f12:	68fb      	ldr	r3, [r7, #12]
  403f14:	671a      	str	r2, [r3, #112]	; 0x70
  403f16:	e006      	b.n	403f26 <ioport_set_pin_mode+0xea>
		base->PIO_ABCDSR[0] &= ~mask;
  403f18:	68fb      	ldr	r3, [r7, #12]
  403f1a:	6f1a      	ldr	r2, [r3, #112]	; 0x70
  403f1c:	69bb      	ldr	r3, [r7, #24]
  403f1e:	43db      	mvns	r3, r3
  403f20:	401a      	ands	r2, r3
  403f22:	68fb      	ldr	r3, [r7, #12]
  403f24:	671a      	str	r2, [r3, #112]	; 0x70
	if (mode & IOPORT_MODE_MUX_BIT1) {
  403f26:	697b      	ldr	r3, [r7, #20]
  403f28:	f003 0302 	and.w	r3, r3, #2
  403f2c:	2b00      	cmp	r3, #0
  403f2e:	d006      	beq.n	403f3e <ioport_set_pin_mode+0x102>
		base->PIO_ABCDSR[1] |= mask;
  403f30:	68fb      	ldr	r3, [r7, #12]
  403f32:	6f5a      	ldr	r2, [r3, #116]	; 0x74
  403f34:	69bb      	ldr	r3, [r7, #24]
  403f36:	431a      	orrs	r2, r3
  403f38:	68fb      	ldr	r3, [r7, #12]
  403f3a:	675a      	str	r2, [r3, #116]	; 0x74
}
  403f3c:	e006      	b.n	403f4c <ioport_set_pin_mode+0x110>
		base->PIO_ABCDSR[1] &= ~mask;
  403f3e:	68fb      	ldr	r3, [r7, #12]
  403f40:	6f5a      	ldr	r2, [r3, #116]	; 0x74
  403f42:	69bb      	ldr	r3, [r7, #24]
  403f44:	43db      	mvns	r3, r3
  403f46:	401a      	ands	r2, r3
  403f48:	68fb      	ldr	r3, [r7, #12]
  403f4a:	675a      	str	r2, [r3, #116]	; 0x74
  403f4c:	bf00      	nop
  403f4e:	3734      	adds	r7, #52	; 0x34
  403f50:	46bd      	mov	sp, r7
  403f52:	f85d 7b04 	ldr.w	r7, [sp], #4
  403f56:	4770      	bx	lr

00403f58 <ioport_set_pin_dir>:
{
  403f58:	b480      	push	{r7}
  403f5a:	b08d      	sub	sp, #52	; 0x34
  403f5c:	af00      	add	r7, sp, #0
  403f5e:	6078      	str	r0, [r7, #4]
  403f60:	460b      	mov	r3, r1
  403f62:	70fb      	strb	r3, [r7, #3]
  403f64:	687b      	ldr	r3, [r7, #4]
  403f66:	62fb      	str	r3, [r7, #44]	; 0x2c
  403f68:	78fb      	ldrb	r3, [r7, #3]
  403f6a:	f887 302b 	strb.w	r3, [r7, #43]	; 0x2b
  403f6e:	6afb      	ldr	r3, [r7, #44]	; 0x2c
  403f70:	627b      	str	r3, [r7, #36]	; 0x24
  403f72:	6a7b      	ldr	r3, [r7, #36]	; 0x24
  403f74:	623b      	str	r3, [r7, #32]
	return pin >> 5;
  403f76:	6a3b      	ldr	r3, [r7, #32]
  403f78:	095b      	lsrs	r3, r3, #5
  403f7a:	61fb      	str	r3, [r7, #28]
	return (Pio *)((uintptr_t)IOPORT_BASE_ADDRESS +
  403f7c:	69fb      	ldr	r3, [r7, #28]
  403f7e:	f503 1300 	add.w	r3, r3, #2097152	; 0x200000
  403f82:	f203 7307 	addw	r3, r3, #1799	; 0x707
  403f86:	025b      	lsls	r3, r3, #9
	Pio *base = arch_ioport_pin_to_base(pin);
  403f88:	61bb      	str	r3, [r7, #24]
	if (dir == IOPORT_DIR_OUTPUT) {
  403f8a:	f897 302b 	ldrb.w	r3, [r7, #43]	; 0x2b
  403f8e:	2b01      	cmp	r3, #1
  403f90:	d109      	bne.n	403fa6 <ioport_set_pin_dir+0x4e>
  403f92:	6afb      	ldr	r3, [r7, #44]	; 0x2c
  403f94:	617b      	str	r3, [r7, #20]
	return 1U << (pin & 0x1F);
  403f96:	697b      	ldr	r3, [r7, #20]
  403f98:	f003 031f 	and.w	r3, r3, #31
  403f9c:	2201      	movs	r2, #1
  403f9e:	409a      	lsls	r2, r3
		base->PIO_OER = arch_ioport_pin_to_mask(pin);
  403fa0:	69bb      	ldr	r3, [r7, #24]
  403fa2:	611a      	str	r2, [r3, #16]
  403fa4:	e00c      	b.n	403fc0 <ioport_set_pin_dir+0x68>
	} else if (dir == IOPORT_DIR_INPUT) {
  403fa6:	f897 302b 	ldrb.w	r3, [r7, #43]	; 0x2b
  403faa:	2b00      	cmp	r3, #0
  403fac:	d108      	bne.n	403fc0 <ioport_set_pin_dir+0x68>
  403fae:	6afb      	ldr	r3, [r7, #44]	; 0x2c
  403fb0:	613b      	str	r3, [r7, #16]
	return 1U << (pin & 0x1F);
  403fb2:	693b      	ldr	r3, [r7, #16]
  403fb4:	f003 031f 	and.w	r3, r3, #31
  403fb8:	2201      	movs	r2, #1
  403fba:	409a      	lsls	r2, r3
		base->PIO_ODR = arch_ioport_pin_to_mask(pin);
  403fbc:	69bb      	ldr	r3, [r7, #24]
  403fbe:	615a      	str	r2, [r3, #20]
  403fc0:	6afb      	ldr	r3, [r7, #44]	; 0x2c
  403fc2:	60fb      	str	r3, [r7, #12]
	return 1U << (pin & 0x1F);
  403fc4:	68fb      	ldr	r3, [r7, #12]
  403fc6:	f003 031f 	and.w	r3, r3, #31
  403fca:	2201      	movs	r2, #1
  403fcc:	409a      	lsls	r2, r3
	base->PIO_OWER = arch_ioport_pin_to_mask(pin);
  403fce:	69bb      	ldr	r3, [r7, #24]
  403fd0:	f8c3 20a0 	str.w	r2, [r3, #160]	; 0xa0
}
  403fd4:	bf00      	nop
  403fd6:	3734      	adds	r7, #52	; 0x34
  403fd8:	46bd      	mov	sp, r7
  403fda:	f85d 7b04 	ldr.w	r7, [sp], #4
  403fde:	4770      	bx	lr

00403fe0 <ioport_set_pin_level>:
{
  403fe0:	b480      	push	{r7}
  403fe2:	b08b      	sub	sp, #44	; 0x2c
  403fe4:	af00      	add	r7, sp, #0
  403fe6:	6078      	str	r0, [r7, #4]
  403fe8:	460b      	mov	r3, r1
  403fea:	70fb      	strb	r3, [r7, #3]
  403fec:	687b      	ldr	r3, [r7, #4]
  403fee:	627b      	str	r3, [r7, #36]	; 0x24
  403ff0:	78fb      	ldrb	r3, [r7, #3]
  403ff2:	f887 3023 	strb.w	r3, [r7, #35]	; 0x23
  403ff6:	6a7b      	ldr	r3, [r7, #36]	; 0x24
  403ff8:	61fb      	str	r3, [r7, #28]
  403ffa:	69fb      	ldr	r3, [r7, #28]
  403ffc:	61bb      	str	r3, [r7, #24]
	return pin >> 5;
  403ffe:	69bb      	ldr	r3, [r7, #24]
  404000:	095b      	lsrs	r3, r3, #5
  404002:	617b      	str	r3, [r7, #20]
	return (Pio *)((uintptr_t)IOPORT_BASE_ADDRESS +
  404004:	697b      	ldr	r3, [r7, #20]
  404006:	f503 1300 	add.w	r3, r3, #2097152	; 0x200000
  40400a:	f203 7307 	addw	r3, r3, #1799	; 0x707
  40400e:	025b      	lsls	r3, r3, #9
	Pio *base = arch_ioport_pin_to_base(pin);
  404010:	613b      	str	r3, [r7, #16]
	if (level) {
  404012:	f897 3023 	ldrb.w	r3, [r7, #35]	; 0x23
  404016:	2b00      	cmp	r3, #0
  404018:	d009      	beq.n	40402e <ioport_set_pin_level+0x4e>
  40401a:	6a7b      	ldr	r3, [r7, #36]	; 0x24
  40401c:	60fb      	str	r3, [r7, #12]
	return 1U << (pin & 0x1F);
  40401e:	68fb      	ldr	r3, [r7, #12]
  404020:	f003 031f 	and.w	r3, r3, #31
  404024:	2201      	movs	r2, #1
  404026:	409a      	lsls	r2, r3
		base->PIO_SODR = arch_ioport_pin_to_mask(pin);
  404028:	693b      	ldr	r3, [r7, #16]
  40402a:	631a      	str	r2, [r3, #48]	; 0x30
}
  40402c:	e008      	b.n	404040 <ioport_set_pin_level+0x60>
  40402e:	6a7b      	ldr	r3, [r7, #36]	; 0x24
  404030:	60bb      	str	r3, [r7, #8]
	return 1U << (pin & 0x1F);
  404032:	68bb      	ldr	r3, [r7, #8]
  404034:	f003 031f 	and.w	r3, r3, #31
  404038:	2201      	movs	r2, #1
  40403a:	409a      	lsls	r2, r3
		base->PIO_CODR = arch_ioport_pin_to_mask(pin);
  40403c:	693b      	ldr	r3, [r7, #16]
  40403e:	635a      	str	r2, [r3, #52]	; 0x34
  404040:	bf00      	nop
  404042:	372c      	adds	r7, #44	; 0x2c
  404044:	46bd      	mov	sp, r7
  404046:	f85d 7b04 	ldr.w	r7, [sp], #4
  40404a:	4770      	bx	lr

0040404c <system_board_init>:
void board_init(void);
#  pragma weak board_init=system_board_init
#endif

void system_board_init(void)
{
  40404c:	b580      	push	{r7, lr}
  40404e:	af00      	add	r7, sp, #0

#ifndef CONF_BOARD_KEEP_WATCHDOG_AT_INIT
	WDT->WDT_MR = WDT_MR_WDDIS;
  404050:	4b4c      	ldr	r3, [pc, #304]	; (404184 <system_board_init+0x138>)
  404052:	f44f 4200 	mov.w	r2, #32768	; 0x8000
  404056:	605a      	str	r2, [r3, #4]
#endif
	ioport_init();
  404058:	4b4b      	ldr	r3, [pc, #300]	; (404188 <system_board_init+0x13c>)
  40405a:	4798      	blx	r3

	/* Initialize LED0, turned off */
	ioport_set_pin_dir(LED_0_PIN, IOPORT_DIR_OUTPUT);
  40405c:	2101      	movs	r1, #1
  40405e:	2006      	movs	r0, #6
  404060:	4b4a      	ldr	r3, [pc, #296]	; (40418c <system_board_init+0x140>)
  404062:	4798      	blx	r3
	ioport_set_pin_level(LED_0_PIN, IOPORT_PIN_LEVEL_HIGH);
  404064:	2101      	movs	r1, #1
  404066:	2006      	movs	r0, #6
  404068:	4b49      	ldr	r3, [pc, #292]	; (404190 <system_board_init+0x144>)
  40406a:	4798      	blx	r3

	/* Initialize SW0 */
	ioport_set_pin_dir(BUTTON_0_PIN, IOPORT_DIR_INPUT);
  40406c:	2100      	movs	r1, #0
  40406e:	2002      	movs	r0, #2
  404070:	4b46      	ldr	r3, [pc, #280]	; (40418c <system_board_init+0x140>)
  404072:	4798      	blx	r3
	ioport_set_pin_mode(BUTTON_0_PIN, IOPORT_MODE_PULLUP);
  404074:	2108      	movs	r1, #8
  404076:	2002      	movs	r0, #2
  404078:	4b46      	ldr	r3, [pc, #280]	; (404194 <system_board_init+0x148>)
  40407a:	4798      	blx	r3

	/* Initialize EXT3 LED0, LED1 & LED2, turned off */
	ioport_set_pin_level(OLED1_LED1_PIN, !OLED1_LED1_ACTIVE);
  40407c:	2101      	movs	r1, #1
  40407e:	2001      	movs	r0, #1
  404080:	4b43      	ldr	r3, [pc, #268]	; (404190 <system_board_init+0x144>)
  404082:	4798      	blx	r3
	ioport_set_pin_dir(OLED1_LED1_PIN, IOPORT_DIR_OUTPUT);
  404084:	2101      	movs	r1, #1
  404086:	2001      	movs	r0, #1
  404088:	4b40      	ldr	r3, [pc, #256]	; (40418c <system_board_init+0x140>)
  40408a:	4798      	blx	r3
	ioport_set_pin_level(OLED1_LED2_PIN, !OLED1_LED2_ACTIVE);
  40408c:	2101      	movs	r1, #1
  40408e:	202d      	movs	r0, #45	; 0x2d
  404090:	4b3f      	ldr	r3, [pc, #252]	; (404190 <system_board_init+0x144>)
  404092:	4798      	blx	r3
	ioport_set_pin_dir(OLED1_LED2_PIN, IOPORT_DIR_OUTPUT);
  404094:	2101      	movs	r1, #1
  404096:	202d      	movs	r0, #45	; 0x2d
  404098:	4b3c      	ldr	r3, [pc, #240]	; (40418c <system_board_init+0x140>)
  40409a:	4798      	blx	r3
	ioport_set_pin_level(OLED1_LED3_PIN, !OLED1_LED3_ACTIVE);
  40409c:	2101      	movs	r1, #1
  40409e:	202f      	movs	r0, #47	; 0x2f
  4040a0:	4b3b      	ldr	r3, [pc, #236]	; (404190 <system_board_init+0x144>)
  4040a2:	4798      	blx	r3
	ioport_set_pin_dir(OLED1_LED3_PIN, IOPORT_DIR_OUTPUT);
  4040a4:	2101      	movs	r1, #1
  4040a6:	202f      	movs	r0, #47	; 0x2f
  4040a8:	4b38      	ldr	r3, [pc, #224]	; (40418c <system_board_init+0x140>)
  4040aa:	4798      	blx	r3

#if defined (CONF_BOARD_UART_CONSOLE)
	/* Configure UART pins */
	ioport_set_port_peripheral_mode(PINS_USART0_PORT, PINS_USART0, PINS_USART0_FLAGS);
  4040ac:	2201      	movs	r2, #1
  4040ae:	f44f 61c0 	mov.w	r1, #1536	; 0x600
  4040b2:	2000      	movs	r0, #0
  4040b4:	4b38      	ldr	r3, [pc, #224]	; (404198 <system_board_init+0x14c>)
  4040b6:	4798      	blx	r3
  4040b8:	f44f 61c0 	mov.w	r1, #1536	; 0x600
  4040bc:	2000      	movs	r0, #0
  4040be:	4b37      	ldr	r3, [pc, #220]	; (40419c <system_board_init+0x150>)
  4040c0:	4798      	blx	r3
	ioport_set_port_peripheral_mode(PINS_USART7_PORT, PINS_USART7, PINS_USART7_FLAGS);
  4040c2:	2201      	movs	r2, #1
  4040c4:	f04f 51c0 	mov.w	r1, #402653184	; 0x18000000
  4040c8:	2000      	movs	r0, #0
  4040ca:	4b33      	ldr	r3, [pc, #204]	; (404198 <system_board_init+0x14c>)
  4040cc:	4798      	blx	r3
  4040ce:	f04f 51c0 	mov.w	r1, #402653184	; 0x18000000
  4040d2:	2000      	movs	r0, #0
  4040d4:	4b31      	ldr	r3, [pc, #196]	; (40419c <system_board_init+0x150>)
  4040d6:	4798      	blx	r3
	ioport_set_pin_peripheral_mode(EXT3_PIN_8,
			IOPORT_MODE_MUX_B);
#endif

#if defined(CONF_BOARD_SPI) || defined(CONF_BOARD_SD_MMC_SPI)
	ioport_set_pin_peripheral_mode(SPI_MISO_GPIO, SPI_MISO_FLAGS);
  4040d8:	2100      	movs	r1, #0
  4040da:	200c      	movs	r0, #12
  4040dc:	4b2d      	ldr	r3, [pc, #180]	; (404194 <system_board_init+0x148>)
  4040de:	4798      	blx	r3
  4040e0:	200c      	movs	r0, #12
  4040e2:	4b2f      	ldr	r3, [pc, #188]	; (4041a0 <system_board_init+0x154>)
  4040e4:	4798      	blx	r3
	ioport_set_pin_peripheral_mode(SPI_MOSI_GPIO, SPI_MOSI_FLAGS);
  4040e6:	2100      	movs	r1, #0
  4040e8:	200d      	movs	r0, #13
  4040ea:	4b2a      	ldr	r3, [pc, #168]	; (404194 <system_board_init+0x148>)
  4040ec:	4798      	blx	r3
  4040ee:	200d      	movs	r0, #13
  4040f0:	4b2b      	ldr	r3, [pc, #172]	; (4041a0 <system_board_init+0x154>)
  4040f2:	4798      	blx	r3
	ioport_set_pin_peripheral_mode(SPI_SPCK_GPIO, SPI_SPCK_FLAGS);
  4040f4:	2100      	movs	r1, #0
  4040f6:	200e      	movs	r0, #14
  4040f8:	4b26      	ldr	r3, [pc, #152]	; (404194 <system_board_init+0x148>)
  4040fa:	4798      	blx	r3
  4040fc:	200e      	movs	r0, #14
  4040fe:	4b28      	ldr	r3, [pc, #160]	; (4041a0 <system_board_init+0x154>)
  404100:	4798      	blx	r3
	ioport_set_pin_dir(SD_MMC_0_CD_GPIO, IOPORT_DIR_INPUT);
	ioport_set_pin_mode(SD_MMC_0_CD_GPIO, IOPORT_MODE_PULLUP);
#endif

#ifdef CONF_BOARD_SPI_NPCS0
	ioport_set_pin_peripheral_mode(SPI_NPCS0_GPIO, SPI_NPCS0_FLAGS);
  404102:	2100      	movs	r1, #0
  404104:	200b      	movs	r0, #11
  404106:	4b23      	ldr	r3, [pc, #140]	; (404194 <system_board_init+0x148>)
  404108:	4798      	blx	r3
  40410a:	200b      	movs	r0, #11
  40410c:	4b24      	ldr	r3, [pc, #144]	; (4041a0 <system_board_init+0x154>)
  40410e:	4798      	blx	r3
#endif

#ifdef CONF_BOARD_SPI_NPCS1
	ioport_set_pin_peripheral_mode(SPI_NPCS1_GPIO, SPI_NPCS1_FLAGS);
  404110:	2101      	movs	r1, #1
  404112:	2005      	movs	r0, #5
  404114:	4b1f      	ldr	r3, [pc, #124]	; (404194 <system_board_init+0x148>)
  404116:	4798      	blx	r3
  404118:	2005      	movs	r0, #5
  40411a:	4b21      	ldr	r3, [pc, #132]	; (4041a0 <system_board_init+0x154>)
  40411c:	4798      	blx	r3
	ioport_set_pin_peripheral_mode(TWI2_DATA_GPIO, TWI2_DATA_FLAGS);
	ioport_set_pin_peripheral_mode(TWI2_CLK_GPIO, TWI2_CLK_FLAGS);
#endif

#if defined(CONF_BOARD_TWI4) ||defined(CONF_BOARD_AT30TSE)
	ioport_set_pin_peripheral_mode(TWI4_DATA_GPIO, TWI4_DATA_FLAGS);
  40411e:	2100      	movs	r1, #0
  404120:	2028      	movs	r0, #40	; 0x28
  404122:	4b1c      	ldr	r3, [pc, #112]	; (404194 <system_board_init+0x148>)
  404124:	4798      	blx	r3
  404126:	2028      	movs	r0, #40	; 0x28
  404128:	4b1d      	ldr	r3, [pc, #116]	; (4041a0 <system_board_init+0x154>)
  40412a:	4798      	blx	r3
	ioport_set_pin_peripheral_mode(TWI4_CLK_GPIO, TWI4_CLK_FLAGS);
  40412c:	2100      	movs	r1, #0
  40412e:	2029      	movs	r0, #41	; 0x29
  404130:	4b18      	ldr	r3, [pc, #96]	; (404194 <system_board_init+0x148>)
  404132:	4798      	blx	r3
  404134:	2029      	movs	r0, #41	; 0x29
  404136:	4b1a      	ldr	r3, [pc, #104]	; (4041a0 <system_board_init+0x154>)
  404138:	4798      	blx	r3
	ioport_set_pin_peripheral_mode(PDM_CLK_GPIO, PDM_CLK_FLAGS);
	ioport_set_pin_peripheral_mode(PDM_DAT_GPIO, PDM_DAT_FLAGS);
#endif

#ifdef CONF_BOARD_USART0
	ioport_set_pin_peripheral_mode(USART0_RXD_GPIO, USART0_RXD_FLAGS);
  40413a:	2100      	movs	r1, #0
  40413c:	2009      	movs	r0, #9
  40413e:	4b15      	ldr	r3, [pc, #84]	; (404194 <system_board_init+0x148>)
  404140:	4798      	blx	r3
  404142:	2009      	movs	r0, #9
  404144:	4b16      	ldr	r3, [pc, #88]	; (4041a0 <system_board_init+0x154>)
  404146:	4798      	blx	r3
	ioport_set_pin_peripheral_mode(USART0_TXD_GPIO, USART0_TXD_FLAGS);
  404148:	2100      	movs	r1, #0
  40414a:	200a      	movs	r0, #10
  40414c:	4b11      	ldr	r3, [pc, #68]	; (404194 <system_board_init+0x148>)
  40414e:	4798      	blx	r3
  404150:	200a      	movs	r0, #10
  404152:	4b13      	ldr	r3, [pc, #76]	; (4041a0 <system_board_init+0x154>)
  404154:	4798      	blx	r3
	ioport_set_pin_peripheral_mode(USART0_SCK_GPIO, USART0_SCK_FLAGS);
  404156:	2100      	movs	r1, #0
  404158:	2020      	movs	r0, #32
  40415a:	4b0e      	ldr	r3, [pc, #56]	; (404194 <system_board_init+0x148>)
  40415c:	4798      	blx	r3
  40415e:	2020      	movs	r0, #32
  404160:	4b0f      	ldr	r3, [pc, #60]	; (4041a0 <system_board_init+0x154>)
  404162:	4798      	blx	r3
	ioport_set_pin_peripheral_mode(USART0_CTS_GPIO, USART0_CTS_FLAGS);
  404164:	2100      	movs	r1, #0
  404166:	2019      	movs	r0, #25
  404168:	4b0a      	ldr	r3, [pc, #40]	; (404194 <system_board_init+0x148>)
  40416a:	4798      	blx	r3
  40416c:	2019      	movs	r0, #25
  40416e:	4b0c      	ldr	r3, [pc, #48]	; (4041a0 <system_board_init+0x154>)
  404170:	4798      	blx	r3
	ioport_set_pin_peripheral_mode(USART0_RTS_GPIO, USART0_RTS_FLAGS);
  404172:	2100      	movs	r1, #0
  404174:	201a      	movs	r0, #26
  404176:	4b07      	ldr	r3, [pc, #28]	; (404194 <system_board_init+0x148>)
  404178:	4798      	blx	r3
  40417a:	201a      	movs	r0, #26
  40417c:	4b08      	ldr	r3, [pc, #32]	; (4041a0 <system_board_init+0x154>)
  40417e:	4798      	blx	r3
#if defined(CONF_BOARD_USB_PORT)
#  if defined(CONF_BOARD_USB_VBUS_DETECT)
	gpio_configure_pin(USB_VBUS_PIN, USB_VBUS_FLAGS);
#  endif
#endif
}
  404180:	bf00      	nop
  404182:	bd80      	pop	{r7, pc}
  404184:	400e1450 	.word	0x400e1450
  404188:	00403ca5 	.word	0x00403ca5
  40418c:	00403f59 	.word	0x00403f59
  404190:	00403fe1 	.word	0x00403fe1
  404194:	00403e3d 	.word	0x00403e3d
  404198:	00403d3b 	.word	0x00403d3b
  40419c:	00403d07 	.word	0x00403d07
  4041a0:	00403cbd 	.word	0x00403cbd

004041a4 <pmc_switch_mck_to_pllack>:
 *
 * \retval 0 Success.
 * \retval 1 Timeout error.
 */
uint32_t pmc_switch_mck_to_pllack(uint32_t ul_pres)
{
  4041a4:	b480      	push	{r7}
  4041a6:	b085      	sub	sp, #20
  4041a8:	af00      	add	r7, sp, #0
  4041aa:	6078      	str	r0, [r7, #4]
	uint32_t ul_timeout;

	PMC->PMC_MCKR = (PMC->PMC_MCKR & (~PMC_MCKR_PRES_Msk)) | ul_pres;
  4041ac:	491d      	ldr	r1, [pc, #116]	; (404224 <pmc_switch_mck_to_pllack+0x80>)
  4041ae:	4b1d      	ldr	r3, [pc, #116]	; (404224 <pmc_switch_mck_to_pllack+0x80>)
  4041b0:	6b1b      	ldr	r3, [r3, #48]	; 0x30
  4041b2:	f023 0270 	bic.w	r2, r3, #112	; 0x70
  4041b6:	687b      	ldr	r3, [r7, #4]
  4041b8:	4313      	orrs	r3, r2
  4041ba:	630b      	str	r3, [r1, #48]	; 0x30
	for (ul_timeout = PMC_TIMEOUT; !(PMC->PMC_SR & PMC_SR_MCKRDY);
  4041bc:	f44f 6300 	mov.w	r3, #2048	; 0x800
  4041c0:	60fb      	str	r3, [r7, #12]
  4041c2:	e007      	b.n	4041d4 <pmc_switch_mck_to_pllack+0x30>
			--ul_timeout) {
		if (ul_timeout == 0) {
  4041c4:	68fb      	ldr	r3, [r7, #12]
  4041c6:	2b00      	cmp	r3, #0
  4041c8:	d101      	bne.n	4041ce <pmc_switch_mck_to_pllack+0x2a>
			return 1;
  4041ca:	2301      	movs	r3, #1
  4041cc:	e023      	b.n	404216 <pmc_switch_mck_to_pllack+0x72>
			--ul_timeout) {
  4041ce:	68fb      	ldr	r3, [r7, #12]
  4041d0:	3b01      	subs	r3, #1
  4041d2:	60fb      	str	r3, [r7, #12]
	for (ul_timeout = PMC_TIMEOUT; !(PMC->PMC_SR & PMC_SR_MCKRDY);
  4041d4:	4b13      	ldr	r3, [pc, #76]	; (404224 <pmc_switch_mck_to_pllack+0x80>)
  4041d6:	6e9b      	ldr	r3, [r3, #104]	; 0x68
  4041d8:	f003 0308 	and.w	r3, r3, #8
  4041dc:	2b00      	cmp	r3, #0
  4041de:	d0f1      	beq.n	4041c4 <pmc_switch_mck_to_pllack+0x20>
		}
	}

	PMC->PMC_MCKR = (PMC->PMC_MCKR & (~PMC_MCKR_CSS_Msk)) |
  4041e0:	4a10      	ldr	r2, [pc, #64]	; (404224 <pmc_switch_mck_to_pllack+0x80>)
  4041e2:	4b10      	ldr	r3, [pc, #64]	; (404224 <pmc_switch_mck_to_pllack+0x80>)
  4041e4:	6b1b      	ldr	r3, [r3, #48]	; 0x30
  4041e6:	f023 0303 	bic.w	r3, r3, #3
  4041ea:	f043 0302 	orr.w	r3, r3, #2
  4041ee:	6313      	str	r3, [r2, #48]	; 0x30
			PMC_MCKR_CSS_PLLA_CLK;

	for (ul_timeout = PMC_TIMEOUT; !(PMC->PMC_SR & PMC_SR_MCKRDY);
  4041f0:	f44f 6300 	mov.w	r3, #2048	; 0x800
  4041f4:	60fb      	str	r3, [r7, #12]
  4041f6:	e007      	b.n	404208 <pmc_switch_mck_to_pllack+0x64>
			--ul_timeout) {
		if (ul_timeout == 0) {
  4041f8:	68fb      	ldr	r3, [r7, #12]
  4041fa:	2b00      	cmp	r3, #0
  4041fc:	d101      	bne.n	404202 <pmc_switch_mck_to_pllack+0x5e>
			return 1;
  4041fe:	2301      	movs	r3, #1
  404200:	e009      	b.n	404216 <pmc_switch_mck_to_pllack+0x72>
			--ul_timeout) {
  404202:	68fb      	ldr	r3, [r7, #12]
  404204:	3b01      	subs	r3, #1
  404206:	60fb      	str	r3, [r7, #12]
	for (ul_timeout = PMC_TIMEOUT; !(PMC->PMC_SR & PMC_SR_MCKRDY);
  404208:	4b06      	ldr	r3, [pc, #24]	; (404224 <pmc_switch_mck_to_pllack+0x80>)
  40420a:	6e9b      	ldr	r3, [r3, #104]	; 0x68
  40420c:	f003 0308 	and.w	r3, r3, #8
  404210:	2b00      	cmp	r3, #0
  404212:	d0f1      	beq.n	4041f8 <pmc_switch_mck_to_pllack+0x54>
		}
	}

	return 0;
  404214:	2300      	movs	r3, #0
}
  404216:	4618      	mov	r0, r3
  404218:	3714      	adds	r7, #20
  40421a:	46bd      	mov	sp, r7
  40421c:	f85d 7b04 	ldr.w	r7, [sp], #4
  404220:	4770      	bx	lr
  404222:	bf00      	nop
  404224:	400e0400 	.word	0x400e0400

00404228 <pmc_switch_sclk_to_32kxtal>:
 *       VDDIO power supply.
 *
 * \param ul_bypass 0 for Xtal, 1 for bypass.
 */
void pmc_switch_sclk_to_32kxtal(uint32_t ul_bypass)
{
  404228:	b480      	push	{r7}
  40422a:	b083      	sub	sp, #12
  40422c:	af00      	add	r7, sp, #0
  40422e:	6078      	str	r0, [r7, #4]
	/* Set Bypass mode if required */
	if (ul_bypass == 1) {
  404230:	687b      	ldr	r3, [r7, #4]
  404232:	2b01      	cmp	r3, #1
  404234:	d107      	bne.n	404246 <pmc_switch_sclk_to_32kxtal+0x1e>
		SUPC->SUPC_MR |= SUPC_MR_KEY_PASSWD |
  404236:	4a08      	ldr	r2, [pc, #32]	; (404258 <pmc_switch_sclk_to_32kxtal+0x30>)
  404238:	4b07      	ldr	r3, [pc, #28]	; (404258 <pmc_switch_sclk_to_32kxtal+0x30>)
  40423a:	689b      	ldr	r3, [r3, #8]
  40423c:	f043 4325 	orr.w	r3, r3, #2768240640	; 0xa5000000
  404240:	f443 1380 	orr.w	r3, r3, #1048576	; 0x100000
  404244:	6093      	str	r3, [r2, #8]
			SUPC_MR_OSCBYPASS;
	}

	SUPC->SUPC_CR = SUPC_CR_KEY_PASSWD | SUPC_CR_XTALSEL;
  404246:	4b04      	ldr	r3, [pc, #16]	; (404258 <pmc_switch_sclk_to_32kxtal+0x30>)
  404248:	4a04      	ldr	r2, [pc, #16]	; (40425c <pmc_switch_sclk_to_32kxtal+0x34>)
  40424a:	601a      	str	r2, [r3, #0]
}
  40424c:	bf00      	nop
  40424e:	370c      	adds	r7, #12
  404250:	46bd      	mov	sp, r7
  404252:	f85d 7b04 	ldr.w	r7, [sp], #4
  404256:	4770      	bx	lr
  404258:	400e1410 	.word	0x400e1410
  40425c:	a5000008 	.word	0xa5000008

00404260 <pmc_osc_is_ready_32kxtal>:
 *
 * \retval 1 External 32k Xtal is ready.
 * \retval 0 External 32k Xtal is not ready.
 */
uint32_t pmc_osc_is_ready_32kxtal(void)
{
  404260:	b480      	push	{r7}
  404262:	af00      	add	r7, sp, #0
	return ((SUPC->SUPC_SR & SUPC_SR_OSCSEL)
  404264:	4b09      	ldr	r3, [pc, #36]	; (40428c <pmc_osc_is_ready_32kxtal+0x2c>)
  404266:	695b      	ldr	r3, [r3, #20]
  404268:	f003 0380 	and.w	r3, r3, #128	; 0x80
			&& (PMC->PMC_SR & PMC_SR_OSCSELS));
  40426c:	2b00      	cmp	r3, #0
  40426e:	d007      	beq.n	404280 <pmc_osc_is_ready_32kxtal+0x20>
  404270:	4b07      	ldr	r3, [pc, #28]	; (404290 <pmc_osc_is_ready_32kxtal+0x30>)
  404272:	6e9b      	ldr	r3, [r3, #104]	; 0x68
  404274:	f003 0380 	and.w	r3, r3, #128	; 0x80
  404278:	2b00      	cmp	r3, #0
  40427a:	d001      	beq.n	404280 <pmc_osc_is_ready_32kxtal+0x20>
  40427c:	2301      	movs	r3, #1
  40427e:	e000      	b.n	404282 <pmc_osc_is_ready_32kxtal+0x22>
  404280:	2300      	movs	r3, #0
}
  404282:	4618      	mov	r0, r3
  404284:	46bd      	mov	sp, r7
  404286:	f85d 7b04 	ldr.w	r7, [sp], #4
  40428a:	4770      	bx	lr
  40428c:	400e1410 	.word	0x400e1410
  404290:	400e0400 	.word	0x400e0400

00404294 <pmc_switch_mainck_to_fastrc>:
 * \retval 0 Success.
 * \retval 1 Timeout error.
 * \retval 2 Invalid frequency.
 */
void pmc_switch_mainck_to_fastrc(uint32_t ul_moscrcf)
{
  404294:	b480      	push	{r7}
  404296:	b083      	sub	sp, #12
  404298:	af00      	add	r7, sp, #0
  40429a:	6078      	str	r0, [r7, #4]
	/* Enable Fast RC oscillator but DO NOT switch to RC now */
	PMC->CKGR_MOR |= (CKGR_MOR_KEY_PASSWD | CKGR_MOR_MOSCRCEN);
  40429c:	4a18      	ldr	r2, [pc, #96]	; (404300 <pmc_switch_mainck_to_fastrc+0x6c>)
  40429e:	4b18      	ldr	r3, [pc, #96]	; (404300 <pmc_switch_mainck_to_fastrc+0x6c>)
  4042a0:	6a1b      	ldr	r3, [r3, #32]
  4042a2:	f443 135c 	orr.w	r3, r3, #3604480	; 0x370000
  4042a6:	f043 0308 	orr.w	r3, r3, #8
  4042aa:	6213      	str	r3, [r2, #32]

	/* Wait the Fast RC to stabilize */
	while (!(PMC->PMC_SR & PMC_SR_MOSCRCS));
  4042ac:	bf00      	nop
  4042ae:	4b14      	ldr	r3, [pc, #80]	; (404300 <pmc_switch_mainck_to_fastrc+0x6c>)
  4042b0:	6e9b      	ldr	r3, [r3, #104]	; 0x68
  4042b2:	f403 3300 	and.w	r3, r3, #131072	; 0x20000
  4042b6:	2b00      	cmp	r3, #0
  4042b8:	d0f9      	beq.n	4042ae <pmc_switch_mainck_to_fastrc+0x1a>

	/* Change Fast RC oscillator frequency */
	PMC->CKGR_MOR = (PMC->CKGR_MOR & ~CKGR_MOR_MOSCRCF_Msk) |
  4042ba:	4911      	ldr	r1, [pc, #68]	; (404300 <pmc_switch_mainck_to_fastrc+0x6c>)
  4042bc:	4b10      	ldr	r3, [pc, #64]	; (404300 <pmc_switch_mainck_to_fastrc+0x6c>)
  4042be:	6a1b      	ldr	r3, [r3, #32]
  4042c0:	f423 135c 	bic.w	r3, r3, #3604480	; 0x370000
  4042c4:	f023 0370 	bic.w	r3, r3, #112	; 0x70
			CKGR_MOR_KEY_PASSWD | ul_moscrcf;
  4042c8:	687a      	ldr	r2, [r7, #4]
  4042ca:	4313      	orrs	r3, r2
  4042cc:	f443 135c 	orr.w	r3, r3, #3604480	; 0x370000
	PMC->CKGR_MOR = (PMC->CKGR_MOR & ~CKGR_MOR_MOSCRCF_Msk) |
  4042d0:	620b      	str	r3, [r1, #32]

	/* Wait the Fast RC to stabilize */
	while (!(PMC->PMC_SR & PMC_SR_MOSCRCS));
  4042d2:	bf00      	nop
  4042d4:	4b0a      	ldr	r3, [pc, #40]	; (404300 <pmc_switch_mainck_to_fastrc+0x6c>)
  4042d6:	6e9b      	ldr	r3, [r3, #104]	; 0x68
  4042d8:	f403 3300 	and.w	r3, r3, #131072	; 0x20000
  4042dc:	2b00      	cmp	r3, #0
  4042de:	d0f9      	beq.n	4042d4 <pmc_switch_mainck_to_fastrc+0x40>

	/* Switch to Fast RC */
	PMC->CKGR_MOR = (PMC->CKGR_MOR & ~CKGR_MOR_MOSCSEL) |
  4042e0:	4a07      	ldr	r2, [pc, #28]	; (404300 <pmc_switch_mainck_to_fastrc+0x6c>)
  4042e2:	4b07      	ldr	r3, [pc, #28]	; (404300 <pmc_switch_mainck_to_fastrc+0x6c>)
  4042e4:	6a1b      	ldr	r3, [r3, #32]
  4042e6:	f023 739b 	bic.w	r3, r3, #20316160	; 0x1360000
  4042ea:	f423 3380 	bic.w	r3, r3, #65536	; 0x10000
  4042ee:	f443 135c 	orr.w	r3, r3, #3604480	; 0x370000
  4042f2:	6213      	str	r3, [r2, #32]
			CKGR_MOR_KEY_PASSWD;
}
  4042f4:	bf00      	nop
  4042f6:	370c      	adds	r7, #12
  4042f8:	46bd      	mov	sp, r7
  4042fa:	f85d 7b04 	ldr.w	r7, [sp], #4
  4042fe:	4770      	bx	lr
  404300:	400e0400 	.word	0x400e0400

00404304 <pmc_switch_mainck_to_xtal>:
 * \retval 0 Success.
 * \retval 1 Timeout error.
 */
void pmc_switch_mainck_to_xtal(uint32_t ul_bypass,
		uint32_t ul_xtal_startup_time)
{
  404304:	b480      	push	{r7}
  404306:	b083      	sub	sp, #12
  404308:	af00      	add	r7, sp, #0
  40430a:	6078      	str	r0, [r7, #4]
  40430c:	6039      	str	r1, [r7, #0]
	/* Enable Main Xtal oscillator */
	if (ul_bypass) {
  40430e:	687b      	ldr	r3, [r7, #4]
  404310:	2b00      	cmp	r3, #0
  404312:	d008      	beq.n	404326 <pmc_switch_mainck_to_xtal+0x22>
		PMC->CKGR_MOR = (PMC->CKGR_MOR & ~CKGR_MOR_MOSCXTEN) |
  404314:	4916      	ldr	r1, [pc, #88]	; (404370 <pmc_switch_mainck_to_xtal+0x6c>)
  404316:	4b16      	ldr	r3, [pc, #88]	; (404370 <pmc_switch_mainck_to_xtal+0x6c>)
  404318:	6a1b      	ldr	r3, [r3, #32]
				CKGR_MOR_KEY_PASSWD | CKGR_MOR_MOSCXTBY |
  40431a:	4a16      	ldr	r2, [pc, #88]	; (404374 <pmc_switch_mainck_to_xtal+0x70>)
  40431c:	401a      	ands	r2, r3
  40431e:	4b16      	ldr	r3, [pc, #88]	; (404378 <pmc_switch_mainck_to_xtal+0x74>)
  404320:	4313      	orrs	r3, r2
		PMC->CKGR_MOR = (PMC->CKGR_MOR & ~CKGR_MOR_MOSCXTEN) |
  404322:	620b      	str	r3, [r1, #32]
		/* Wait the Xtal to stabilize */
		while (!(PMC->PMC_SR & PMC_SR_MOSCXTS));

		PMC->CKGR_MOR |= CKGR_MOR_KEY_PASSWD | CKGR_MOR_MOSCSEL;
	}
}
  404324:	e01e      	b.n	404364 <pmc_switch_mainck_to_xtal+0x60>
		PMC->CKGR_MOR = (PMC->CKGR_MOR & ~CKGR_MOR_MOSCXTBY) |
  404326:	4912      	ldr	r1, [pc, #72]	; (404370 <pmc_switch_mainck_to_xtal+0x6c>)
  404328:	4b11      	ldr	r3, [pc, #68]	; (404370 <pmc_switch_mainck_to_xtal+0x6c>)
  40432a:	6a1b      	ldr	r3, [r3, #32]
				CKGR_MOR_KEY_PASSWD | CKGR_MOR_MOSCXTEN |
  40432c:	f423 135c 	bic.w	r3, r3, #3604480	; 0x370000
  404330:	f023 0303 	bic.w	r3, r3, #3
				CKGR_MOR_MOSCXTST(ul_xtal_startup_time);
  404334:	683a      	ldr	r2, [r7, #0]
  404336:	0212      	lsls	r2, r2, #8
  404338:	b292      	uxth	r2, r2
				CKGR_MOR_KEY_PASSWD | CKGR_MOR_MOSCXTEN |
  40433a:	4313      	orrs	r3, r2
  40433c:	f443 135c 	orr.w	r3, r3, #3604480	; 0x370000
  404340:	f043 0301 	orr.w	r3, r3, #1
		PMC->CKGR_MOR = (PMC->CKGR_MOR & ~CKGR_MOR_MOSCXTBY) |
  404344:	620b      	str	r3, [r1, #32]
		while (!(PMC->PMC_SR & PMC_SR_MOSCXTS));
  404346:	bf00      	nop
  404348:	4b09      	ldr	r3, [pc, #36]	; (404370 <pmc_switch_mainck_to_xtal+0x6c>)
  40434a:	6e9b      	ldr	r3, [r3, #104]	; 0x68
  40434c:	f003 0301 	and.w	r3, r3, #1
  404350:	2b00      	cmp	r3, #0
  404352:	d0f9      	beq.n	404348 <pmc_switch_mainck_to_xtal+0x44>
		PMC->CKGR_MOR |= CKGR_MOR_KEY_PASSWD | CKGR_MOR_MOSCSEL;
  404354:	4a06      	ldr	r2, [pc, #24]	; (404370 <pmc_switch_mainck_to_xtal+0x6c>)
  404356:	4b06      	ldr	r3, [pc, #24]	; (404370 <pmc_switch_mainck_to_xtal+0x6c>)
  404358:	6a1b      	ldr	r3, [r3, #32]
  40435a:	f043 739b 	orr.w	r3, r3, #20316160	; 0x1360000
  40435e:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
  404362:	6213      	str	r3, [r2, #32]
}
  404364:	bf00      	nop
  404366:	370c      	adds	r7, #12
  404368:	46bd      	mov	sp, r7
  40436a:	f85d 7b04 	ldr.w	r7, [sp], #4
  40436e:	4770      	bx	lr
  404370:	400e0400 	.word	0x400e0400
  404374:	fec8fffc 	.word	0xfec8fffc
  404378:	01370002 	.word	0x01370002

0040437c <pmc_osc_is_ready_mainck>:
 *
 * \retval 1 Xtal is ready.
 * \retval 0 Xtal is not ready.
 */
uint32_t pmc_osc_is_ready_mainck(void)
{
  40437c:	b480      	push	{r7}
  40437e:	af00      	add	r7, sp, #0
	return PMC->PMC_SR & PMC_SR_MOSCSELS;
  404380:	4b04      	ldr	r3, [pc, #16]	; (404394 <pmc_osc_is_ready_mainck+0x18>)
  404382:	6e9b      	ldr	r3, [r3, #104]	; 0x68
  404384:	f403 3380 	and.w	r3, r3, #65536	; 0x10000
}
  404388:	4618      	mov	r0, r3
  40438a:	46bd      	mov	sp, r7
  40438c:	f85d 7b04 	ldr.w	r7, [sp], #4
  404390:	4770      	bx	lr
  404392:	bf00      	nop
  404394:	400e0400 	.word	0x400e0400

00404398 <pmc_disable_pllack>:

/**
 * \brief Disable PLLA clock.
 */
void pmc_disable_pllack(void)
{
  404398:	b480      	push	{r7}
  40439a:	af00      	add	r7, sp, #0
#if (SAM4C || SAM4CM || SAM4CP || SAMG)
	PMC->CKGR_PLLAR = CKGR_PLLAR_MULA(0);
  40439c:	4b03      	ldr	r3, [pc, #12]	; (4043ac <pmc_disable_pllack+0x14>)
  40439e:	2200      	movs	r2, #0
  4043a0:	629a      	str	r2, [r3, #40]	; 0x28
#else
	PMC->CKGR_PLLAR = CKGR_PLLAR_ONE | CKGR_PLLAR_MULA(0);
#endif
}
  4043a2:	bf00      	nop
  4043a4:	46bd      	mov	sp, r7
  4043a6:	f85d 7b04 	ldr.w	r7, [sp], #4
  4043aa:	4770      	bx	lr
  4043ac:	400e0400 	.word	0x400e0400

004043b0 <pmc_is_locked_pllack>:
 *
 * \retval 0 Not locked.
 * \retval 1 Locked.
 */
uint32_t pmc_is_locked_pllack(void)
{
  4043b0:	b480      	push	{r7}
  4043b2:	af00      	add	r7, sp, #0
	return (PMC->PMC_SR & PMC_SR_LOCKA);
  4043b4:	4b04      	ldr	r3, [pc, #16]	; (4043c8 <pmc_is_locked_pllack+0x18>)
  4043b6:	6e9b      	ldr	r3, [r3, #104]	; 0x68
  4043b8:	f003 0302 	and.w	r3, r3, #2
}
  4043bc:	4618      	mov	r0, r3
  4043be:	46bd      	mov	sp, r7
  4043c0:	f85d 7b04 	ldr.w	r7, [sp], #4
  4043c4:	4770      	bx	lr
  4043c6:	bf00      	nop
  4043c8:	400e0400 	.word	0x400e0400

004043cc <pmc_disable_pllbck>:

/**
 * \brief Disable PLLB clock.
 */
void pmc_disable_pllbck(void)
{
  4043cc:	b480      	push	{r7}
  4043ce:	af00      	add	r7, sp, #0
	PMC->CKGR_PLLBR = CKGR_PLLBR_MULB(0);
  4043d0:	4b03      	ldr	r3, [pc, #12]	; (4043e0 <pmc_disable_pllbck+0x14>)
  4043d2:	2200      	movs	r2, #0
  4043d4:	62da      	str	r2, [r3, #44]	; 0x2c
}
  4043d6:	bf00      	nop
  4043d8:	46bd      	mov	sp, r7
  4043da:	f85d 7b04 	ldr.w	r7, [sp], #4
  4043de:	4770      	bx	lr
  4043e0:	400e0400 	.word	0x400e0400

004043e4 <pmc_is_locked_pllbck>:
 *
 * \retval 0 Not locked.
 * \retval 1 Locked.
 */
uint32_t pmc_is_locked_pllbck(void)
{
  4043e4:	b480      	push	{r7}
  4043e6:	af00      	add	r7, sp, #0
	return (PMC->PMC_SR & PMC_SR_LOCKB);
  4043e8:	4b04      	ldr	r3, [pc, #16]	; (4043fc <pmc_is_locked_pllbck+0x18>)
  4043ea:	6e9b      	ldr	r3, [r3, #104]	; 0x68
  4043ec:	f003 0304 	and.w	r3, r3, #4
}
  4043f0:	4618      	mov	r0, r3
  4043f2:	46bd      	mov	sp, r7
  4043f4:	f85d 7b04 	ldr.w	r7, [sp], #4
  4043f8:	4770      	bx	lr
  4043fa:	bf00      	nop
  4043fc:	400e0400 	.word	0x400e0400

00404400 <pmc_enable_periph_clk>:
 *
 * \retval 0 Success.
 * \retval 1 Invalid parameter.
 */
uint32_t pmc_enable_periph_clk(uint32_t ul_id)
{
  404400:	b480      	push	{r7}
  404402:	b083      	sub	sp, #12
  404404:	af00      	add	r7, sp, #0
  404406:	6078      	str	r0, [r7, #4]
	if (ul_id > MAX_PERIPH_ID) {
  404408:	687b      	ldr	r3, [r7, #4]
  40440a:	2b32      	cmp	r3, #50	; 0x32
  40440c:	d901      	bls.n	404412 <pmc_enable_periph_clk+0x12>
		return 1;
  40440e:	2301      	movs	r3, #1
  404410:	e02f      	b.n	404472 <pmc_enable_periph_clk+0x72>
	}

	if (ul_id < 32) {
  404412:	687b      	ldr	r3, [r7, #4]
  404414:	2b1f      	cmp	r3, #31
  404416:	d813      	bhi.n	404440 <pmc_enable_periph_clk+0x40>
		if ((PMC->PMC_PCSR0 & (1u << ul_id)) != (1u << ul_id)) {
  404418:	4b19      	ldr	r3, [pc, #100]	; (404480 <pmc_enable_periph_clk+0x80>)
  40441a:	699a      	ldr	r2, [r3, #24]
  40441c:	2101      	movs	r1, #1
  40441e:	687b      	ldr	r3, [r7, #4]
  404420:	fa01 f303 	lsl.w	r3, r1, r3
  404424:	401a      	ands	r2, r3
  404426:	2101      	movs	r1, #1
  404428:	687b      	ldr	r3, [r7, #4]
  40442a:	fa01 f303 	lsl.w	r3, r1, r3
  40442e:	429a      	cmp	r2, r3
  404430:	d01e      	beq.n	404470 <pmc_enable_periph_clk+0x70>
			PMC->PMC_PCER0 = 1 << ul_id;
  404432:	4a13      	ldr	r2, [pc, #76]	; (404480 <pmc_enable_periph_clk+0x80>)
  404434:	2101      	movs	r1, #1
  404436:	687b      	ldr	r3, [r7, #4]
  404438:	fa01 f303 	lsl.w	r3, r1, r3
  40443c:	6113      	str	r3, [r2, #16]
  40443e:	e017      	b.n	404470 <pmc_enable_periph_clk+0x70>
		}
#if (SAM3S || SAM3XA || SAM4S || SAM4E || SAM4C || SAM4CM || SAM4CP || SAMG55 || SAMV71 || SAMV70 || SAME70 || SAMS70)
	} else {
		ul_id -= 32;
  404440:	687b      	ldr	r3, [r7, #4]
  404442:	3b20      	subs	r3, #32
  404444:	607b      	str	r3, [r7, #4]
		if ((PMC->PMC_PCSR1 & (1u << ul_id)) != (1u << ul_id)) {
  404446:	4b0e      	ldr	r3, [pc, #56]	; (404480 <pmc_enable_periph_clk+0x80>)
  404448:	f8d3 2108 	ldr.w	r2, [r3, #264]	; 0x108
  40444c:	2101      	movs	r1, #1
  40444e:	687b      	ldr	r3, [r7, #4]
  404450:	fa01 f303 	lsl.w	r3, r1, r3
  404454:	401a      	ands	r2, r3
  404456:	2101      	movs	r1, #1
  404458:	687b      	ldr	r3, [r7, #4]
  40445a:	fa01 f303 	lsl.w	r3, r1, r3
  40445e:	429a      	cmp	r2, r3
  404460:	d006      	beq.n	404470 <pmc_enable_periph_clk+0x70>
			PMC->PMC_PCER1 = 1 << ul_id;
  404462:	4a07      	ldr	r2, [pc, #28]	; (404480 <pmc_enable_periph_clk+0x80>)
  404464:	2101      	movs	r1, #1
  404466:	687b      	ldr	r3, [r7, #4]
  404468:	fa01 f303 	lsl.w	r3, r1, r3
  40446c:	f8c2 3100 	str.w	r3, [r2, #256]	; 0x100
		}
#endif
	}

	return 0;
  404470:	2300      	movs	r3, #0
}
  404472:	4618      	mov	r0, r3
  404474:	370c      	adds	r7, #12
  404476:	46bd      	mov	sp, r7
  404478:	f85d 7b04 	ldr.w	r7, [sp], #4
  40447c:	4770      	bx	lr
  40447e:	bf00      	nop
  404480:	400e0400 	.word	0x400e0400

00404484 <pmc_switch_pck_to_mck>:
 *
 * \retval 0 Success.
 * \retval 1 Timeout error.
 */
uint32_t pmc_switch_pck_to_mck(uint32_t ul_id, uint32_t ul_pres)
{
  404484:	b480      	push	{r7}
  404486:	b085      	sub	sp, #20
  404488:	af00      	add	r7, sp, #0
  40448a:	6078      	str	r0, [r7, #4]
  40448c:	6039      	str	r1, [r7, #0]
	uint32_t ul_timeout;

	PMC->PMC_PCK[ul_id] = PMC_PCK_CSS_MCK | ul_pres;
  40448e:	4912      	ldr	r1, [pc, #72]	; (4044d8 <pmc_switch_pck_to_mck+0x54>)
  404490:	683b      	ldr	r3, [r7, #0]
  404492:	f043 0204 	orr.w	r2, r3, #4
  404496:	687b      	ldr	r3, [r7, #4]
  404498:	3310      	adds	r3, #16
  40449a:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
	for (ul_timeout = PMC_TIMEOUT;
  40449e:	f44f 6300 	mov.w	r3, #2048	; 0x800
  4044a2:	60fb      	str	r3, [r7, #12]
  4044a4:	e007      	b.n	4044b6 <pmc_switch_pck_to_mck+0x32>
	!(PMC->PMC_SR & (PMC_SR_PCKRDY0 << ul_id)); --ul_timeout) {
		if (ul_timeout == 0) {
  4044a6:	68fb      	ldr	r3, [r7, #12]
  4044a8:	2b00      	cmp	r3, #0
  4044aa:	d101      	bne.n	4044b0 <pmc_switch_pck_to_mck+0x2c>
			return 1;
  4044ac:	2301      	movs	r3, #1
  4044ae:	e00d      	b.n	4044cc <pmc_switch_pck_to_mck+0x48>
	!(PMC->PMC_SR & (PMC_SR_PCKRDY0 << ul_id)); --ul_timeout) {
  4044b0:	68fb      	ldr	r3, [r7, #12]
  4044b2:	3b01      	subs	r3, #1
  4044b4:	60fb      	str	r3, [r7, #12]
  4044b6:	4b08      	ldr	r3, [pc, #32]	; (4044d8 <pmc_switch_pck_to_mck+0x54>)
  4044b8:	6e9a      	ldr	r2, [r3, #104]	; 0x68
  4044ba:	f44f 7180 	mov.w	r1, #256	; 0x100
  4044be:	687b      	ldr	r3, [r7, #4]
  4044c0:	fa01 f303 	lsl.w	r3, r1, r3
  4044c4:	4013      	ands	r3, r2
	for (ul_timeout = PMC_TIMEOUT;
  4044c6:	2b00      	cmp	r3, #0
  4044c8:	d0ed      	beq.n	4044a6 <pmc_switch_pck_to_mck+0x22>
		}
	}

	return 0;
  4044ca:	2300      	movs	r3, #0
}
  4044cc:	4618      	mov	r0, r3
  4044ce:	3714      	adds	r7, #20
  4044d0:	46bd      	mov	sp, r7
  4044d2:	f85d 7b04 	ldr.w	r7, [sp], #4
  4044d6:	4770      	bx	lr
  4044d8:	400e0400 	.word	0x400e0400

004044dc <pmc_enable_pck>:
 * \brief Enable the specified programmable clock.
 *
 * \param ul_id Id of the programmable clock.
 */
void pmc_enable_pck(uint32_t ul_id)
{
  4044dc:	b480      	push	{r7}
  4044de:	b083      	sub	sp, #12
  4044e0:	af00      	add	r7, sp, #0
  4044e2:	6078      	str	r0, [r7, #4]
	PMC->PMC_SCER = PMC_SCER_PCK0 << ul_id;
  4044e4:	4a06      	ldr	r2, [pc, #24]	; (404500 <pmc_enable_pck+0x24>)
  4044e6:	f44f 7180 	mov.w	r1, #256	; 0x100
  4044ea:	687b      	ldr	r3, [r7, #4]
  4044ec:	fa01 f303 	lsl.w	r3, r1, r3
  4044f0:	6013      	str	r3, [r2, #0]
}
  4044f2:	bf00      	nop
  4044f4:	370c      	adds	r7, #12
  4044f6:	46bd      	mov	sp, r7
  4044f8:	f85d 7b04 	ldr.w	r7, [sp], #4
  4044fc:	4770      	bx	lr
  4044fe:	bf00      	nop
  404500:	400e0400 	.word	0x400e0400

00404504 <pmc_disable_pck>:
 * \brief Disable the specified programmable clock.
 *
 * \param ul_id Id of the programmable clock.
 */
void pmc_disable_pck(uint32_t ul_id)
{
  404504:	b480      	push	{r7}
  404506:	b083      	sub	sp, #12
  404508:	af00      	add	r7, sp, #0
  40450a:	6078      	str	r0, [r7, #4]
	PMC->PMC_SCDR = PMC_SCER_PCK0 << ul_id;
  40450c:	4a06      	ldr	r2, [pc, #24]	; (404528 <pmc_disable_pck+0x24>)
  40450e:	f44f 7180 	mov.w	r1, #256	; 0x100
  404512:	687b      	ldr	r3, [r7, #4]
  404514:	fa01 f303 	lsl.w	r3, r1, r3
  404518:	6053      	str	r3, [r2, #4]
}
  40451a:	bf00      	nop
  40451c:	370c      	adds	r7, #12
  40451e:	46bd      	mov	sp, r7
  404520:	f85d 7b04 	ldr.w	r7, [sp], #4
  404524:	4770      	bx	lr
  404526:	bf00      	nop
  404528:	400e0400 	.word	0x400e0400

0040452c <supc_set_regulator_trim_user>:
 * \param value the trim value.
 *
 * \note For the trim value in 96M PLL, please read the value in flash unique identifier area.
 */
void supc_set_regulator_trim_user(Supc *p_supc, uint32_t value)
{
  40452c:	b480      	push	{r7}
  40452e:	b085      	sub	sp, #20
  404530:	af00      	add	r7, sp, #0
  404532:	6078      	str	r0, [r7, #4]
  404534:	6039      	str	r1, [r7, #0]
#if SAMG54
	uint32_t ul_mr = p_supc->SUPC_MR & (~SUPC_MR_VRVDD_Msk);
	p_supc->SUPC_MR = SUPC_MR_KEY_PASSWD | ul_mr | SUPC_MR_VDDSEL_USER_VRVDD
		 | SUPC_MR_VRVDD(value);
#else
	uint32_t ul_pwmr = p_supc->SUPC_PWMR & (~(0xFu << 9));
  404536:	687b      	ldr	r3, [r7, #4]
  404538:	69db      	ldr	r3, [r3, #28]
  40453a:	f423 53f0 	bic.w	r3, r3, #7680	; 0x1e00
  40453e:	60fb      	str	r3, [r7, #12]
	p_supc->SUPC_PWMR = SUPC_PWMR_KEY_PASSWD | ul_pwmr | SUPC_PWMR_ECPWRS
		| ((value & 0xFu) << 9);
  404540:	683b      	ldr	r3, [r7, #0]
  404542:	025b      	lsls	r3, r3, #9
  404544:	f403 52f0 	and.w	r2, r3, #7680	; 0x1e00
  404548:	68fb      	ldr	r3, [r7, #12]
  40454a:	4313      	orrs	r3, r2
  40454c:	f043 43b4 	orr.w	r3, r3, #1509949440	; 0x5a000000
  404550:	f443 7380 	orr.w	r3, r3, #256	; 0x100
	p_supc->SUPC_PWMR = SUPC_PWMR_KEY_PASSWD | ul_pwmr | SUPC_PWMR_ECPWRS
  404554:	687a      	ldr	r2, [r7, #4]
  404556:	61d3      	str	r3, [r2, #28]
#endif
}
  404558:	bf00      	nop
  40455a:	3714      	adds	r7, #20
  40455c:	46bd      	mov	sp, r7
  40455e:	f85d 7b04 	ldr.w	r7, [sp], #4
  404562:	4770      	bx	lr

00404564 <cpu_irq_save>:
{
  404564:	b480      	push	{r7}
  404566:	b083      	sub	sp, #12
  404568:	af00      	add	r7, sp, #0
  __ASM volatile ("MRS %0, primask" : "=r" (result) );
  40456a:	f3ef 8310 	mrs	r3, PRIMASK
  40456e:	607b      	str	r3, [r7, #4]
  return(result);
  404570:	687b      	ldr	r3, [r7, #4]
	volatile irqflags_t flags = cpu_irq_is_enabled();
  404572:	2b00      	cmp	r3, #0
  404574:	bf0c      	ite	eq
  404576:	2301      	moveq	r3, #1
  404578:	2300      	movne	r3, #0
  40457a:	b2db      	uxtb	r3, r3
  40457c:	603b      	str	r3, [r7, #0]
  __ASM volatile ("cpsid i" : : : "memory");
  40457e:	b672      	cpsid	i
  404580:	f3bf 8f5f 	dmb	sy
	cpu_irq_disable();
  404584:	4b04      	ldr	r3, [pc, #16]	; (404598 <cpu_irq_save+0x34>)
  404586:	2200      	movs	r2, #0
  404588:	701a      	strb	r2, [r3, #0]
	return flags;
  40458a:	683b      	ldr	r3, [r7, #0]
}
  40458c:	4618      	mov	r0, r3
  40458e:	370c      	adds	r7, #12
  404590:	46bd      	mov	sp, r7
  404592:	f85d 7b04 	ldr.w	r7, [sp], #4
  404596:	4770      	bx	lr
  404598:	20000119 	.word	0x20000119

0040459c <cpu_irq_is_enabled_flags>:
{
  40459c:	b480      	push	{r7}
  40459e:	b083      	sub	sp, #12
  4045a0:	af00      	add	r7, sp, #0
  4045a2:	6078      	str	r0, [r7, #4]
	return (flags);
  4045a4:	687b      	ldr	r3, [r7, #4]
  4045a6:	2b00      	cmp	r3, #0
  4045a8:	bf14      	ite	ne
  4045aa:	2301      	movne	r3, #1
  4045ac:	2300      	moveq	r3, #0
  4045ae:	b2db      	uxtb	r3, r3
}
  4045b0:	4618      	mov	r0, r3
  4045b2:	370c      	adds	r7, #12
  4045b4:	46bd      	mov	sp, r7
  4045b6:	f85d 7b04 	ldr.w	r7, [sp], #4
  4045ba:	4770      	bx	lr

004045bc <cpu_irq_restore>:
{
  4045bc:	b580      	push	{r7, lr}
  4045be:	b082      	sub	sp, #8
  4045c0:	af00      	add	r7, sp, #0
  4045c2:	6078      	str	r0, [r7, #4]
	if (cpu_irq_is_enabled_flags(flags))
  4045c4:	6878      	ldr	r0, [r7, #4]
  4045c6:	4b07      	ldr	r3, [pc, #28]	; (4045e4 <cpu_irq_restore+0x28>)
  4045c8:	4798      	blx	r3
  4045ca:	4603      	mov	r3, r0
  4045cc:	2b00      	cmp	r3, #0
  4045ce:	d005      	beq.n	4045dc <cpu_irq_restore+0x20>
		cpu_irq_enable();
  4045d0:	4b05      	ldr	r3, [pc, #20]	; (4045e8 <cpu_irq_restore+0x2c>)
  4045d2:	2201      	movs	r2, #1
  4045d4:	701a      	strb	r2, [r3, #0]
  4045d6:	f3bf 8f5f 	dmb	sy
  __ASM volatile ("cpsie i" : : : "memory");
  4045da:	b662      	cpsie	i
}
  4045dc:	bf00      	nop
  4045de:	3708      	adds	r7, #8
  4045e0:	46bd      	mov	sp, r7
  4045e2:	bd80      	pop	{r7, pc}
  4045e4:	0040459d 	.word	0x0040459d
  4045e8:	20000119 	.word	0x20000119

004045ec <Reset_Handler>:
/**
 * \brief This is the code that gets called on processor reset.
 * To initialize the device, and call the main() routine.
 */
void Reset_Handler(void)
{
  4045ec:	b580      	push	{r7, lr}
  4045ee:	b084      	sub	sp, #16
  4045f0:	af00      	add	r7, sp, #0
        uint32_t *pSrc, *pDest;

        /* Initialize the relocate segment */
        pSrc = &_etext;
  4045f2:	4b25      	ldr	r3, [pc, #148]	; (404688 <Reset_Handler+0x9c>)
  4045f4:	60fb      	str	r3, [r7, #12]
        pDest = &_srelocate;
  4045f6:	4b25      	ldr	r3, [pc, #148]	; (40468c <Reset_Handler+0xa0>)
  4045f8:	60bb      	str	r3, [r7, #8]

        if (pSrc != pDest) {
  4045fa:	68fa      	ldr	r2, [r7, #12]
  4045fc:	68bb      	ldr	r3, [r7, #8]
  4045fe:	429a      	cmp	r2, r3
  404600:	d00c      	beq.n	40461c <Reset_Handler+0x30>
                for (; pDest < &_erelocate;) {
  404602:	e007      	b.n	404614 <Reset_Handler+0x28>
                        *pDest++ = *pSrc++;
  404604:	68bb      	ldr	r3, [r7, #8]
  404606:	1d1a      	adds	r2, r3, #4
  404608:	60ba      	str	r2, [r7, #8]
  40460a:	68fa      	ldr	r2, [r7, #12]
  40460c:	1d11      	adds	r1, r2, #4
  40460e:	60f9      	str	r1, [r7, #12]
  404610:	6812      	ldr	r2, [r2, #0]
  404612:	601a      	str	r2, [r3, #0]
                for (; pDest < &_erelocate;) {
  404614:	68bb      	ldr	r3, [r7, #8]
  404616:	4a1e      	ldr	r2, [pc, #120]	; (404690 <Reset_Handler+0xa4>)
  404618:	4293      	cmp	r3, r2
  40461a:	d3f3      	bcc.n	404604 <Reset_Handler+0x18>
                }
        }

        /* Clear the zero segment */
        for (pDest = &_szero; pDest < &_ezero;) {
  40461c:	4b1d      	ldr	r3, [pc, #116]	; (404694 <Reset_Handler+0xa8>)
  40461e:	60bb      	str	r3, [r7, #8]
  404620:	e004      	b.n	40462c <Reset_Handler+0x40>
                *pDest++ = 0;
  404622:	68bb      	ldr	r3, [r7, #8]
  404624:	1d1a      	adds	r2, r3, #4
  404626:	60ba      	str	r2, [r7, #8]
  404628:	2200      	movs	r2, #0
  40462a:	601a      	str	r2, [r3, #0]
        for (pDest = &_szero; pDest < &_ezero;) {
  40462c:	68bb      	ldr	r3, [r7, #8]
  40462e:	4a1a      	ldr	r2, [pc, #104]	; (404698 <Reset_Handler+0xac>)
  404630:	4293      	cmp	r3, r2
  404632:	d3f6      	bcc.n	404622 <Reset_Handler+0x36>
        }

        /* Set the vector table base address */
        pSrc = (uint32_t *) & _sfixed;
  404634:	4b19      	ldr	r3, [pc, #100]	; (40469c <Reset_Handler+0xb0>)
  404636:	60fb      	str	r3, [r7, #12]
        SCB->VTOR = ((uint32_t) pSrc & SCB_VTOR_TBLOFF_Msk);
  404638:	4a19      	ldr	r2, [pc, #100]	; (4046a0 <Reset_Handler+0xb4>)
  40463a:	68fb      	ldr	r3, [r7, #12]
  40463c:	f023 037f 	bic.w	r3, r3, #127	; 0x7f
  404640:	6093      	str	r3, [r2, #8]
 * \brief Enable FPU
 */
__always_inline static void fpu_enable(void)
{
	irqflags_t flags;
	flags = cpu_irq_save();
  404642:	4b18      	ldr	r3, [pc, #96]	; (4046a4 <Reset_Handler+0xb8>)
  404644:	4798      	blx	r3
  404646:	6078      	str	r0, [r7, #4]
	REG_CPACR |=  (0xFu << 20);
  404648:	4a17      	ldr	r2, [pc, #92]	; (4046a8 <Reset_Handler+0xbc>)
  40464a:	4b17      	ldr	r3, [pc, #92]	; (4046a8 <Reset_Handler+0xbc>)
  40464c:	681b      	ldr	r3, [r3, #0]
  40464e:	f443 0370 	orr.w	r3, r3, #15728640	; 0xf00000
  404652:	6013      	str	r3, [r2, #0]
  __ASM volatile ("dsb");
  404654:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb");
  404658:	f3bf 8f6f 	isb	sy
	__DSB();
	__ISB();
	cpu_irq_restore(flags);
  40465c:	6878      	ldr	r0, [r7, #4]
  40465e:	4b13      	ldr	r3, [pc, #76]	; (4046ac <Reset_Handler+0xc0>)
  404660:	4798      	blx	r3

#if __FPU_USED
	fpu_enable();
#endif

	if (((uint32_t) pSrc >= IRAM_ADDR) && ((uint32_t) pSrc < IRAM_ADDR + IRAM_SIZE)) {
  404662:	68fb      	ldr	r3, [r7, #12]
  404664:	f1b3 5f00 	cmp.w	r3, #536870912	; 0x20000000
  404668:	d309      	bcc.n	40467e <Reset_Handler+0x92>
  40466a:	68fb      	ldr	r3, [r7, #12]
  40466c:	4a10      	ldr	r2, [pc, #64]	; (4046b0 <Reset_Handler+0xc4>)
  40466e:	4293      	cmp	r3, r2
  404670:	d805      	bhi.n	40467e <Reset_Handler+0x92>
		SCB->VTOR |= 1 << SCB_VTOR_TBLBASE_Pos;
  404672:	4a0b      	ldr	r2, [pc, #44]	; (4046a0 <Reset_Handler+0xb4>)
  404674:	4b0a      	ldr	r3, [pc, #40]	; (4046a0 <Reset_Handler+0xb4>)
  404676:	689b      	ldr	r3, [r3, #8]
  404678:	f043 5300 	orr.w	r3, r3, #536870912	; 0x20000000
  40467c:	6093      	str	r3, [r2, #8]
	}

	/* Initialize the C library */
	__libc_init_array();
  40467e:	4b0d      	ldr	r3, [pc, #52]	; (4046b4 <Reset_Handler+0xc8>)
  404680:	4798      	blx	r3

        /* Branch to main function */
        main();
  404682:	4b0d      	ldr	r3, [pc, #52]	; (4046b8 <Reset_Handler+0xcc>)
  404684:	4798      	blx	r3

        /* Infinite loop */
        while (1);
  404686:	e7fe      	b.n	404686 <Reset_Handler+0x9a>
  404688:	0041d8dc 	.word	0x0041d8dc
  40468c:	20000000 	.word	0x20000000
  404690:	20000d08 	.word	0x20000d08
  404694:	20000d08 	.word	0x20000d08
  404698:	20002144 	.word	0x20002144
  40469c:	00400000 	.word	0x00400000
  4046a0:	e000ed00 	.word	0xe000ed00
  4046a4:	00404565 	.word	0x00404565
  4046a8:	e000ed88 	.word	0xe000ed88
  4046ac:	004045bd 	.word	0x004045bd
  4046b0:	20027fff 	.word	0x20027fff
  4046b4:	00413f95 	.word	0x00413f95
  4046b8:	0040117d 	.word	0x0040117d

004046bc <Dummy_Handler>:

/**
 * \brief Default interrupt handler for unused IRQs.
 */
void Dummy_Handler(void)
{
  4046bc:	b480      	push	{r7}
  4046be:	af00      	add	r7, sp, #0
        while (1) {
  4046c0:	e7fe      	b.n	4046c0 <Dummy_Handler+0x4>
	...

004046c4 <SystemCoreClockUpdate>:

	SystemCoreClock = CHIP_FREQ_CPU_MAX;
}

void SystemCoreClockUpdate(void)
{
  4046c4:	b480      	push	{r7}
  4046c6:	af00      	add	r7, sp, #0
	/* Determine clock frequency according to clock register values */
	switch (PMC->PMC_MCKR & (uint32_t) PMC_MCKR_CSS_Msk) {
  4046c8:	4b41      	ldr	r3, [pc, #260]	; (4047d0 <SystemCoreClockUpdate+0x10c>)
  4046ca:	6b1b      	ldr	r3, [r3, #48]	; 0x30
  4046cc:	f003 0303 	and.w	r3, r3, #3
  4046d0:	2b01      	cmp	r3, #1
  4046d2:	d014      	beq.n	4046fe <SystemCoreClockUpdate+0x3a>
  4046d4:	2b01      	cmp	r3, #1
  4046d6:	d302      	bcc.n	4046de <SystemCoreClockUpdate+0x1a>
  4046d8:	2b02      	cmp	r3, #2
  4046da:	d038      	beq.n	40474e <SystemCoreClockUpdate+0x8a>
			SystemCoreClock *= ((((PMC->CKGR_PLLAR) & CKGR_PLLAR_MULA_Msk) >> 
					CKGR_PLLAR_MULA_Pos) + 1U);
		}
		break;
	default:
		break;
  4046dc:	e059      	b.n	404792 <SystemCoreClockUpdate+0xce>
		if (SUPC->SUPC_SR & SUPC_SR_OSCSEL) {
  4046de:	4b3d      	ldr	r3, [pc, #244]	; (4047d4 <SystemCoreClockUpdate+0x110>)
  4046e0:	695b      	ldr	r3, [r3, #20]
  4046e2:	f003 0380 	and.w	r3, r3, #128	; 0x80
  4046e6:	2b00      	cmp	r3, #0
  4046e8:	d004      	beq.n	4046f4 <SystemCoreClockUpdate+0x30>
			SystemCoreClock = CHIP_FREQ_XTAL_32K;
  4046ea:	4b3b      	ldr	r3, [pc, #236]	; (4047d8 <SystemCoreClockUpdate+0x114>)
  4046ec:	f44f 4200 	mov.w	r2, #32768	; 0x8000
  4046f0:	601a      	str	r2, [r3, #0]
		break;
  4046f2:	e04e      	b.n	404792 <SystemCoreClockUpdate+0xce>
			SystemCoreClock = CHIP_FREQ_SLCK_RC;
  4046f4:	4b38      	ldr	r3, [pc, #224]	; (4047d8 <SystemCoreClockUpdate+0x114>)
  4046f6:	f44f 42fa 	mov.w	r2, #32000	; 0x7d00
  4046fa:	601a      	str	r2, [r3, #0]
		break;
  4046fc:	e049      	b.n	404792 <SystemCoreClockUpdate+0xce>
		if (PMC->CKGR_MOR & CKGR_MOR_MOSCSEL) {
  4046fe:	4b34      	ldr	r3, [pc, #208]	; (4047d0 <SystemCoreClockUpdate+0x10c>)
  404700:	6a1b      	ldr	r3, [r3, #32]
  404702:	f003 7380 	and.w	r3, r3, #16777216	; 0x1000000
  404706:	2b00      	cmp	r3, #0
  404708:	d003      	beq.n	404712 <SystemCoreClockUpdate+0x4e>
			SystemCoreClock = CHIP_FREQ_XTAL;
  40470a:	4b33      	ldr	r3, [pc, #204]	; (4047d8 <SystemCoreClockUpdate+0x114>)
  40470c:	4a33      	ldr	r2, [pc, #204]	; (4047dc <SystemCoreClockUpdate+0x118>)
  40470e:	601a      	str	r2, [r3, #0]
		break;
  404710:	e03f      	b.n	404792 <SystemCoreClockUpdate+0xce>
			SystemCoreClock = CHIP_FREQ_MAINCK_RC_8MHZ;
  404712:	4b31      	ldr	r3, [pc, #196]	; (4047d8 <SystemCoreClockUpdate+0x114>)
  404714:	4a32      	ldr	r2, [pc, #200]	; (4047e0 <SystemCoreClockUpdate+0x11c>)
  404716:	601a      	str	r2, [r3, #0]
			switch (PMC->CKGR_MOR & CKGR_MOR_MOSCRCF_Msk) {
  404718:	4b2d      	ldr	r3, [pc, #180]	; (4047d0 <SystemCoreClockUpdate+0x10c>)
  40471a:	6a1b      	ldr	r3, [r3, #32]
  40471c:	f003 0370 	and.w	r3, r3, #112	; 0x70
  404720:	2b10      	cmp	r3, #16
  404722:	d004      	beq.n	40472e <SystemCoreClockUpdate+0x6a>
  404724:	2b20      	cmp	r3, #32
  404726:	d008      	beq.n	40473a <SystemCoreClockUpdate+0x76>
  404728:	2b00      	cmp	r3, #0
  40472a:	d00e      	beq.n	40474a <SystemCoreClockUpdate+0x86>
				break;
  40472c:	e00e      	b.n	40474c <SystemCoreClockUpdate+0x88>
				SystemCoreClock *= 2U;
  40472e:	4b2a      	ldr	r3, [pc, #168]	; (4047d8 <SystemCoreClockUpdate+0x114>)
  404730:	681b      	ldr	r3, [r3, #0]
  404732:	005b      	lsls	r3, r3, #1
  404734:	4a28      	ldr	r2, [pc, #160]	; (4047d8 <SystemCoreClockUpdate+0x114>)
  404736:	6013      	str	r3, [r2, #0]
				break;
  404738:	e008      	b.n	40474c <SystemCoreClockUpdate+0x88>
				SystemCoreClock *= 3U;
  40473a:	4b27      	ldr	r3, [pc, #156]	; (4047d8 <SystemCoreClockUpdate+0x114>)
  40473c:	681a      	ldr	r2, [r3, #0]
  40473e:	4613      	mov	r3, r2
  404740:	005b      	lsls	r3, r3, #1
  404742:	4413      	add	r3, r2
  404744:	4a24      	ldr	r2, [pc, #144]	; (4047d8 <SystemCoreClockUpdate+0x114>)
  404746:	6013      	str	r3, [r2, #0]
				break;
  404748:	e000      	b.n	40474c <SystemCoreClockUpdate+0x88>
				break;
  40474a:	bf00      	nop
		break;
  40474c:	e021      	b.n	404792 <SystemCoreClockUpdate+0xce>
		if (SUPC->SUPC_SR & SUPC_SR_OSCSEL) {
  40474e:	4b21      	ldr	r3, [pc, #132]	; (4047d4 <SystemCoreClockUpdate+0x110>)
  404750:	695b      	ldr	r3, [r3, #20]
  404752:	f003 0380 	and.w	r3, r3, #128	; 0x80
  404756:	2b00      	cmp	r3, #0
  404758:	d004      	beq.n	404764 <SystemCoreClockUpdate+0xa0>
			SystemCoreClock = CHIP_FREQ_XTAL_32K;
  40475a:	4b1f      	ldr	r3, [pc, #124]	; (4047d8 <SystemCoreClockUpdate+0x114>)
  40475c:	f44f 4200 	mov.w	r2, #32768	; 0x8000
  404760:	601a      	str	r2, [r3, #0]
  404762:	e003      	b.n	40476c <SystemCoreClockUpdate+0xa8>
			SystemCoreClock = CHIP_FREQ_SLCK_RC;
  404764:	4b1c      	ldr	r3, [pc, #112]	; (4047d8 <SystemCoreClockUpdate+0x114>)
  404766:	f44f 42fa 	mov.w	r2, #32000	; 0x7d00
  40476a:	601a      	str	r2, [r3, #0]
		if ((uint32_t) (PMC->PMC_MCKR & (uint32_t) PMC_MCKR_CSS_Msk) == PMC_MCKR_CSS_PLLA_CLK) {
  40476c:	4b18      	ldr	r3, [pc, #96]	; (4047d0 <SystemCoreClockUpdate+0x10c>)
  40476e:	6b1b      	ldr	r3, [r3, #48]	; 0x30
  404770:	f003 0303 	and.w	r3, r3, #3
  404774:	2b02      	cmp	r3, #2
  404776:	d10b      	bne.n	404790 <SystemCoreClockUpdate+0xcc>
			SystemCoreClock *= ((((PMC->CKGR_PLLAR) & CKGR_PLLAR_MULA_Msk) >> 
  404778:	4b15      	ldr	r3, [pc, #84]	; (4047d0 <SystemCoreClockUpdate+0x10c>)
  40477a:	6a9b      	ldr	r3, [r3, #40]	; 0x28
  40477c:	0c1b      	lsrs	r3, r3, #16
  40477e:	f3c3 030c 	ubfx	r3, r3, #0, #13
					CKGR_PLLAR_MULA_Pos) + 1U);
  404782:	3301      	adds	r3, #1
			SystemCoreClock *= ((((PMC->CKGR_PLLAR) & CKGR_PLLAR_MULA_Msk) >> 
  404784:	4a14      	ldr	r2, [pc, #80]	; (4047d8 <SystemCoreClockUpdate+0x114>)
  404786:	6812      	ldr	r2, [r2, #0]
  404788:	fb02 f303 	mul.w	r3, r2, r3
  40478c:	4a12      	ldr	r2, [pc, #72]	; (4047d8 <SystemCoreClockUpdate+0x114>)
  40478e:	6013      	str	r3, [r2, #0]
		break;
  404790:	bf00      	nop
	}

	if ((PMC->PMC_MCKR & PMC_MCKR_PRES_Msk) == PMC_MCKR_PRES_CLK_3) {
  404792:	4b0f      	ldr	r3, [pc, #60]	; (4047d0 <SystemCoreClockUpdate+0x10c>)
  404794:	6b1b      	ldr	r3, [r3, #48]	; 0x30
  404796:	f003 0370 	and.w	r3, r3, #112	; 0x70
  40479a:	2b70      	cmp	r3, #112	; 0x70
  40479c:	d108      	bne.n	4047b0 <SystemCoreClockUpdate+0xec>
		SystemCoreClock /= 3U;
  40479e:	4b0e      	ldr	r3, [pc, #56]	; (4047d8 <SystemCoreClockUpdate+0x114>)
  4047a0:	681b      	ldr	r3, [r3, #0]
  4047a2:	4a10      	ldr	r2, [pc, #64]	; (4047e4 <SystemCoreClockUpdate+0x120>)
  4047a4:	fba2 2303 	umull	r2, r3, r2, r3
  4047a8:	085b      	lsrs	r3, r3, #1
  4047aa:	4a0b      	ldr	r2, [pc, #44]	; (4047d8 <SystemCoreClockUpdate+0x114>)
  4047ac:	6013      	str	r3, [r2, #0]
	} else {
		SystemCoreClock >>= ((PMC->PMC_MCKR & PMC_MCKR_PRES_Msk) >> PMC_MCKR_PRES_Pos);
	}
}
  4047ae:	e00a      	b.n	4047c6 <SystemCoreClockUpdate+0x102>
		SystemCoreClock >>= ((PMC->PMC_MCKR & PMC_MCKR_PRES_Msk) >> PMC_MCKR_PRES_Pos);
  4047b0:	4b07      	ldr	r3, [pc, #28]	; (4047d0 <SystemCoreClockUpdate+0x10c>)
  4047b2:	6b1b      	ldr	r3, [r3, #48]	; 0x30
  4047b4:	091b      	lsrs	r3, r3, #4
  4047b6:	f003 0307 	and.w	r3, r3, #7
  4047ba:	4a07      	ldr	r2, [pc, #28]	; (4047d8 <SystemCoreClockUpdate+0x114>)
  4047bc:	6812      	ldr	r2, [r2, #0]
  4047be:	fa22 f303 	lsr.w	r3, r2, r3
  4047c2:	4a05      	ldr	r2, [pc, #20]	; (4047d8 <SystemCoreClockUpdate+0x114>)
  4047c4:	6013      	str	r3, [r2, #0]
}
  4047c6:	bf00      	nop
  4047c8:	46bd      	mov	sp, r7
  4047ca:	f85d 7b04 	ldr.w	r7, [sp], #4
  4047ce:	4770      	bx	lr
  4047d0:	400e0400 	.word	0x400e0400
  4047d4:	400e1410 	.word	0x400e1410
  4047d8:	2000011c 	.word	0x2000011c
  4047dc:	00b71b00 	.word	0x00b71b00
  4047e0:	007a1200 	.word	0x007a1200
  4047e4:	aaaaaaab 	.word	0xaaaaaaab

004047e8 <system_init_flash>:

/** 
 * Initialize flash.
 */
void system_init_flash(uint32_t ul_clk)
{
  4047e8:	b480      	push	{r7}
  4047ea:	b083      	sub	sp, #12
  4047ec:	af00      	add	r7, sp, #0
  4047ee:	6078      	str	r0, [r7, #4]
	/* Set FWS for embedded Flash access according to operating frequency */
	if (ul_clk < CHIP_FREQ_FWS_0) {
  4047f0:	687b      	ldr	r3, [r7, #4]
  4047f2:	4a19      	ldr	r2, [pc, #100]	; (404858 <system_init_flash+0x70>)
  4047f4:	4293      	cmp	r3, r2
  4047f6:	d804      	bhi.n	404802 <system_init_flash+0x1a>
		EFC->EEFC_FMR = EEFC_FMR_FWS(0)|EEFC_FMR_CLOE;
  4047f8:	4b18      	ldr	r3, [pc, #96]	; (40485c <system_init_flash+0x74>)
  4047fa:	f04f 6280 	mov.w	r2, #67108864	; 0x4000000
  4047fe:	601a      	str	r2, [r3, #0]
	} else if (ul_clk < CHIP_FREQ_FWS_4) {
		EFC->EEFC_FMR = EEFC_FMR_FWS(4)|EEFC_FMR_CLOE;
	} else {
		EFC->EEFC_FMR = EEFC_FMR_FWS(5)|EEFC_FMR_CLOE;
	}
}
  404800:	e023      	b.n	40484a <system_init_flash+0x62>
	} else if (ul_clk < CHIP_FREQ_FWS_1) {
  404802:	687b      	ldr	r3, [r7, #4]
  404804:	4a16      	ldr	r2, [pc, #88]	; (404860 <system_init_flash+0x78>)
  404806:	4293      	cmp	r3, r2
  404808:	d803      	bhi.n	404812 <system_init_flash+0x2a>
		EFC->EEFC_FMR = EEFC_FMR_FWS(1)|EEFC_FMR_CLOE;
  40480a:	4b14      	ldr	r3, [pc, #80]	; (40485c <system_init_flash+0x74>)
  40480c:	4a15      	ldr	r2, [pc, #84]	; (404864 <system_init_flash+0x7c>)
  40480e:	601a      	str	r2, [r3, #0]
}
  404810:	e01b      	b.n	40484a <system_init_flash+0x62>
	} else if (ul_clk < CHIP_FREQ_FWS_2) {
  404812:	687b      	ldr	r3, [r7, #4]
  404814:	4a14      	ldr	r2, [pc, #80]	; (404868 <system_init_flash+0x80>)
  404816:	4293      	cmp	r3, r2
  404818:	d803      	bhi.n	404822 <system_init_flash+0x3a>
		EFC->EEFC_FMR = EEFC_FMR_FWS(2)|EEFC_FMR_CLOE;
  40481a:	4b10      	ldr	r3, [pc, #64]	; (40485c <system_init_flash+0x74>)
  40481c:	4a13      	ldr	r2, [pc, #76]	; (40486c <system_init_flash+0x84>)
  40481e:	601a      	str	r2, [r3, #0]
}
  404820:	e013      	b.n	40484a <system_init_flash+0x62>
	} else if (ul_clk < CHIP_FREQ_FWS_3) {
  404822:	687b      	ldr	r3, [r7, #4]
  404824:	4a12      	ldr	r2, [pc, #72]	; (404870 <system_init_flash+0x88>)
  404826:	4293      	cmp	r3, r2
  404828:	d803      	bhi.n	404832 <system_init_flash+0x4a>
		EFC->EEFC_FMR = EEFC_FMR_FWS(3)|EEFC_FMR_CLOE;
  40482a:	4b0c      	ldr	r3, [pc, #48]	; (40485c <system_init_flash+0x74>)
  40482c:	4a11      	ldr	r2, [pc, #68]	; (404874 <system_init_flash+0x8c>)
  40482e:	601a      	str	r2, [r3, #0]
}
  404830:	e00b      	b.n	40484a <system_init_flash+0x62>
	} else if (ul_clk < CHIP_FREQ_FWS_4) {
  404832:	687b      	ldr	r3, [r7, #4]
  404834:	4a10      	ldr	r2, [pc, #64]	; (404878 <system_init_flash+0x90>)
  404836:	4293      	cmp	r3, r2
  404838:	d804      	bhi.n	404844 <system_init_flash+0x5c>
		EFC->EEFC_FMR = EEFC_FMR_FWS(4)|EEFC_FMR_CLOE;
  40483a:	4b08      	ldr	r3, [pc, #32]	; (40485c <system_init_flash+0x74>)
  40483c:	f04f 2204 	mov.w	r2, #67109888	; 0x4000400
  404840:	601a      	str	r2, [r3, #0]
}
  404842:	e002      	b.n	40484a <system_init_flash+0x62>
		EFC->EEFC_FMR = EEFC_FMR_FWS(5)|EEFC_FMR_CLOE;
  404844:	4b05      	ldr	r3, [pc, #20]	; (40485c <system_init_flash+0x74>)
  404846:	4a0d      	ldr	r2, [pc, #52]	; (40487c <system_init_flash+0x94>)
  404848:	601a      	str	r2, [r3, #0]
}
  40484a:	bf00      	nop
  40484c:	370c      	adds	r7, #12
  40484e:	46bd      	mov	sp, r7
  404850:	f85d 7b04 	ldr.w	r7, [sp], #4
  404854:	4770      	bx	lr
  404856:	bf00      	nop
  404858:	01312cff 	.word	0x01312cff
  40485c:	400e0a00 	.word	0x400e0a00
  404860:	026259ff 	.word	0x026259ff
  404864:	04000100 	.word	0x04000100
  404868:	039386ff 	.word	0x039386ff
  40486c:	04000200 	.word	0x04000200
  404870:	04c4b3ff 	.word	0x04c4b3ff
  404874:	04000300 	.word	0x04000300
  404878:	05f5e0ff 	.word	0x05f5e0ff
  40487c:	04000500 	.word	0x04000500

00404880 <_sbrk>:
extern void _exit(int status);
extern void _kill(int pid, int sig);
extern int _getpid(void);

extern caddr_t _sbrk(int incr)
{
  404880:	b480      	push	{r7}
  404882:	b085      	sub	sp, #20
  404884:	af00      	add	r7, sp, #0
  404886:	6078      	str	r0, [r7, #4]
	static unsigned char *heap = NULL;
	unsigned char *prev_heap;
	int ramend = (int)&__ram_end__;
  404888:	4b10      	ldr	r3, [pc, #64]	; (4048cc <_sbrk+0x4c>)
  40488a:	60fb      	str	r3, [r7, #12]

	if (heap == NULL) {
  40488c:	4b10      	ldr	r3, [pc, #64]	; (4048d0 <_sbrk+0x50>)
  40488e:	681b      	ldr	r3, [r3, #0]
  404890:	2b00      	cmp	r3, #0
  404892:	d102      	bne.n	40489a <_sbrk+0x1a>
		heap = (unsigned char *)&_end;
  404894:	4b0e      	ldr	r3, [pc, #56]	; (4048d0 <_sbrk+0x50>)
  404896:	4a0f      	ldr	r2, [pc, #60]	; (4048d4 <_sbrk+0x54>)
  404898:	601a      	str	r2, [r3, #0]
	}
	prev_heap = heap;
  40489a:	4b0d      	ldr	r3, [pc, #52]	; (4048d0 <_sbrk+0x50>)
  40489c:	681b      	ldr	r3, [r3, #0]
  40489e:	60bb      	str	r3, [r7, #8]

	if (((int)prev_heap + incr) > ramend) {
  4048a0:	68ba      	ldr	r2, [r7, #8]
  4048a2:	687b      	ldr	r3, [r7, #4]
  4048a4:	441a      	add	r2, r3
  4048a6:	68fb      	ldr	r3, [r7, #12]
  4048a8:	429a      	cmp	r2, r3
  4048aa:	dd02      	ble.n	4048b2 <_sbrk+0x32>
		return (caddr_t) -1;	
  4048ac:	f04f 33ff 	mov.w	r3, #4294967295
  4048b0:	e006      	b.n	4048c0 <_sbrk+0x40>
	}

	heap += incr;
  4048b2:	4b07      	ldr	r3, [pc, #28]	; (4048d0 <_sbrk+0x50>)
  4048b4:	681a      	ldr	r2, [r3, #0]
  4048b6:	687b      	ldr	r3, [r7, #4]
  4048b8:	4413      	add	r3, r2
  4048ba:	4a05      	ldr	r2, [pc, #20]	; (4048d0 <_sbrk+0x50>)
  4048bc:	6013      	str	r3, [r2, #0]

	return (caddr_t) prev_heap;
  4048be:	68bb      	ldr	r3, [r7, #8]
}
  4048c0:	4618      	mov	r0, r3
  4048c2:	3714      	adds	r7, #20
  4048c4:	46bd      	mov	sp, r7
  4048c6:	f85d 7b04 	ldr.w	r7, [sp], #4
  4048ca:	4770      	bx	lr
  4048cc:	20027ffc 	.word	0x20027ffc
  4048d0:	20001430 	.word	0x20001430
  4048d4:	20005148 	.word	0x20005148

004048d8 <inv_icm20948_register_aux_compass>:
static const short AK09916_ST_Lower[3] = {-200, -200, -1000};
static const short AK09916_ST_Upper[3] = {200, 200, -200};

void inv_icm20948_register_aux_compass(struct inv_icm20948 * s,
		enum inv_icm20948_compass_id compass_id, uint8_t compass_i2c_addr)
{
  4048d8:	b480      	push	{r7}
  4048da:	b083      	sub	sp, #12
  4048dc:	af00      	add	r7, sp, #0
  4048de:	6078      	str	r0, [r7, #4]
  4048e0:	460b      	mov	r3, r1
  4048e2:	70fb      	strb	r3, [r7, #3]
  4048e4:	4613      	mov	r3, r2
  4048e6:	70bb      	strb	r3, [r7, #2]
	switch(compass_id) {
  4048e8:	78fb      	ldrb	r3, [r7, #3]
  4048ea:	3b01      	subs	r3, #1
  4048ec:	2b03      	cmp	r3, #3
  4048ee:	d86f      	bhi.n	4049d0 <inv_icm20948_register_aux_compass+0xf8>
  4048f0:	a201      	add	r2, pc, #4	; (adr r2, 4048f8 <inv_icm20948_register_aux_compass+0x20>)
  4048f2:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
  4048f6:	bf00      	nop
  4048f8:	00404909 	.word	0x00404909
  4048fc:	0040493b 	.word	0x0040493b
  404900:	0040499f 	.word	0x0040499f
  404904:	0040496d 	.word	0x0040496d
	case INV_ICM20948_COMPASS_ID_AK09911:
		s->secondary_state.compass_slave_id = HW_AK09911;
  404908:	687b      	ldr	r3, [r7, #4]
  40490a:	2223      	movs	r2, #35	; 0x23
  40490c:	f8c3 2088 	str.w	r2, [r3, #136]	; 0x88
		s->secondary_state.compass_chip_addr = compass_i2c_addr;
  404910:	78ba      	ldrb	r2, [r7, #2]
  404912:	687b      	ldr	r3, [r7, #4]
  404914:	f8c3 2084 	str.w	r2, [r3, #132]	; 0x84
		s->secondary_state.compass_state = INV_ICM20948_COMPASS_INITED;
  404918:	687b      	ldr	r3, [r7, #4]
  40491a:	2201      	movs	r2, #1
  40491c:	f883 208c 	strb.w	r2, [r3, #140]	; 0x8c
		/* initialise mounting matrix of compass to identity akm9911 */
		s->mounting_matrix_secondary_compass[0] = -1 ;
  404920:	687b      	ldr	r3, [r7, #4]
  404922:	22ff      	movs	r2, #255	; 0xff
  404924:	f883 227d 	strb.w	r2, [r3, #637]	; 0x27d
		s->mounting_matrix_secondary_compass[4] = -1;
  404928:	687b      	ldr	r3, [r7, #4]
  40492a:	22ff      	movs	r2, #255	; 0xff
  40492c:	f883 2281 	strb.w	r2, [r3, #641]	; 0x281
		s->mounting_matrix_secondary_compass[8] = 1;
  404930:	687b      	ldr	r3, [r7, #4]
  404932:	2201      	movs	r2, #1
  404934:	f883 2285 	strb.w	r2, [r3, #645]	; 0x285
		break;
  404938:	e056      	b.n	4049e8 <inv_icm20948_register_aux_compass+0x110>
	case INV_ICM20948_COMPASS_ID_AK09912:
		s->secondary_state.compass_slave_id = HW_AK09912;
  40493a:	687b      	ldr	r3, [r7, #4]
  40493c:	2224      	movs	r2, #36	; 0x24
  40493e:	f8c3 2088 	str.w	r2, [r3, #136]	; 0x88
		s->secondary_state.compass_chip_addr = compass_i2c_addr;
  404942:	78ba      	ldrb	r2, [r7, #2]
  404944:	687b      	ldr	r3, [r7, #4]
  404946:	f8c3 2084 	str.w	r2, [r3, #132]	; 0x84
		s->secondary_state.compass_state = INV_ICM20948_COMPASS_INITED;
  40494a:	687b      	ldr	r3, [r7, #4]
  40494c:	2201      	movs	r2, #1
  40494e:	f883 208c 	strb.w	r2, [r3, #140]	; 0x8c
		/* initialise mounting matrix of compass to identity akm9912 */
		s->mounting_matrix_secondary_compass[0] = 1 ;
  404952:	687b      	ldr	r3, [r7, #4]
  404954:	2201      	movs	r2, #1
  404956:	f883 227d 	strb.w	r2, [r3, #637]	; 0x27d
		s->mounting_matrix_secondary_compass[4] = 1;
  40495a:	687b      	ldr	r3, [r7, #4]
  40495c:	2201      	movs	r2, #1
  40495e:	f883 2281 	strb.w	r2, [r3, #641]	; 0x281
		s->mounting_matrix_secondary_compass[8] = 1;
  404962:	687b      	ldr	r3, [r7, #4]
  404964:	2201      	movs	r2, #1
  404966:	f883 2285 	strb.w	r2, [r3, #645]	; 0x285
		break;
  40496a:	e03d      	b.n	4049e8 <inv_icm20948_register_aux_compass+0x110>
	case INV_ICM20948_COMPASS_ID_AK08963:
		s->secondary_state.compass_slave_id = HW_AK8963;
  40496c:	687b      	ldr	r3, [r7, #4]
  40496e:	2220      	movs	r2, #32
  404970:	f8c3 2088 	str.w	r2, [r3, #136]	; 0x88
		s->secondary_state.compass_chip_addr = compass_i2c_addr;
  404974:	78ba      	ldrb	r2, [r7, #2]
  404976:	687b      	ldr	r3, [r7, #4]
  404978:	f8c3 2084 	str.w	r2, [r3, #132]	; 0x84
		s->secondary_state.compass_state = INV_ICM20948_COMPASS_INITED;
  40497c:	687b      	ldr	r3, [r7, #4]
  40497e:	2201      	movs	r2, #1
  404980:	f883 208c 	strb.w	r2, [r3, #140]	; 0x8c
		/* initialise mounting matrix of compass to identity akm8963 */
		s->mounting_matrix_secondary_compass[0] = 1;
  404984:	687b      	ldr	r3, [r7, #4]
  404986:	2201      	movs	r2, #1
  404988:	f883 227d 	strb.w	r2, [r3, #637]	; 0x27d
		s->mounting_matrix_secondary_compass[4] = 1;
  40498c:	687b      	ldr	r3, [r7, #4]
  40498e:	2201      	movs	r2, #1
  404990:	f883 2281 	strb.w	r2, [r3, #641]	; 0x281
		s->mounting_matrix_secondary_compass[8] = 1;
  404994:	687b      	ldr	r3, [r7, #4]
  404996:	2201      	movs	r2, #1
  404998:	f883 2285 	strb.w	r2, [r3, #645]	; 0x285
		break;
  40499c:	e024      	b.n	4049e8 <inv_icm20948_register_aux_compass+0x110>
	case INV_ICM20948_COMPASS_ID_AK09916:
		s->secondary_state.compass_slave_id = HW_AK09916;
  40499e:	687b      	ldr	r3, [r7, #4]
  4049a0:	2225      	movs	r2, #37	; 0x25
  4049a2:	f8c3 2088 	str.w	r2, [r3, #136]	; 0x88
		s->secondary_state.compass_chip_addr = compass_i2c_addr;
  4049a6:	78ba      	ldrb	r2, [r7, #2]
  4049a8:	687b      	ldr	r3, [r7, #4]
  4049aa:	f8c3 2084 	str.w	r2, [r3, #132]	; 0x84
		s->secondary_state.compass_state = INV_ICM20948_COMPASS_INITED;
  4049ae:	687b      	ldr	r3, [r7, #4]
  4049b0:	2201      	movs	r2, #1
  4049b2:	f883 208c 	strb.w	r2, [r3, #140]	; 0x8c
		/* initialise mounting matrix of compass to identity akm9916 */
		s->mounting_matrix_secondary_compass[0] = 1 ;
  4049b6:	687b      	ldr	r3, [r7, #4]
  4049b8:	2201      	movs	r2, #1
  4049ba:	f883 227d 	strb.w	r2, [r3, #637]	; 0x27d
		s->mounting_matrix_secondary_compass[4] = -1;
  4049be:	687b      	ldr	r3, [r7, #4]
  4049c0:	22ff      	movs	r2, #255	; 0xff
  4049c2:	f883 2281 	strb.w	r2, [r3, #641]	; 0x281
		s->mounting_matrix_secondary_compass[8] = -1;
  4049c6:	687b      	ldr	r3, [r7, #4]
  4049c8:	22ff      	movs	r2, #255	; 0xff
  4049ca:	f883 2285 	strb.w	r2, [r3, #645]	; 0x285
		break;
  4049ce:	e00b      	b.n	4049e8 <inv_icm20948_register_aux_compass+0x110>
	default:
		s->secondary_state.compass_slave_id  = 0;
  4049d0:	687b      	ldr	r3, [r7, #4]
  4049d2:	2200      	movs	r2, #0
  4049d4:	f8c3 2088 	str.w	r2, [r3, #136]	; 0x88
		s->secondary_state.compass_chip_addr = 0;
  4049d8:	687b      	ldr	r3, [r7, #4]
  4049da:	2200      	movs	r2, #0
  4049dc:	f8c3 2084 	str.w	r2, [r3, #132]	; 0x84
		s->secondary_state.compass_state = INV_ICM20948_COMPASS_RESET;
  4049e0:	687b      	ldr	r3, [r7, #4]
  4049e2:	2200      	movs	r2, #0
  4049e4:	f883 208c 	strb.w	r2, [r3, #140]	; 0x8c
	}
}
  4049e8:	bf00      	nop
  4049ea:	370c      	adds	r7, #12
  4049ec:	46bd      	mov	sp, r7
  4049ee:	f85d 7b04 	ldr.w	r7, [sp], #4
  4049f2:	4770      	bx	lr

004049f4 <inv_icm20948_setup_compass_akm>:

/*
 *  inv_icm20948_setup_compass_akm() - Configure akm series compass.
 */
int inv_icm20948_setup_compass_akm(struct inv_icm20948 * s)
{
  4049f4:	b590      	push	{r4, r7, lr}
  4049f6:	b087      	sub	sp, #28
  4049f8:	af02      	add	r7, sp, #8
  4049fa:	6078      	str	r0, [r7, #4]
	unsigned char data[4];
#if (MEMS_CHIP != HW_ICM20948)
	uint8_t sens, cmd;
#endif
	//reset variable to initial values
	memset(s->secondary_state.final_matrix, 0, sizeof(s->secondary_state.final_matrix));
  4049fc:	687b      	ldr	r3, [r7, #4]
  4049fe:	3350      	adds	r3, #80	; 0x50
  404a00:	2224      	movs	r2, #36	; 0x24
  404a02:	2100      	movs	r1, #0
  404a04:	4618      	mov	r0, r3
  404a06:	4b34      	ldr	r3, [pc, #208]	; (404ad8 <inv_icm20948_setup_compass_akm+0xe4>)
  404a08:	4798      	blx	r3
	memset(s->secondary_state.compass_sens, 0, sizeof(s->secondary_state.compass_sens));
  404a0a:	687b      	ldr	r3, [r7, #4]
  404a0c:	334d      	adds	r3, #77	; 0x4d
  404a0e:	2203      	movs	r2, #3
  404a10:	2100      	movs	r1, #0
  404a12:	4618      	mov	r0, r3
  404a14:	4b30      	ldr	r3, [pc, #192]	; (404ad8 <inv_icm20948_setup_compass_akm+0xe4>)
  404a16:	4798      	blx	r3
	s->secondary_state.scale = 0;
  404a18:	687b      	ldr	r3, [r7, #4]
  404a1a:	2200      	movs	r2, #0
  404a1c:	67da      	str	r2, [r3, #124]	; 0x7c
	s->secondary_state.dmp_on = 1;
  404a1e:	687b      	ldr	r3, [r7, #4]
  404a20:	2201      	movs	r2, #1
  404a22:	f883 2080 	strb.w	r2, [r3, #128]	; 0x80
	s->secondary_state.secondary_resume_compass_state = 0;
  404a26:	687b      	ldr	r3, [r7, #4]
  404a28:	2200      	movs	r2, #0
  404a2a:	f883 2081 	strb.w	r2, [r3, #129]	; 0x81

	/* Read WHOAMI through I2C SLV for compass */
	result = inv_icm20948_execute_read_secondary(s, COMPASS_I2C_SLV_READ, s->secondary_state.compass_chip_addr, REG_AKM_ID, 1, data);
  404a2e:	687b      	ldr	r3, [r7, #4]
  404a30:	f8d3 3084 	ldr.w	r3, [r3, #132]	; 0x84
  404a34:	b2da      	uxtb	r2, r3
  404a36:	f107 0308 	add.w	r3, r7, #8
  404a3a:	9301      	str	r3, [sp, #4]
  404a3c:	2301      	movs	r3, #1
  404a3e:	9300      	str	r3, [sp, #0]
  404a40:	2300      	movs	r3, #0
  404a42:	2100      	movs	r1, #0
  404a44:	6878      	ldr	r0, [r7, #4]
  404a46:	4c25      	ldr	r4, [pc, #148]	; (404adc <inv_icm20948_setup_compass_akm+0xe8>)
  404a48:	47a0      	blx	r4
  404a4a:	60f8      	str	r0, [r7, #12]
	if (result) {
  404a4c:	68fb      	ldr	r3, [r7, #12]
  404a4e:	2b00      	cmp	r3, #0
  404a50:	d001      	beq.n	404a56 <inv_icm20948_setup_compass_akm+0x62>
        // inv_log("Read secondary error: Compass.\r\n");
		return result;
  404a52:	68fb      	ldr	r3, [r7, #12]
  404a54:	e03c      	b.n	404ad0 <inv_icm20948_setup_compass_akm+0xdc>
    }
	if (data[0] != DATA_AKM_ID) {
  404a56:	7a3b      	ldrb	r3, [r7, #8]
  404a58:	2b48      	cmp	r3, #72	; 0x48
  404a5a:	d002      	beq.n	404a62 <inv_icm20948_setup_compass_akm+0x6e>
        // inv_log("Compass not found!!\r\n");
		return -1;
  404a5c:	f04f 33ff 	mov.w	r3, #4294967295
  404a60:	e036      	b.n	404ad0 <inv_icm20948_setup_compass_akm+0xdc>
    }
    // inv_log("Compass found.\r\n");

	/* setup upper and lower limit of self-test */
#if (MEMS_CHIP == HW_ICM20948)
	s->secondary_state.st_upper = AK09916_ST_Upper;
  404a62:	687b      	ldr	r3, [r7, #4]
  404a64:	4a1e      	ldr	r2, [pc, #120]	; (404ae0 <inv_icm20948_setup_compass_akm+0xec>)
  404a66:	675a      	str	r2, [r3, #116]	; 0x74
	s->secondary_state.st_lower = AK09916_ST_Lower;
  404a68:	687b      	ldr	r3, [r7, #4]
  404a6a:	4a1e      	ldr	r2, [pc, #120]	; (404ae4 <inv_icm20948_setup_compass_akm+0xf0>)
  404a6c:	679a      	str	r2, [r3, #120]	; 0x78
#endif


#if (MEMS_CHIP == HW_ICM20948)
	/* Read conf and configure compass through I2C SLV for compass and subsequent channel */
	s->secondary_state.mode_reg_addr = REG_AK09916_CNTL2;
  404a6e:	687b      	ldr	r3, [r7, #4]
  404a70:	2231      	movs	r2, #49	; 0x31
  404a72:	f883 2082 	strb.w	r2, [r3, #130]	; 0x82
	// no sensitivity adjustment value
	s->secondary_state.compass_sens[0] = 128;
  404a76:	687b      	ldr	r3, [r7, #4]
  404a78:	2280      	movs	r2, #128	; 0x80
  404a7a:	f883 204d 	strb.w	r2, [r3, #77]	; 0x4d
	s->secondary_state.compass_sens[1] = 128;
  404a7e:	687b      	ldr	r3, [r7, #4]
  404a80:	2280      	movs	r2, #128	; 0x80
  404a82:	f883 204e 	strb.w	r2, [r3, #78]	; 0x4e
	s->secondary_state.compass_sens[2] = 128;
  404a86:	687b      	ldr	r3, [r7, #4]
  404a88:	2280      	movs	r2, #128	; 0x80
  404a8a:	f883 204f 	strb.w	r2, [r3, #79]	; 0x4f
		if (result)
			return result;
	}
#endif
	/* Set compass in power down through I2C SLV for compass */
	result = inv_icm20948_execute_write_secondary(s, COMPASS_I2C_SLV_WRITE, s->secondary_state.compass_chip_addr, s->secondary_state.mode_reg_addr, DATA_AKM_MODE_PD);
  404a8e:	687b      	ldr	r3, [r7, #4]
  404a90:	f8d3 3084 	ldr.w	r3, [r3, #132]	; 0x84
  404a94:	b2da      	uxtb	r2, r3
  404a96:	687b      	ldr	r3, [r7, #4]
  404a98:	f893 3082 	ldrb.w	r3, [r3, #130]	; 0x82
  404a9c:	4619      	mov	r1, r3
  404a9e:	2300      	movs	r3, #0
  404aa0:	9300      	str	r3, [sp, #0]
  404aa2:	460b      	mov	r3, r1
  404aa4:	2101      	movs	r1, #1
  404aa6:	6878      	ldr	r0, [r7, #4]
  404aa8:	4c0f      	ldr	r4, [pc, #60]	; (404ae8 <inv_icm20948_setup_compass_akm+0xf4>)
  404aaa:	47a0      	blx	r4
  404aac:	60f8      	str	r0, [r7, #12]
	if (result)
  404aae:	68fb      	ldr	r3, [r7, #12]
  404ab0:	2b00      	cmp	r3, #0
  404ab2:	d001      	beq.n	404ab8 <inv_icm20948_setup_compass_akm+0xc4>
		return result;
  404ab4:	68fb      	ldr	r3, [r7, #12]
  404ab6:	e00b      	b.n	404ad0 <inv_icm20948_setup_compass_akm+0xdc>

	s->secondary_state.secondary_resume_compass_state = 1;
  404ab8:	687b      	ldr	r3, [r7, #4]
  404aba:	2201      	movs	r2, #1
  404abc:	f883 2081 	strb.w	r2, [r3, #129]	; 0x81
	s->secondary_state.compass_state = INV_ICM20948_COMPASS_SETUP;
  404ac0:	687b      	ldr	r3, [r7, #4]
  404ac2:	2202      	movs	r2, #2
  404ac4:	f883 208c 	strb.w	r2, [r3, #140]	; 0x8c
	return inv_icm20948_suspend_akm(s);
  404ac8:	6878      	ldr	r0, [r7, #4]
  404aca:	4b08      	ldr	r3, [pc, #32]	; (404aec <inv_icm20948_setup_compass_akm+0xf8>)
  404acc:	4798      	blx	r3
  404ace:	4603      	mov	r3, r0
}
  404ad0:	4618      	mov	r0, r3
  404ad2:	3714      	adds	r7, #20
  404ad4:	46bd      	mov	sp, r7
  404ad6:	bd90      	pop	{r4, r7, pc}
  404ad8:	00414241 	.word	0x00414241
  404adc:	00405479 	.word	0x00405479
  404ae0:	0041bd08 	.word	0x0041bd08
  404ae4:	0041bd00 	.word	0x0041bd00
  404ae8:	004055d1 	.word	0x004055d1
  404aec:	00404e2d 	.word	0x00404e2d

00404af0 <inv_icm20948_check_akm_self_test>:

int inv_icm20948_check_akm_self_test(struct inv_icm20948 * s)
{
  404af0:	b590      	push	{r4, r7, lr}
  404af2:	b091      	sub	sp, #68	; 0x44
  404af4:	af02      	add	r7, sp, #8
  404af6:	6078      	str	r0, [r7, #4]
	unsigned char slv_ctrl[2];
	unsigned char odr_cfg;
#if (MEMS_CHIP != HW_ICM20948)
	unsigned char cntl;
#endif
	addr = s->secondary_state.compass_chip_addr;
  404af8:	687b      	ldr	r3, [r7, #4]
  404afa:	f8d3 3084 	ldr.w	r3, [r3, #132]	; 0x84
  404afe:	f887 302b 	strb.w	r3, [r7, #43]	; 0x2b
	sens = s->secondary_state.compass_sens;
  404b02:	687b      	ldr	r3, [r7, #4]
  404b04:	334d      	adds	r3, #77	; 0x4d
  404b06:	627b      	str	r3, [r7, #36]	; 0x24

	/* back up registers */
	/* SLV0_CTRL */
	result = inv_icm20948_read_mems_reg(s, REG_I2C_SLV0_CTRL, 1, &slv_ctrl[0]);
  404b08:	f107 0310 	add.w	r3, r7, #16
  404b0c:	2201      	movs	r2, #1
  404b0e:	f240 1185 	movw	r1, #389	; 0x185
  404b12:	6878      	ldr	r0, [r7, #4]
  404b14:	4ca6      	ldr	r4, [pc, #664]	; (404db0 <inv_icm20948_check_akm_self_test+0x2c0>)
  404b16:	47a0      	blx	r4
  404b18:	6378      	str	r0, [r7, #52]	; 0x34
	if (result)
  404b1a:	6b7b      	ldr	r3, [r7, #52]	; 0x34
  404b1c:	2b00      	cmp	r3, #0
  404b1e:	d001      	beq.n	404b24 <inv_icm20948_check_akm_self_test+0x34>
		return result;
  404b20:	6b7b      	ldr	r3, [r7, #52]	; 0x34
  404b22:	e17c      	b.n	404e1e <inv_icm20948_check_akm_self_test+0x32e>
	result = inv_icm20948_write_single_mems_reg(s, REG_I2C_SLV0_CTRL, 0);
  404b24:	2200      	movs	r2, #0
  404b26:	f240 1185 	movw	r1, #389	; 0x185
  404b2a:	6878      	ldr	r0, [r7, #4]
  404b2c:	4ba1      	ldr	r3, [pc, #644]	; (404db4 <inv_icm20948_check_akm_self_test+0x2c4>)
  404b2e:	4798      	blx	r3
  404b30:	6378      	str	r0, [r7, #52]	; 0x34
	if (result)
  404b32:	6b7b      	ldr	r3, [r7, #52]	; 0x34
  404b34:	2b00      	cmp	r3, #0
  404b36:	d001      	beq.n	404b3c <inv_icm20948_check_akm_self_test+0x4c>
		return result;
  404b38:	6b7b      	ldr	r3, [r7, #52]	; 0x34
  404b3a:	e170      	b.n	404e1e <inv_icm20948_check_akm_self_test+0x32e>
	/* SLV1_CTRL */
	result = inv_icm20948_read_mems_reg(s, REG_I2C_SLV1_CTRL, 1, &slv_ctrl[1]);
  404b3c:	f107 0310 	add.w	r3, r7, #16
  404b40:	3301      	adds	r3, #1
  404b42:	2201      	movs	r2, #1
  404b44:	f240 1189 	movw	r1, #393	; 0x189
  404b48:	6878      	ldr	r0, [r7, #4]
  404b4a:	4c99      	ldr	r4, [pc, #612]	; (404db0 <inv_icm20948_check_akm_self_test+0x2c0>)
  404b4c:	47a0      	blx	r4
  404b4e:	6378      	str	r0, [r7, #52]	; 0x34
	if (result)
  404b50:	6b7b      	ldr	r3, [r7, #52]	; 0x34
  404b52:	2b00      	cmp	r3, #0
  404b54:	d001      	beq.n	404b5a <inv_icm20948_check_akm_self_test+0x6a>
		return result;
  404b56:	6b7b      	ldr	r3, [r7, #52]	; 0x34
  404b58:	e161      	b.n	404e1e <inv_icm20948_check_akm_self_test+0x32e>
	result = inv_icm20948_write_single_mems_reg(s, REG_I2C_SLV1_CTRL, 0);
  404b5a:	2200      	movs	r2, #0
  404b5c:	f240 1189 	movw	r1, #393	; 0x189
  404b60:	6878      	ldr	r0, [r7, #4]
  404b62:	4b94      	ldr	r3, [pc, #592]	; (404db4 <inv_icm20948_check_akm_self_test+0x2c4>)
  404b64:	4798      	blx	r3
  404b66:	6378      	str	r0, [r7, #52]	; 0x34
	if (result)
  404b68:	6b7b      	ldr	r3, [r7, #52]	; 0x34
  404b6a:	2b00      	cmp	r3, #0
  404b6c:	d001      	beq.n	404b72 <inv_icm20948_check_akm_self_test+0x82>
		return result;
  404b6e:	6b7b      	ldr	r3, [r7, #52]	; 0x34
  404b70:	e155      	b.n	404e1e <inv_icm20948_check_akm_self_test+0x32e>
	/* I2C_MST ODR */
	result = inv_icm20948_read_mems_reg(s, REG_I2C_MST_ODR_CONFIG, 1, &odr_cfg);
  404b72:	f107 030f 	add.w	r3, r7, #15
  404b76:	2201      	movs	r2, #1
  404b78:	f44f 71c0 	mov.w	r1, #384	; 0x180
  404b7c:	6878      	ldr	r0, [r7, #4]
  404b7e:	4c8c      	ldr	r4, [pc, #560]	; (404db0 <inv_icm20948_check_akm_self_test+0x2c0>)
  404b80:	47a0      	blx	r4
  404b82:	6378      	str	r0, [r7, #52]	; 0x34
	if (result)
  404b84:	6b7b      	ldr	r3, [r7, #52]	; 0x34
  404b86:	2b00      	cmp	r3, #0
  404b88:	d001      	beq.n	404b8e <inv_icm20948_check_akm_self_test+0x9e>
		return result;
  404b8a:	6b7b      	ldr	r3, [r7, #52]	; 0x34
  404b8c:	e147      	b.n	404e1e <inv_icm20948_check_akm_self_test+0x32e>
	result = inv_icm20948_write_single_mems_reg(s, REG_I2C_MST_ODR_CONFIG, 0);
  404b8e:	2200      	movs	r2, #0
  404b90:	f44f 71c0 	mov.w	r1, #384	; 0x180
  404b94:	6878      	ldr	r0, [r7, #4]
  404b96:	4b87      	ldr	r3, [pc, #540]	; (404db4 <inv_icm20948_check_akm_self_test+0x2c4>)
  404b98:	4798      	blx	r3
  404b9a:	6378      	str	r0, [r7, #52]	; 0x34
	if (result)
  404b9c:	6b7b      	ldr	r3, [r7, #52]	; 0x34
  404b9e:	2b00      	cmp	r3, #0
  404ba0:	d001      	beq.n	404ba6 <inv_icm20948_check_akm_self_test+0xb6>
		return result;
  404ba2:	6b7b      	ldr	r3, [r7, #52]	; 0x34
  404ba4:	e13b      	b.n	404e1e <inv_icm20948_check_akm_self_test+0x32e>

#if (MEMS_CHIP == HW_ICM20948)
	mode = REG_AK09916_CNTL2;
  404ba6:	2331      	movs	r3, #49	; 0x31
  404ba8:	f887 3023 	strb.w	r3, [r7, #35]	; 0x23
		mode = REG_AK09916_CNTL2;
	else
		mode = REG_AKM_MODE;
#endif
	/* set to power down mode */
	result = inv_icm20948_execute_write_secondary(s, 0, addr, mode, DATA_AKM_MODE_PD);
  404bac:	f897 1023 	ldrb.w	r1, [r7, #35]	; 0x23
  404bb0:	f897 202b 	ldrb.w	r2, [r7, #43]	; 0x2b
  404bb4:	2300      	movs	r3, #0
  404bb6:	9300      	str	r3, [sp, #0]
  404bb8:	460b      	mov	r3, r1
  404bba:	2100      	movs	r1, #0
  404bbc:	6878      	ldr	r0, [r7, #4]
  404bbe:	4c7e      	ldr	r4, [pc, #504]	; (404db8 <inv_icm20948_check_akm_self_test+0x2c8>)
  404bc0:	47a0      	blx	r4
  404bc2:	6378      	str	r0, [r7, #52]	; 0x34
	if (result)
  404bc4:	6b7b      	ldr	r3, [r7, #52]	; 0x34
  404bc6:	2b00      	cmp	r3, #0
  404bc8:	f040 80e9 	bne.w	404d9e <inv_icm20948_check_akm_self_test+0x2ae>
		goto AKM_fail;

	/* write 1 to ASTC register */
	if ((HW_AK09911 != s->secondary_state.compass_slave_id) &&
  404bcc:	687b      	ldr	r3, [r7, #4]
  404bce:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
  404bd2:	2b23      	cmp	r3, #35	; 0x23
  404bd4:	d012      	beq.n	404bfc <inv_icm20948_check_akm_self_test+0x10c>
		(HW_AK09912 != s->secondary_state.compass_slave_id)) {
  404bd6:	687b      	ldr	r3, [r7, #4]
  404bd8:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
	if ((HW_AK09911 != s->secondary_state.compass_slave_id) &&
  404bdc:	2b24      	cmp	r3, #36	; 0x24
  404bde:	d00d      	beq.n	404bfc <inv_icm20948_check_akm_self_test+0x10c>
		result = inv_icm20948_execute_write_secondary(s, 0, addr, REG_AKM_ST_CTRL, DATA_AKM_SELF_TEST);
  404be0:	f897 202b 	ldrb.w	r2, [r7, #43]	; 0x2b
  404be4:	2340      	movs	r3, #64	; 0x40
  404be6:	9300      	str	r3, [sp, #0]
  404be8:	230c      	movs	r3, #12
  404bea:	2100      	movs	r1, #0
  404bec:	6878      	ldr	r0, [r7, #4]
  404bee:	4c72      	ldr	r4, [pc, #456]	; (404db8 <inv_icm20948_check_akm_self_test+0x2c8>)
  404bf0:	47a0      	blx	r4
  404bf2:	6378      	str	r0, [r7, #52]	; 0x34
		if (result)
  404bf4:	6b7b      	ldr	r3, [r7, #52]	; 0x34
  404bf6:	2b00      	cmp	r3, #0
  404bf8:	f040 80d3 	bne.w	404da2 <inv_icm20948_check_akm_self_test+0x2b2>
			goto AKM_fail;
	}
#if (MEMS_CHIP == HW_ICM20948)
	result = inv_icm20948_execute_write_secondary(s, 0, addr, mode, DATA_AK09916_MODE_ST);
  404bfc:	f897 1023 	ldrb.w	r1, [r7, #35]	; 0x23
  404c00:	f897 202b 	ldrb.w	r2, [r7, #43]	; 0x2b
  404c04:	2310      	movs	r3, #16
  404c06:	9300      	str	r3, [sp, #0]
  404c08:	460b      	mov	r3, r1
  404c0a:	2100      	movs	r1, #0
  404c0c:	6878      	ldr	r0, [r7, #4]
  404c0e:	4c6a      	ldr	r4, [pc, #424]	; (404db8 <inv_icm20948_check_akm_self_test+0x2c8>)
  404c10:	47a0      	blx	r4
  404c12:	6378      	str	r0, [r7, #52]	; 0x34
	else if (HW_AK09916 == s->secondary_state.compass_slave_id)
		result = inv_icm20948_execute_write_secondary(s, 0, addr, mode, DATA_AK09916_MODE_ST);
	else
		result = inv_icm20948_execute_write_secondary(s, 0, addr, mode,	DATA_AKM_MODE_ST);
#endif
	if (result)
  404c14:	6b7b      	ldr	r3, [r7, #52]	; 0x34
  404c16:	2b00      	cmp	r3, #0
  404c18:	f040 80c5 	bne.w	404da6 <inv_icm20948_check_akm_self_test+0x2b6>
		goto AKM_fail;
	counter = DEF_ST_COMPASS_TRY_TIMES;
  404c1c:	230a      	movs	r3, #10
  404c1e:	f887 3033 	strb.w	r3, [r7, #51]	; 0x33
	while (counter > 0) {
  404c22:	e022      	b.n	404c6a <inv_icm20948_check_akm_self_test+0x17a>
//		usleep_range(DEF_ST_COMPASS_WAIT_MIN, DEF_ST_COMPASS_WAIT_MAX);
        inv_icm20948_sleep_us(15000);
  404c24:	f643 2098 	movw	r0, #15000	; 0x3a98
  404c28:	4b64      	ldr	r3, [pc, #400]	; (404dbc <inv_icm20948_check_akm_self_test+0x2cc>)
  404c2a:	4798      	blx	r3

#if (MEMS_CHIP == HW_ICM20948)
		result = inv_icm20948_execute_read_secondary(s, 0, addr, REG_AK09916_STATUS1, 1, data);
  404c2c:	f897 202b 	ldrb.w	r2, [r7, #43]	; 0x2b
  404c30:	f107 0314 	add.w	r3, r7, #20
  404c34:	9301      	str	r3, [sp, #4]
  404c36:	2301      	movs	r3, #1
  404c38:	9300      	str	r3, [sp, #0]
  404c3a:	2310      	movs	r3, #16
  404c3c:	2100      	movs	r1, #0
  404c3e:	6878      	ldr	r0, [r7, #4]
  404c40:	4c5f      	ldr	r4, [pc, #380]	; (404dc0 <inv_icm20948_check_akm_self_test+0x2d0>)
  404c42:	47a0      	blx	r4
  404c44:	6378      	str	r0, [r7, #52]	; 0x34
		else if (HW_AK09916 == s->secondary_state.compass_slave_id)
			result = inv_icm20948_execute_read_secondary(s, 0, addr, REG_AK09916_STATUS1, 1, data);
		else
			result = inv_icm20948_execute_read_secondary(s, 0, addr, REG_AKM_STATUS, 1, data);
#endif
		if (result)
  404c46:	6b7b      	ldr	r3, [r7, #52]	; 0x34
  404c48:	2b00      	cmp	r3, #0
  404c4a:	f040 80ae 	bne.w	404daa <inv_icm20948_check_akm_self_test+0x2ba>
			goto AKM_fail;
		if ((data[0] & DATA_AKM_DRDY) == 0)
  404c4e:	7d3b      	ldrb	r3, [r7, #20]
  404c50:	f003 0301 	and.w	r3, r3, #1
  404c54:	2b00      	cmp	r3, #0
  404c56:	d105      	bne.n	404c64 <inv_icm20948_check_akm_self_test+0x174>
			counter--;
  404c58:	f897 3033 	ldrb.w	r3, [r7, #51]	; 0x33
  404c5c:	3b01      	subs	r3, #1
  404c5e:	f887 3033 	strb.w	r3, [r7, #51]	; 0x33
  404c62:	e002      	b.n	404c6a <inv_icm20948_check_akm_self_test+0x17a>
		else
			counter = 0;
  404c64:	2300      	movs	r3, #0
  404c66:	f887 3033 	strb.w	r3, [r7, #51]	; 0x33
	while (counter > 0) {
  404c6a:	f897 3033 	ldrb.w	r3, [r7, #51]	; 0x33
  404c6e:	2b00      	cmp	r3, #0
  404c70:	d1d8      	bne.n	404c24 <inv_icm20948_check_akm_self_test+0x134>
	}
	if ((data[0] & DATA_AKM_DRDY) == 0) {
  404c72:	7d3b      	ldrb	r3, [r7, #20]
  404c74:	f003 0301 	and.w	r3, r3, #1
  404c78:	2b00      	cmp	r3, #0
  404c7a:	d103      	bne.n	404c84 <inv_icm20948_check_akm_self_test+0x194>
		result = -1;
  404c7c:	f04f 33ff 	mov.w	r3, #4294967295
  404c80:	637b      	str	r3, [r7, #52]	; 0x34
		goto AKM_fail;
  404c82:	e0a0      	b.n	404dc6 <inv_icm20948_check_akm_self_test+0x2d6>
	}
#if (MEMS_CHIP == HW_ICM20948)
	result = inv_icm20948_execute_read_secondary(s, 0, addr, REG_AK09916_MEASURE_DATA, BYTES_PER_SENSOR, data);
  404c84:	f897 202b 	ldrb.w	r2, [r7, #43]	; 0x2b
  404c88:	f107 0314 	add.w	r3, r7, #20
  404c8c:	9301      	str	r3, [sp, #4]
  404c8e:	2306      	movs	r3, #6
  404c90:	9300      	str	r3, [sp, #0]
  404c92:	2311      	movs	r3, #17
  404c94:	2100      	movs	r1, #0
  404c96:	6878      	ldr	r0, [r7, #4]
  404c98:	4c49      	ldr	r4, [pc, #292]	; (404dc0 <inv_icm20948_check_akm_self_test+0x2d0>)
  404c9a:	47a0      	blx	r4
  404c9c:	6378      	str	r0, [r7, #52]	; 0x34
		result = inv_icm20948_execute_read_secondary(s, 0, addr, REG_AK09916_MEASURE_DATA, BYTES_PER_SENSOR, data);
	} else {
		result = inv_icm20948_execute_read_secondary(s, 0, addr, REG_AKM_MEASURE_DATA, BYTES_PER_SENSOR, data);
	}
#endif
	if (result)
  404c9e:	6b7b      	ldr	r3, [r7, #52]	; 0x34
  404ca0:	2b00      	cmp	r3, #0
  404ca2:	f040 808f 	bne.w	404dc4 <inv_icm20948_check_akm_self_test+0x2d4>
		goto AKM_fail;

    x = ((short)data[1])<<8|data[0];
  404ca6:	7d7b      	ldrb	r3, [r7, #21]
  404ca8:	021b      	lsls	r3, r3, #8
  404caa:	b21a      	sxth	r2, r3
  404cac:	7d3b      	ldrb	r3, [r7, #20]
  404cae:	b21b      	sxth	r3, r3
  404cb0:	4313      	orrs	r3, r2
  404cb2:	843b      	strh	r3, [r7, #32]
    y = ((short)data[3])<<8|data[2];
  404cb4:	7dfb      	ldrb	r3, [r7, #23]
  404cb6:	021b      	lsls	r3, r3, #8
  404cb8:	b21a      	sxth	r2, r3
  404cba:	7dbb      	ldrb	r3, [r7, #22]
  404cbc:	b21b      	sxth	r3, r3
  404cbe:	4313      	orrs	r3, r2
  404cc0:	83fb      	strh	r3, [r7, #30]
    z = ((short)data[5])<<8|data[4];
  404cc2:	7e7b      	ldrb	r3, [r7, #25]
  404cc4:	021b      	lsls	r3, r3, #8
  404cc6:	b21a      	sxth	r2, r3
  404cc8:	7e3b      	ldrb	r3, [r7, #24]
  404cca:	b21b      	sxth	r3, r3
  404ccc:	4313      	orrs	r3, r2
  404cce:	83bb      	strh	r3, [r7, #28]

	if (HW_AK09911 == s->secondary_state.compass_slave_id)
  404cd0:	687b      	ldr	r3, [r7, #4]
  404cd2:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
  404cd6:	2b23      	cmp	r3, #35	; 0x23
  404cd8:	d102      	bne.n	404ce0 <inv_icm20948_check_akm_self_test+0x1f0>
		shift = 7;
  404cda:	2307      	movs	r3, #7
  404cdc:	62fb      	str	r3, [r7, #44]	; 0x2c
  404cde:	e001      	b.n	404ce4 <inv_icm20948_check_akm_self_test+0x1f4>
	else
		shift = 8;
  404ce0:	2308      	movs	r3, #8
  404ce2:	62fb      	str	r3, [r7, #44]	; 0x2c
	x = ((x * (sens[0] + 128)) >> shift);
  404ce4:	f9b7 3020 	ldrsh.w	r3, [r7, #32]
  404ce8:	6a7a      	ldr	r2, [r7, #36]	; 0x24
  404cea:	7812      	ldrb	r2, [r2, #0]
  404cec:	3280      	adds	r2, #128	; 0x80
  404cee:	fb02 f203 	mul.w	r2, r2, r3
  404cf2:	6afb      	ldr	r3, [r7, #44]	; 0x2c
  404cf4:	fa42 f303 	asr.w	r3, r2, r3
  404cf8:	843b      	strh	r3, [r7, #32]
	y = ((y * (sens[1] + 128)) >> shift);
  404cfa:	f9b7 301e 	ldrsh.w	r3, [r7, #30]
  404cfe:	6a7a      	ldr	r2, [r7, #36]	; 0x24
  404d00:	3201      	adds	r2, #1
  404d02:	7812      	ldrb	r2, [r2, #0]
  404d04:	3280      	adds	r2, #128	; 0x80
  404d06:	fb02 f203 	mul.w	r2, r2, r3
  404d0a:	6afb      	ldr	r3, [r7, #44]	; 0x2c
  404d0c:	fa42 f303 	asr.w	r3, r2, r3
  404d10:	83fb      	strh	r3, [r7, #30]
	z = ((z * (sens[2] + 128)) >> shift);
  404d12:	f9b7 301c 	ldrsh.w	r3, [r7, #28]
  404d16:	6a7a      	ldr	r2, [r7, #36]	; 0x24
  404d18:	3202      	adds	r2, #2
  404d1a:	7812      	ldrb	r2, [r2, #0]
  404d1c:	3280      	adds	r2, #128	; 0x80
  404d1e:	fb02 f203 	mul.w	r2, r2, r3
  404d22:	6afb      	ldr	r3, [r7, #44]	; 0x2c
  404d24:	fa42 f303 	asr.w	r3, r2, r3
  404d28:	83bb      	strh	r3, [r7, #28]
			z <<= DEF_ST_COMPASS_8963_SHIFT;
		}
	}
#endif

	result = -1;
  404d2a:	f04f 33ff 	mov.w	r3, #4294967295
  404d2e:	637b      	str	r3, [r7, #52]	; 0x34
	if (x > s->secondary_state.st_upper[0] || x < s->secondary_state.st_lower[0])
  404d30:	687b      	ldr	r3, [r7, #4]
  404d32:	6f5b      	ldr	r3, [r3, #116]	; 0x74
  404d34:	f9b3 3000 	ldrsh.w	r3, [r3]
  404d38:	f9b7 2020 	ldrsh.w	r2, [r7, #32]
  404d3c:	429a      	cmp	r2, r3
  404d3e:	dc42      	bgt.n	404dc6 <inv_icm20948_check_akm_self_test+0x2d6>
  404d40:	687b      	ldr	r3, [r7, #4]
  404d42:	6f9b      	ldr	r3, [r3, #120]	; 0x78
  404d44:	f9b3 3000 	ldrsh.w	r3, [r3]
  404d48:	f9b7 2020 	ldrsh.w	r2, [r7, #32]
  404d4c:	429a      	cmp	r2, r3
  404d4e:	db3a      	blt.n	404dc6 <inv_icm20948_check_akm_self_test+0x2d6>
		goto AKM_fail;
	if (y > s->secondary_state.st_upper[1] || y < s->secondary_state.st_lower[1])
  404d50:	687b      	ldr	r3, [r7, #4]
  404d52:	6f5b      	ldr	r3, [r3, #116]	; 0x74
  404d54:	3302      	adds	r3, #2
  404d56:	f9b3 3000 	ldrsh.w	r3, [r3]
  404d5a:	f9b7 201e 	ldrsh.w	r2, [r7, #30]
  404d5e:	429a      	cmp	r2, r3
  404d60:	dc31      	bgt.n	404dc6 <inv_icm20948_check_akm_self_test+0x2d6>
  404d62:	687b      	ldr	r3, [r7, #4]
  404d64:	6f9b      	ldr	r3, [r3, #120]	; 0x78
  404d66:	3302      	adds	r3, #2
  404d68:	f9b3 3000 	ldrsh.w	r3, [r3]
  404d6c:	f9b7 201e 	ldrsh.w	r2, [r7, #30]
  404d70:	429a      	cmp	r2, r3
  404d72:	db28      	blt.n	404dc6 <inv_icm20948_check_akm_self_test+0x2d6>
		goto AKM_fail;
	if (z > s->secondary_state.st_upper[2] || z < s->secondary_state.st_lower[2])
  404d74:	687b      	ldr	r3, [r7, #4]
  404d76:	6f5b      	ldr	r3, [r3, #116]	; 0x74
  404d78:	3304      	adds	r3, #4
  404d7a:	f9b3 3000 	ldrsh.w	r3, [r3]
  404d7e:	f9b7 201c 	ldrsh.w	r2, [r7, #28]
  404d82:	429a      	cmp	r2, r3
  404d84:	dc1f      	bgt.n	404dc6 <inv_icm20948_check_akm_self_test+0x2d6>
  404d86:	687b      	ldr	r3, [r7, #4]
  404d88:	6f9b      	ldr	r3, [r3, #120]	; 0x78
  404d8a:	3304      	adds	r3, #4
  404d8c:	f9b3 3000 	ldrsh.w	r3, [r3]
  404d90:	f9b7 201c 	ldrsh.w	r2, [r7, #28]
  404d94:	429a      	cmp	r2, r3
  404d96:	db16      	blt.n	404dc6 <inv_icm20948_check_akm_self_test+0x2d6>
		goto AKM_fail;
	result = 0;
  404d98:	2300      	movs	r3, #0
  404d9a:	637b      	str	r3, [r7, #52]	; 0x34
  404d9c:	e013      	b.n	404dc6 <inv_icm20948_check_akm_self_test+0x2d6>
		goto AKM_fail;
  404d9e:	bf00      	nop
  404da0:	e011      	b.n	404dc6 <inv_icm20948_check_akm_self_test+0x2d6>
			goto AKM_fail;
  404da2:	bf00      	nop
  404da4:	e00f      	b.n	404dc6 <inv_icm20948_check_akm_self_test+0x2d6>
		goto AKM_fail;
  404da6:	bf00      	nop
  404da8:	e00d      	b.n	404dc6 <inv_icm20948_check_akm_self_test+0x2d6>
			goto AKM_fail;
  404daa:	bf00      	nop
  404dac:	e00b      	b.n	404dc6 <inv_icm20948_check_akm_self_test+0x2d6>
  404dae:	bf00      	nop
  404db0:	0040c755 	.word	0x0040c755
  404db4:	0040c689 	.word	0x0040c689
  404db8:	004055d1 	.word	0x004055d1
  404dbc:	004015f9 	.word	0x004015f9
  404dc0:	00405479 	.word	0x00405479
		goto AKM_fail;
  404dc4:	bf00      	nop
AKM_fail:
	/*write 0 to ASTC register */
	if ((HW_AK09911 != s->secondary_state.compass_slave_id) &&
  404dc6:	687b      	ldr	r3, [r7, #4]
  404dc8:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
  404dcc:	2b23      	cmp	r3, #35	; 0x23
  404dce:	d016      	beq.n	404dfe <inv_icm20948_check_akm_self_test+0x30e>
		(HW_AK09912 != s->secondary_state.compass_slave_id) &&
  404dd0:	687b      	ldr	r3, [r7, #4]
  404dd2:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
	if ((HW_AK09911 != s->secondary_state.compass_slave_id) &&
  404dd6:	2b24      	cmp	r3, #36	; 0x24
  404dd8:	d011      	beq.n	404dfe <inv_icm20948_check_akm_self_test+0x30e>
		(HW_AK09916 != s->secondary_state.compass_slave_id)) {
  404dda:	687b      	ldr	r3, [r7, #4]
  404ddc:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
		(HW_AK09912 != s->secondary_state.compass_slave_id) &&
  404de0:	2b25      	cmp	r3, #37	; 0x25
  404de2:	d00c      	beq.n	404dfe <inv_icm20948_check_akm_self_test+0x30e>
		result |= inv_icm20948_execute_write_secondary(s, 0, addr, REG_AKM_ST_CTRL, 0);
  404de4:	f897 202b 	ldrb.w	r2, [r7, #43]	; 0x2b
  404de8:	2300      	movs	r3, #0
  404dea:	9300      	str	r3, [sp, #0]
  404dec:	230c      	movs	r3, #12
  404dee:	2100      	movs	r1, #0
  404df0:	6878      	ldr	r0, [r7, #4]
  404df2:	4c0d      	ldr	r4, [pc, #52]	; (404e28 <inv_icm20948_check_akm_self_test+0x338>)
  404df4:	47a0      	blx	r4
  404df6:	4602      	mov	r2, r0
  404df8:	6b7b      	ldr	r3, [r7, #52]	; 0x34
  404dfa:	4313      	orrs	r3, r2
  404dfc:	637b      	str	r3, [r7, #52]	; 0x34
	}
	/*set to power down mode */
	result |= inv_icm20948_execute_write_secondary(s, 0, addr, mode, DATA_AKM_MODE_PD);
  404dfe:	f897 1023 	ldrb.w	r1, [r7, #35]	; 0x23
  404e02:	f897 202b 	ldrb.w	r2, [r7, #43]	; 0x2b
  404e06:	2300      	movs	r3, #0
  404e08:	9300      	str	r3, [sp, #0]
  404e0a:	460b      	mov	r3, r1
  404e0c:	2100      	movs	r1, #0
  404e0e:	6878      	ldr	r0, [r7, #4]
  404e10:	4c05      	ldr	r4, [pc, #20]	; (404e28 <inv_icm20948_check_akm_self_test+0x338>)
  404e12:	47a0      	blx	r4
  404e14:	4602      	mov	r2, r0
  404e16:	6b7b      	ldr	r3, [r7, #52]	; 0x34
  404e18:	4313      	orrs	r3, r2
  404e1a:	637b      	str	r3, [r7, #52]	; 0x34

    return result;
  404e1c:	6b7b      	ldr	r3, [r7, #52]	; 0x34
}
  404e1e:	4618      	mov	r0, r3
  404e20:	373c      	adds	r7, #60	; 0x3c
  404e22:	46bd      	mov	sp, r7
  404e24:	bd90      	pop	{r4, r7, pc}
  404e26:	bf00      	nop
  404e28:	004055d1 	.word	0x004055d1

00404e2c <inv_icm20948_suspend_akm>:
#endif
	return 0;
}

int inv_icm20948_suspend_akm(struct inv_icm20948 * s)
{
  404e2c:	b580      	push	{r7, lr}
  404e2e:	b084      	sub	sp, #16
  404e30:	af00      	add	r7, sp, #0
  404e32:	6078      	str	r0, [r7, #4]
	int result;

	if (!s->secondary_state.secondary_resume_compass_state)
  404e34:	687b      	ldr	r3, [r7, #4]
  404e36:	f893 3081 	ldrb.w	r3, [r3, #129]	; 0x81
  404e3a:	2b00      	cmp	r3, #0
  404e3c:	d101      	bne.n	404e42 <inv_icm20948_suspend_akm+0x16>
		return 0;
  404e3e:	2300      	movs	r3, #0
  404e40:	e01d      	b.n	404e7e <inv_icm20948_suspend_akm+0x52>

	/* slave 0 is disabled */
	result = inv_icm20948_secondary_stop_channel(s, COMPASS_I2C_SLV_READ);
  404e42:	2100      	movs	r1, #0
  404e44:	6878      	ldr	r0, [r7, #4]
  404e46:	4b10      	ldr	r3, [pc, #64]	; (404e88 <inv_icm20948_suspend_akm+0x5c>)
  404e48:	4798      	blx	r3
  404e4a:	60f8      	str	r0, [r7, #12]
	/* slave 1 is disabled */
	result |= inv_icm20948_secondary_stop_channel(s, COMPASS_I2C_SLV_WRITE);
  404e4c:	2101      	movs	r1, #1
  404e4e:	6878      	ldr	r0, [r7, #4]
  404e50:	4b0d      	ldr	r3, [pc, #52]	; (404e88 <inv_icm20948_suspend_akm+0x5c>)
  404e52:	4798      	blx	r3
  404e54:	4602      	mov	r2, r0
  404e56:	68fb      	ldr	r3, [r7, #12]
  404e58:	4313      	orrs	r3, r2
  404e5a:	60fb      	str	r3, [r7, #12]
	if (result)
  404e5c:	68fb      	ldr	r3, [r7, #12]
  404e5e:	2b00      	cmp	r3, #0
  404e60:	d001      	beq.n	404e66 <inv_icm20948_suspend_akm+0x3a>
		return result;
  404e62:	68fb      	ldr	r3, [r7, #12]
  404e64:	e00b      	b.n	404e7e <inv_icm20948_suspend_akm+0x52>

	// Switch off I2C Interface as compass is alone
	result |= inv_icm20948_secondary_disable_i2c(s);
  404e66:	6878      	ldr	r0, [r7, #4]
  404e68:	4b08      	ldr	r3, [pc, #32]	; (404e8c <inv_icm20948_suspend_akm+0x60>)
  404e6a:	4798      	blx	r3
  404e6c:	4602      	mov	r2, r0
  404e6e:	68fb      	ldr	r3, [r7, #12]
  404e70:	4313      	orrs	r3, r2
  404e72:	60fb      	str	r3, [r7, #12]

	s->secondary_state.secondary_resume_compass_state = 0;
  404e74:	687b      	ldr	r3, [r7, #4]
  404e76:	2200      	movs	r2, #0
  404e78:	f883 2081 	strb.w	r2, [r3, #129]	; 0x81

	return result;
  404e7c:	68fb      	ldr	r3, [r7, #12]
}
  404e7e:	4618      	mov	r0, r3
  404e80:	3710      	adds	r7, #16
  404e82:	46bd      	mov	sp, r7
  404e84:	bd80      	pop	{r7, pc}
  404e86:	bf00      	nop
  404e88:	00405655 	.word	0x00405655
  404e8c:	004056b9 	.word	0x004056b9

00404e90 <inv_icm20948_resume_akm>:

int inv_icm20948_resume_akm(struct inv_icm20948 * s)
{
  404e90:	b590      	push	{r4, r7, lr}
  404e92:	b089      	sub	sp, #36	; 0x24
  404e94:	af02      	add	r7, sp, #8
  404e96:	6078      	str	r0, [r7, #4]
	int result;
	uint8_t reg_addr, bytes;
    unsigned char lDataToWrite;

	if (s->secondary_state.secondary_resume_compass_state)
  404e98:	687b      	ldr	r3, [r7, #4]
  404e9a:	f893 3081 	ldrb.w	r3, [r3, #129]	; 0x81
  404e9e:	2b00      	cmp	r3, #0
  404ea0:	d001      	beq.n	404ea6 <inv_icm20948_resume_akm+0x16>
		return 0;
  404ea2:	2300      	movs	r3, #0
  404ea4:	e046      	b.n	404f34 <inv_icm20948_resume_akm+0xa4>

	/* slave 0 is used to read data from compass */
	/*read mode */
#if (MEMS_CHIP == HW_ICM20948)
	if (s->secondary_state.dmp_on) {
  404ea6:	687b      	ldr	r3, [r7, #4]
  404ea8:	f893 3080 	ldrb.w	r3, [r3, #128]	; 0x80
  404eac:	2b00      	cmp	r3, #0
  404eae:	d004      	beq.n	404eba <inv_icm20948_resume_akm+0x2a>
		reg_addr = REG_AK09916_DMP_READ;
  404eb0:	2303      	movs	r3, #3
  404eb2:	75fb      	strb	r3, [r7, #23]
		bytes = DATA_AKM_99_BYTES_DMP;
  404eb4:	230a      	movs	r3, #10
  404eb6:	75bb      	strb	r3, [r7, #22]
  404eb8:	e003      	b.n	404ec2 <inv_icm20948_resume_akm+0x32>
	} else {
		reg_addr = REG_AK09916_STATUS1;
  404eba:	2310      	movs	r3, #16
  404ebc:	75fb      	strb	r3, [r7, #23]
		bytes = DATA_AKM_99_BYTES_DMP - 1;
  404ebe:	2309      	movs	r3, #9
  404ec0:	75bb      	strb	r3, [r7, #22]
			bytes = DATA_AKM_89_BYTES_DMP - 1;
		}
	}
#endif
	/* slave 0 is enabled, read 10 or 8 bytes from here depending on compass type, swap bytes to feed DMP */
	result = inv_icm20948_read_secondary(s, COMPASS_I2C_SLV_READ, s->secondary_state.compass_chip_addr, reg_addr, INV_MPU_BIT_GRP | INV_MPU_BIT_BYTE_SW | bytes);
  404ec2:	687b      	ldr	r3, [r7, #4]
  404ec4:	f8d3 3084 	ldr.w	r3, [r3, #132]	; 0x84
  404ec8:	b2da      	uxtb	r2, r3
  404eca:	7dbb      	ldrb	r3, [r7, #22]
  404ecc:	f043 0350 	orr.w	r3, r3, #80	; 0x50
  404ed0:	b2db      	uxtb	r3, r3
  404ed2:	b25b      	sxtb	r3, r3
  404ed4:	7df9      	ldrb	r1, [r7, #23]
  404ed6:	9300      	str	r3, [sp, #0]
  404ed8:	460b      	mov	r3, r1
  404eda:	2100      	movs	r1, #0
  404edc:	6878      	ldr	r0, [r7, #4]
  404ede:	4c17      	ldr	r4, [pc, #92]	; (404f3c <inv_icm20948_resume_akm+0xac>)
  404ee0:	47a0      	blx	r4
  404ee2:	6138      	str	r0, [r7, #16]
	if (result)
  404ee4:	693b      	ldr	r3, [r7, #16]
  404ee6:	2b00      	cmp	r3, #0
  404ee8:	d001      	beq.n	404eee <inv_icm20948_resume_akm+0x5e>
		return result;
  404eea:	693b      	ldr	r3, [r7, #16]
  404eec:	e022      	b.n	404f34 <inv_icm20948_resume_akm+0xa4>
#if (MEMS_CHIP == HW_ICM20948)
	lDataToWrite = DATA_AKM_MODE_SM;
  404eee:	2301      	movs	r3, #1
  404ef0:	73fb      	strb	r3, [r7, #15]
		lDataToWrite = DATA_AKM_MODE_SM;
	} else {
		return -1;
	}
#endif
	result = inv_icm20948_write_secondary(s, COMPASS_I2C_SLV_WRITE, s->secondary_state.compass_chip_addr, s->secondary_state.mode_reg_addr, lDataToWrite);
  404ef2:	687b      	ldr	r3, [r7, #4]
  404ef4:	f8d3 3084 	ldr.w	r3, [r3, #132]	; 0x84
  404ef8:	b2da      	uxtb	r2, r3
  404efa:	687b      	ldr	r3, [r7, #4]
  404efc:	f893 1082 	ldrb.w	r1, [r3, #130]	; 0x82
  404f00:	f997 300f 	ldrsb.w	r3, [r7, #15]
  404f04:	9300      	str	r3, [sp, #0]
  404f06:	460b      	mov	r3, r1
  404f08:	2101      	movs	r1, #1
  404f0a:	6878      	ldr	r0, [r7, #4]
  404f0c:	4c0c      	ldr	r4, [pc, #48]	; (404f40 <inv_icm20948_resume_akm+0xb0>)
  404f0e:	47a0      	blx	r4
  404f10:	6138      	str	r0, [r7, #16]
	if (result)
  404f12:	693b      	ldr	r3, [r7, #16]
  404f14:	2b00      	cmp	r3, #0
  404f16:	d001      	beq.n	404f1c <inv_icm20948_resume_akm+0x8c>
		return result;
  404f18:	693b      	ldr	r3, [r7, #16]
  404f1a:	e00b      	b.n	404f34 <inv_icm20948_resume_akm+0xa4>

	result |= inv_icm20948_secondary_enable_i2c(s);
  404f1c:	6878      	ldr	r0, [r7, #4]
  404f1e:	4b09      	ldr	r3, [pc, #36]	; (404f44 <inv_icm20948_resume_akm+0xb4>)
  404f20:	4798      	blx	r3
  404f22:	4602      	mov	r2, r0
  404f24:	693b      	ldr	r3, [r7, #16]
  404f26:	4313      	orrs	r3, r2
  404f28:	613b      	str	r3, [r7, #16]

    s->secondary_state.secondary_resume_compass_state = 1;
  404f2a:	687b      	ldr	r3, [r7, #4]
  404f2c:	2201      	movs	r2, #1
  404f2e:	f883 2081 	strb.w	r2, [r3, #129]	; 0x81

	return result;
  404f32:	693b      	ldr	r3, [r7, #16]
}
  404f34:	4618      	mov	r0, r3
  404f36:	371c      	adds	r7, #28
  404f38:	46bd      	mov	sp, r7
  404f3a:	bd90      	pop	{r4, r7, pc}
  404f3c:	004053d5 	.word	0x004053d5
  404f40:	00405515 	.word	0x00405515
  404f44:	00405685 	.word	0x00405685

00404f48 <inv_icm20948_compass_dmp_cal>:
*  @param[in]  Compass mounting matrix
*  @return     0 if successful.
*/

int inv_icm20948_compass_dmp_cal(struct inv_icm20948 * s, const signed char *m, const signed char *compass_m)
{
  404f48:	b590      	push	{r4, r7, lr}
  404f4a:	b0a3      	sub	sp, #140	; 0x8c
  404f4c:	af00      	add	r7, sp, #0
  404f4e:	60f8      	str	r0, [r7, #12]
  404f50:	60b9      	str	r1, [r7, #8]
  404f52:	607a      	str	r2, [r7, #4]
	int sens[THREE_AXES];
	int scale;
	int shift;
    int current_compass_matrix[NINE_ELEM];

	for (i = 0; i < THREE_AXES; i++)
  404f54:	2300      	movs	r3, #0
  404f56:	f8c7 3084 	str.w	r3, [r7, #132]	; 0x84
  404f5a:	e02b      	b.n	404fb4 <inv_icm20948_compass_dmp_cal+0x6c>
		for (j = 0; j < THREE_AXES; j++)
  404f5c:	2300      	movs	r3, #0
  404f5e:	f8c7 3080 	str.w	r3, [r7, #128]	; 0x80
  404f62:	e01e      	b.n	404fa2 <inv_icm20948_compass_dmp_cal+0x5a>
			trans[THREE_AXES * j + i] = m[THREE_AXES * i + j];
  404f64:	f8d7 2080 	ldr.w	r2, [r7, #128]	; 0x80
  404f68:	4613      	mov	r3, r2
  404f6a:	005b      	lsls	r3, r3, #1
  404f6c:	441a      	add	r2, r3
  404f6e:	f8d7 3084 	ldr.w	r3, [r7, #132]	; 0x84
  404f72:	18d1      	adds	r1, r2, r3
  404f74:	f8d7 2084 	ldr.w	r2, [r7, #132]	; 0x84
  404f78:	4613      	mov	r3, r2
  404f7a:	005b      	lsls	r3, r3, #1
  404f7c:	441a      	add	r2, r3
  404f7e:	f8d7 3080 	ldr.w	r3, [r7, #128]	; 0x80
  404f82:	4413      	add	r3, r2
  404f84:	461a      	mov	r2, r3
  404f86:	68bb      	ldr	r3, [r7, #8]
  404f88:	4413      	add	r3, r2
  404f8a:	f993 2000 	ldrsb.w	r2, [r3]
  404f8e:	f107 0388 	add.w	r3, r7, #136	; 0x88
  404f92:	440b      	add	r3, r1
  404f94:	f803 2c20 	strb.w	r2, [r3, #-32]
		for (j = 0; j < THREE_AXES; j++)
  404f98:	f8d7 3080 	ldr.w	r3, [r7, #128]	; 0x80
  404f9c:	3301      	adds	r3, #1
  404f9e:	f8c7 3080 	str.w	r3, [r7, #128]	; 0x80
  404fa2:	f8d7 3080 	ldr.w	r3, [r7, #128]	; 0x80
  404fa6:	2b02      	cmp	r3, #2
  404fa8:	dddc      	ble.n	404f64 <inv_icm20948_compass_dmp_cal+0x1c>
	for (i = 0; i < THREE_AXES; i++)
  404faa:	f8d7 3084 	ldr.w	r3, [r7, #132]	; 0x84
  404fae:	3301      	adds	r3, #1
  404fb0:	f8c7 3084 	str.w	r3, [r7, #132]	; 0x84
  404fb4:	f8d7 3084 	ldr.w	r3, [r7, #132]	; 0x84
  404fb8:	2b02      	cmp	r3, #2
  404fba:	ddcf      	ble.n	404f5c <inv_icm20948_compass_dmp_cal+0x14>

    switch (s->secondary_state.compass_slave_id)
  404fbc:	68fb      	ldr	r3, [r7, #12]
  404fbe:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
  404fc2:	2b25      	cmp	r3, #37	; 0x25
  404fc4:	d104      	bne.n	404fd0 <inv_icm20948_compass_dmp_cal+0x88>
            scale = DATA_AK09912_SCALE;
            shift = AK89XX_SHIFT;
            break;
#else
        case HW_AK09916:
            scale = DATA_AK09916_SCALE;
  404fc6:	4ba3      	ldr	r3, [pc, #652]	; (405254 <inv_icm20948_compass_dmp_cal+0x30c>)
  404fc8:	67bb      	str	r3, [r7, #120]	; 0x78
            shift = AK89XX_SHIFT;
  404fca:	2316      	movs	r3, #22
  404fcc:	677b      	str	r3, [r7, #116]	; 0x74
            break;
  404fce:	e004      	b.n	404fda <inv_icm20948_compass_dmp_cal+0x92>
#endif
		default:
				scale = DATA_AKM8963_SCALE1;
  404fd0:	4ba0      	ldr	r3, [pc, #640]	; (405254 <inv_icm20948_compass_dmp_cal+0x30c>)
  404fd2:	67bb      	str	r3, [r7, #120]	; 0x78
				shift = AK89XX_SHIFT;
  404fd4:	2316      	movs	r3, #22
  404fd6:	677b      	str	r3, [r7, #116]	; 0x74
				break;
  404fd8:	bf00      	nop
    }

	for (i = 0; i < THREE_AXES; i++) {
  404fda:	2300      	movs	r3, #0
  404fdc:	f8c7 3084 	str.w	r3, [r7, #132]	; 0x84
  404fe0:	e02c      	b.n	40503c <inv_icm20948_compass_dmp_cal+0xf4>
		sens[i] = s->secondary_state.compass_sens[i] + 128;
  404fe2:	68fa      	ldr	r2, [r7, #12]
  404fe4:	f8d7 3084 	ldr.w	r3, [r7, #132]	; 0x84
  404fe8:	4413      	add	r3, r2
  404fea:	334d      	adds	r3, #77	; 0x4d
  404fec:	781b      	ldrb	r3, [r3, #0]
  404fee:	f103 0280 	add.w	r2, r3, #128	; 0x80
  404ff2:	f8d7 3084 	ldr.w	r3, [r7, #132]	; 0x84
  404ff6:	009b      	lsls	r3, r3, #2
  404ff8:	f107 0188 	add.w	r1, r7, #136	; 0x88
  404ffc:	440b      	add	r3, r1
  404ffe:	f843 2c50 	str.w	r2, [r3, #-80]
		sens[i] = inv_icm20948_convert_mult_q30_fxp(sens[i] << shift, scale);
  405002:	f8d7 3084 	ldr.w	r3, [r7, #132]	; 0x84
  405006:	009b      	lsls	r3, r3, #2
  405008:	f107 0288 	add.w	r2, r7, #136	; 0x88
  40500c:	4413      	add	r3, r2
  40500e:	f853 2c50 	ldr.w	r2, [r3, #-80]
  405012:	6f7b      	ldr	r3, [r7, #116]	; 0x74
  405014:	fa02 f303 	lsl.w	r3, r2, r3
  405018:	6fb9      	ldr	r1, [r7, #120]	; 0x78
  40501a:	4618      	mov	r0, r3
  40501c:	4b8e      	ldr	r3, [pc, #568]	; (405258 <inv_icm20948_compass_dmp_cal+0x310>)
  40501e:	4798      	blx	r3
  405020:	4602      	mov	r2, r0
  405022:	f8d7 3084 	ldr.w	r3, [r7, #132]	; 0x84
  405026:	009b      	lsls	r3, r3, #2
  405028:	f107 0188 	add.w	r1, r7, #136	; 0x88
  40502c:	440b      	add	r3, r1
  40502e:	f843 2c50 	str.w	r2, [r3, #-80]
	for (i = 0; i < THREE_AXES; i++) {
  405032:	f8d7 3084 	ldr.w	r3, [r7, #132]	; 0x84
  405036:	3301      	adds	r3, #1
  405038:	f8c7 3084 	str.w	r3, [r7, #132]	; 0x84
  40503c:	f8d7 3084 	ldr.w	r3, [r7, #132]	; 0x84
  405040:	2b02      	cmp	r3, #2
  405042:	ddce      	ble.n	404fe2 <inv_icm20948_compass_dmp_cal+0x9a>
	}
	for (i = 0; i < NINE_ELEM; i++) {
  405044:	2300      	movs	r3, #0
  405046:	f8c7 3084 	str.w	r3, [r7, #132]	; 0x84
  40504a:	e02f      	b.n	4050ac <inv_icm20948_compass_dmp_cal+0x164>
		current_compass_matrix[i] = compass_m[i] * sens[i % THREE_AXES];
  40504c:	f8d7 3084 	ldr.w	r3, [r7, #132]	; 0x84
  405050:	687a      	ldr	r2, [r7, #4]
  405052:	4413      	add	r3, r2
  405054:	f993 3000 	ldrsb.w	r3, [r3]
  405058:	4618      	mov	r0, r3
  40505a:	f8d7 1084 	ldr.w	r1, [r7, #132]	; 0x84
  40505e:	4b7f      	ldr	r3, [pc, #508]	; (40525c <inv_icm20948_compass_dmp_cal+0x314>)
  405060:	fb83 3201 	smull	r3, r2, r3, r1
  405064:	17cb      	asrs	r3, r1, #31
  405066:	1ad2      	subs	r2, r2, r3
  405068:	4613      	mov	r3, r2
  40506a:	005b      	lsls	r3, r3, #1
  40506c:	4413      	add	r3, r2
  40506e:	1aca      	subs	r2, r1, r3
  405070:	0093      	lsls	r3, r2, #2
  405072:	f107 0288 	add.w	r2, r7, #136	; 0x88
  405076:	4413      	add	r3, r2
  405078:	f853 3c50 	ldr.w	r3, [r3, #-80]
  40507c:	fb03 f200 	mul.w	r2, r3, r0
  405080:	f8d7 3084 	ldr.w	r3, [r7, #132]	; 0x84
  405084:	009b      	lsls	r3, r3, #2
  405086:	f107 0188 	add.w	r1, r7, #136	; 0x88
  40508a:	440b      	add	r3, r1
  40508c:	f843 2c74 	str.w	r2, [r3, #-116]
		tmp_m[i] = 0;
  405090:	f8d7 3084 	ldr.w	r3, [r7, #132]	; 0x84
  405094:	009b      	lsls	r3, r3, #2
  405096:	f107 0288 	add.w	r2, r7, #136	; 0x88
  40509a:	4413      	add	r3, r2
  40509c:	2200      	movs	r2, #0
  40509e:	f843 2c44 	str.w	r2, [r3, #-68]
	for (i = 0; i < NINE_ELEM; i++) {
  4050a2:	f8d7 3084 	ldr.w	r3, [r7, #132]	; 0x84
  4050a6:	3301      	adds	r3, #1
  4050a8:	f8c7 3084 	str.w	r3, [r7, #132]	; 0x84
  4050ac:	f8d7 3084 	ldr.w	r3, [r7, #132]	; 0x84
  4050b0:	2b08      	cmp	r3, #8
  4050b2:	ddcb      	ble.n	40504c <inv_icm20948_compass_dmp_cal+0x104>
	}

    for (i = 0; i < THREE_AXES; i++) {
  4050b4:	2300      	movs	r3, #0
  4050b6:	f8c7 3084 	str.w	r3, [r7, #132]	; 0x84
  4050ba:	e060      	b.n	40517e <inv_icm20948_compass_dmp_cal+0x236>
		for (j = 0; j < THREE_AXES; j++) {
  4050bc:	2300      	movs	r3, #0
  4050be:	f8c7 3080 	str.w	r3, [r7, #128]	; 0x80
  4050c2:	e053      	b.n	40516c <inv_icm20948_compass_dmp_cal+0x224>
			s->secondary_state.final_matrix[i * THREE_AXES + j] = 0;
  4050c4:	f8d7 2084 	ldr.w	r2, [r7, #132]	; 0x84
  4050c8:	4613      	mov	r3, r2
  4050ca:	005b      	lsls	r3, r3, #1
  4050cc:	441a      	add	r2, r3
  4050ce:	f8d7 3080 	ldr.w	r3, [r7, #128]	; 0x80
  4050d2:	4413      	add	r3, r2
  4050d4:	68fa      	ldr	r2, [r7, #12]
  4050d6:	3312      	adds	r3, #18
  4050d8:	009b      	lsls	r3, r3, #2
  4050da:	4413      	add	r3, r2
  4050dc:	2200      	movs	r2, #0
  4050de:	609a      	str	r2, [r3, #8]
			for (k = 0; k < THREE_AXES; k++)
  4050e0:	2300      	movs	r3, #0
  4050e2:	67fb      	str	r3, [r7, #124]	; 0x7c
  4050e4:	e03a      	b.n	40515c <inv_icm20948_compass_dmp_cal+0x214>
				s->secondary_state.final_matrix[i * THREE_AXES + j] +=
					inv_icm20948_convert_mult_q30_fxp(s->soft_iron_matrix[i * THREE_AXES + k],
  4050e6:	f8d7 2084 	ldr.w	r2, [r7, #132]	; 0x84
  4050ea:	4613      	mov	r3, r2
  4050ec:	005b      	lsls	r3, r3, #1
  4050ee:	441a      	add	r2, r3
  4050f0:	6ffb      	ldr	r3, [r7, #124]	; 0x7c
  4050f2:	441a      	add	r2, r3
  4050f4:	68fb      	ldr	r3, [r7, #12]
  4050f6:	32a2      	adds	r2, #162	; 0xa2
  4050f8:	f853 0022 	ldr.w	r0, [r3, r2, lsl #2]
                                 current_compass_matrix[j + k * THREE_AXES]);
  4050fc:	6ffa      	ldr	r2, [r7, #124]	; 0x7c
  4050fe:	4613      	mov	r3, r2
  405100:	005b      	lsls	r3, r3, #1
  405102:	441a      	add	r2, r3
  405104:	f8d7 3080 	ldr.w	r3, [r7, #128]	; 0x80
  405108:	4413      	add	r3, r2
  40510a:	009b      	lsls	r3, r3, #2
  40510c:	f107 0288 	add.w	r2, r7, #136	; 0x88
  405110:	4413      	add	r3, r2
  405112:	f853 3c74 	ldr.w	r3, [r3, #-116]
					inv_icm20948_convert_mult_q30_fxp(s->soft_iron_matrix[i * THREE_AXES + k],
  405116:	4619      	mov	r1, r3
  405118:	4b4f      	ldr	r3, [pc, #316]	; (405258 <inv_icm20948_compass_dmp_cal+0x310>)
  40511a:	4798      	blx	r3
  40511c:	4601      	mov	r1, r0
				s->secondary_state.final_matrix[i * THREE_AXES + j] +=
  40511e:	f8d7 2084 	ldr.w	r2, [r7, #132]	; 0x84
  405122:	4613      	mov	r3, r2
  405124:	005b      	lsls	r3, r3, #1
  405126:	441a      	add	r2, r3
  405128:	f8d7 3080 	ldr.w	r3, [r7, #128]	; 0x80
  40512c:	18d0      	adds	r0, r2, r3
  40512e:	f8d7 2084 	ldr.w	r2, [r7, #132]	; 0x84
  405132:	4613      	mov	r3, r2
  405134:	005b      	lsls	r3, r3, #1
  405136:	441a      	add	r2, r3
  405138:	f8d7 3080 	ldr.w	r3, [r7, #128]	; 0x80
  40513c:	4413      	add	r3, r2
  40513e:	68fa      	ldr	r2, [r7, #12]
  405140:	3312      	adds	r3, #18
  405142:	009b      	lsls	r3, r3, #2
  405144:	4413      	add	r3, r2
  405146:	689b      	ldr	r3, [r3, #8]
  405148:	185a      	adds	r2, r3, r1
  40514a:	68f9      	ldr	r1, [r7, #12]
  40514c:	f100 0312 	add.w	r3, r0, #18
  405150:	009b      	lsls	r3, r3, #2
  405152:	440b      	add	r3, r1
  405154:	609a      	str	r2, [r3, #8]
			for (k = 0; k < THREE_AXES; k++)
  405156:	6ffb      	ldr	r3, [r7, #124]	; 0x7c
  405158:	3301      	adds	r3, #1
  40515a:	67fb      	str	r3, [r7, #124]	; 0x7c
  40515c:	6ffb      	ldr	r3, [r7, #124]	; 0x7c
  40515e:	2b02      	cmp	r3, #2
  405160:	ddc1      	ble.n	4050e6 <inv_icm20948_compass_dmp_cal+0x19e>
		for (j = 0; j < THREE_AXES; j++) {
  405162:	f8d7 3080 	ldr.w	r3, [r7, #128]	; 0x80
  405166:	3301      	adds	r3, #1
  405168:	f8c7 3080 	str.w	r3, [r7, #128]	; 0x80
  40516c:	f8d7 3080 	ldr.w	r3, [r7, #128]	; 0x80
  405170:	2b02      	cmp	r3, #2
  405172:	dda7      	ble.n	4050c4 <inv_icm20948_compass_dmp_cal+0x17c>
    for (i = 0; i < THREE_AXES; i++) {
  405174:	f8d7 3084 	ldr.w	r3, [r7, #132]	; 0x84
  405178:	3301      	adds	r3, #1
  40517a:	f8c7 3084 	str.w	r3, [r7, #132]	; 0x84
  40517e:	f8d7 3084 	ldr.w	r3, [r7, #132]	; 0x84
  405182:	2b02      	cmp	r3, #2
  405184:	dd9a      	ble.n	4050bc <inv_icm20948_compass_dmp_cal+0x174>
		}
	}

    for (i = 0; i < THREE_AXES; i++)
  405186:	2300      	movs	r3, #0
  405188:	f8c7 3084 	str.w	r3, [r7, #132]	; 0x84
  40518c:	e052      	b.n	405234 <inv_icm20948_compass_dmp_cal+0x2ec>
		for (j = 0; j < THREE_AXES; j++)
  40518e:	2300      	movs	r3, #0
  405190:	f8c7 3080 	str.w	r3, [r7, #128]	; 0x80
  405194:	e045      	b.n	405222 <inv_icm20948_compass_dmp_cal+0x2da>
			for (k = 0; k < THREE_AXES; k++)
  405196:	2300      	movs	r3, #0
  405198:	67fb      	str	r3, [r7, #124]	; 0x7c
  40519a:	e03a      	b.n	405212 <inv_icm20948_compass_dmp_cal+0x2ca>
				tmp_m[THREE_AXES * i + j] +=
  40519c:	f8d7 2084 	ldr.w	r2, [r7, #132]	; 0x84
  4051a0:	4613      	mov	r3, r2
  4051a2:	005b      	lsls	r3, r3, #1
  4051a4:	441a      	add	r2, r3
  4051a6:	f8d7 3080 	ldr.w	r3, [r7, #128]	; 0x80
  4051aa:	18d1      	adds	r1, r2, r3
  4051ac:	f8d7 2084 	ldr.w	r2, [r7, #132]	; 0x84
  4051b0:	4613      	mov	r3, r2
  4051b2:	005b      	lsls	r3, r3, #1
  4051b4:	441a      	add	r2, r3
  4051b6:	f8d7 3080 	ldr.w	r3, [r7, #128]	; 0x80
  4051ba:	4413      	add	r3, r2
  4051bc:	009b      	lsls	r3, r3, #2
  4051be:	f107 0288 	add.w	r2, r7, #136	; 0x88
  4051c2:	4413      	add	r3, r2
  4051c4:	f853 0c44 	ldr.w	r0, [r3, #-68]
					trans[THREE_AXES * i + k] *
  4051c8:	f8d7 2084 	ldr.w	r2, [r7, #132]	; 0x84
  4051cc:	4613      	mov	r3, r2
  4051ce:	005b      	lsls	r3, r3, #1
  4051d0:	441a      	add	r2, r3
  4051d2:	6ffb      	ldr	r3, [r7, #124]	; 0x7c
  4051d4:	4413      	add	r3, r2
  4051d6:	f107 0288 	add.w	r2, r7, #136	; 0x88
  4051da:	4413      	add	r3, r2
  4051dc:	f913 3c20 	ldrsb.w	r3, [r3, #-32]
  4051e0:	461c      	mov	r4, r3
						s->secondary_state.final_matrix[THREE_AXES * k + j];
  4051e2:	6ffa      	ldr	r2, [r7, #124]	; 0x7c
  4051e4:	4613      	mov	r3, r2
  4051e6:	005b      	lsls	r3, r3, #1
  4051e8:	441a      	add	r2, r3
  4051ea:	f8d7 3080 	ldr.w	r3, [r7, #128]	; 0x80
  4051ee:	4413      	add	r3, r2
  4051f0:	68fa      	ldr	r2, [r7, #12]
  4051f2:	3312      	adds	r3, #18
  4051f4:	009b      	lsls	r3, r3, #2
  4051f6:	4413      	add	r3, r2
  4051f8:	689b      	ldr	r3, [r3, #8]
					trans[THREE_AXES * i + k] *
  4051fa:	fb03 f304 	mul.w	r3, r3, r4
				tmp_m[THREE_AXES * i + j] +=
  4051fe:	18c2      	adds	r2, r0, r3
  405200:	008b      	lsls	r3, r1, #2
  405202:	f107 0188 	add.w	r1, r7, #136	; 0x88
  405206:	440b      	add	r3, r1
  405208:	f843 2c44 	str.w	r2, [r3, #-68]
			for (k = 0; k < THREE_AXES; k++)
  40520c:	6ffb      	ldr	r3, [r7, #124]	; 0x7c
  40520e:	3301      	adds	r3, #1
  405210:	67fb      	str	r3, [r7, #124]	; 0x7c
  405212:	6ffb      	ldr	r3, [r7, #124]	; 0x7c
  405214:	2b02      	cmp	r3, #2
  405216:	ddc1      	ble.n	40519c <inv_icm20948_compass_dmp_cal+0x254>
		for (j = 0; j < THREE_AXES; j++)
  405218:	f8d7 3080 	ldr.w	r3, [r7, #128]	; 0x80
  40521c:	3301      	adds	r3, #1
  40521e:	f8c7 3080 	str.w	r3, [r7, #128]	; 0x80
  405222:	f8d7 3080 	ldr.w	r3, [r7, #128]	; 0x80
  405226:	2b02      	cmp	r3, #2
  405228:	ddb5      	ble.n	405196 <inv_icm20948_compass_dmp_cal+0x24e>
    for (i = 0; i < THREE_AXES; i++)
  40522a:	f8d7 3084 	ldr.w	r3, [r7, #132]	; 0x84
  40522e:	3301      	adds	r3, #1
  405230:	f8c7 3084 	str.w	r3, [r7, #132]	; 0x84
  405234:	f8d7 3084 	ldr.w	r3, [r7, #132]	; 0x84
  405238:	2b02      	cmp	r3, #2
  40523a:	dda8      	ble.n	40518e <inv_icm20948_compass_dmp_cal+0x246>

    return dmp_icm20948_set_compass_matrix(s, tmp_m);
  40523c:	f107 0344 	add.w	r3, r7, #68	; 0x44
  405240:	4619      	mov	r1, r3
  405242:	68f8      	ldr	r0, [r7, #12]
  405244:	4b06      	ldr	r3, [pc, #24]	; (405260 <inv_icm20948_compass_dmp_cal+0x318>)
  405246:	4798      	blx	r3
  405248:	4603      	mov	r3, r0
}
  40524a:	4618      	mov	r0, r3
  40524c:	378c      	adds	r7, #140	; 0x8c
  40524e:	46bd      	mov	sp, r7
  405250:	bd90      	pop	{r4, r7, pc}
  405252:	bf00      	nop
  405254:	09999999 	.word	0x09999999
  405258:	00406ce9 	.word	0x00406ce9
  40525c:	55555556 	.word	0x55555556
  405260:	004080f1 	.word	0x004080f1

00405264 <inv_icm20948_apply_raw_compass_matrix>:
*  @param[in]  Compensated compass data
*  @return     0 if successful.
*/

int inv_icm20948_apply_raw_compass_matrix(struct inv_icm20948 * s, short *raw_data, long *compensated_out)
{
  405264:	b5f0      	push	{r4, r5, r6, r7, lr}
  405266:	b089      	sub	sp, #36	; 0x24
  405268:	af00      	add	r7, sp, #0
  40526a:	60f8      	str	r0, [r7, #12]
  40526c:	60b9      	str	r1, [r7, #8]
  40526e:	607a      	str	r2, [r7, #4]
	int i, j;
	long long tmp;

	for (i = 0; i < THREE_AXES; i++) {
  405270:	2200      	movs	r2, #0
  405272:	61fa      	str	r2, [r7, #28]
  405274:	e045      	b.n	405302 <inv_icm20948_apply_raw_compass_matrix+0x9e>
		tmp = 0;
  405276:	f04f 0100 	mov.w	r1, #0
  40527a:	f04f 0200 	mov.w	r2, #0
  40527e:	e9c7 1204 	strd	r1, r2, [r7, #16]
		for (j = 0; j < THREE_AXES; j++)
  405282:	2200      	movs	r2, #0
  405284:	61ba      	str	r2, [r7, #24]
  405286:	e02a      	b.n	4052de <inv_icm20948_apply_raw_compass_matrix+0x7a>
			tmp  +=
			(long long)s->secondary_state.final_matrix[i * THREE_AXES + j] * (((int)raw_data[j]) << 16);
  405288:	69f9      	ldr	r1, [r7, #28]
  40528a:	460a      	mov	r2, r1
  40528c:	0052      	lsls	r2, r2, #1
  40528e:	4411      	add	r1, r2
  405290:	69ba      	ldr	r2, [r7, #24]
  405292:	440a      	add	r2, r1
  405294:	68f9      	ldr	r1, [r7, #12]
  405296:	3212      	adds	r2, #18
  405298:	0092      	lsls	r2, r2, #2
  40529a:	440a      	add	r2, r1
  40529c:	6892      	ldr	r2, [r2, #8]
  40529e:	4615      	mov	r5, r2
  4052a0:	ea4f 76e5 	mov.w	r6, r5, asr #31
  4052a4:	69ba      	ldr	r2, [r7, #24]
  4052a6:	0052      	lsls	r2, r2, #1
  4052a8:	68b9      	ldr	r1, [r7, #8]
  4052aa:	440a      	add	r2, r1
  4052ac:	f9b2 2000 	ldrsh.w	r2, [r2]
  4052b0:	0412      	lsls	r2, r2, #16
  4052b2:	4611      	mov	r1, r2
  4052b4:	ea4f 72e1 	mov.w	r2, r1, asr #31
  4052b8:	fb01 fe06 	mul.w	lr, r1, r6
  4052bc:	fb05 f002 	mul.w	r0, r5, r2
  4052c0:	4470      	add	r0, lr
  4052c2:	fba5 1201 	umull	r1, r2, r5, r1
  4052c6:	4410      	add	r0, r2
  4052c8:	4602      	mov	r2, r0
			tmp  +=
  4052ca:	e9d7 5604 	ldrd	r5, r6, [r7, #16]
  4052ce:	1949      	adds	r1, r1, r5
  4052d0:	eb42 0206 	adc.w	r2, r2, r6
  4052d4:	e9c7 1204 	strd	r1, r2, [r7, #16]
		for (j = 0; j < THREE_AXES; j++)
  4052d8:	69ba      	ldr	r2, [r7, #24]
  4052da:	3201      	adds	r2, #1
  4052dc:	61ba      	str	r2, [r7, #24]
  4052de:	69ba      	ldr	r2, [r7, #24]
  4052e0:	2a02      	cmp	r2, #2
  4052e2:	ddd1      	ble.n	405288 <inv_icm20948_apply_raw_compass_matrix+0x24>
		compensated_out[i] = (long)(tmp >> 30);
  4052e4:	69fa      	ldr	r2, [r7, #28]
  4052e6:	0092      	lsls	r2, r2, #2
  4052e8:	6879      	ldr	r1, [r7, #4]
  4052ea:	1888      	adds	r0, r1, r2
  4052ec:	e9d7 1204 	ldrd	r1, r2, [r7, #16]
  4052f0:	0f8b      	lsrs	r3, r1, #30
  4052f2:	ea43 0382 	orr.w	r3, r3, r2, lsl #2
  4052f6:	1794      	asrs	r4, r2, #30
  4052f8:	461a      	mov	r2, r3
  4052fa:	6002      	str	r2, [r0, #0]
	for (i = 0; i < THREE_AXES; i++) {
  4052fc:	69fa      	ldr	r2, [r7, #28]
  4052fe:	3201      	adds	r2, #1
  405300:	61fa      	str	r2, [r7, #28]
  405302:	69fa      	ldr	r2, [r7, #28]
  405304:	2a02      	cmp	r2, #2
  405306:	ddb6      	ble.n	405276 <inv_icm20948_apply_raw_compass_matrix+0x12>
	}

	return 0;
  405308:	2300      	movs	r3, #0
}
  40530a:	4618      	mov	r0, r3
  40530c:	3724      	adds	r7, #36	; 0x24
  40530e:	46bd      	mov	sp, r7
  405310:	bdf0      	pop	{r4, r5, r6, r7, pc}
	...

00405314 <inv_icm20948_init_secondary>:
#include "Icm20948DataBaseDriver.h"

#include "Icm20948AuxTransport.h"

void inv_icm20948_init_secondary(struct inv_icm20948 * s)
{
  405314:	b580      	push	{r7, lr}
  405316:	b082      	sub	sp, #8
  405318:	af00      	add	r7, sp, #0
  40531a:	6078      	str	r0, [r7, #4]
	s->secondary_state.slv_reg[0].addr = REG_I2C_SLV0_ADDR;
  40531c:	687b      	ldr	r3, [r7, #4]
  40531e:	f240 1283 	movw	r2, #387	; 0x183
  405322:	859a      	strh	r2, [r3, #44]	; 0x2c
	s->secondary_state.slv_reg[0].reg  = REG_I2C_SLV0_REG;
  405324:	687b      	ldr	r3, [r7, #4]
  405326:	f44f 72c2 	mov.w	r2, #388	; 0x184
  40532a:	85da      	strh	r2, [r3, #46]	; 0x2e
	s->secondary_state.slv_reg[0].ctrl = REG_I2C_SLV0_CTRL;
  40532c:	687b      	ldr	r3, [r7, #4]
  40532e:	f240 1285 	movw	r2, #389	; 0x185
  405332:	861a      	strh	r2, [r3, #48]	; 0x30
	s->secondary_state.slv_reg[0].d0   = REG_I2C_SLV0_DO;
  405334:	687b      	ldr	r3, [r7, #4]
  405336:	f44f 72c3 	mov.w	r2, #390	; 0x186
  40533a:	865a      	strh	r2, [r3, #50]	; 0x32
    
    s->secondary_state.slv_reg[1].addr = REG_I2C_SLV1_ADDR;
  40533c:	687b      	ldr	r3, [r7, #4]
  40533e:	f240 1287 	movw	r2, #391	; 0x187
  405342:	869a      	strh	r2, [r3, #52]	; 0x34
	s->secondary_state.slv_reg[1].reg  = REG_I2C_SLV1_REG;
  405344:	687b      	ldr	r3, [r7, #4]
  405346:	f44f 72c4 	mov.w	r2, #392	; 0x188
  40534a:	86da      	strh	r2, [r3, #54]	; 0x36
	s->secondary_state.slv_reg[1].ctrl = REG_I2C_SLV1_CTRL;
  40534c:	687b      	ldr	r3, [r7, #4]
  40534e:	f240 1289 	movw	r2, #393	; 0x189
  405352:	871a      	strh	r2, [r3, #56]	; 0x38
	s->secondary_state.slv_reg[1].d0   = REG_I2C_SLV1_DO;
  405354:	687b      	ldr	r3, [r7, #4]
  405356:	f44f 72c5 	mov.w	r2, #394	; 0x18a
  40535a:	875a      	strh	r2, [r3, #58]	; 0x3a
    
    s->secondary_state.slv_reg[2].addr = REG_I2C_SLV2_ADDR;
  40535c:	687b      	ldr	r3, [r7, #4]
  40535e:	f240 128b 	movw	r2, #395	; 0x18b
  405362:	879a      	strh	r2, [r3, #60]	; 0x3c
	s->secondary_state.slv_reg[2].reg  = REG_I2C_SLV2_REG;
  405364:	687b      	ldr	r3, [r7, #4]
  405366:	f44f 72c6 	mov.w	r2, #396	; 0x18c
  40536a:	87da      	strh	r2, [r3, #62]	; 0x3e
	s->secondary_state.slv_reg[2].ctrl = REG_I2C_SLV2_CTRL;
  40536c:	687b      	ldr	r3, [r7, #4]
  40536e:	f240 128d 	movw	r2, #397	; 0x18d
  405372:	f8a3 2040 	strh.w	r2, [r3, #64]	; 0x40
	s->secondary_state.slv_reg[2].d0   = REG_I2C_SLV2_DO;
  405376:	687b      	ldr	r3, [r7, #4]
  405378:	f44f 72c7 	mov.w	r2, #398	; 0x18e
  40537c:	f8a3 2042 	strh.w	r2, [r3, #66]	; 0x42
    
	s->secondary_state.slv_reg[3].addr = REG_I2C_SLV3_ADDR;
  405380:	687b      	ldr	r3, [r7, #4]
  405382:	f240 128f 	movw	r2, #399	; 0x18f
  405386:	f8a3 2044 	strh.w	r2, [r3, #68]	; 0x44
	s->secondary_state.slv_reg[3].reg  = REG_I2C_SLV3_REG;
  40538a:	687b      	ldr	r3, [r7, #4]
  40538c:	f44f 72c8 	mov.w	r2, #400	; 0x190
  405390:	f8a3 2046 	strh.w	r2, [r3, #70]	; 0x46
	s->secondary_state.slv_reg[3].ctrl = REG_I2C_SLV3_CTRL;
  405394:	687b      	ldr	r3, [r7, #4]
  405396:	f240 1291 	movw	r2, #401	; 0x191
  40539a:	f8a3 2048 	strh.w	r2, [r3, #72]	; 0x48
	s->secondary_state.slv_reg[3].d0   = REG_I2C_SLV3_DO;
  40539e:	687b      	ldr	r3, [r7, #4]
  4053a0:	f44f 72c9 	mov.w	r2, #402	; 0x192
  4053a4:	f8a3 204a 	strh.w	r2, [r3, #74]	; 0x4a
	
	/* Make sure that by default all channels are disabled 
	To not inherit from a previous configuration from a previous run*/
	inv_icm20948_secondary_stop_channel(s, 0);
  4053a8:	2100      	movs	r1, #0
  4053aa:	6878      	ldr	r0, [r7, #4]
  4053ac:	4b08      	ldr	r3, [pc, #32]	; (4053d0 <inv_icm20948_init_secondary+0xbc>)
  4053ae:	4798      	blx	r3
	inv_icm20948_secondary_stop_channel(s, 1);
  4053b0:	2101      	movs	r1, #1
  4053b2:	6878      	ldr	r0, [r7, #4]
  4053b4:	4b06      	ldr	r3, [pc, #24]	; (4053d0 <inv_icm20948_init_secondary+0xbc>)
  4053b6:	4798      	blx	r3
	inv_icm20948_secondary_stop_channel(s, 2);
  4053b8:	2102      	movs	r1, #2
  4053ba:	6878      	ldr	r0, [r7, #4]
  4053bc:	4b04      	ldr	r3, [pc, #16]	; (4053d0 <inv_icm20948_init_secondary+0xbc>)
  4053be:	4798      	blx	r3
	inv_icm20948_secondary_stop_channel(s, 3);
  4053c0:	2103      	movs	r1, #3
  4053c2:	6878      	ldr	r0, [r7, #4]
  4053c4:	4b02      	ldr	r3, [pc, #8]	; (4053d0 <inv_icm20948_init_secondary+0xbc>)
  4053c6:	4798      	blx	r3
}
  4053c8:	bf00      	nop
  4053ca:	3708      	adds	r7, #8
  4053cc:	46bd      	mov	sp, r7
  4053ce:	bd80      	pop	{r7, pc}
  4053d0:	00405655 	.word	0x00405655

004053d4 <inv_icm20948_read_secondary>:
* reg is the device register we wish to access
* len is the number of bytes to be read
* 
*/
int inv_icm20948_read_secondary(struct inv_icm20948 * s, int index, unsigned char addr, unsigned char reg, char len)
{
  4053d4:	b590      	push	{r4, r7, lr}
  4053d6:	b087      	sub	sp, #28
  4053d8:	af00      	add	r7, sp, #0
  4053da:	60f8      	str	r0, [r7, #12]
  4053dc:	60b9      	str	r1, [r7, #8]
  4053de:	4611      	mov	r1, r2
  4053e0:	461a      	mov	r2, r3
  4053e2:	460b      	mov	r3, r1
  4053e4:	71fb      	strb	r3, [r7, #7]
  4053e6:	4613      	mov	r3, r2
  4053e8:	71bb      	strb	r3, [r7, #6]
	int result = 0;
  4053ea:	2300      	movs	r3, #0
  4053ec:	617b      	str	r3, [r7, #20]
    unsigned char data;

    data = INV_MPU_BIT_I2C_READ | addr;
  4053ee:	79fb      	ldrb	r3, [r7, #7]
  4053f0:	f063 037f 	orn	r3, r3, #127	; 0x7f
  4053f4:	b2db      	uxtb	r3, r3
  4053f6:	74fb      	strb	r3, [r7, #19]
	result |= inv_icm20948_write_mems_reg(s, s->secondary_state.slv_reg[index].addr, 1, &data);
  4053f8:	68fa      	ldr	r2, [r7, #12]
  4053fa:	68bb      	ldr	r3, [r7, #8]
  4053fc:	3305      	adds	r3, #5
  4053fe:	00db      	lsls	r3, r3, #3
  405400:	4413      	add	r3, r2
  405402:	8899      	ldrh	r1, [r3, #4]
  405404:	f107 0313 	add.w	r3, r7, #19
  405408:	2201      	movs	r2, #1
  40540a:	68f8      	ldr	r0, [r7, #12]
  40540c:	4c19      	ldr	r4, [pc, #100]	; (405474 <inv_icm20948_read_secondary+0xa0>)
  40540e:	47a0      	blx	r4
  405410:	4602      	mov	r2, r0
  405412:	697b      	ldr	r3, [r7, #20]
  405414:	4313      	orrs	r3, r2
  405416:	617b      	str	r3, [r7, #20]

    data = reg;
  405418:	79bb      	ldrb	r3, [r7, #6]
  40541a:	74fb      	strb	r3, [r7, #19]
	result |= inv_icm20948_write_mems_reg(s, s->secondary_state.slv_reg[index].reg, 1, &data);
  40541c:	68fa      	ldr	r2, [r7, #12]
  40541e:	68bb      	ldr	r3, [r7, #8]
  405420:	3305      	adds	r3, #5
  405422:	00db      	lsls	r3, r3, #3
  405424:	4413      	add	r3, r2
  405426:	88d9      	ldrh	r1, [r3, #6]
  405428:	f107 0313 	add.w	r3, r7, #19
  40542c:	2201      	movs	r2, #1
  40542e:	68f8      	ldr	r0, [r7, #12]
  405430:	4c10      	ldr	r4, [pc, #64]	; (405474 <inv_icm20948_read_secondary+0xa0>)
  405432:	47a0      	blx	r4
  405434:	4602      	mov	r2, r0
  405436:	697b      	ldr	r3, [r7, #20]
  405438:	4313      	orrs	r3, r2
  40543a:	617b      	str	r3, [r7, #20]
    
    data = INV_MPU_BIT_SLV_EN | len;
  40543c:	f897 3028 	ldrb.w	r3, [r7, #40]	; 0x28
  405440:	f063 037f 	orn	r3, r3, #127	; 0x7f
  405444:	b25b      	sxtb	r3, r3
  405446:	b2db      	uxtb	r3, r3
  405448:	74fb      	strb	r3, [r7, #19]
	result |= inv_icm20948_write_mems_reg(s, s->secondary_state.slv_reg[index].ctrl, 1, &data);
  40544a:	68fa      	ldr	r2, [r7, #12]
  40544c:	68bb      	ldr	r3, [r7, #8]
  40544e:	3305      	adds	r3, #5
  405450:	00db      	lsls	r3, r3, #3
  405452:	4413      	add	r3, r2
  405454:	8919      	ldrh	r1, [r3, #8]
  405456:	f107 0313 	add.w	r3, r7, #19
  40545a:	2201      	movs	r2, #1
  40545c:	68f8      	ldr	r0, [r7, #12]
  40545e:	4c05      	ldr	r4, [pc, #20]	; (405474 <inv_icm20948_read_secondary+0xa0>)
  405460:	47a0      	blx	r4
  405462:	4602      	mov	r2, r0
  405464:	697b      	ldr	r3, [r7, #20]
  405466:	4313      	orrs	r3, r2
  405468:	617b      	str	r3, [r7, #20]
    
	return result;
  40546a:	697b      	ldr	r3, [r7, #20]
}
  40546c:	4618      	mov	r0, r3
  40546e:	371c      	adds	r7, #28
  405470:	46bd      	mov	sp, r7
  405472:	bd90      	pop	{r4, r7, pc}
  405474:	0040c581 	.word	0x0040c581

00405478 <inv_icm20948_execute_read_secondary>:

int inv_icm20948_execute_read_secondary(struct inv_icm20948 * s, int index, unsigned char addr, int reg, int len, uint8_t *d)
{
  405478:	b590      	push	{r4, r7, lr}
  40547a:	b089      	sub	sp, #36	; 0x24
  40547c:	af02      	add	r7, sp, #8
  40547e:	60f8      	str	r0, [r7, #12]
  405480:	60b9      	str	r1, [r7, #8]
  405482:	603b      	str	r3, [r7, #0]
  405484:	4613      	mov	r3, r2
  405486:	71fb      	strb	r3, [r7, #7]
	int result = 0;
  405488:	2300      	movs	r3, #0
  40548a:	617b      	str	r3, [r7, #20]

	result |= inv_icm20948_read_secondary(s, index, addr, reg, len);
  40548c:	683b      	ldr	r3, [r7, #0]
  40548e:	b2d9      	uxtb	r1, r3
  405490:	6abb      	ldr	r3, [r7, #40]	; 0x28
  405492:	b25b      	sxtb	r3, r3
  405494:	79fa      	ldrb	r2, [r7, #7]
  405496:	9300      	str	r3, [sp, #0]
  405498:	460b      	mov	r3, r1
  40549a:	68b9      	ldr	r1, [r7, #8]
  40549c:	68f8      	ldr	r0, [r7, #12]
  40549e:	4c17      	ldr	r4, [pc, #92]	; (4054fc <inv_icm20948_execute_read_secondary+0x84>)
  4054a0:	47a0      	blx	r4
  4054a2:	4602      	mov	r2, r0
  4054a4:	697b      	ldr	r3, [r7, #20]
  4054a6:	4313      	orrs	r3, r2
  4054a8:	617b      	str	r3, [r7, #20]
	
	result |= inv_icm20948_secondary_enable_i2c(s);
  4054aa:	68f8      	ldr	r0, [r7, #12]
  4054ac:	4b14      	ldr	r3, [pc, #80]	; (405500 <inv_icm20948_execute_read_secondary+0x88>)
  4054ae:	4798      	blx	r3
  4054b0:	4602      	mov	r2, r0
  4054b2:	697b      	ldr	r3, [r7, #20]
  4054b4:	4313      	orrs	r3, r2
  4054b6:	617b      	str	r3, [r7, #20]
    
	inv_icm20948_sleep_us(SECONDARY_INIT_WAIT*1000);
  4054b8:	f64e 2060 	movw	r0, #60000	; 0xea60
  4054bc:	4b11      	ldr	r3, [pc, #68]	; (405504 <inv_icm20948_execute_read_secondary+0x8c>)
  4054be:	4798      	blx	r3
    
	result |= inv_icm20948_secondary_disable_i2c(s);
  4054c0:	68f8      	ldr	r0, [r7, #12]
  4054c2:	4b11      	ldr	r3, [pc, #68]	; (405508 <inv_icm20948_execute_read_secondary+0x90>)
  4054c4:	4798      	blx	r3
  4054c6:	4602      	mov	r2, r0
  4054c8:	697b      	ldr	r3, [r7, #20]
  4054ca:	4313      	orrs	r3, r2
  4054cc:	617b      	str	r3, [r7, #20]

    result |= inv_icm20948_read_mems_reg(s, REG_EXT_SLV_SENS_DATA_00, len, d); 
  4054ce:	6aba      	ldr	r2, [r7, #40]	; 0x28
  4054d0:	6afb      	ldr	r3, [r7, #44]	; 0x2c
  4054d2:	213b      	movs	r1, #59	; 0x3b
  4054d4:	68f8      	ldr	r0, [r7, #12]
  4054d6:	4c0d      	ldr	r4, [pc, #52]	; (40550c <inv_icm20948_execute_read_secondary+0x94>)
  4054d8:	47a0      	blx	r4
  4054da:	4602      	mov	r2, r0
  4054dc:	697b      	ldr	r3, [r7, #20]
  4054de:	4313      	orrs	r3, r2
  4054e0:	617b      	str	r3, [r7, #20]

	result |= inv_icm20948_secondary_stop_channel(s, index);
  4054e2:	68b9      	ldr	r1, [r7, #8]
  4054e4:	68f8      	ldr	r0, [r7, #12]
  4054e6:	4b0a      	ldr	r3, [pc, #40]	; (405510 <inv_icm20948_execute_read_secondary+0x98>)
  4054e8:	4798      	blx	r3
  4054ea:	4602      	mov	r2, r0
  4054ec:	697b      	ldr	r3, [r7, #20]
  4054ee:	4313      	orrs	r3, r2
  4054f0:	617b      	str	r3, [r7, #20]

	return result;
  4054f2:	697b      	ldr	r3, [r7, #20]
}
  4054f4:	4618      	mov	r0, r3
  4054f6:	371c      	adds	r7, #28
  4054f8:	46bd      	mov	sp, r7
  4054fa:	bd90      	pop	{r4, r7, pc}
  4054fc:	004053d5 	.word	0x004053d5
  405500:	00405685 	.word	0x00405685
  405504:	004015f9 	.word	0x004015f9
  405508:	004056b9 	.word	0x004056b9
  40550c:	0040c755 	.word	0x0040c755
  405510:	00405655 	.word	0x00405655

00405514 <inv_icm20948_write_secondary>:
* reg is the device register we wish to access
* len is the number of bytes to be read
* 
*/
int inv_icm20948_write_secondary(struct inv_icm20948 * s, int index, unsigned char addr, unsigned char reg, char v)
{
  405514:	b590      	push	{r4, r7, lr}
  405516:	b087      	sub	sp, #28
  405518:	af00      	add	r7, sp, #0
  40551a:	60f8      	str	r0, [r7, #12]
  40551c:	60b9      	str	r1, [r7, #8]
  40551e:	4611      	mov	r1, r2
  405520:	461a      	mov	r2, r3
  405522:	460b      	mov	r3, r1
  405524:	71fb      	strb	r3, [r7, #7]
  405526:	4613      	mov	r3, r2
  405528:	71bb      	strb	r3, [r7, #6]
	int result = 0;
  40552a:	2300      	movs	r3, #0
  40552c:	617b      	str	r3, [r7, #20]
    unsigned char data;
    
    data = (unsigned char)addr;
  40552e:	79fb      	ldrb	r3, [r7, #7]
  405530:	74fb      	strb	r3, [r7, #19]
	result |= inv_icm20948_write_mems_reg(s, s->secondary_state.slv_reg[index].addr, 1, &data);
  405532:	68fa      	ldr	r2, [r7, #12]
  405534:	68bb      	ldr	r3, [r7, #8]
  405536:	3305      	adds	r3, #5
  405538:	00db      	lsls	r3, r3, #3
  40553a:	4413      	add	r3, r2
  40553c:	8899      	ldrh	r1, [r3, #4]
  40553e:	f107 0313 	add.w	r3, r7, #19
  405542:	2201      	movs	r2, #1
  405544:	68f8      	ldr	r0, [r7, #12]
  405546:	4c21      	ldr	r4, [pc, #132]	; (4055cc <inv_icm20948_write_secondary+0xb8>)
  405548:	47a0      	blx	r4
  40554a:	4602      	mov	r2, r0
  40554c:	697b      	ldr	r3, [r7, #20]
  40554e:	4313      	orrs	r3, r2
  405550:	617b      	str	r3, [r7, #20]

    data = reg;
  405552:	79bb      	ldrb	r3, [r7, #6]
  405554:	74fb      	strb	r3, [r7, #19]
	result |= inv_icm20948_write_mems_reg(s, s->secondary_state.slv_reg[index].reg, 1, &data);
  405556:	68fa      	ldr	r2, [r7, #12]
  405558:	68bb      	ldr	r3, [r7, #8]
  40555a:	3305      	adds	r3, #5
  40555c:	00db      	lsls	r3, r3, #3
  40555e:	4413      	add	r3, r2
  405560:	88d9      	ldrh	r1, [r3, #6]
  405562:	f107 0313 	add.w	r3, r7, #19
  405566:	2201      	movs	r2, #1
  405568:	68f8      	ldr	r0, [r7, #12]
  40556a:	4c18      	ldr	r4, [pc, #96]	; (4055cc <inv_icm20948_write_secondary+0xb8>)
  40556c:	47a0      	blx	r4
  40556e:	4602      	mov	r2, r0
  405570:	697b      	ldr	r3, [r7, #20]
  405572:	4313      	orrs	r3, r2
  405574:	617b      	str	r3, [r7, #20]

    data = v;
  405576:	f897 3028 	ldrb.w	r3, [r7, #40]	; 0x28
  40557a:	74fb      	strb	r3, [r7, #19]
    result |= inv_icm20948_write_mems_reg(s, s->secondary_state.slv_reg[index].d0, 1, &data);
  40557c:	68fa      	ldr	r2, [r7, #12]
  40557e:	68bb      	ldr	r3, [r7, #8]
  405580:	3305      	adds	r3, #5
  405582:	00db      	lsls	r3, r3, #3
  405584:	4413      	add	r3, r2
  405586:	8959      	ldrh	r1, [r3, #10]
  405588:	f107 0313 	add.w	r3, r7, #19
  40558c:	2201      	movs	r2, #1
  40558e:	68f8      	ldr	r0, [r7, #12]
  405590:	4c0e      	ldr	r4, [pc, #56]	; (4055cc <inv_icm20948_write_secondary+0xb8>)
  405592:	47a0      	blx	r4
  405594:	4602      	mov	r2, r0
  405596:	697b      	ldr	r3, [r7, #20]
  405598:	4313      	orrs	r3, r2
  40559a:	617b      	str	r3, [r7, #20]
    
    data = INV_MPU_BIT_SLV_EN | 1;
  40559c:	2381      	movs	r3, #129	; 0x81
  40559e:	74fb      	strb	r3, [r7, #19]
	result |= inv_icm20948_write_mems_reg(s, s->secondary_state.slv_reg[index].ctrl, 1, &data);
  4055a0:	68fa      	ldr	r2, [r7, #12]
  4055a2:	68bb      	ldr	r3, [r7, #8]
  4055a4:	3305      	adds	r3, #5
  4055a6:	00db      	lsls	r3, r3, #3
  4055a8:	4413      	add	r3, r2
  4055aa:	8919      	ldrh	r1, [r3, #8]
  4055ac:	f107 0313 	add.w	r3, r7, #19
  4055b0:	2201      	movs	r2, #1
  4055b2:	68f8      	ldr	r0, [r7, #12]
  4055b4:	4c05      	ldr	r4, [pc, #20]	; (4055cc <inv_icm20948_write_secondary+0xb8>)
  4055b6:	47a0      	blx	r4
  4055b8:	4602      	mov	r2, r0
  4055ba:	697b      	ldr	r3, [r7, #20]
  4055bc:	4313      	orrs	r3, r2
  4055be:	617b      	str	r3, [r7, #20]
    
    return result;
  4055c0:	697b      	ldr	r3, [r7, #20]
}
  4055c2:	4618      	mov	r0, r3
  4055c4:	371c      	adds	r7, #28
  4055c6:	46bd      	mov	sp, r7
  4055c8:	bd90      	pop	{r4, r7, pc}
  4055ca:	bf00      	nop
  4055cc:	0040c581 	.word	0x0040c581

004055d0 <inv_icm20948_execute_write_secondary>:

int inv_icm20948_execute_write_secondary(struct inv_icm20948 * s, int index, unsigned char addr, int reg, uint8_t v)
{
  4055d0:	b590      	push	{r4, r7, lr}
  4055d2:	b089      	sub	sp, #36	; 0x24
  4055d4:	af02      	add	r7, sp, #8
  4055d6:	60f8      	str	r0, [r7, #12]
  4055d8:	60b9      	str	r1, [r7, #8]
  4055da:	603b      	str	r3, [r7, #0]
  4055dc:	4613      	mov	r3, r2
  4055de:	71fb      	strb	r3, [r7, #7]
	int result = 0;
  4055e0:	2300      	movs	r3, #0
  4055e2:	617b      	str	r3, [r7, #20]

	result |= inv_icm20948_write_secondary(s, index, addr, reg, v);
  4055e4:	683b      	ldr	r3, [r7, #0]
  4055e6:	b2d9      	uxtb	r1, r3
  4055e8:	f997 3028 	ldrsb.w	r3, [r7, #40]	; 0x28
  4055ec:	79fa      	ldrb	r2, [r7, #7]
  4055ee:	9300      	str	r3, [sp, #0]
  4055f0:	460b      	mov	r3, r1
  4055f2:	68b9      	ldr	r1, [r7, #8]
  4055f4:	68f8      	ldr	r0, [r7, #12]
  4055f6:	4c12      	ldr	r4, [pc, #72]	; (405640 <inv_icm20948_execute_write_secondary+0x70>)
  4055f8:	47a0      	blx	r4
  4055fa:	4602      	mov	r2, r0
  4055fc:	697b      	ldr	r3, [r7, #20]
  4055fe:	4313      	orrs	r3, r2
  405600:	617b      	str	r3, [r7, #20]
	
	result |= inv_icm20948_secondary_enable_i2c(s);
  405602:	68f8      	ldr	r0, [r7, #12]
  405604:	4b0f      	ldr	r3, [pc, #60]	; (405644 <inv_icm20948_execute_write_secondary+0x74>)
  405606:	4798      	blx	r3
  405608:	4602      	mov	r2, r0
  40560a:	697b      	ldr	r3, [r7, #20]
  40560c:	4313      	orrs	r3, r2
  40560e:	617b      	str	r3, [r7, #20]
    
	inv_icm20948_sleep_us(SECONDARY_INIT_WAIT*1000);
  405610:	f64e 2060 	movw	r0, #60000	; 0xea60
  405614:	4b0c      	ldr	r3, [pc, #48]	; (405648 <inv_icm20948_execute_write_secondary+0x78>)
  405616:	4798      	blx	r3
    
	result |= inv_icm20948_secondary_disable_i2c(s);
  405618:	68f8      	ldr	r0, [r7, #12]
  40561a:	4b0c      	ldr	r3, [pc, #48]	; (40564c <inv_icm20948_execute_write_secondary+0x7c>)
  40561c:	4798      	blx	r3
  40561e:	4602      	mov	r2, r0
  405620:	697b      	ldr	r3, [r7, #20]
  405622:	4313      	orrs	r3, r2
  405624:	617b      	str	r3, [r7, #20]

	result |= inv_icm20948_secondary_stop_channel(s, index);
  405626:	68b9      	ldr	r1, [r7, #8]
  405628:	68f8      	ldr	r0, [r7, #12]
  40562a:	4b09      	ldr	r3, [pc, #36]	; (405650 <inv_icm20948_execute_write_secondary+0x80>)
  40562c:	4798      	blx	r3
  40562e:	4602      	mov	r2, r0
  405630:	697b      	ldr	r3, [r7, #20]
  405632:	4313      	orrs	r3, r2
  405634:	617b      	str	r3, [r7, #20]

	return result;
  405636:	697b      	ldr	r3, [r7, #20]
}
  405638:	4618      	mov	r0, r3
  40563a:	371c      	adds	r7, #28
  40563c:	46bd      	mov	sp, r7
  40563e:	bd90      	pop	{r4, r7, pc}
  405640:	00405515 	.word	0x00405515
  405644:	00405685 	.word	0x00405685
  405648:	004015f9 	.word	0x004015f9
  40564c:	004056b9 	.word	0x004056b9
  405650:	00405655 	.word	0x00405655

00405654 <inv_icm20948_secondary_stop_channel>:
{
	inv_icm20948_write_single_mems_reg(s, REG_I2C_MST_ODR_CONFIG,s->secondary_state.sSavedI2cOdr);
}

int inv_icm20948_secondary_stop_channel(struct inv_icm20948 * s, int index)
{
  405654:	b580      	push	{r7, lr}
  405656:	b082      	sub	sp, #8
  405658:	af00      	add	r7, sp, #0
  40565a:	6078      	str	r0, [r7, #4]
  40565c:	6039      	str	r1, [r7, #0]
	return inv_icm20948_write_single_mems_reg(s, s->secondary_state.slv_reg[index].ctrl, 0);
  40565e:	687a      	ldr	r2, [r7, #4]
  405660:	683b      	ldr	r3, [r7, #0]
  405662:	3305      	adds	r3, #5
  405664:	00db      	lsls	r3, r3, #3
  405666:	4413      	add	r3, r2
  405668:	891b      	ldrh	r3, [r3, #8]
  40566a:	2200      	movs	r2, #0
  40566c:	4619      	mov	r1, r3
  40566e:	6878      	ldr	r0, [r7, #4]
  405670:	4b03      	ldr	r3, [pc, #12]	; (405680 <inv_icm20948_secondary_stop_channel+0x2c>)
  405672:	4798      	blx	r3
  405674:	4603      	mov	r3, r0
}
  405676:	4618      	mov	r0, r3
  405678:	3708      	adds	r7, #8
  40567a:	46bd      	mov	sp, r7
  40567c:	bd80      	pop	{r7, pc}
  40567e:	bf00      	nop
  405680:	0040c689 	.word	0x0040c689

00405684 <inv_icm20948_secondary_enable_i2c>:

int inv_icm20948_secondary_enable_i2c(struct inv_icm20948 * s)
{
  405684:	b580      	push	{r7, lr}
  405686:	b082      	sub	sp, #8
  405688:	af00      	add	r7, sp, #0
  40568a:	6078      	str	r0, [r7, #4]
	s->base_state.user_ctrl |= BIT_I2C_MST_EN;
  40568c:	687b      	ldr	r3, [r7, #4]
  40568e:	7f1b      	ldrb	r3, [r3, #28]
  405690:	f043 0320 	orr.w	r3, r3, #32
  405694:	b2da      	uxtb	r2, r3
  405696:	687b      	ldr	r3, [r7, #4]
  405698:	771a      	strb	r2, [r3, #28]
	return inv_icm20948_write_single_mems_reg(s, REG_USER_CTRL, s->base_state.user_ctrl); 
  40569a:	687b      	ldr	r3, [r7, #4]
  40569c:	7f1b      	ldrb	r3, [r3, #28]
  40569e:	461a      	mov	r2, r3
  4056a0:	2103      	movs	r1, #3
  4056a2:	6878      	ldr	r0, [r7, #4]
  4056a4:	4b03      	ldr	r3, [pc, #12]	; (4056b4 <inv_icm20948_secondary_enable_i2c+0x30>)
  4056a6:	4798      	blx	r3
  4056a8:	4603      	mov	r3, r0
}
  4056aa:	4618      	mov	r0, r3
  4056ac:	3708      	adds	r7, #8
  4056ae:	46bd      	mov	sp, r7
  4056b0:	bd80      	pop	{r7, pc}
  4056b2:	bf00      	nop
  4056b4:	0040c689 	.word	0x0040c689

004056b8 <inv_icm20948_secondary_disable_i2c>:

int inv_icm20948_secondary_disable_i2c(struct inv_icm20948 * s)
{
  4056b8:	b580      	push	{r7, lr}
  4056ba:	b082      	sub	sp, #8
  4056bc:	af00      	add	r7, sp, #0
  4056be:	6078      	str	r0, [r7, #4]
	s->base_state.user_ctrl &= ~BIT_I2C_MST_EN;
  4056c0:	687b      	ldr	r3, [r7, #4]
  4056c2:	7f1b      	ldrb	r3, [r3, #28]
  4056c4:	f023 0320 	bic.w	r3, r3, #32
  4056c8:	b2da      	uxtb	r2, r3
  4056ca:	687b      	ldr	r3, [r7, #4]
  4056cc:	771a      	strb	r2, [r3, #28]
	return inv_icm20948_write_single_mems_reg(s, REG_USER_CTRL, s->base_state.user_ctrl); 
  4056ce:	687b      	ldr	r3, [r7, #4]
  4056d0:	7f1b      	ldrb	r3, [r3, #28]
  4056d2:	461a      	mov	r2, r3
  4056d4:	2103      	movs	r1, #3
  4056d6:	6878      	ldr	r0, [r7, #4]
  4056d8:	4b03      	ldr	r3, [pc, #12]	; (4056e8 <inv_icm20948_secondary_disable_i2c+0x30>)
  4056da:	4798      	blx	r3
  4056dc:	4603      	mov	r3, r0
}
  4056de:	4618      	mov	r0, r3
  4056e0:	3708      	adds	r7, #8
  4056e2:	46bd      	mov	sp, r7
  4056e4:	bd80      	pop	{r7, pc}
  4056e6:	bf00      	nop
  4056e8:	0040c689 	.word	0x0040c689

004056ec <inv_icm20948_secondary_set_odr>:


int inv_icm20948_secondary_set_odr(struct inv_icm20948 * s, int divider, unsigned int* effectiveDivider)
{
  4056ec:	b580      	push	{r7, lr}
  4056ee:	b086      	sub	sp, #24
  4056f0:	af00      	add	r7, sp, #0
  4056f2:	60f8      	str	r0, [r7, #12]
  4056f4:	60b9      	str	r1, [r7, #8]
  4056f6:	607a      	str	r2, [r7, #4]
	int mst_odr_config = 0;
  4056f8:	2300      	movs	r3, #0
  4056fa:	617b      	str	r3, [r7, #20]

    // find 2^x = divider to fit BASE_SAMPLE_RATE/2^REG_I2C_MST_ODR_CONFIG
    do
    {
		divider>>=1;
  4056fc:	68bb      	ldr	r3, [r7, #8]
  4056fe:	105b      	asrs	r3, r3, #1
  405700:	60bb      	str	r3, [r7, #8]
		mst_odr_config++;
  405702:	697b      	ldr	r3, [r7, #20]
  405704:	3301      	adds	r3, #1
  405706:	617b      	str	r3, [r7, #20]
    } while(divider>>1);
  405708:	68bb      	ldr	r3, [r7, #8]
  40570a:	105b      	asrs	r3, r3, #1
  40570c:	2b00      	cmp	r3, #0
  40570e:	d1f5      	bne.n	4056fc <inv_icm20948_secondary_set_odr+0x10>
    
	if (mst_odr_config < MIN_MST_ODR_CONFIG)
  405710:	697b      	ldr	r3, [r7, #20]
  405712:	2b03      	cmp	r3, #3
  405714:	dc01      	bgt.n	40571a <inv_icm20948_secondary_set_odr+0x2e>
		mst_odr_config = MIN_MST_ODR_CONFIG;
  405716:	2304      	movs	r3, #4
  405718:	617b      	str	r3, [r7, #20]

	*effectiveDivider = 1<<mst_odr_config;
  40571a:	2201      	movs	r2, #1
  40571c:	697b      	ldr	r3, [r7, #20]
  40571e:	fa02 f303 	lsl.w	r3, r2, r3
  405722:	461a      	mov	r2, r3
  405724:	687b      	ldr	r3, [r7, #4]
  405726:	601a      	str	r2, [r3, #0]

	return	inv_icm20948_set_secondary_divider(s, (unsigned char)mst_odr_config);
  405728:	697b      	ldr	r3, [r7, #20]
  40572a:	b2db      	uxtb	r3, r3
  40572c:	4619      	mov	r1, r3
  40572e:	68f8      	ldr	r0, [r7, #12]
  405730:	4b03      	ldr	r3, [pc, #12]	; (405740 <inv_icm20948_secondary_set_odr+0x54>)
  405732:	4798      	blx	r3
  405734:	4603      	mov	r3, r0
}
  405736:	4618      	mov	r0, r3
  405738:	3718      	adds	r7, #24
  40573a:	46bd      	mov	sp, r7
  40573c:	bd80      	pop	{r7, pc}
  40573e:	bf00      	nop
  405740:	00405ed5 	.word	0x00405ed5

00405744 <inv_icm20948_prevent_lpen_control>:
#include "Icm20948Dmp3Driver.h"

static unsigned char inv_is_gyro_enabled(struct inv_icm20948 * s);

void inv_icm20948_prevent_lpen_control(struct inv_icm20948 * s)
{
  405744:	b480      	push	{r7}
  405746:	b083      	sub	sp, #12
  405748:	af00      	add	r7, sp, #0
  40574a:	6078      	str	r0, [r7, #4]
	s->sAllowLpEn = 0;
  40574c:	687b      	ldr	r3, [r7, #4]
  40574e:	2200      	movs	r2, #0
  405750:	f883 20b8 	strb.w	r2, [r3, #184]	; 0xb8
}
  405754:	bf00      	nop
  405756:	370c      	adds	r7, #12
  405758:	46bd      	mov	sp, r7
  40575a:	f85d 7b04 	ldr.w	r7, [sp], #4
  40575e:	4770      	bx	lr

00405760 <inv_icm20948_allow_lpen_control>:
void inv_icm20948_allow_lpen_control(struct inv_icm20948 * s)
{
  405760:	b580      	push	{r7, lr}
  405762:	b082      	sub	sp, #8
  405764:	af00      	add	r7, sp, #0
  405766:	6078      	str	r0, [r7, #4]
	s->sAllowLpEn = 1;
  405768:	687b      	ldr	r3, [r7, #4]
  40576a:	2201      	movs	r2, #1
  40576c:	f883 20b8 	strb.w	r2, [r3, #184]	; 0xb8
	inv_icm20948_set_chip_power_state(s, CHIP_LP_ENABLE, 1);
  405770:	2201      	movs	r2, #1
  405772:	2102      	movs	r1, #2
  405774:	6878      	ldr	r0, [r7, #4]
  405776:	4b03      	ldr	r3, [pc, #12]	; (405784 <inv_icm20948_allow_lpen_control+0x24>)
  405778:	4798      	blx	r3
}
  40577a:	bf00      	nop
  40577c:	3708      	adds	r7, #8
  40577e:	46bd      	mov	sp, r7
  405780:	bd80      	pop	{r7, pc}
  405782:	bf00      	nop
  405784:	004057a5 	.word	0x004057a5

00405788 <inv_icm20948_get_lpen_control>:
static uint8_t inv_icm20948_get_lpen_control(struct inv_icm20948 * s)
{
  405788:	b480      	push	{r7}
  40578a:	b083      	sub	sp, #12
  40578c:	af00      	add	r7, sp, #0
  40578e:	6078      	str	r0, [r7, #4]
	return s->sAllowLpEn;
  405790:	687b      	ldr	r3, [r7, #4]
  405792:	f893 30b8 	ldrb.w	r3, [r3, #184]	; 0xb8
}
  405796:	4618      	mov	r0, r3
  405798:	370c      	adds	r7, #12
  40579a:	46bd      	mov	sp, r7
  40579c:	f85d 7b04 	ldr.w	r7, [sp], #4
  4057a0:	4770      	bx	lr
	...

004057a4 <inv_icm20948_set_chip_power_state>:
 *   @param[in] On/Off - The functions are enabled if previously disabled and 
                disabled if previously enabled based on the value of On/Off.
 ******************************************************************************
 */ 
int inv_icm20948_set_chip_power_state(struct inv_icm20948 * s, unsigned char func, unsigned char on_off)
{
  4057a4:	b580      	push	{r7, lr}
  4057a6:	b084      	sub	sp, #16
  4057a8:	af00      	add	r7, sp, #0
  4057aa:	6078      	str	r0, [r7, #4]
  4057ac:	460b      	mov	r3, r1
  4057ae:	70fb      	strb	r3, [r7, #3]
  4057b0:	4613      	mov	r3, r2
  4057b2:	70bb      	strb	r3, [r7, #2]
	int status = 0;
  4057b4:	2300      	movs	r3, #0
  4057b6:	60fb      	str	r3, [r7, #12]

	switch(func) {
  4057b8:	78fb      	ldrb	r3, [r7, #3]
  4057ba:	2b01      	cmp	r3, #1
  4057bc:	d002      	beq.n	4057c4 <inv_icm20948_set_chip_power_state+0x20>
  4057be:	2b02      	cmp	r3, #2
  4057c0:	d044      	beq.n	40584c <inv_icm20948_set_chip_power_state+0xa8>
				}
			}
		break;

		default:
		break;
  4057c2:	e094      	b.n	4058ee <inv_icm20948_set_chip_power_state+0x14a>
			if(on_off){
  4057c4:	78bb      	ldrb	r3, [r7, #2]
  4057c6:	2b00      	cmp	r3, #0
  4057c8:	d020      	beq.n	40580c <inv_icm20948_set_chip_power_state+0x68>
				if((s->base_state.wake_state & CHIP_AWAKE) == 0) {// undo sleep_en
  4057ca:	687b      	ldr	r3, [r7, #4]
  4057cc:	7e1b      	ldrb	r3, [r3, #24]
  4057ce:	f003 0301 	and.w	r3, r3, #1
  4057d2:	2b00      	cmp	r3, #0
  4057d4:	f040 8088 	bne.w	4058e8 <inv_icm20948_set_chip_power_state+0x144>
					s->base_state.pwr_mgmt_1 &= ~BIT_SLEEP;
  4057d8:	687b      	ldr	r3, [r7, #4]
  4057da:	7e9b      	ldrb	r3, [r3, #26]
  4057dc:	f023 0340 	bic.w	r3, r3, #64	; 0x40
  4057e0:	b2da      	uxtb	r2, r3
  4057e2:	687b      	ldr	r3, [r7, #4]
  4057e4:	769a      	strb	r2, [r3, #26]
					status = inv_icm20948_write_single_mems_reg_core(s, REG_PWR_MGMT_1, s->base_state.pwr_mgmt_1);
  4057e6:	687b      	ldr	r3, [r7, #4]
  4057e8:	7e9b      	ldrb	r3, [r3, #26]
  4057ea:	461a      	mov	r2, r3
  4057ec:	2106      	movs	r1, #6
  4057ee:	6878      	ldr	r0, [r7, #4]
  4057f0:	4b41      	ldr	r3, [pc, #260]	; (4058f8 <inv_icm20948_set_chip_power_state+0x154>)
  4057f2:	4798      	blx	r3
  4057f4:	60f8      	str	r0, [r7, #12]
					s->base_state.wake_state |= CHIP_AWAKE;
  4057f6:	687b      	ldr	r3, [r7, #4]
  4057f8:	7e1b      	ldrb	r3, [r3, #24]
  4057fa:	f043 0301 	orr.w	r3, r3, #1
  4057fe:	b2da      	uxtb	r2, r3
  405800:	687b      	ldr	r3, [r7, #4]
  405802:	761a      	strb	r2, [r3, #24]
					inv_icm20948_sleep_100us(1); // after writing the bit wait 100 Micro Seconds
  405804:	2001      	movs	r0, #1
  405806:	4b3d      	ldr	r3, [pc, #244]	; (4058fc <inv_icm20948_set_chip_power_state+0x158>)
  405808:	4798      	blx	r3
		break;
  40580a:	e06d      	b.n	4058e8 <inv_icm20948_set_chip_power_state+0x144>
				if(s->base_state.wake_state & CHIP_AWAKE) {// set sleep_en
  40580c:	687b      	ldr	r3, [r7, #4]
  40580e:	7e1b      	ldrb	r3, [r3, #24]
  405810:	f003 0301 	and.w	r3, r3, #1
  405814:	2b00      	cmp	r3, #0
  405816:	d067      	beq.n	4058e8 <inv_icm20948_set_chip_power_state+0x144>
					s->base_state.pwr_mgmt_1 |= BIT_SLEEP;
  405818:	687b      	ldr	r3, [r7, #4]
  40581a:	7e9b      	ldrb	r3, [r3, #26]
  40581c:	f043 0340 	orr.w	r3, r3, #64	; 0x40
  405820:	b2da      	uxtb	r2, r3
  405822:	687b      	ldr	r3, [r7, #4]
  405824:	769a      	strb	r2, [r3, #26]
					status = inv_icm20948_write_single_mems_reg_core(s, REG_PWR_MGMT_1, s->base_state.pwr_mgmt_1);
  405826:	687b      	ldr	r3, [r7, #4]
  405828:	7e9b      	ldrb	r3, [r3, #26]
  40582a:	461a      	mov	r2, r3
  40582c:	2106      	movs	r1, #6
  40582e:	6878      	ldr	r0, [r7, #4]
  405830:	4b31      	ldr	r3, [pc, #196]	; (4058f8 <inv_icm20948_set_chip_power_state+0x154>)
  405832:	4798      	blx	r3
  405834:	60f8      	str	r0, [r7, #12]
					s->base_state.wake_state &= ~CHIP_AWAKE;
  405836:	687b      	ldr	r3, [r7, #4]
  405838:	7e1b      	ldrb	r3, [r3, #24]
  40583a:	f023 0301 	bic.w	r3, r3, #1
  40583e:	b2da      	uxtb	r2, r3
  405840:	687b      	ldr	r3, [r7, #4]
  405842:	761a      	strb	r2, [r3, #24]
					inv_icm20948_sleep_100us(1); // after writing the bit wait 100 Micro Seconds
  405844:	2001      	movs	r0, #1
  405846:	4b2d      	ldr	r3, [pc, #180]	; (4058fc <inv_icm20948_set_chip_power_state+0x158>)
  405848:	4798      	blx	r3
		break;
  40584a:	e04d      	b.n	4058e8 <inv_icm20948_set_chip_power_state+0x144>
			if(s->base_state.lp_en_support == 1) {
  40584c:	687b      	ldr	r3, [r7, #4]
  40584e:	f893 3026 	ldrb.w	r3, [r3, #38]	; 0x26
  405852:	f003 0301 	and.w	r3, r3, #1
  405856:	b2db      	uxtb	r3, r3
  405858:	2b00      	cmp	r3, #0
  40585a:	d047      	beq.n	4058ec <inv_icm20948_set_chip_power_state+0x148>
				if(on_off) {
  40585c:	78bb      	ldrb	r3, [r7, #2]
  40585e:	2b00      	cmp	r3, #0
  405860:	d022      	beq.n	4058a8 <inv_icm20948_set_chip_power_state+0x104>
					if( (inv_icm20948_get_lpen_control(s)) && ((s->base_state.wake_state & CHIP_LP_ENABLE) == 0)){
  405862:	6878      	ldr	r0, [r7, #4]
  405864:	4b26      	ldr	r3, [pc, #152]	; (405900 <inv_icm20948_set_chip_power_state+0x15c>)
  405866:	4798      	blx	r3
  405868:	4603      	mov	r3, r0
  40586a:	2b00      	cmp	r3, #0
  40586c:	d03e      	beq.n	4058ec <inv_icm20948_set_chip_power_state+0x148>
  40586e:	687b      	ldr	r3, [r7, #4]
  405870:	7e1b      	ldrb	r3, [r3, #24]
  405872:	f003 0302 	and.w	r3, r3, #2
  405876:	2b00      	cmp	r3, #0
  405878:	d138      	bne.n	4058ec <inv_icm20948_set_chip_power_state+0x148>
						s->base_state.pwr_mgmt_1 |= BIT_LP_EN; // lp_en ON
  40587a:	687b      	ldr	r3, [r7, #4]
  40587c:	7e9b      	ldrb	r3, [r3, #26]
  40587e:	f043 0320 	orr.w	r3, r3, #32
  405882:	b2da      	uxtb	r2, r3
  405884:	687b      	ldr	r3, [r7, #4]
  405886:	769a      	strb	r2, [r3, #26]
						status = inv_icm20948_write_single_mems_reg_core(s, REG_PWR_MGMT_1, s->base_state.pwr_mgmt_1);
  405888:	687b      	ldr	r3, [r7, #4]
  40588a:	7e9b      	ldrb	r3, [r3, #26]
  40588c:	461a      	mov	r2, r3
  40588e:	2106      	movs	r1, #6
  405890:	6878      	ldr	r0, [r7, #4]
  405892:	4b19      	ldr	r3, [pc, #100]	; (4058f8 <inv_icm20948_set_chip_power_state+0x154>)
  405894:	4798      	blx	r3
  405896:	60f8      	str	r0, [r7, #12]
						s->base_state.wake_state |= CHIP_LP_ENABLE;
  405898:	687b      	ldr	r3, [r7, #4]
  40589a:	7e1b      	ldrb	r3, [r3, #24]
  40589c:	f043 0302 	orr.w	r3, r3, #2
  4058a0:	b2da      	uxtb	r2, r3
  4058a2:	687b      	ldr	r3, [r7, #4]
  4058a4:	761a      	strb	r2, [r3, #24]
		break;
  4058a6:	e021      	b.n	4058ec <inv_icm20948_set_chip_power_state+0x148>
					if(s->base_state.wake_state & CHIP_LP_ENABLE){
  4058a8:	687b      	ldr	r3, [r7, #4]
  4058aa:	7e1b      	ldrb	r3, [r3, #24]
  4058ac:	f003 0302 	and.w	r3, r3, #2
  4058b0:	2b00      	cmp	r3, #0
  4058b2:	d01b      	beq.n	4058ec <inv_icm20948_set_chip_power_state+0x148>
						s->base_state.pwr_mgmt_1 &= ~BIT_LP_EN; // lp_en off
  4058b4:	687b      	ldr	r3, [r7, #4]
  4058b6:	7e9b      	ldrb	r3, [r3, #26]
  4058b8:	f023 0320 	bic.w	r3, r3, #32
  4058bc:	b2da      	uxtb	r2, r3
  4058be:	687b      	ldr	r3, [r7, #4]
  4058c0:	769a      	strb	r2, [r3, #26]
						status = inv_icm20948_write_single_mems_reg_core(s, REG_PWR_MGMT_1, s->base_state.pwr_mgmt_1);
  4058c2:	687b      	ldr	r3, [r7, #4]
  4058c4:	7e9b      	ldrb	r3, [r3, #26]
  4058c6:	461a      	mov	r2, r3
  4058c8:	2106      	movs	r1, #6
  4058ca:	6878      	ldr	r0, [r7, #4]
  4058cc:	4b0a      	ldr	r3, [pc, #40]	; (4058f8 <inv_icm20948_set_chip_power_state+0x154>)
  4058ce:	4798      	blx	r3
  4058d0:	60f8      	str	r0, [r7, #12]
						s->base_state.wake_state &= ~CHIP_LP_ENABLE;
  4058d2:	687b      	ldr	r3, [r7, #4]
  4058d4:	7e1b      	ldrb	r3, [r3, #24]
  4058d6:	f023 0302 	bic.w	r3, r3, #2
  4058da:	b2da      	uxtb	r2, r3
  4058dc:	687b      	ldr	r3, [r7, #4]
  4058de:	761a      	strb	r2, [r3, #24]
						inv_icm20948_sleep_100us(1); // after writing the bit wait 100 Micro Seconds
  4058e0:	2001      	movs	r0, #1
  4058e2:	4b06      	ldr	r3, [pc, #24]	; (4058fc <inv_icm20948_set_chip_power_state+0x158>)
  4058e4:	4798      	blx	r3
		break;
  4058e6:	e001      	b.n	4058ec <inv_icm20948_set_chip_power_state+0x148>
		break;
  4058e8:	bf00      	nop
  4058ea:	e000      	b.n	4058ee <inv_icm20948_set_chip_power_state+0x14a>
		break;
  4058ec:	bf00      	nop

	}// end switch

	return status;
  4058ee:	68fb      	ldr	r3, [r7, #12]
}
  4058f0:	4618      	mov	r0, r3
  4058f2:	3710      	adds	r7, #16
  4058f4:	46bd      	mov	sp, r7
  4058f6:	bd80      	pop	{r7, pc}
  4058f8:	0040cbf5 	.word	0x0040cbf5
  4058fc:	0040c44d 	.word	0x0040c44d
  405900:	00405789 	.word	0x00405789

00405904 <inv_icm20948_get_chip_power_state>:
 ******************************************************************************
 *   @return    Current wake status of the Ivory chip.
 ******************************************************************************
 */
uint8_t inv_icm20948_get_chip_power_state(struct inv_icm20948 * s)
{
  405904:	b480      	push	{r7}
  405906:	b083      	sub	sp, #12
  405908:	af00      	add	r7, sp, #0
  40590a:	6078      	str	r0, [r7, #4]
	return s->base_state.wake_state;
  40590c:	687b      	ldr	r3, [r7, #4]
  40590e:	7e1b      	ldrb	r3, [r3, #24]
}
  405910:	4618      	mov	r0, r3
  405912:	370c      	adds	r7, #12
  405914:	46bd      	mov	sp, r7
  405916:	f85d 7b04 	ldr.w	r7, [sp], #4
  40591a:	4770      	bx	lr

0040591c <inv_icm20948_wakeup_mems>:

/** Wakes up DMP3 (SMARTSENSOR).
*/
int inv_icm20948_wakeup_mems(struct inv_icm20948 * s)
{
  40591c:	b590      	push	{r4, r7, lr}
  40591e:	b085      	sub	sp, #20
  405920:	af00      	add	r7, sp, #0
  405922:	6078      	str	r0, [r7, #4]
	unsigned char data;
	int result = 0;
  405924:	2300      	movs	r3, #0
  405926:	60fb      	str	r3, [r7, #12]

	result = inv_icm20948_set_chip_power_state(s, CHIP_AWAKE, 1);
  405928:	2201      	movs	r2, #1
  40592a:	2101      	movs	r1, #1
  40592c:	6878      	ldr	r0, [r7, #4]
  40592e:	4b25      	ldr	r3, [pc, #148]	; (4059c4 <inv_icm20948_wakeup_mems+0xa8>)
  405930:	4798      	blx	r3
  405932:	60f8      	str	r0, [r7, #12]

	if(s->base_state.serial_interface == SERIAL_INTERFACE_SPI) {
  405934:	687b      	ldr	r3, [r7, #4]
  405936:	f893 3027 	ldrb.w	r3, [r3, #39]	; 0x27
  40593a:	2b02      	cmp	r3, #2
  40593c:	d10d      	bne.n	40595a <inv_icm20948_wakeup_mems+0x3e>
		s->base_state.user_ctrl |= BIT_I2C_IF_DIS;
  40593e:	687b      	ldr	r3, [r7, #4]
  405940:	7f1b      	ldrb	r3, [r3, #28]
  405942:	f043 0310 	orr.w	r3, r3, #16
  405946:	b2da      	uxtb	r2, r3
  405948:	687b      	ldr	r3, [r7, #4]
  40594a:	771a      	strb	r2, [r3, #28]
		inv_icm20948_write_single_mems_reg(s, REG_USER_CTRL, s->base_state.user_ctrl);  
  40594c:	687b      	ldr	r3, [r7, #4]
  40594e:	7f1b      	ldrb	r3, [r3, #28]
  405950:	461a      	mov	r2, r3
  405952:	2103      	movs	r1, #3
  405954:	6878      	ldr	r0, [r7, #4]
  405956:	4b1c      	ldr	r3, [pc, #112]	; (4059c8 <inv_icm20948_wakeup_mems+0xac>)
  405958:	4798      	blx	r3
	}

	data = 0x47;	// FIXME, should set up according to sensor/engines enabled.
  40595a:	2347      	movs	r3, #71	; 0x47
  40595c:	72fb      	strb	r3, [r7, #11]
	result |= inv_icm20948_write_mems_reg(s, REG_PWR_MGMT_2, 1, &data);
  40595e:	f107 030b 	add.w	r3, r7, #11
  405962:	2201      	movs	r2, #1
  405964:	2107      	movs	r1, #7
  405966:	6878      	ldr	r0, [r7, #4]
  405968:	4c18      	ldr	r4, [pc, #96]	; (4059cc <inv_icm20948_wakeup_mems+0xb0>)
  40596a:	47a0      	blx	r4
  40596c:	4602      	mov	r2, r0
  40596e:	68fb      	ldr	r3, [r7, #12]
  405970:	4313      	orrs	r3, r2
  405972:	60fb      	str	r3, [r7, #12]

	if(s->base_state.firmware_loaded == 1) {
  405974:	687b      	ldr	r3, [r7, #4]
  405976:	f893 3026 	ldrb.w	r3, [r3, #38]	; 0x26
  40597a:	f003 0302 	and.w	r3, r3, #2
  40597e:	b2db      	uxtb	r3, r3
  405980:	2b00      	cmp	r3, #0
  405982:	d011      	beq.n	4059a8 <inv_icm20948_wakeup_mems+0x8c>
		s->base_state.user_ctrl |= BIT_DMP_EN | BIT_FIFO_EN;
  405984:	687b      	ldr	r3, [r7, #4]
  405986:	7f1b      	ldrb	r3, [r3, #28]
  405988:	f063 033f 	orn	r3, r3, #63	; 0x3f
  40598c:	b2da      	uxtb	r2, r3
  40598e:	687b      	ldr	r3, [r7, #4]
  405990:	771a      	strb	r2, [r3, #28]
		result |= inv_icm20948_write_single_mems_reg(s, REG_USER_CTRL, s->base_state.user_ctrl);  
  405992:	687b      	ldr	r3, [r7, #4]
  405994:	7f1b      	ldrb	r3, [r3, #28]
  405996:	461a      	mov	r2, r3
  405998:	2103      	movs	r1, #3
  40599a:	6878      	ldr	r0, [r7, #4]
  40599c:	4b0a      	ldr	r3, [pc, #40]	; (4059c8 <inv_icm20948_wakeup_mems+0xac>)
  40599e:	4798      	blx	r3
  4059a0:	4602      	mov	r2, r0
  4059a2:	68fb      	ldr	r3, [r7, #12]
  4059a4:	4313      	orrs	r3, r2
  4059a6:	60fb      	str	r3, [r7, #12]
	}

	result |= inv_icm20948_set_chip_power_state(s, CHIP_LP_ENABLE, 1);
  4059a8:	2201      	movs	r2, #1
  4059aa:	2102      	movs	r1, #2
  4059ac:	6878      	ldr	r0, [r7, #4]
  4059ae:	4b05      	ldr	r3, [pc, #20]	; (4059c4 <inv_icm20948_wakeup_mems+0xa8>)
  4059b0:	4798      	blx	r3
  4059b2:	4602      	mov	r2, r0
  4059b4:	68fb      	ldr	r3, [r7, #12]
  4059b6:	4313      	orrs	r3, r2
  4059b8:	60fb      	str	r3, [r7, #12]
	return result;
  4059ba:	68fb      	ldr	r3, [r7, #12]
}
  4059bc:	4618      	mov	r0, r3
  4059be:	3714      	adds	r7, #20
  4059c0:	46bd      	mov	sp, r7
  4059c2:	bd90      	pop	{r4, r7, pc}
  4059c4:	004057a5 	.word	0x004057a5
  4059c8:	0040c689 	.word	0x0040c689
  4059cc:	0040c581 	.word	0x0040c581

004059d0 <inv_icm20948_sleep_mems>:

/** Puts DMP3 (SMARTSENSOR) into the lowest power state. Assumes sensors are all off.
*/
int inv_icm20948_sleep_mems(struct inv_icm20948 * s)
{
  4059d0:	b590      	push	{r4, r7, lr}
  4059d2:	b085      	sub	sp, #20
  4059d4:	af00      	add	r7, sp, #0
  4059d6:	6078      	str	r0, [r7, #4]
	int result;
	unsigned char data;

	data = 0x7F;
  4059d8:	237f      	movs	r3, #127	; 0x7f
  4059da:	72fb      	strb	r3, [r7, #11]
	result = inv_icm20948_write_mems_reg(s, REG_PWR_MGMT_2, 1, &data);
  4059dc:	f107 030b 	add.w	r3, r7, #11
  4059e0:	2201      	movs	r2, #1
  4059e2:	2107      	movs	r1, #7
  4059e4:	6878      	ldr	r0, [r7, #4]
  4059e6:	4c08      	ldr	r4, [pc, #32]	; (405a08 <inv_icm20948_sleep_mems+0x38>)
  4059e8:	47a0      	blx	r4
  4059ea:	60f8      	str	r0, [r7, #12]

	result |= inv_icm20948_set_chip_power_state(s, CHIP_AWAKE, 0);
  4059ec:	2200      	movs	r2, #0
  4059ee:	2101      	movs	r1, #1
  4059f0:	6878      	ldr	r0, [r7, #4]
  4059f2:	4b06      	ldr	r3, [pc, #24]	; (405a0c <inv_icm20948_sleep_mems+0x3c>)
  4059f4:	4798      	blx	r3
  4059f6:	4602      	mov	r2, r0
  4059f8:	68fb      	ldr	r3, [r7, #12]
  4059fa:	4313      	orrs	r3, r2
  4059fc:	60fb      	str	r3, [r7, #12]

	return result;
  4059fe:	68fb      	ldr	r3, [r7, #12]
}
  405a00:	4618      	mov	r0, r3
  405a02:	3714      	adds	r7, #20
  405a04:	46bd      	mov	sp, r7
  405a06:	bd90      	pop	{r4, r7, pc}
  405a08:	0040c581 	.word	0x0040c581
  405a0c:	004057a5 	.word	0x004057a5

00405a10 <inv_icm20948_set_dmp_address>:

int inv_icm20948_set_dmp_address(struct inv_icm20948 * s)
{
  405a10:	b590      	push	{r4, r7, lr}
  405a12:	b087      	sub	sp, #28
  405a14:	af00      	add	r7, sp, #0
  405a16:	6078      	str	r0, [r7, #4]
	int result;
	unsigned char dmp_cfg[2] = {0};
  405a18:	2300      	movs	r3, #0
  405a1a:	823b      	strh	r3, [r7, #16]
	unsigned short config;

	// Write DMP Start address
	inv_icm20948_get_dmp_start_address(s, &config);
  405a1c:	f107 030e 	add.w	r3, r7, #14
  405a20:	4619      	mov	r1, r3
  405a22:	6878      	ldr	r0, [r7, #4]
  405a24:	4b0b      	ldr	r3, [pc, #44]	; (405a54 <inv_icm20948_set_dmp_address+0x44>)
  405a26:	4798      	blx	r3
	/* setup DMP start address and firmware */
	dmp_cfg[0] = (unsigned char)((config >> 8) & 0xff);
  405a28:	89fb      	ldrh	r3, [r7, #14]
  405a2a:	0a1b      	lsrs	r3, r3, #8
  405a2c:	b29b      	uxth	r3, r3
  405a2e:	b2db      	uxtb	r3, r3
  405a30:	743b      	strb	r3, [r7, #16]
	dmp_cfg[1] = (unsigned char)(config & 0xff);
  405a32:	89fb      	ldrh	r3, [r7, #14]
  405a34:	b2db      	uxtb	r3, r3
  405a36:	747b      	strb	r3, [r7, #17]

	result = inv_icm20948_write_mems_reg(s, REG_PRGM_START_ADDRH, 2, dmp_cfg);
  405a38:	f107 0310 	add.w	r3, r7, #16
  405a3c:	2202      	movs	r2, #2
  405a3e:	f44f 71a8 	mov.w	r1, #336	; 0x150
  405a42:	6878      	ldr	r0, [r7, #4]
  405a44:	4c04      	ldr	r4, [pc, #16]	; (405a58 <inv_icm20948_set_dmp_address+0x48>)
  405a46:	47a0      	blx	r4
  405a48:	6178      	str	r0, [r7, #20]
	return result;
  405a4a:	697b      	ldr	r3, [r7, #20]
}
  405a4c:	4618      	mov	r0, r3
  405a4e:	371c      	adds	r7, #28
  405a50:	46bd      	mov	sp, r7
  405a52:	bd90      	pop	{r4, r7, pc}
  405a54:	00407c19 	.word	0x00407c19
  405a58:	0040c581 	.word	0x0040c581

00405a5c <inv_icm20948_set_secondary>:
*  @param[in]  MPU state varible
*  @return     0 if successful.
*/

int inv_icm20948_set_secondary(struct inv_icm20948 * s)
{
  405a5c:	b580      	push	{r7, lr}
  405a5e:	b084      	sub	sp, #16
  405a60:	af00      	add	r7, sp, #0
  405a62:	6078      	str	r0, [r7, #4]
	int r = 0;
  405a64:	2300      	movs	r3, #0
  405a66:	60fb      	str	r3, [r7, #12]
	static uint8_t lIsInited = 0;

	if(lIsInited == 0) {
  405a68:	4b0e      	ldr	r3, [pc, #56]	; (405aa4 <inv_icm20948_set_secondary+0x48>)
  405a6a:	781b      	ldrb	r3, [r3, #0]
  405a6c:	2b00      	cmp	r3, #0
  405a6e:	d113      	bne.n	405a98 <inv_icm20948_set_secondary+0x3c>
		r  = inv_icm20948_write_single_mems_reg(s, REG_I2C_MST_CTRL, BIT_I2C_MST_P_NSR);
  405a70:	2210      	movs	r2, #16
  405a72:	f240 1181 	movw	r1, #385	; 0x181
  405a76:	6878      	ldr	r0, [r7, #4]
  405a78:	4b0b      	ldr	r3, [pc, #44]	; (405aa8 <inv_icm20948_set_secondary+0x4c>)
  405a7a:	4798      	blx	r3
  405a7c:	60f8      	str	r0, [r7, #12]
		r |= inv_icm20948_write_single_mems_reg(s, REG_I2C_MST_ODR_CONFIG, MIN_MST_ODR_CONFIG);
  405a7e:	2204      	movs	r2, #4
  405a80:	f44f 71c0 	mov.w	r1, #384	; 0x180
  405a84:	6878      	ldr	r0, [r7, #4]
  405a86:	4b08      	ldr	r3, [pc, #32]	; (405aa8 <inv_icm20948_set_secondary+0x4c>)
  405a88:	4798      	blx	r3
  405a8a:	4602      	mov	r2, r0
  405a8c:	68fb      	ldr	r3, [r7, #12]
  405a8e:	4313      	orrs	r3, r2
  405a90:	60fb      	str	r3, [r7, #12]

		lIsInited = 1;
  405a92:	4b04      	ldr	r3, [pc, #16]	; (405aa4 <inv_icm20948_set_secondary+0x48>)
  405a94:	2201      	movs	r2, #1
  405a96:	701a      	strb	r2, [r3, #0]
	}
	return r;
  405a98:	68fb      	ldr	r3, [r7, #12]
}
  405a9a:	4618      	mov	r0, r3
  405a9c:	3710      	adds	r7, #16
  405a9e:	46bd      	mov	sp, r7
  405aa0:	bd80      	pop	{r7, pc}
  405aa2:	bf00      	nop
  405aa4:	20001434 	.word	0x20001434
  405aa8:	0040c689 	.word	0x0040c689

00405aac <inv_icm20948_enter_duty_cycle_mode>:

int inv_icm20948_enter_duty_cycle_mode(struct inv_icm20948 * s)
{
  405aac:	b590      	push	{r4, r7, lr}
  405aae:	b085      	sub	sp, #20
  405ab0:	af00      	add	r7, sp, #0
  405ab2:	6078      	str	r0, [r7, #4]
	/* secondary cycle mode should be set all the time */
	unsigned char data  = BIT_I2C_MST_CYCLE|BIT_ACCEL_CYCLE|BIT_GYRO_CYCLE;
  405ab4:	2370      	movs	r3, #112	; 0x70
  405ab6:	73fb      	strb	r3, [r7, #15]

	s->base_state.chip_lp_ln_mode = CHIP_LOW_POWER_ICM20948;
  405ab8:	687b      	ldr	r3, [r7, #4]
  405aba:	2201      	movs	r2, #1
  405abc:	765a      	strb	r2, [r3, #25]
	return inv_icm20948_write_mems_reg(s, REG_LP_CONFIG, 1, &data);
  405abe:	f107 030f 	add.w	r3, r7, #15
  405ac2:	2201      	movs	r2, #1
  405ac4:	2105      	movs	r1, #5
  405ac6:	6878      	ldr	r0, [r7, #4]
  405ac8:	4c03      	ldr	r4, [pc, #12]	; (405ad8 <inv_icm20948_enter_duty_cycle_mode+0x2c>)
  405aca:	47a0      	blx	r4
  405acc:	4603      	mov	r3, r0
}
  405ace:	4618      	mov	r0, r3
  405ad0:	3714      	adds	r7, #20
  405ad2:	46bd      	mov	sp, r7
  405ad4:	bd90      	pop	{r4, r7, pc}
  405ad6:	bf00      	nop
  405ad8:	0040c581 	.word	0x0040c581

00405adc <inv_icm20948_enter_low_noise_mode>:

int inv_icm20948_enter_low_noise_mode(struct inv_icm20948 * s)
{
  405adc:	b590      	push	{r4, r7, lr}
  405ade:	b085      	sub	sp, #20
  405ae0:	af00      	add	r7, sp, #0
  405ae2:	6078      	str	r0, [r7, #4]
	/* secondary cycle mode should be set all the time */
	unsigned char data  = BIT_I2C_MST_CYCLE;
  405ae4:	2340      	movs	r3, #64	; 0x40
  405ae6:	73fb      	strb	r3, [r7, #15]

	s->base_state.chip_lp_ln_mode = CHIP_LOW_NOISE_ICM20948;
  405ae8:	687b      	ldr	r3, [r7, #4]
  405aea:	2200      	movs	r2, #0
  405aec:	765a      	strb	r2, [r3, #25]
	return inv_icm20948_write_mems_reg(s, REG_LP_CONFIG, 1, &data);
  405aee:	f107 030f 	add.w	r3, r7, #15
  405af2:	2201      	movs	r2, #1
  405af4:	2105      	movs	r1, #5
  405af6:	6878      	ldr	r0, [r7, #4]
  405af8:	4c03      	ldr	r4, [pc, #12]	; (405b08 <inv_icm20948_enter_low_noise_mode+0x2c>)
  405afa:	47a0      	blx	r4
  405afc:	4603      	mov	r3, r0
}
  405afe:	4618      	mov	r0, r3
  405b00:	3714      	adds	r7, #20
  405b02:	46bd      	mov	sp, r7
  405b04:	bd90      	pop	{r4, r7, pc}
  405b06:	bf00      	nop
  405b08:	0040c581 	.word	0x0040c581

00405b0c <inv_icm20948_initialize_lower_driver>:
/** Should be called once on power up. Loads DMP3, initializes internal variables needed 
*   for other lower driver functions.
*/
int inv_icm20948_initialize_lower_driver(struct inv_icm20948 * s, enum SMARTSENSOR_SERIAL_INTERFACE type, 
	const uint8_t *dmp3_image, uint32_t dmp3_image_size)
{
  405b0c:	b590      	push	{r4, r7, lr}
  405b0e:	b087      	sub	sp, #28
  405b10:	af00      	add	r7, sp, #0
  405b12:	60f8      	str	r0, [r7, #12]
  405b14:	607a      	str	r2, [r7, #4]
  405b16:	603b      	str	r3, [r7, #0]
  405b18:	460b      	mov	r3, r1
  405b1a:	72fb      	strb	r3, [r7, #11]
	int result = 0;
  405b1c:	2300      	movs	r3, #0
  405b1e:	617b      	str	r3, [r7, #20]
	static unsigned char data;
	// set static variable
	s->sAllowLpEn = 1;
  405b20:	68fb      	ldr	r3, [r7, #12]
  405b22:	2201      	movs	r2, #1
  405b24:	f883 20b8 	strb.w	r2, [r3, #184]	; 0xb8
	s->s_compass_available = 0;
  405b28:	68fb      	ldr	r3, [r7, #12]
  405b2a:	2200      	movs	r2, #0
  405b2c:	f883 20b9 	strb.w	r2, [r3, #185]	; 0xb9
	// ICM20948 do not support the proximity sensor for the moment.
	// s_proximity_available variable is nerver changes
	s->s_proximity_available = 0;
  405b30:	68fb      	ldr	r3, [r7, #12]
  405b32:	2200      	movs	r2, #0
  405b34:	f883 20ba 	strb.w	r2, [r3, #186]	; 0xba

	// Set varialbes to default values
	memset(&s->base_state, 0, sizeof(s->base_state));
  405b38:	68fb      	ldr	r3, [r7, #12]
  405b3a:	3318      	adds	r3, #24
  405b3c:	2212      	movs	r2, #18
  405b3e:	2100      	movs	r1, #0
  405b40:	4618      	mov	r0, r3
  405b42:	4b8a      	ldr	r3, [pc, #552]	; (405d6c <inv_icm20948_initialize_lower_driver+0x260>)
  405b44:	4798      	blx	r3
	s->base_state.pwr_mgmt_1 = BIT_CLK_PLL;
  405b46:	68fb      	ldr	r3, [r7, #12]
  405b48:	2201      	movs	r2, #1
  405b4a:	769a      	strb	r2, [r3, #26]
	s->base_state.pwr_mgmt_2 = BIT_PWR_ACCEL_STBY | BIT_PWR_GYRO_STBY | BIT_PWR_PRESSURE_STBY;
  405b4c:	68fb      	ldr	r3, [r7, #12]
  405b4e:	227f      	movs	r2, #127	; 0x7f
  405b50:	76da      	strb	r2, [r3, #27]
	s->base_state.serial_interface = type;
  405b52:	68fb      	ldr	r3, [r7, #12]
  405b54:	7afa      	ldrb	r2, [r7, #11]
  405b56:	f883 2027 	strb.w	r2, [r3, #39]	; 0x27
	result |= inv_icm20948_read_mems_reg(s, REG_USER_CTRL, 1, &s->base_state.user_ctrl);
  405b5a:	68fb      	ldr	r3, [r7, #12]
  405b5c:	331c      	adds	r3, #28
  405b5e:	2201      	movs	r2, #1
  405b60:	2103      	movs	r1, #3
  405b62:	68f8      	ldr	r0, [r7, #12]
  405b64:	4c82      	ldr	r4, [pc, #520]	; (405d70 <inv_icm20948_initialize_lower_driver+0x264>)
  405b66:	47a0      	blx	r4
  405b68:	4602      	mov	r2, r0
  405b6a:	697b      	ldr	r3, [r7, #20]
  405b6c:	4313      	orrs	r3, r2
  405b6e:	617b      	str	r3, [r7, #20]

	result |= inv_icm20948_wakeup_mems(s);
  405b70:	68f8      	ldr	r0, [r7, #12]
  405b72:	4b80      	ldr	r3, [pc, #512]	; (405d74 <inv_icm20948_initialize_lower_driver+0x268>)
  405b74:	4798      	blx	r3
  405b76:	4602      	mov	r2, r0
  405b78:	697b      	ldr	r3, [r7, #20]
  405b7a:	4313      	orrs	r3, r2
  405b7c:	617b      	str	r3, [r7, #20]

	result |= inv_icm20948_read_mems_reg(s, REG_WHO_AM_I, 1, &data);
  405b7e:	4b7e      	ldr	r3, [pc, #504]	; (405d78 <inv_icm20948_initialize_lower_driver+0x26c>)
  405b80:	2201      	movs	r2, #1
  405b82:	2100      	movs	r1, #0
  405b84:	68f8      	ldr	r0, [r7, #12]
  405b86:	4c7a      	ldr	r4, [pc, #488]	; (405d70 <inv_icm20948_initialize_lower_driver+0x264>)
  405b88:	47a0      	blx	r4
  405b8a:	4602      	mov	r2, r0
  405b8c:	697b      	ldr	r3, [r7, #20]
  405b8e:	4313      	orrs	r3, r2
  405b90:	617b      	str	r3, [r7, #20]

	/* secondary cycle mode should be set all the time */
	data = BIT_I2C_MST_CYCLE|BIT_ACCEL_CYCLE|BIT_GYRO_CYCLE;
  405b92:	4b79      	ldr	r3, [pc, #484]	; (405d78 <inv_icm20948_initialize_lower_driver+0x26c>)
  405b94:	2270      	movs	r2, #112	; 0x70
  405b96:	701a      	strb	r2, [r3, #0]

	// Set default mode to low power mode
	result |= inv_icm20948_set_lowpower_or_highperformance(s, 0);
  405b98:	2100      	movs	r1, #0
  405b9a:	68f8      	ldr	r0, [r7, #12]
  405b9c:	4b77      	ldr	r3, [pc, #476]	; (405d7c <inv_icm20948_initialize_lower_driver+0x270>)
  405b9e:	4798      	blx	r3
  405ba0:	4602      	mov	r2, r0
  405ba2:	697b      	ldr	r3, [r7, #20]
  405ba4:	4313      	orrs	r3, r2
  405ba6:	617b      	str	r3, [r7, #20]
	
	// Disable Ivory DMP.
	if(s->base_state.serial_interface == SERIAL_INTERFACE_SPI)   
  405ba8:	68fb      	ldr	r3, [r7, #12]
  405baa:	f893 3027 	ldrb.w	r3, [r3, #39]	; 0x27
  405bae:	2b02      	cmp	r3, #2
  405bb0:	d103      	bne.n	405bba <inv_icm20948_initialize_lower_driver+0xae>
		s->base_state.user_ctrl = BIT_I2C_IF_DIS;
  405bb2:	68fb      	ldr	r3, [r7, #12]
  405bb4:	2210      	movs	r2, #16
  405bb6:	771a      	strb	r2, [r3, #28]
  405bb8:	e002      	b.n	405bc0 <inv_icm20948_initialize_lower_driver+0xb4>
	else
		s->base_state.user_ctrl = 0;
  405bba:	68fb      	ldr	r3, [r7, #12]
  405bbc:	2200      	movs	r2, #0
  405bbe:	771a      	strb	r2, [r3, #28]

	result |= inv_icm20948_write_single_mems_reg(s, REG_USER_CTRL, s->base_state.user_ctrl);
  405bc0:	68fb      	ldr	r3, [r7, #12]
  405bc2:	7f1b      	ldrb	r3, [r3, #28]
  405bc4:	461a      	mov	r2, r3
  405bc6:	2103      	movs	r1, #3
  405bc8:	68f8      	ldr	r0, [r7, #12]
  405bca:	4b6d      	ldr	r3, [pc, #436]	; (405d80 <inv_icm20948_initialize_lower_driver+0x274>)
  405bcc:	4798      	blx	r3
  405bce:	4602      	mov	r2, r0
  405bd0:	697b      	ldr	r3, [r7, #20]
  405bd2:	4313      	orrs	r3, r2
  405bd4:	617b      	str	r3, [r7, #20]

	//Setup Ivory DMP.
	result |= inv_icm20948_load_firmware(s, dmp3_image, dmp3_image_size);
  405bd6:	683a      	ldr	r2, [r7, #0]
  405bd8:	6879      	ldr	r1, [r7, #4]
  405bda:	68f8      	ldr	r0, [r7, #12]
  405bdc:	4b69      	ldr	r3, [pc, #420]	; (405d84 <inv_icm20948_initialize_lower_driver+0x278>)
  405bde:	4798      	blx	r3
  405be0:	4602      	mov	r2, r0
  405be2:	697b      	ldr	r3, [r7, #20]
  405be4:	4313      	orrs	r3, r2
  405be6:	617b      	str	r3, [r7, #20]
	if(result)
  405be8:	697b      	ldr	r3, [r7, #20]
  405bea:	2b00      	cmp	r3, #0
  405bec:	d001      	beq.n	405bf2 <inv_icm20948_initialize_lower_driver+0xe6>
		return result;
  405bee:	697b      	ldr	r3, [r7, #20]
  405bf0:	e0b8      	b.n	405d64 <inv_icm20948_initialize_lower_driver+0x258>
	else
		s->base_state.firmware_loaded = 1;
  405bf2:	68fa      	ldr	r2, [r7, #12]
  405bf4:	f892 3026 	ldrb.w	r3, [r2, #38]	; 0x26
  405bf8:	f043 0302 	orr.w	r3, r3, #2
  405bfc:	f882 3026 	strb.w	r3, [r2, #38]	; 0x26
	result |= inv_icm20948_set_dmp_address(s);
  405c00:	68f8      	ldr	r0, [r7, #12]
  405c02:	4b61      	ldr	r3, [pc, #388]	; (405d88 <inv_icm20948_initialize_lower_driver+0x27c>)
  405c04:	4798      	blx	r3
  405c06:	4602      	mov	r2, r0
  405c08:	697b      	ldr	r3, [r7, #20]
  405c0a:	4313      	orrs	r3, r2
  405c0c:	617b      	str	r3, [r7, #20]
	// Turn off all sensors on DMP by default.
	//result |= dmp_set_data_output_control1(0);   // FIXME in DMP, these should be off by default.
	result |= dmp_icm20948_reset_control_registers(s);
  405c0e:	68f8      	ldr	r0, [r7, #12]
  405c10:	4b5e      	ldr	r3, [pc, #376]	; (405d8c <inv_icm20948_initialize_lower_driver+0x280>)
  405c12:	4798      	blx	r3
  405c14:	4602      	mov	r2, r0
  405c16:	697b      	ldr	r3, [r7, #20]
  405c18:	4313      	orrs	r3, r2
  405c1a:	617b      	str	r3, [r7, #20]
	
	// set FIFO watermark to 80% of actual FIFO size
	result |= dmp_icm20948_set_FIFO_watermark(s, 800);
  405c1c:	f44f 7148 	mov.w	r1, #800	; 0x320
  405c20:	68f8      	ldr	r0, [r7, #12]
  405c22:	4b5b      	ldr	r3, [pc, #364]	; (405d90 <inv_icm20948_initialize_lower_driver+0x284>)
  405c24:	4798      	blx	r3
  405c26:	4602      	mov	r2, r0
  405c28:	697b      	ldr	r3, [r7, #20]
  405c2a:	4313      	orrs	r3, r2
  405c2c:	617b      	str	r3, [r7, #20]

	// Enable Interrupts.
	data = 0x2;
  405c2e:	4b52      	ldr	r3, [pc, #328]	; (405d78 <inv_icm20948_initialize_lower_driver+0x26c>)
  405c30:	2202      	movs	r2, #2
  405c32:	701a      	strb	r2, [r3, #0]
	result |= inv_icm20948_write_mems_reg(s, REG_INT_ENABLE, 1, &data); // Enable DMP Interrupt
  405c34:	4b50      	ldr	r3, [pc, #320]	; (405d78 <inv_icm20948_initialize_lower_driver+0x26c>)
  405c36:	2201      	movs	r2, #1
  405c38:	2110      	movs	r1, #16
  405c3a:	68f8      	ldr	r0, [r7, #12]
  405c3c:	4c55      	ldr	r4, [pc, #340]	; (405d94 <inv_icm20948_initialize_lower_driver+0x288>)
  405c3e:	47a0      	blx	r4
  405c40:	4602      	mov	r2, r0
  405c42:	697b      	ldr	r3, [r7, #20]
  405c44:	4313      	orrs	r3, r2
  405c46:	617b      	str	r3, [r7, #20]
	data = 0x1;
  405c48:	4b4b      	ldr	r3, [pc, #300]	; (405d78 <inv_icm20948_initialize_lower_driver+0x26c>)
  405c4a:	2201      	movs	r2, #1
  405c4c:	701a      	strb	r2, [r3, #0]
	result |= inv_icm20948_write_mems_reg(s, REG_INT_ENABLE_2, 1, &data); // Enable FIFO Overflow Interrupt
  405c4e:	4b4a      	ldr	r3, [pc, #296]	; (405d78 <inv_icm20948_initialize_lower_driver+0x26c>)
  405c50:	2201      	movs	r2, #1
  405c52:	2112      	movs	r1, #18
  405c54:	68f8      	ldr	r0, [r7, #12]
  405c56:	4c4f      	ldr	r4, [pc, #316]	; (405d94 <inv_icm20948_initialize_lower_driver+0x288>)
  405c58:	47a0      	blx	r4
  405c5a:	4602      	mov	r2, r0
  405c5c:	697b      	ldr	r3, [r7, #20]
  405c5e:	4313      	orrs	r3, r2
  405c60:	617b      	str	r3, [r7, #20]

	// TRACKING : To have accelerometers datas and the interrupt without gyro enables.
	data = 0XE4;
  405c62:	4b45      	ldr	r3, [pc, #276]	; (405d78 <inv_icm20948_initialize_lower_driver+0x26c>)
  405c64:	22e4      	movs	r2, #228	; 0xe4
  405c66:	701a      	strb	r2, [r3, #0]
	result |= inv_icm20948_write_mems_reg(s, REG_SINGLE_FIFO_PRIORITY_SEL, 1, &data);
  405c68:	4b43      	ldr	r3, [pc, #268]	; (405d78 <inv_icm20948_initialize_lower_driver+0x26c>)
  405c6a:	2201      	movs	r2, #1
  405c6c:	2126      	movs	r1, #38	; 0x26
  405c6e:	68f8      	ldr	r0, [r7, #12]
  405c70:	4c48      	ldr	r4, [pc, #288]	; (405d94 <inv_icm20948_initialize_lower_driver+0x288>)
  405c72:	47a0      	blx	r4
  405c74:	4602      	mov	r2, r0
  405c76:	697b      	ldr	r3, [r7, #20]
  405c78:	4313      	orrs	r3, r2
  405c7a:	617b      	str	r3, [r7, #20]

	// Disable HW temp fix
	inv_icm20948_read_mems_reg(s, REG_HW_FIX_DISABLE,1,&data);
  405c7c:	4b3e      	ldr	r3, [pc, #248]	; (405d78 <inv_icm20948_initialize_lower_driver+0x26c>)
  405c7e:	2201      	movs	r2, #1
  405c80:	2175      	movs	r1, #117	; 0x75
  405c82:	68f8      	ldr	r0, [r7, #12]
  405c84:	4c3a      	ldr	r4, [pc, #232]	; (405d70 <inv_icm20948_initialize_lower_driver+0x264>)
  405c86:	47a0      	blx	r4
	data |= 0x08;
  405c88:	4b3b      	ldr	r3, [pc, #236]	; (405d78 <inv_icm20948_initialize_lower_driver+0x26c>)
  405c8a:	781b      	ldrb	r3, [r3, #0]
  405c8c:	f043 0308 	orr.w	r3, r3, #8
  405c90:	b2da      	uxtb	r2, r3
  405c92:	4b39      	ldr	r3, [pc, #228]	; (405d78 <inv_icm20948_initialize_lower_driver+0x26c>)
  405c94:	701a      	strb	r2, [r3, #0]
	inv_icm20948_write_mems_reg(s, REG_HW_FIX_DISABLE,1,&data);
  405c96:	4b38      	ldr	r3, [pc, #224]	; (405d78 <inv_icm20948_initialize_lower_driver+0x26c>)
  405c98:	2201      	movs	r2, #1
  405c9a:	2175      	movs	r1, #117	; 0x75
  405c9c:	68f8      	ldr	r0, [r7, #12]
  405c9e:	4c3d      	ldr	r4, [pc, #244]	; (405d94 <inv_icm20948_initialize_lower_driver+0x288>)
  405ca0:	47a0      	blx	r4

	// Setup MEMs properties.
	s->base_state.accel_averaging = 1; //Change this value if higher sensor sample avergaing is required.
  405ca2:	68fb      	ldr	r3, [r7, #12]
  405ca4:	2201      	movs	r2, #1
  405ca6:	f883 2023 	strb.w	r2, [r3, #35]	; 0x23
	s->base_state.gyro_averaging = 1;  //Change this value if higher sensor sample avergaing is required.
  405caa:	68fb      	ldr	r3, [r7, #12]
  405cac:	2201      	movs	r2, #1
  405cae:	f883 2022 	strb.w	r2, [r3, #34]	; 0x22
	inv_icm20948_set_gyro_divider(s, FIFO_DIVIDER);       //Initial sampling rate 1125Hz/19+1 = 56Hz.
  405cb2:	2113      	movs	r1, #19
  405cb4:	68f8      	ldr	r0, [r7, #12]
  405cb6:	4b38      	ldr	r3, [pc, #224]	; (405d98 <inv_icm20948_initialize_lower_driver+0x28c>)
  405cb8:	4798      	blx	r3
	inv_icm20948_set_accel_divider(s, FIFO_DIVIDER);      //Initial sampling rate 1125Hz/19+1 = 56Hz.
  405cba:	2113      	movs	r1, #19
  405cbc:	68f8      	ldr	r0, [r7, #12]
  405cbe:	4b37      	ldr	r3, [pc, #220]	; (405d9c <inv_icm20948_initialize_lower_driver+0x290>)
  405cc0:	4798      	blx	r3

	// Init the sample rate to 56 Hz for BAC,STEPC and B2S
	dmp_icm20948_set_bac_rate(s, DMP_ALGO_FREQ_56);
  405cc2:	2138      	movs	r1, #56	; 0x38
  405cc4:	68f8      	ldr	r0, [r7, #12]
  405cc6:	4b36      	ldr	r3, [pc, #216]	; (405da0 <inv_icm20948_initialize_lower_driver+0x294>)
  405cc8:	4798      	blx	r3
	dmp_icm20948_set_b2s_rate(s, DMP_ALGO_FREQ_56);
  405cca:	2138      	movs	r1, #56	; 0x38
  405ccc:	68f8      	ldr	r0, [r7, #12]
  405cce:	4b35      	ldr	r3, [pc, #212]	; (405da4 <inv_icm20948_initialize_lower_driver+0x298>)
  405cd0:	4798      	blx	r3

	// FIFO Setup.
	result |= inv_icm20948_write_single_mems_reg(s, REG_FIFO_CFG, BIT_SINGLE_FIFO_CFG); // FIFO Config. fixme do once? burst write?
  405cd2:	2200      	movs	r2, #0
  405cd4:	2176      	movs	r1, #118	; 0x76
  405cd6:	68f8      	ldr	r0, [r7, #12]
  405cd8:	4b29      	ldr	r3, [pc, #164]	; (405d80 <inv_icm20948_initialize_lower_driver+0x274>)
  405cda:	4798      	blx	r3
  405cdc:	4602      	mov	r2, r0
  405cde:	697b      	ldr	r3, [r7, #20]
  405ce0:	4313      	orrs	r3, r2
  405ce2:	617b      	str	r3, [r7, #20]
	result |= inv_icm20948_write_single_mems_reg(s, REG_FIFO_RST, 0x1f); // Reset all FIFOs.
  405ce4:	221f      	movs	r2, #31
  405ce6:	2168      	movs	r1, #104	; 0x68
  405ce8:	68f8      	ldr	r0, [r7, #12]
  405cea:	4b25      	ldr	r3, [pc, #148]	; (405d80 <inv_icm20948_initialize_lower_driver+0x274>)
  405cec:	4798      	blx	r3
  405cee:	4602      	mov	r2, r0
  405cf0:	697b      	ldr	r3, [r7, #20]
  405cf2:	4313      	orrs	r3, r2
  405cf4:	617b      	str	r3, [r7, #20]
	result |= inv_icm20948_write_single_mems_reg(s, REG_FIFO_RST, 0x1e); // Keep all but Gyro FIFO in reset.
  405cf6:	221e      	movs	r2, #30
  405cf8:	2168      	movs	r1, #104	; 0x68
  405cfa:	68f8      	ldr	r0, [r7, #12]
  405cfc:	4b20      	ldr	r3, [pc, #128]	; (405d80 <inv_icm20948_initialize_lower_driver+0x274>)
  405cfe:	4798      	blx	r3
  405d00:	4602      	mov	r2, r0
  405d02:	697b      	ldr	r3, [r7, #20]
  405d04:	4313      	orrs	r3, r2
  405d06:	617b      	str	r3, [r7, #20]
	result |= inv_icm20948_write_single_mems_reg(s, REG_FIFO_EN, 0x0); // Slave FIFO turned off.
  405d08:	2200      	movs	r2, #0
  405d0a:	2166      	movs	r1, #102	; 0x66
  405d0c:	68f8      	ldr	r0, [r7, #12]
  405d0e:	4b1c      	ldr	r3, [pc, #112]	; (405d80 <inv_icm20948_initialize_lower_driver+0x274>)
  405d10:	4798      	blx	r3
  405d12:	4602      	mov	r2, r0
  405d14:	697b      	ldr	r3, [r7, #20]
  405d16:	4313      	orrs	r3, r2
  405d18:	617b      	str	r3, [r7, #20]
	result |= inv_icm20948_write_single_mems_reg(s, REG_FIFO_EN_2, 0x0); // Hardware FIFO turned off.
  405d1a:	2200      	movs	r2, #0
  405d1c:	2167      	movs	r1, #103	; 0x67
  405d1e:	68f8      	ldr	r0, [r7, #12]
  405d20:	4b17      	ldr	r3, [pc, #92]	; (405d80 <inv_icm20948_initialize_lower_driver+0x274>)
  405d22:	4798      	blx	r3
  405d24:	4602      	mov	r2, r0
  405d26:	697b      	ldr	r3, [r7, #20]
  405d28:	4313      	orrs	r3, r2
  405d2a:	617b      	str	r3, [r7, #20]
    
	s->base_state.lp_en_support = 1;
  405d2c:	68fa      	ldr	r2, [r7, #12]
  405d2e:	f892 3026 	ldrb.w	r3, [r2, #38]	; 0x26
  405d32:	f043 0301 	orr.w	r3, r3, #1
  405d36:	f882 3026 	strb.w	r3, [r2, #38]	; 0x26
	
	if(s->base_state.lp_en_support == 1)
  405d3a:	68fb      	ldr	r3, [r7, #12]
  405d3c:	f893 3026 	ldrb.w	r3, [r3, #38]	; 0x26
  405d40:	f003 0301 	and.w	r3, r3, #1
  405d44:	b2db      	uxtb	r3, r3
  405d46:	2b00      	cmp	r3, #0
  405d48:	d004      	beq.n	405d54 <inv_icm20948_initialize_lower_driver+0x248>
		inv_icm20948_set_chip_power_state(s, CHIP_LP_ENABLE, 1);
  405d4a:	2201      	movs	r2, #1
  405d4c:	2102      	movs	r1, #2
  405d4e:	68f8      	ldr	r0, [r7, #12]
  405d50:	4b15      	ldr	r3, [pc, #84]	; (405da8 <inv_icm20948_initialize_lower_driver+0x29c>)
  405d52:	4798      	blx	r3

	result |= inv_icm20948_sleep_mems(s);   
  405d54:	68f8      	ldr	r0, [r7, #12]
  405d56:	4b15      	ldr	r3, [pc, #84]	; (405dac <inv_icm20948_initialize_lower_driver+0x2a0>)
  405d58:	4798      	blx	r3
  405d5a:	4602      	mov	r2, r0
  405d5c:	697b      	ldr	r3, [r7, #20]
  405d5e:	4313      	orrs	r3, r2
  405d60:	617b      	str	r3, [r7, #20]
        
	return result;
  405d62:	697b      	ldr	r3, [r7, #20]
}
  405d64:	4618      	mov	r0, r3
  405d66:	371c      	adds	r7, #28
  405d68:	46bd      	mov	sp, r7
  405d6a:	bd90      	pop	{r4, r7, pc}
  405d6c:	00414241 	.word	0x00414241
  405d70:	0040c755 	.word	0x0040c755
  405d74:	0040591d 	.word	0x0040591d
  405d78:	20001435 	.word	0x20001435
  405d7c:	0040a9c9 	.word	0x0040a9c9
  405d80:	0040c689 	.word	0x0040c689
  405d84:	00407bf1 	.word	0x00407bf1
  405d88:	00405a11 	.word	0x00405a11
  405d8c:	00407cad 	.word	0x00407cad
  405d90:	00407d81 	.word	0x00407d81
  405d94:	0040c581 	.word	0x0040c581
  405d98:	00405e8d 	.word	0x00405e8d
  405d9c:	00405f0d 	.word	0x00405f0d
  405da0:	0040856d 	.word	0x0040856d
  405da4:	00408601 	.word	0x00408601
  405da8:	004057a5 	.word	0x004057a5
  405dac:	004059d1 	.word	0x004059d1

00405db0 <activate_compass>:

static void activate_compass(struct inv_icm20948 * s)
{
  405db0:	b480      	push	{r7}
  405db2:	b083      	sub	sp, #12
  405db4:	af00      	add	r7, sp, #0
  405db6:	6078      	str	r0, [r7, #4]
	s->s_compass_available = 1;
  405db8:	687b      	ldr	r3, [r7, #4]
  405dba:	2201      	movs	r2, #1
  405dbc:	f883 20b9 	strb.w	r2, [r3, #185]	; 0xb9
}
  405dc0:	bf00      	nop
  405dc2:	370c      	adds	r7, #12
  405dc4:	46bd      	mov	sp, r7
  405dc6:	f85d 7b04 	ldr.w	r7, [sp], #4
  405dca:	4770      	bx	lr

00405dcc <desactivate_compass>:

static void desactivate_compass(struct inv_icm20948 * s)
{
  405dcc:	b480      	push	{r7}
  405dce:	b083      	sub	sp, #12
  405dd0:	af00      	add	r7, sp, #0
  405dd2:	6078      	str	r0, [r7, #4]
	s->s_compass_available = 0;
  405dd4:	687b      	ldr	r3, [r7, #4]
  405dd6:	2200      	movs	r2, #0
  405dd8:	f883 20b9 	strb.w	r2, [r3, #185]	; 0xb9
}
  405ddc:	bf00      	nop
  405dde:	370c      	adds	r7, #12
  405de0:	46bd      	mov	sp, r7
  405de2:	f85d 7b04 	ldr.w	r7, [sp], #4
  405de6:	4770      	bx	lr

00405de8 <inv_icm20948_get_compass_availability>:

int inv_icm20948_get_compass_availability(struct inv_icm20948 * s)
{
  405de8:	b480      	push	{r7}
  405dea:	b083      	sub	sp, #12
  405dec:	af00      	add	r7, sp, #0
  405dee:	6078      	str	r0, [r7, #4]
	return s->s_compass_available;
  405df0:	687b      	ldr	r3, [r7, #4]
  405df2:	f893 30b9 	ldrb.w	r3, [r3, #185]	; 0xb9
}
  405df6:	4618      	mov	r0, r3
  405df8:	370c      	adds	r7, #12
  405dfa:	46bd      	mov	sp, r7
  405dfc:	f85d 7b04 	ldr.w	r7, [sp], #4
  405e00:	4770      	bx	lr
	...

00405e04 <inv_icm20948_set_slave_compass_id>:
{
	return s->s_proximity_available;
}

int inv_icm20948_set_slave_compass_id(struct inv_icm20948 * s, int id)
{
  405e04:	b580      	push	{r7, lr}
  405e06:	b084      	sub	sp, #16
  405e08:	af00      	add	r7, sp, #0
  405e0a:	6078      	str	r0, [r7, #4]
  405e0c:	6039      	str	r1, [r7, #0]
	int result = 0;
  405e0e:	2300      	movs	r3, #0
  405e10:	60fb      	str	r3, [r7, #12]

	//result = inv_icm20948_wakeup_mems(s);
	//if (result)
	//	return result;
		
	inv_icm20948_prevent_lpen_control(s);
  405e12:	6878      	ldr	r0, [r7, #4]
  405e14:	4b15      	ldr	r3, [pc, #84]	; (405e6c <inv_icm20948_set_slave_compass_id+0x68>)
  405e16:	4798      	blx	r3
	activate_compass(s);
  405e18:	6878      	ldr	r0, [r7, #4]
  405e1a:	4b15      	ldr	r3, [pc, #84]	; (405e70 <inv_icm20948_set_slave_compass_id+0x6c>)
  405e1c:	4798      	blx	r3
	
	inv_icm20948_init_secondary(s);
  405e1e:	6878      	ldr	r0, [r7, #4]
  405e20:	4b14      	ldr	r3, [pc, #80]	; (405e74 <inv_icm20948_set_slave_compass_id+0x70>)
  405e22:	4798      	blx	r3

	// Set up the secondary I2C bus on 20630.
	inv_icm20948_set_secondary(s);
  405e24:	6878      	ldr	r0, [r7, #4]
  405e26:	4b14      	ldr	r3, [pc, #80]	; (405e78 <inv_icm20948_set_slave_compass_id+0x74>)
  405e28:	4798      	blx	r3

	//Setup Compass
	result = inv_icm20948_setup_compass_akm(s);
  405e2a:	6878      	ldr	r0, [r7, #4]
  405e2c:	4b13      	ldr	r3, [pc, #76]	; (405e7c <inv_icm20948_set_slave_compass_id+0x78>)
  405e2e:	4798      	blx	r3
  405e30:	60f8      	str	r0, [r7, #12]

	//Setup Compass mounting matrix into DMP
	result |= inv_icm20948_compass_dmp_cal(s, s->mounting_matrix, s->mounting_matrix_secondary_compass);
  405e32:	687b      	ldr	r3, [r7, #4]
  405e34:	f503 711d 	add.w	r1, r3, #628	; 0x274
  405e38:	687b      	ldr	r3, [r7, #4]
  405e3a:	f203 237d 	addw	r3, r3, #637	; 0x27d
  405e3e:	461a      	mov	r2, r3
  405e40:	6878      	ldr	r0, [r7, #4]
  405e42:	4b0f      	ldr	r3, [pc, #60]	; (405e80 <inv_icm20948_set_slave_compass_id+0x7c>)
  405e44:	4798      	blx	r3
  405e46:	4602      	mov	r2, r0
  405e48:	68fb      	ldr	r3, [r7, #12]
  405e4a:	4313      	orrs	r3, r2
  405e4c:	60fb      	str	r3, [r7, #12]
	
	if (result)
  405e4e:	68fb      	ldr	r3, [r7, #12]
  405e50:	2b00      	cmp	r3, #0
  405e52:	d002      	beq.n	405e5a <inv_icm20948_set_slave_compass_id+0x56>
		desactivate_compass(s);
  405e54:	6878      	ldr	r0, [r7, #4]
  405e56:	4b0b      	ldr	r3, [pc, #44]	; (405e84 <inv_icm20948_set_slave_compass_id+0x80>)
  405e58:	4798      	blx	r3

	//result = inv_icm20948_sleep_mems(s);
	inv_icm20948_allow_lpen_control(s);
  405e5a:	6878      	ldr	r0, [r7, #4]
  405e5c:	4b0a      	ldr	r3, [pc, #40]	; (405e88 <inv_icm20948_set_slave_compass_id+0x84>)
  405e5e:	4798      	blx	r3
	return result;
  405e60:	68fb      	ldr	r3, [r7, #12]
}
  405e62:	4618      	mov	r0, r3
  405e64:	3710      	adds	r7, #16
  405e66:	46bd      	mov	sp, r7
  405e68:	bd80      	pop	{r7, pc}
  405e6a:	bf00      	nop
  405e6c:	00405745 	.word	0x00405745
  405e70:	00405db1 	.word	0x00405db1
  405e74:	00405315 	.word	0x00405315
  405e78:	00405a5d 	.word	0x00405a5d
  405e7c:	004049f5 	.word	0x004049f5
  405e80:	00404f49 	.word	0x00404f49
  405e84:	00405dcd 	.word	0x00405dcd
  405e88:	00405761 	.word	0x00405761

00405e8c <inv_icm20948_set_gyro_divider>:

int inv_icm20948_set_gyro_divider(struct inv_icm20948 * s, unsigned char div)
{
  405e8c:	b590      	push	{r4, r7, lr}
  405e8e:	b083      	sub	sp, #12
  405e90:	af00      	add	r7, sp, #0
  405e92:	6078      	str	r0, [r7, #4]
  405e94:	460b      	mov	r3, r1
  405e96:	70fb      	strb	r3, [r7, #3]
	s->base_state.gyro_div = div;
  405e98:	78fa      	ldrb	r2, [r7, #3]
  405e9a:	687b      	ldr	r3, [r7, #4]
  405e9c:	775a      	strb	r2, [r3, #29]
	return inv_icm20948_write_mems_reg(s, REG_GYRO_SMPLRT_DIV, 1, &div);
  405e9e:	1cfb      	adds	r3, r7, #3
  405ea0:	2201      	movs	r2, #1
  405ea2:	f44f 7180 	mov.w	r1, #256	; 0x100
  405ea6:	6878      	ldr	r0, [r7, #4]
  405ea8:	4c03      	ldr	r4, [pc, #12]	; (405eb8 <inv_icm20948_set_gyro_divider+0x2c>)
  405eaa:	47a0      	blx	r4
  405eac:	4603      	mov	r3, r0
}
  405eae:	4618      	mov	r0, r3
  405eb0:	370c      	adds	r7, #12
  405eb2:	46bd      	mov	sp, r7
  405eb4:	bd90      	pop	{r4, r7, pc}
  405eb6:	bf00      	nop
  405eb8:	0040c581 	.word	0x0040c581

00405ebc <inv_icm20948_get_gyro_divider>:

unsigned char inv_icm20948_get_gyro_divider(struct inv_icm20948 * s)
{
  405ebc:	b480      	push	{r7}
  405ebe:	b083      	sub	sp, #12
  405ec0:	af00      	add	r7, sp, #0
  405ec2:	6078      	str	r0, [r7, #4]
	return s->base_state.gyro_div;
  405ec4:	687b      	ldr	r3, [r7, #4]
  405ec6:	7f5b      	ldrb	r3, [r3, #29]
}
  405ec8:	4618      	mov	r0, r3
  405eca:	370c      	adds	r7, #12
  405ecc:	46bd      	mov	sp, r7
  405ece:	f85d 7b04 	ldr.w	r7, [sp], #4
  405ed2:	4770      	bx	lr

00405ed4 <inv_icm20948_set_secondary_divider>:

int inv_icm20948_set_secondary_divider(struct inv_icm20948 * s, unsigned char div)
{
  405ed4:	b580      	push	{r7, lr}
  405ed6:	b082      	sub	sp, #8
  405ed8:	af00      	add	r7, sp, #0
  405eda:	6078      	str	r0, [r7, #4]
  405edc:	460b      	mov	r3, r1
  405ede:	70fb      	strb	r3, [r7, #3]
	s->base_state.secondary_div = 1UL<<div;
  405ee0:	78fb      	ldrb	r3, [r7, #3]
  405ee2:	2201      	movs	r2, #1
  405ee4:	fa02 f303 	lsl.w	r3, r2, r3
  405ee8:	b29a      	uxth	r2, r3
  405eea:	687b      	ldr	r3, [r7, #4]
  405eec:	83da      	strh	r2, [r3, #30]
	return inv_icm20948_write_single_mems_reg(s, REG_I2C_MST_ODR_CONFIG, div);
  405eee:	78fb      	ldrb	r3, [r7, #3]
  405ef0:	461a      	mov	r2, r3
  405ef2:	f44f 71c0 	mov.w	r1, #384	; 0x180
  405ef6:	6878      	ldr	r0, [r7, #4]
  405ef8:	4b03      	ldr	r3, [pc, #12]	; (405f08 <inv_icm20948_set_secondary_divider+0x34>)
  405efa:	4798      	blx	r3
  405efc:	4603      	mov	r3, r0
}
  405efe:	4618      	mov	r0, r3
  405f00:	3708      	adds	r7, #8
  405f02:	46bd      	mov	sp, r7
  405f04:	bd80      	pop	{r7, pc}
  405f06:	bf00      	nop
  405f08:	0040c689 	.word	0x0040c689

00405f0c <inv_icm20948_set_accel_divider>:
{
	return s->base_state.secondary_div;
}

int inv_icm20948_set_accel_divider(struct inv_icm20948 * s, short div)
{
  405f0c:	b590      	push	{r4, r7, lr}
  405f0e:	b085      	sub	sp, #20
  405f10:	af00      	add	r7, sp, #0
  405f12:	6078      	str	r0, [r7, #4]
  405f14:	460b      	mov	r3, r1
  405f16:	807b      	strh	r3, [r7, #2]
	unsigned char data[2] = {0};
  405f18:	2300      	movs	r3, #0
  405f1a:	81bb      	strh	r3, [r7, #12]

	s->base_state.accel_div = div;
  405f1c:	687b      	ldr	r3, [r7, #4]
  405f1e:	887a      	ldrh	r2, [r7, #2]
  405f20:	841a      	strh	r2, [r3, #32]
	data[0] = (unsigned char)(div >> 8);
  405f22:	f9b7 3002 	ldrsh.w	r3, [r7, #2]
  405f26:	121b      	asrs	r3, r3, #8
  405f28:	b21b      	sxth	r3, r3
  405f2a:	b2db      	uxtb	r3, r3
  405f2c:	733b      	strb	r3, [r7, #12]
	data[1] = (unsigned char)(div & 0xff);
  405f2e:	887b      	ldrh	r3, [r7, #2]
  405f30:	b2db      	uxtb	r3, r3
  405f32:	737b      	strb	r3, [r7, #13]

	return inv_icm20948_write_mems_reg(s, REG_ACCEL_SMPLRT_DIV_1, 2, data);
  405f34:	f107 030c 	add.w	r3, r7, #12
  405f38:	2202      	movs	r2, #2
  405f3a:	f44f 7188 	mov.w	r1, #272	; 0x110
  405f3e:	6878      	ldr	r0, [r7, #4]
  405f40:	4c03      	ldr	r4, [pc, #12]	; (405f50 <inv_icm20948_set_accel_divider+0x44>)
  405f42:	47a0      	blx	r4
  405f44:	4603      	mov	r3, r0
}
  405f46:	4618      	mov	r0, r3
  405f48:	3714      	adds	r7, #20
  405f4a:	46bd      	mov	sp, r7
  405f4c:	bd90      	pop	{r4, r7, pc}
  405f4e:	bf00      	nop
  405f50:	0040c581 	.word	0x0040c581
  405f54:	00000000 	.word	0x00000000

00405f58 <inv_icm20948_set_gyro_sf>:
*            0=1125Hz sample rate, 1=562.5Hz sample rate, ... 4=225Hz sample rate, ...
*            10=102.2727Hz sample rate, ... etc.
* @param[in] gyro_level 0=250 dps, 1=500 dps, 2=1000 dps, 3=2000 dps
*/
int inv_icm20948_set_gyro_sf(struct inv_icm20948 * s, unsigned char div, int gyro_level)
{
  405f58:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
  405f5c:	b08d      	sub	sp, #52	; 0x34
  405f5e:	af00      	add	r7, sp, #0
  405f60:	60f8      	str	r0, [r7, #12]
  405f62:	460b      	mov	r3, r1
  405f64:	607a      	str	r2, [r7, #4]
  405f66:	72fb      	strb	r3, [r7, #11]
	long gyro_sf;
	static long lLastGyroSf = 0;
	int result = 0;
  405f68:	2300      	movs	r3, #0
  405f6a:	62bb      	str	r3, [r7, #40]	; 0x28

	// gyro_level should be set to 4 regardless of fullscale, due to the addition of API dmp_icm20648_set_gyro_fsr()
	gyro_level = 4;
  405f6c:	2304      	movs	r3, #4
  405f6e:	607b      	str	r3, [r7, #4]

	if(s->base_state.timebase_correction_pll == 0)
  405f70:	68fb      	ldr	r3, [r7, #12]
  405f72:	f893 3028 	ldrb.w	r3, [r3, #40]	; 0x28
  405f76:	2b00      	cmp	r3, #0
  405f78:	d10a      	bne.n	405f90 <inv_icm20948_set_gyro_sf+0x38>
		result |= inv_icm20948_read_mems_reg(s, REG_TIMEBASE_CORRECTION_PLL, 1, &s->base_state.timebase_correction_pll);
  405f7a:	68fb      	ldr	r3, [r7, #12]
  405f7c:	3328      	adds	r3, #40	; 0x28
  405f7e:	2201      	movs	r2, #1
  405f80:	21a8      	movs	r1, #168	; 0xa8
  405f82:	68f8      	ldr	r0, [r7, #12]
  405f84:	4e58      	ldr	r6, [pc, #352]	; (4060e8 <inv_icm20948_set_gyro_sf+0x190>)
  405f86:	47b0      	blx	r6
  405f88:	4602      	mov	r2, r0
  405f8a:	6abb      	ldr	r3, [r7, #40]	; 0x28
  405f8c:	4313      	orrs	r3, r2
  405f8e:	62bb      	str	r3, [r7, #40]	; 0x28

	{
		unsigned long long const MagicConstant = 264446880937391LL;
  405f90:	a353      	add	r3, pc, #332	; (adr r3, 4060e0 <inv_icm20948_set_gyro_sf+0x188>)
  405f92:	e9d3 2300 	ldrd	r2, r3, [r3]
  405f96:	e9c7 2306 	strd	r2, r3, [r7, #24]
		unsigned long long const MagicConstantScale = 100000LL;
  405f9a:	4a54      	ldr	r2, [pc, #336]	; (4060ec <inv_icm20948_set_gyro_sf+0x194>)
  405f9c:	f04f 0300 	mov.w	r3, #0
  405fa0:	e9c7 2304 	strd	r2, r3, [r7, #16]
		unsigned long long ResultLL;

		if (s->base_state.timebase_correction_pll & 0x80) {
  405fa4:	68fb      	ldr	r3, [r7, #12]
  405fa6:	f893 3028 	ldrb.w	r3, [r3, #40]	; 0x28
  405faa:	b25b      	sxtb	r3, r3
  405fac:	2b00      	cmp	r3, #0
  405fae:	da3a      	bge.n	406026 <inv_icm20948_set_gyro_sf+0xce>
			ResultLL = (MagicConstant * (long long)(1ULL << gyro_level) * (1 + div) / (1270 - (s->base_state.timebase_correction_pll & 0x7F)) / MagicConstantScale);
  405fb0:	e9d7 3406 	ldrd	r3, r4, [r7, #24]
  405fb4:	687a      	ldr	r2, [r7, #4]
  405fb6:	f1a2 0020 	sub.w	r0, r2, #32
  405fba:	f1c2 0120 	rsb	r1, r2, #32
  405fbe:	fa04 f902 	lsl.w	r9, r4, r2
  405fc2:	fa03 f000 	lsl.w	r0, r3, r0
  405fc6:	ea49 0900 	orr.w	r9, r9, r0
  405fca:	fa23 f101 	lsr.w	r1, r3, r1
  405fce:	ea49 0901 	orr.w	r9, r9, r1
  405fd2:	fa03 f802 	lsl.w	r8, r3, r2
  405fd6:	7afb      	ldrb	r3, [r7, #11]
  405fd8:	3301      	adds	r3, #1
  405fda:	ea4f 74e3 	mov.w	r4, r3, asr #31
  405fde:	fb03 f109 	mul.w	r1, r3, r9
  405fe2:	fb08 f204 	mul.w	r2, r8, r4
  405fe6:	440a      	add	r2, r1
  405fe8:	fba8 0103 	umull	r0, r1, r8, r3
  405fec:	1853      	adds	r3, r2, r1
  405fee:	4619      	mov	r1, r3
  405ff0:	68fb      	ldr	r3, [r7, #12]
  405ff2:	f893 3028 	ldrb.w	r3, [r3, #40]	; 0x28
  405ff6:	f003 037f 	and.w	r3, r3, #127	; 0x7f
  405ffa:	f5c3 639e 	rsb	r3, r3, #1264	; 0x4f0
  405ffe:	3306      	adds	r3, #6
  406000:	ea4f 74e3 	mov.w	r4, r3, asr #31
  406004:	4d3a      	ldr	r5, [pc, #232]	; (4060f0 <inv_icm20948_set_gyro_sf+0x198>)
  406006:	461a      	mov	r2, r3
  406008:	4623      	mov	r3, r4
  40600a:	47a8      	blx	r5
  40600c:	4603      	mov	r3, r0
  40600e:	460c      	mov	r4, r1
  406010:	4618      	mov	r0, r3
  406012:	4621      	mov	r1, r4
  406014:	4c36      	ldr	r4, [pc, #216]	; (4060f0 <inv_icm20948_set_gyro_sf+0x198>)
  406016:	e9d7 2304 	ldrd	r2, r3, [r7, #16]
  40601a:	47a0      	blx	r4
  40601c:	4603      	mov	r3, r0
  40601e:	460c      	mov	r4, r1
  406020:	e9c7 3408 	strd	r3, r4, [r7, #32]
  406024:	e035      	b.n	406092 <inv_icm20948_set_gyro_sf+0x13a>
		}
		else {
			ResultLL = (MagicConstant * (long long)(1ULL << gyro_level) * (1 + div) / (1270 + s->base_state.timebase_correction_pll) / MagicConstantScale);
  406026:	e9d7 2306 	ldrd	r2, r3, [r7, #24]
  40602a:	6879      	ldr	r1, [r7, #4]
  40602c:	f1a1 0620 	sub.w	r6, r1, #32
  406030:	f1c1 0020 	rsb	r0, r1, #32
  406034:	fa03 f501 	lsl.w	r5, r3, r1
  406038:	fa02 f606 	lsl.w	r6, r2, r6
  40603c:	4335      	orrs	r5, r6
  40603e:	fa22 f000 	lsr.w	r0, r2, r0
  406042:	4305      	orrs	r5, r0
  406044:	fa02 f401 	lsl.w	r4, r2, r1
  406048:	7afb      	ldrb	r3, [r7, #11]
  40604a:	3301      	adds	r3, #1
  40604c:	461a      	mov	r2, r3
  40604e:	ea4f 73e2 	mov.w	r3, r2, asr #31
  406052:	fb02 f005 	mul.w	r0, r2, r5
  406056:	fb04 f103 	mul.w	r1, r4, r3
  40605a:	1846      	adds	r6, r0, r1
  40605c:	fba4 0102 	umull	r0, r1, r4, r2
  406060:	1873      	adds	r3, r6, r1
  406062:	4619      	mov	r1, r3
  406064:	68fb      	ldr	r3, [r7, #12]
  406066:	f893 3028 	ldrb.w	r3, [r3, #40]	; 0x28
  40606a:	f203 43f6 	addw	r3, r3, #1270	; 0x4f6
  40606e:	ea4f 74e3 	mov.w	r4, r3, asr #31
  406072:	4d1f      	ldr	r5, [pc, #124]	; (4060f0 <inv_icm20948_set_gyro_sf+0x198>)
  406074:	461a      	mov	r2, r3
  406076:	4623      	mov	r3, r4
  406078:	47a8      	blx	r5
  40607a:	4603      	mov	r3, r0
  40607c:	460c      	mov	r4, r1
  40607e:	4618      	mov	r0, r3
  406080:	4621      	mov	r1, r4
  406082:	4c1b      	ldr	r4, [pc, #108]	; (4060f0 <inv_icm20948_set_gyro_sf+0x198>)
  406084:	e9d7 2304 	ldrd	r2, r3, [r7, #16]
  406088:	47a0      	blx	r4
  40608a:	4603      	mov	r3, r0
  40608c:	460c      	mov	r4, r1
  40608e:	e9c7 3408 	strd	r3, r4, [r7, #32]
		/*
		    In above deprecated FP version, worst case arguments can produce a result that overflows a signed long.
		    Here, for such cases, we emulate the FP behavior of setting the result to the maximum positive value, as
		    the compiler's conversion of a u64 to an s32 is simple truncation of the u64's high half, sadly....
		*/
		if  (ResultLL > 0x7FFFFFFF) 
  406092:	e9d7 3408 	ldrd	r3, r4, [r7, #32]
  406096:	f06f 4100 	mvn.w	r1, #2147483648	; 0x80000000
  40609a:	f04f 0200 	mov.w	r2, #0
  40609e:	42a2      	cmp	r2, r4
  4060a0:	bf08      	it	eq
  4060a2:	4299      	cmpeq	r1, r3
  4060a4:	d203      	bcs.n	4060ae <inv_icm20948_set_gyro_sf+0x156>
			gyro_sf = 0x7FFFFFFF;
  4060a6:	f06f 4300 	mvn.w	r3, #2147483648	; 0x80000000
  4060aa:	62fb      	str	r3, [r7, #44]	; 0x2c
  4060ac:	e001      	b.n	4060b2 <inv_icm20948_set_gyro_sf+0x15a>
		else
			gyro_sf = (long)ResultLL;
  4060ae:	6a3b      	ldr	r3, [r7, #32]
  4060b0:	62fb      	str	r3, [r7, #44]	; 0x2c
	}

	if (gyro_sf != lLastGyroSf) {
  4060b2:	4b10      	ldr	r3, [pc, #64]	; (4060f4 <inv_icm20948_set_gyro_sf+0x19c>)
  4060b4:	681b      	ldr	r3, [r3, #0]
  4060b6:	6afa      	ldr	r2, [r7, #44]	; 0x2c
  4060b8:	429a      	cmp	r2, r3
  4060ba:	d00a      	beq.n	4060d2 <inv_icm20948_set_gyro_sf+0x17a>
		result |= dmp_icm20948_set_gyro_sf(s, gyro_sf);
  4060bc:	6af9      	ldr	r1, [r7, #44]	; 0x2c
  4060be:	68f8      	ldr	r0, [r7, #12]
  4060c0:	4b0d      	ldr	r3, [pc, #52]	; (4060f8 <inv_icm20948_set_gyro_sf+0x1a0>)
  4060c2:	4798      	blx	r3
  4060c4:	4602      	mov	r2, r0
  4060c6:	6abb      	ldr	r3, [r7, #40]	; 0x28
  4060c8:	4313      	orrs	r3, r2
  4060ca:	62bb      	str	r3, [r7, #40]	; 0x28
		lLastGyroSf = gyro_sf;
  4060cc:	4a09      	ldr	r2, [pc, #36]	; (4060f4 <inv_icm20948_set_gyro_sf+0x19c>)
  4060ce:	6afb      	ldr	r3, [r7, #44]	; 0x2c
  4060d0:	6013      	str	r3, [r2, #0]
	}

	return result;
  4060d2:	6abb      	ldr	r3, [r7, #40]	; 0x28
}
  4060d4:	4618      	mov	r0, r3
  4060d6:	3734      	adds	r7, #52	; 0x34
  4060d8:	46bd      	mov	sp, r7
  4060da:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
  4060de:	bf00      	nop
  4060e0:	566675af 	.word	0x566675af
  4060e4:	0000f083 	.word	0x0000f083
  4060e8:	0040c755 	.word	0x0040c755
  4060ec:	000186a0 	.word	0x000186a0
  4060f0:	00413c79 	.word	0x00413c79
  4060f4:	20001438 	.word	0x20001438
  4060f8:	00407fd1 	.word	0x00407fd1

004060fc <inv_icm20948_set_gyro_fullscale>:

int inv_icm20948_set_gyro_fullscale(struct inv_icm20948 * s, int level)
{
  4060fc:	b580      	push	{r7, lr}
  4060fe:	b084      	sub	sp, #16
  406100:	af00      	add	r7, sp, #0
  406102:	6078      	str	r0, [r7, #4]
  406104:	6039      	str	r1, [r7, #0]
	int result;
	s->base_state.gyro_fullscale = level;
  406106:	683b      	ldr	r3, [r7, #0]
  406108:	b2da      	uxtb	r2, r3
  40610a:	687b      	ldr	r3, [r7, #4]
  40610c:	f883 2024 	strb.w	r2, [r3, #36]	; 0x24
	result = inv_icm20948_set_icm20948_gyro_fullscale(s, level);
  406110:	6839      	ldr	r1, [r7, #0]
  406112:	6878      	ldr	r0, [r7, #4]
  406114:	4b0f      	ldr	r3, [pc, #60]	; (406154 <inv_icm20948_set_gyro_fullscale+0x58>)
  406116:	4798      	blx	r3
  406118:	60f8      	str	r0, [r7, #12]
	result |= inv_icm20948_set_gyro_sf(s, s->base_state.gyro_div, level);
  40611a:	687b      	ldr	r3, [r7, #4]
  40611c:	7f5b      	ldrb	r3, [r3, #29]
  40611e:	683a      	ldr	r2, [r7, #0]
  406120:	4619      	mov	r1, r3
  406122:	6878      	ldr	r0, [r7, #4]
  406124:	4b0c      	ldr	r3, [pc, #48]	; (406158 <inv_icm20948_set_gyro_fullscale+0x5c>)
  406126:	4798      	blx	r3
  406128:	4602      	mov	r2, r0
  40612a:	68fb      	ldr	r3, [r7, #12]
  40612c:	4313      	orrs	r3, r2
  40612e:	60fb      	str	r3, [r7, #12]
	result |= dmp_icm20948_set_gyro_fsr(s, 250<<level);
  406130:	22fa      	movs	r2, #250	; 0xfa
  406132:	683b      	ldr	r3, [r7, #0]
  406134:	fa02 f303 	lsl.w	r3, r2, r3
  406138:	b21b      	sxth	r3, r3
  40613a:	4619      	mov	r1, r3
  40613c:	6878      	ldr	r0, [r7, #4]
  40613e:	4b07      	ldr	r3, [pc, #28]	; (40615c <inv_icm20948_set_gyro_fullscale+0x60>)
  406140:	4798      	blx	r3
  406142:	4602      	mov	r2, r0
  406144:	68fb      	ldr	r3, [r7, #12]
  406146:	4313      	orrs	r3, r2
  406148:	60fb      	str	r3, [r7, #12]

	return result;
  40614a:	68fb      	ldr	r3, [r7, #12]
}
  40614c:	4618      	mov	r0, r3
  40614e:	3710      	adds	r7, #16
  406150:	46bd      	mov	sp, r7
  406152:	bd80      	pop	{r7, pc}
  406154:	0040617d 	.word	0x0040617d
  406158:	00405f59 	.word	0x00405f59
  40615c:	004082d1 	.word	0x004082d1

00406160 <inv_icm20948_get_gyro_fullscale>:

uint8_t inv_icm20948_get_gyro_fullscale(struct inv_icm20948 * s)
{
  406160:	b480      	push	{r7}
  406162:	b083      	sub	sp, #12
  406164:	af00      	add	r7, sp, #0
  406166:	6078      	str	r0, [r7, #4]
	return s->base_state.gyro_fullscale;
  406168:	687b      	ldr	r3, [r7, #4]
  40616a:	f893 3024 	ldrb.w	r3, [r3, #36]	; 0x24
}
  40616e:	4618      	mov	r0, r3
  406170:	370c      	adds	r7, #12
  406172:	46bd      	mov	sp, r7
  406174:	f85d 7b04 	ldr.w	r7, [sp], #4
  406178:	4770      	bx	lr
	...

0040617c <inv_icm20948_set_icm20948_gyro_fullscale>:


int inv_icm20948_set_icm20948_gyro_fullscale(struct inv_icm20948 * s, int level)
{
  40617c:	b590      	push	{r4, r7, lr}
  40617e:	b087      	sub	sp, #28
  406180:	af00      	add	r7, sp, #0
  406182:	6078      	str	r0, [r7, #4]
  406184:	6039      	str	r1, [r7, #0]
	int result = 0;
  406186:	2300      	movs	r3, #0
  406188:	613b      	str	r3, [r7, #16]
	unsigned char gyro_config_1_reg;
	unsigned char gyro_config_2_reg;
	unsigned char dec3_cfg;
	if (level >= NUM_MPU_GFS)
  40618a:	683b      	ldr	r3, [r7, #0]
  40618c:	2b03      	cmp	r3, #3
  40618e:	dd02      	ble.n	406196 <inv_icm20948_set_icm20948_gyro_fullscale+0x1a>
		return -1;
  406190:	f04f 33ff 	mov.w	r3, #4294967295
  406194:	e07d      	b.n	406292 <inv_icm20948_set_icm20948_gyro_fullscale+0x116>

	result |= inv_icm20948_read_mems_reg(s, REG_GYRO_CONFIG_1, 1, &gyro_config_1_reg);
  406196:	f107 030f 	add.w	r3, r7, #15
  40619a:	2201      	movs	r2, #1
  40619c:	f240 1101 	movw	r1, #257	; 0x101
  4061a0:	6878      	ldr	r0, [r7, #4]
  4061a2:	4c3e      	ldr	r4, [pc, #248]	; (40629c <inv_icm20948_set_icm20948_gyro_fullscale+0x120>)
  4061a4:	47a0      	blx	r4
  4061a6:	4602      	mov	r2, r0
  4061a8:	693b      	ldr	r3, [r7, #16]
  4061aa:	4313      	orrs	r3, r2
  4061ac:	613b      	str	r3, [r7, #16]
	gyro_config_1_reg &= 0xC0;
  4061ae:	7bfb      	ldrb	r3, [r7, #15]
  4061b0:	f023 033f 	bic.w	r3, r3, #63	; 0x3f
  4061b4:	b2db      	uxtb	r3, r3
  4061b6:	73fb      	strb	r3, [r7, #15]
	gyro_config_1_reg |= (level << 1) | 1;  //fchoice = 1, filter = 0.
  4061b8:	683b      	ldr	r3, [r7, #0]
  4061ba:	005b      	lsls	r3, r3, #1
  4061bc:	b2da      	uxtb	r2, r3
  4061be:	7bfb      	ldrb	r3, [r7, #15]
  4061c0:	4313      	orrs	r3, r2
  4061c2:	b2db      	uxtb	r3, r3
  4061c4:	f043 0301 	orr.w	r3, r3, #1
  4061c8:	b2db      	uxtb	r3, r3
  4061ca:	73fb      	strb	r3, [r7, #15]
	result |= inv_icm20948_write_mems_reg(s, REG_GYRO_CONFIG_1, 1, &gyro_config_1_reg);
  4061cc:	f107 030f 	add.w	r3, r7, #15
  4061d0:	2201      	movs	r2, #1
  4061d2:	f240 1101 	movw	r1, #257	; 0x101
  4061d6:	6878      	ldr	r0, [r7, #4]
  4061d8:	4c31      	ldr	r4, [pc, #196]	; (4062a0 <inv_icm20948_set_icm20948_gyro_fullscale+0x124>)
  4061da:	47a0      	blx	r4
  4061dc:	4602      	mov	r2, r0
  4061de:	693b      	ldr	r3, [r7, #16]
  4061e0:	4313      	orrs	r3, r2
  4061e2:	613b      	str	r3, [r7, #16]

	result |= inv_icm20948_read_mems_reg(s, REG_GYRO_CONFIG_2, 1, &gyro_config_2_reg);
  4061e4:	f107 030e 	add.w	r3, r7, #14
  4061e8:	2201      	movs	r2, #1
  4061ea:	f44f 7181 	mov.w	r1, #258	; 0x102
  4061ee:	6878      	ldr	r0, [r7, #4]
  4061f0:	4c2a      	ldr	r4, [pc, #168]	; (40629c <inv_icm20948_set_icm20948_gyro_fullscale+0x120>)
  4061f2:	47a0      	blx	r4
  4061f4:	4602      	mov	r2, r0
  4061f6:	693b      	ldr	r3, [r7, #16]
  4061f8:	4313      	orrs	r3, r2
  4061fa:	613b      	str	r3, [r7, #16]
	gyro_config_2_reg &= 0xF8;
  4061fc:	7bbb      	ldrb	r3, [r7, #14]
  4061fe:	f023 0307 	bic.w	r3, r3, #7
  406202:	b2db      	uxtb	r3, r3
  406204:	73bb      	strb	r3, [r7, #14]
	
	switch(s->base_state.gyro_averaging) {
  406206:	687b      	ldr	r3, [r7, #4]
  406208:	f893 3022 	ldrb.w	r3, [r3, #34]	; 0x22
  40620c:	2b08      	cmp	r3, #8
  40620e:	d01d      	beq.n	40624c <inv_icm20948_set_icm20948_gyro_fullscale+0xd0>
  406210:	2b08      	cmp	r3, #8
  406212:	dc06      	bgt.n	406222 <inv_icm20948_set_icm20948_gyro_fullscale+0xa6>
  406214:	2b02      	cmp	r3, #2
  406216:	d013      	beq.n	406240 <inv_icm20948_set_icm20948_gyro_fullscale+0xc4>
  406218:	2b04      	cmp	r3, #4
  40621a:	d014      	beq.n	406246 <inv_icm20948_set_icm20948_gyro_fullscale+0xca>
  40621c:	2b01      	cmp	r3, #1
  40621e:	d00c      	beq.n	40623a <inv_icm20948_set_icm20948_gyro_fullscale+0xbe>
  406220:	e023      	b.n	40626a <inv_icm20948_set_icm20948_gyro_fullscale+0xee>
  406222:	2b20      	cmp	r3, #32
  406224:	d018      	beq.n	406258 <inv_icm20948_set_icm20948_gyro_fullscale+0xdc>
  406226:	2b20      	cmp	r3, #32
  406228:	dc02      	bgt.n	406230 <inv_icm20948_set_icm20948_gyro_fullscale+0xb4>
  40622a:	2b10      	cmp	r3, #16
  40622c:	d011      	beq.n	406252 <inv_icm20948_set_icm20948_gyro_fullscale+0xd6>
  40622e:	e01c      	b.n	40626a <inv_icm20948_set_icm20948_gyro_fullscale+0xee>
  406230:	2b40      	cmp	r3, #64	; 0x40
  406232:	d014      	beq.n	40625e <inv_icm20948_set_icm20948_gyro_fullscale+0xe2>
  406234:	2b80      	cmp	r3, #128	; 0x80
  406236:	d015      	beq.n	406264 <inv_icm20948_set_icm20948_gyro_fullscale+0xe8>
  406238:	e017      	b.n	40626a <inv_icm20948_set_icm20948_gyro_fullscale+0xee>
		case 1:
			dec3_cfg = 0;
  40623a:	2300      	movs	r3, #0
  40623c:	75fb      	strb	r3, [r7, #23]
			break;
  40623e:	e017      	b.n	406270 <inv_icm20948_set_icm20948_gyro_fullscale+0xf4>

		case 2:
			dec3_cfg = 1;
  406240:	2301      	movs	r3, #1
  406242:	75fb      	strb	r3, [r7, #23]
			break;
  406244:	e014      	b.n	406270 <inv_icm20948_set_icm20948_gyro_fullscale+0xf4>

		case 4:
			dec3_cfg = 2;
  406246:	2302      	movs	r3, #2
  406248:	75fb      	strb	r3, [r7, #23]
			break;
  40624a:	e011      	b.n	406270 <inv_icm20948_set_icm20948_gyro_fullscale+0xf4>

		case 8:
			dec3_cfg = 3;
  40624c:	2303      	movs	r3, #3
  40624e:	75fb      	strb	r3, [r7, #23]
			break;
  406250:	e00e      	b.n	406270 <inv_icm20948_set_icm20948_gyro_fullscale+0xf4>

		case 16:
			dec3_cfg = 4;
  406252:	2304      	movs	r3, #4
  406254:	75fb      	strb	r3, [r7, #23]
			break;
  406256:	e00b      	b.n	406270 <inv_icm20948_set_icm20948_gyro_fullscale+0xf4>

		case 32:
			dec3_cfg = 5;
  406258:	2305      	movs	r3, #5
  40625a:	75fb      	strb	r3, [r7, #23]
			break;
  40625c:	e008      	b.n	406270 <inv_icm20948_set_icm20948_gyro_fullscale+0xf4>

		case 64:
			dec3_cfg = 6;
  40625e:	2306      	movs	r3, #6
  406260:	75fb      	strb	r3, [r7, #23]
			break;
  406262:	e005      	b.n	406270 <inv_icm20948_set_icm20948_gyro_fullscale+0xf4>

		case 128:
			dec3_cfg = 7;
  406264:	2307      	movs	r3, #7
  406266:	75fb      	strb	r3, [r7, #23]
			break;
  406268:	e002      	b.n	406270 <inv_icm20948_set_icm20948_gyro_fullscale+0xf4>

		default:
			dec3_cfg = 0;
  40626a:	2300      	movs	r3, #0
  40626c:	75fb      	strb	r3, [r7, #23]
			break;
  40626e:	bf00      	nop
	}
	gyro_config_2_reg |= dec3_cfg;  
  406270:	7bba      	ldrb	r2, [r7, #14]
  406272:	7dfb      	ldrb	r3, [r7, #23]
  406274:	4313      	orrs	r3, r2
  406276:	b2db      	uxtb	r3, r3
  406278:	73bb      	strb	r3, [r7, #14]
	result |= inv_icm20948_write_single_mems_reg(s, REG_GYRO_CONFIG_2, gyro_config_2_reg);
  40627a:	7bbb      	ldrb	r3, [r7, #14]
  40627c:	461a      	mov	r2, r3
  40627e:	f44f 7181 	mov.w	r1, #258	; 0x102
  406282:	6878      	ldr	r0, [r7, #4]
  406284:	4b07      	ldr	r3, [pc, #28]	; (4062a4 <inv_icm20948_set_icm20948_gyro_fullscale+0x128>)
  406286:	4798      	blx	r3
  406288:	4602      	mov	r2, r0
  40628a:	693b      	ldr	r3, [r7, #16]
  40628c:	4313      	orrs	r3, r2
  40628e:	613b      	str	r3, [r7, #16]
	return result;
  406290:	693b      	ldr	r3, [r7, #16]
}
  406292:	4618      	mov	r0, r3
  406294:	371c      	adds	r7, #28
  406296:	46bd      	mov	sp, r7
  406298:	bd90      	pop	{r4, r7, pc}
  40629a:	bf00      	nop
  40629c:	0040c755 	.word	0x0040c755
  4062a0:	0040c581 	.word	0x0040c581
  4062a4:	0040c689 	.word	0x0040c689

004062a8 <inv_icm20948_set_accel_fullscale>:


int inv_icm20948_set_accel_fullscale(struct inv_icm20948 * s, int level)
{
  4062a8:	b580      	push	{r7, lr}
  4062aa:	b084      	sub	sp, #16
  4062ac:	af00      	add	r7, sp, #0
  4062ae:	6078      	str	r0, [r7, #4]
  4062b0:	6039      	str	r1, [r7, #0]
	int result;
	s->base_state.accel_fullscale = level;
  4062b2:	683b      	ldr	r3, [r7, #0]
  4062b4:	b2da      	uxtb	r2, r3
  4062b6:	687b      	ldr	r3, [r7, #4]
  4062b8:	f883 2025 	strb.w	r2, [r3, #37]	; 0x25
	result = inv_icm20948_set_icm20948_accel_fullscale(s, level);
  4062bc:	6839      	ldr	r1, [r7, #0]
  4062be:	6878      	ldr	r0, [r7, #4]
  4062c0:	4b10      	ldr	r3, [pc, #64]	; (406304 <inv_icm20948_set_accel_fullscale+0x5c>)
  4062c2:	4798      	blx	r3
  4062c4:	60f8      	str	r0, [r7, #12]
	result |= dmp_icm20948_set_accel_fsr(s, 2<<level);
  4062c6:	2202      	movs	r2, #2
  4062c8:	683b      	ldr	r3, [r7, #0]
  4062ca:	fa02 f303 	lsl.w	r3, r2, r3
  4062ce:	b21b      	sxth	r3, r3
  4062d0:	4619      	mov	r1, r3
  4062d2:	6878      	ldr	r0, [r7, #4]
  4062d4:	4b0c      	ldr	r3, [pc, #48]	; (406308 <inv_icm20948_set_accel_fullscale+0x60>)
  4062d6:	4798      	blx	r3
  4062d8:	4602      	mov	r2, r0
  4062da:	68fb      	ldr	r3, [r7, #12]
  4062dc:	4313      	orrs	r3, r2
  4062de:	60fb      	str	r3, [r7, #12]
	result |= dmp_icm20948_set_accel_scale2(s, 2<<level);
  4062e0:	2202      	movs	r2, #2
  4062e2:	683b      	ldr	r3, [r7, #0]
  4062e4:	fa02 f303 	lsl.w	r3, r2, r3
  4062e8:	b21b      	sxth	r3, r3
  4062ea:	4619      	mov	r1, r3
  4062ec:	6878      	ldr	r0, [r7, #4]
  4062ee:	4b07      	ldr	r3, [pc, #28]	; (40630c <inv_icm20948_set_accel_fullscale+0x64>)
  4062f0:	4798      	blx	r3
  4062f2:	4602      	mov	r2, r0
  4062f4:	68fb      	ldr	r3, [r7, #12]
  4062f6:	4313      	orrs	r3, r2
  4062f8:	60fb      	str	r3, [r7, #12]
	return result;
  4062fa:	68fb      	ldr	r3, [r7, #12]
}
  4062fc:	4618      	mov	r0, r3
  4062fe:	3710      	adds	r7, #16
  406300:	46bd      	mov	sp, r7
  406302:	bd80      	pop	{r7, pc}
  406304:	0040632d 	.word	0x0040632d
  406308:	0040836d 	.word	0x0040836d
  40630c:	0040846d 	.word	0x0040846d

00406310 <inv_icm20948_get_accel_fullscale>:

uint8_t inv_icm20948_get_accel_fullscale(struct inv_icm20948 * s)
{
  406310:	b480      	push	{r7}
  406312:	b083      	sub	sp, #12
  406314:	af00      	add	r7, sp, #0
  406316:	6078      	str	r0, [r7, #4]
	return s->base_state.accel_fullscale;
  406318:	687b      	ldr	r3, [r7, #4]
  40631a:	f893 3025 	ldrb.w	r3, [r3, #37]	; 0x25
}
  40631e:	4618      	mov	r0, r3
  406320:	370c      	adds	r7, #12
  406322:	46bd      	mov	sp, r7
  406324:	f85d 7b04 	ldr.w	r7, [sp], #4
  406328:	4770      	bx	lr
	...

0040632c <inv_icm20948_set_icm20948_accel_fullscale>:


int inv_icm20948_set_icm20948_accel_fullscale(struct inv_icm20948 * s, int level)
{
  40632c:	b590      	push	{r4, r7, lr}
  40632e:	b087      	sub	sp, #28
  406330:	af00      	add	r7, sp, #0
  406332:	6078      	str	r0, [r7, #4]
  406334:	6039      	str	r1, [r7, #0]
	int result = 0;
  406336:	2300      	movs	r3, #0
  406338:	613b      	str	r3, [r7, #16]
	unsigned char accel_config_1_reg;
	unsigned char accel_config_2_reg;
	unsigned char dec3_cfg;

	if (level >= NUM_MPU_AFS)
  40633a:	683b      	ldr	r3, [r7, #0]
  40633c:	2b03      	cmp	r3, #3
  40633e:	dd02      	ble.n	406346 <inv_icm20948_set_icm20948_accel_fullscale+0x1a>
		return -1;
  406340:	f04f 33ff 	mov.w	r3, #4294967295
  406344:	e0b2      	b.n	4064ac <inv_icm20948_set_icm20948_accel_fullscale+0x180>

	result |= inv_icm20948_read_mems_reg(s, REG_ACCEL_CONFIG, 1, &accel_config_1_reg);
  406346:	f107 030f 	add.w	r3, r7, #15
  40634a:	2201      	movs	r2, #1
  40634c:	f44f 718a 	mov.w	r1, #276	; 0x114
  406350:	6878      	ldr	r0, [r7, #4]
  406352:	4c58      	ldr	r4, [pc, #352]	; (4064b4 <inv_icm20948_set_icm20948_accel_fullscale+0x188>)
  406354:	47a0      	blx	r4
  406356:	4602      	mov	r2, r0
  406358:	693b      	ldr	r3, [r7, #16]
  40635a:	4313      	orrs	r3, r2
  40635c:	613b      	str	r3, [r7, #16]
	accel_config_1_reg &= 0xC0;
  40635e:	7bfb      	ldrb	r3, [r7, #15]
  406360:	f023 033f 	bic.w	r3, r3, #63	; 0x3f
  406364:	b2db      	uxtb	r3, r3
  406366:	73fb      	strb	r3, [r7, #15]

	if(s->base_state.accel_averaging > 1)
  406368:	687b      	ldr	r3, [r7, #4]
  40636a:	f893 3023 	ldrb.w	r3, [r3, #35]	; 0x23
  40636e:	2b01      	cmp	r3, #1
  406370:	d90a      	bls.n	406388 <inv_icm20948_set_icm20948_accel_fullscale+0x5c>
		accel_config_1_reg |= (7 << 3) | (level << 1) | 1;   //fchoice = 1, filter = 7.
  406372:	683b      	ldr	r3, [r7, #0]
  406374:	005b      	lsls	r3, r3, #1
  406376:	b2da      	uxtb	r2, r3
  406378:	7bfb      	ldrb	r3, [r7, #15]
  40637a:	4313      	orrs	r3, r2
  40637c:	b2db      	uxtb	r3, r3
  40637e:	f043 0339 	orr.w	r3, r3, #57	; 0x39
  406382:	b2db      	uxtb	r3, r3
  406384:	73fb      	strb	r3, [r7, #15]
  406386:	e008      	b.n	40639a <inv_icm20948_set_icm20948_accel_fullscale+0x6e>
	else
		accel_config_1_reg |= (level << 1) | 0;  //fchoice = 0, filter = 0.
  406388:	683b      	ldr	r3, [r7, #0]
  40638a:	005b      	lsls	r3, r3, #1
  40638c:	b25a      	sxtb	r2, r3
  40638e:	7bfb      	ldrb	r3, [r7, #15]
  406390:	b25b      	sxtb	r3, r3
  406392:	4313      	orrs	r3, r2
  406394:	b25b      	sxtb	r3, r3
  406396:	b2db      	uxtb	r3, r3
  406398:	73fb      	strb	r3, [r7, #15]
	/* /!\ FCHOICE=0 considers we are in low power mode always and allows us to have correct values on raw data since not averaged,
	in case low noise mode is to be supported for 20649, please reconsider this value and update base sample rate from 1125 to 4500...
	*/
	result |= inv_icm20948_write_single_mems_reg(s, REG_ACCEL_CONFIG, accel_config_1_reg);
  40639a:	7bfb      	ldrb	r3, [r7, #15]
  40639c:	461a      	mov	r2, r3
  40639e:	f44f 718a 	mov.w	r1, #276	; 0x114
  4063a2:	6878      	ldr	r0, [r7, #4]
  4063a4:	4b44      	ldr	r3, [pc, #272]	; (4064b8 <inv_icm20948_set_icm20948_accel_fullscale+0x18c>)
  4063a6:	4798      	blx	r3
  4063a8:	4602      	mov	r2, r0
  4063aa:	693b      	ldr	r3, [r7, #16]
  4063ac:	4313      	orrs	r3, r2
  4063ae:	613b      	str	r3, [r7, #16]

	switch(s->base_state.accel_averaging) {
  4063b0:	687b      	ldr	r3, [r7, #4]
  4063b2:	f893 3023 	ldrb.w	r3, [r3, #35]	; 0x23
  4063b6:	3b01      	subs	r3, #1
  4063b8:	2b1f      	cmp	r3, #31
  4063ba:	d852      	bhi.n	406462 <inv_icm20948_set_icm20948_accel_fullscale+0x136>
  4063bc:	a201      	add	r2, pc, #4	; (adr r2, 4063c4 <inv_icm20948_set_icm20948_accel_fullscale+0x98>)
  4063be:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
  4063c2:	bf00      	nop
  4063c4:	00406445 	.word	0x00406445
  4063c8:	00406463 	.word	0x00406463
  4063cc:	00406463 	.word	0x00406463
  4063d0:	0040644b 	.word	0x0040644b
  4063d4:	00406463 	.word	0x00406463
  4063d8:	00406463 	.word	0x00406463
  4063dc:	00406463 	.word	0x00406463
  4063e0:	00406451 	.word	0x00406451
  4063e4:	00406463 	.word	0x00406463
  4063e8:	00406463 	.word	0x00406463
  4063ec:	00406463 	.word	0x00406463
  4063f0:	00406463 	.word	0x00406463
  4063f4:	00406463 	.word	0x00406463
  4063f8:	00406463 	.word	0x00406463
  4063fc:	00406463 	.word	0x00406463
  406400:	00406457 	.word	0x00406457
  406404:	00406463 	.word	0x00406463
  406408:	00406463 	.word	0x00406463
  40640c:	00406463 	.word	0x00406463
  406410:	00406463 	.word	0x00406463
  406414:	00406463 	.word	0x00406463
  406418:	00406463 	.word	0x00406463
  40641c:	00406463 	.word	0x00406463
  406420:	00406463 	.word	0x00406463
  406424:	00406463 	.word	0x00406463
  406428:	00406463 	.word	0x00406463
  40642c:	00406463 	.word	0x00406463
  406430:	00406463 	.word	0x00406463
  406434:	00406463 	.word	0x00406463
  406438:	00406463 	.word	0x00406463
  40643c:	00406463 	.word	0x00406463
  406440:	0040645d 	.word	0x0040645d
		case 1:
			dec3_cfg = 0;
  406444:	2300      	movs	r3, #0
  406446:	75fb      	strb	r3, [r7, #23]
			break;
  406448:	e00e      	b.n	406468 <inv_icm20948_set_icm20948_accel_fullscale+0x13c>

		case 4:
			dec3_cfg = 0;
  40644a:	2300      	movs	r3, #0
  40644c:	75fb      	strb	r3, [r7, #23]
			break;
  40644e:	e00b      	b.n	406468 <inv_icm20948_set_icm20948_accel_fullscale+0x13c>
		
		case 8:
			dec3_cfg = 1;
  406450:	2301      	movs	r3, #1
  406452:	75fb      	strb	r3, [r7, #23]
			break;
  406454:	e008      	b.n	406468 <inv_icm20948_set_icm20948_accel_fullscale+0x13c>
	
		case 16:
			dec3_cfg = 2;
  406456:	2302      	movs	r3, #2
  406458:	75fb      	strb	r3, [r7, #23]
			break;
  40645a:	e005      	b.n	406468 <inv_icm20948_set_icm20948_accel_fullscale+0x13c>
		
		case 32:
			dec3_cfg = 3;
  40645c:	2303      	movs	r3, #3
  40645e:	75fb      	strb	r3, [r7, #23]
			break;
  406460:	e002      	b.n	406468 <inv_icm20948_set_icm20948_accel_fullscale+0x13c>

		default:
			dec3_cfg = 0;
  406462:	2300      	movs	r3, #0
  406464:	75fb      	strb	r3, [r7, #23]
			break;
  406466:	bf00      	nop
	}

	result |= inv_icm20948_read_mems_reg(s, REG_ACCEL_CONFIG_2, 1, &accel_config_2_reg);
  406468:	f107 030e 	add.w	r3, r7, #14
  40646c:	2201      	movs	r2, #1
  40646e:	f240 1115 	movw	r1, #277	; 0x115
  406472:	6878      	ldr	r0, [r7, #4]
  406474:	4c0f      	ldr	r4, [pc, #60]	; (4064b4 <inv_icm20948_set_icm20948_accel_fullscale+0x188>)
  406476:	47a0      	blx	r4
  406478:	4602      	mov	r2, r0
  40647a:	693b      	ldr	r3, [r7, #16]
  40647c:	4313      	orrs	r3, r2
  40647e:	613b      	str	r3, [r7, #16]
	accel_config_2_reg &= 0xFC;
  406480:	7bbb      	ldrb	r3, [r7, #14]
  406482:	f023 0303 	bic.w	r3, r3, #3
  406486:	b2db      	uxtb	r3, r3
  406488:	73bb      	strb	r3, [r7, #14]

	accel_config_2_reg |=  dec3_cfg;
  40648a:	7bba      	ldrb	r2, [r7, #14]
  40648c:	7dfb      	ldrb	r3, [r7, #23]
  40648e:	4313      	orrs	r3, r2
  406490:	b2db      	uxtb	r3, r3
  406492:	73bb      	strb	r3, [r7, #14]
	result |= inv_icm20948_write_single_mems_reg(s, REG_ACCEL_CONFIG_2, accel_config_2_reg);
  406494:	7bbb      	ldrb	r3, [r7, #14]
  406496:	461a      	mov	r2, r3
  406498:	f240 1115 	movw	r1, #277	; 0x115
  40649c:	6878      	ldr	r0, [r7, #4]
  40649e:	4b06      	ldr	r3, [pc, #24]	; (4064b8 <inv_icm20948_set_icm20948_accel_fullscale+0x18c>)
  4064a0:	4798      	blx	r3
  4064a2:	4602      	mov	r2, r0
  4064a4:	693b      	ldr	r3, [r7, #16]
  4064a6:	4313      	orrs	r3, r2
  4064a8:	613b      	str	r3, [r7, #16]

	return result;
  4064aa:	693b      	ldr	r3, [r7, #16]
}
  4064ac:	4618      	mov	r0, r3
  4064ae:	371c      	adds	r7, #28
  4064b0:	46bd      	mov	sp, r7
  4064b2:	bd90      	pop	{r4, r7, pc}
  4064b4:	0040c755 	.word	0x0040c755
  4064b8:	0040c689 	.word	0x0040c689

004064bc <inv_icm20948_enable_hw_sensors>:


int inv_icm20948_enable_hw_sensors(struct inv_icm20948 * s, int bit_mask)
{
  4064bc:	b590      	push	{r4, r7, lr}
  4064be:	b085      	sub	sp, #20
  4064c0:	af00      	add	r7, sp, #0
  4064c2:	6078      	str	r0, [r7, #4]
  4064c4:	6039      	str	r1, [r7, #0]
	int rc = 0;
  4064c6:	2300      	movs	r3, #0
  4064c8:	60fb      	str	r3, [r7, #12]

	if ((s->base_state.pwr_mgmt_2 == (BIT_PWR_ACCEL_STBY | BIT_PWR_GYRO_STBY | BIT_PWR_PRESSURE_STBY)) | (bit_mask & 0x80)) {
  4064ca:	687b      	ldr	r3, [r7, #4]
  4064cc:	7edb      	ldrb	r3, [r3, #27]
  4064ce:	2b7f      	cmp	r3, #127	; 0x7f
  4064d0:	bf0c      	ite	eq
  4064d2:	2301      	moveq	r3, #1
  4064d4:	2300      	movne	r3, #0
  4064d6:	b2db      	uxtb	r3, r3
  4064d8:	461a      	mov	r2, r3
  4064da:	683b      	ldr	r3, [r7, #0]
  4064dc:	f003 0380 	and.w	r3, r3, #128	; 0x80
  4064e0:	4313      	orrs	r3, r2
  4064e2:	2b00      	cmp	r3, #0
  4064e4:	d02d      	beq.n	406542 <inv_icm20948_enable_hw_sensors+0x86>
		// All sensors off, or override is on
		s->base_state.pwr_mgmt_2 = 0; // Zero means all sensors are on
  4064e6:	687b      	ldr	r3, [r7, #4]
  4064e8:	2200      	movs	r2, #0
  4064ea:	76da      	strb	r2, [r3, #27]
		// Gyro and Accel were off
		if ((bit_mask & 2) == 0) {
  4064ec:	683b      	ldr	r3, [r7, #0]
  4064ee:	f003 0302 	and.w	r3, r3, #2
  4064f2:	2b00      	cmp	r3, #0
  4064f4:	d102      	bne.n	4064fc <inv_icm20948_enable_hw_sensors+0x40>
			s->base_state.pwr_mgmt_2 = BIT_PWR_ACCEL_STBY; // Turn off accel
  4064f6:	687b      	ldr	r3, [r7, #4]
  4064f8:	2238      	movs	r2, #56	; 0x38
  4064fa:	76da      	strb	r2, [r3, #27]
		}
		if ((bit_mask & 1) == 0) {
  4064fc:	683b      	ldr	r3, [r7, #0]
  4064fe:	f003 0301 	and.w	r3, r3, #1
  406502:	2b00      	cmp	r3, #0
  406504:	d106      	bne.n	406514 <inv_icm20948_enable_hw_sensors+0x58>
			s->base_state.pwr_mgmt_2 |= BIT_PWR_GYRO_STBY; // Turn off gyro
  406506:	687b      	ldr	r3, [r7, #4]
  406508:	7edb      	ldrb	r3, [r3, #27]
  40650a:	f043 0307 	orr.w	r3, r3, #7
  40650e:	b2da      	uxtb	r2, r3
  406510:	687b      	ldr	r3, [r7, #4]
  406512:	76da      	strb	r2, [r3, #27]
		}
		if ((bit_mask & 4) == 0) {
  406514:	683b      	ldr	r3, [r7, #0]
  406516:	f003 0304 	and.w	r3, r3, #4
  40651a:	2b00      	cmp	r3, #0
  40651c:	d106      	bne.n	40652c <inv_icm20948_enable_hw_sensors+0x70>
			s->base_state.pwr_mgmt_2 |= BIT_PWR_PRESSURE_STBY; // Turn off pressure
  40651e:	687b      	ldr	r3, [r7, #4]
  406520:	7edb      	ldrb	r3, [r3, #27]
  406522:	f043 0340 	orr.w	r3, r3, #64	; 0x40
  406526:	b2da      	uxtb	r2, r3
  406528:	687b      	ldr	r3, [r7, #4]
  40652a:	76da      	strb	r2, [r3, #27]
		}

		rc |= inv_icm20948_write_mems_reg(s, REG_PWR_MGMT_2, 1, &s->base_state.pwr_mgmt_2);
  40652c:	687b      	ldr	r3, [r7, #4]
  40652e:	331b      	adds	r3, #27
  406530:	2201      	movs	r2, #1
  406532:	2107      	movs	r1, #7
  406534:	6878      	ldr	r0, [r7, #4]
  406536:	4c0f      	ldr	r4, [pc, #60]	; (406574 <inv_icm20948_enable_hw_sensors+0xb8>)
  406538:	47a0      	blx	r4
  40653a:	4602      	mov	r2, r0
  40653c:	68fb      	ldr	r3, [r7, #12]
  40653e:	4313      	orrs	r3, r2
  406540:	60fb      	str	r3, [r7, #12]
	}

	if (bit_mask & SECONDARY_COMPASS_AVAILABLE) {
  406542:	683b      	ldr	r3, [r7, #0]
  406544:	f003 0308 	and.w	r3, r3, #8
  406548:	2b00      	cmp	r3, #0
  40654a:	d007      	beq.n	40655c <inv_icm20948_enable_hw_sensors+0xa0>
		rc |= inv_icm20948_resume_akm(s);
  40654c:	6878      	ldr	r0, [r7, #4]
  40654e:	4b0a      	ldr	r3, [pc, #40]	; (406578 <inv_icm20948_enable_hw_sensors+0xbc>)
  406550:	4798      	blx	r3
  406552:	4602      	mov	r2, r0
  406554:	68fb      	ldr	r3, [r7, #12]
  406556:	4313      	orrs	r3, r2
  406558:	60fb      	str	r3, [r7, #12]
  40655a:	e006      	b.n	40656a <inv_icm20948_enable_hw_sensors+0xae>
	} 
	else {
		rc |= inv_icm20948_suspend_akm(s);
  40655c:	6878      	ldr	r0, [r7, #4]
  40655e:	4b07      	ldr	r3, [pc, #28]	; (40657c <inv_icm20948_enable_hw_sensors+0xc0>)
  406560:	4798      	blx	r3
  406562:	4602      	mov	r2, r0
  406564:	68fb      	ldr	r3, [r7, #12]
  406566:	4313      	orrs	r3, r2
  406568:	60fb      	str	r3, [r7, #12]
	}

	return rc;
  40656a:	68fb      	ldr	r3, [r7, #12]
}
  40656c:	4618      	mov	r0, r3
  40656e:	3714      	adds	r7, #20
  406570:	46bd      	mov	sp, r7
  406572:	bd90      	pop	{r4, r7, pc}
  406574:	0040c581 	.word	0x0040c581
  406578:	00404e91 	.word	0x00404e91
  40657c:	00404e2d 	.word	0x00404e2d

00406580 <invn_convert_quat_mult_fxp>:
#include <math.h>

static void invn_convert_quat_invert_fxp(const long *quat_q30, long *invQuat_q30);

static void invn_convert_quat_mult_fxp(const long *quat1_q30, const long *quat2_q30, long *quatProd_q30)
{
  406580:	b5b0      	push	{r4, r5, r7, lr}
  406582:	b084      	sub	sp, #16
  406584:	af00      	add	r7, sp, #0
  406586:	60f8      	str	r0, [r7, #12]
  406588:	60b9      	str	r1, [r7, #8]
  40658a:	607a      	str	r2, [r7, #4]
    quatProd_q30[0] = inv_icm20948_convert_mult_q30_fxp(quat1_q30[0], quat2_q30[0]) - inv_icm20948_convert_mult_q30_fxp(quat1_q30[1], quat2_q30[1]) -
  40658c:	68fb      	ldr	r3, [r7, #12]
  40658e:	681a      	ldr	r2, [r3, #0]
  406590:	68bb      	ldr	r3, [r7, #8]
  406592:	681b      	ldr	r3, [r3, #0]
  406594:	4619      	mov	r1, r3
  406596:	4610      	mov	r0, r2
  406598:	4b5f      	ldr	r3, [pc, #380]	; (406718 <invn_convert_quat_mult_fxp+0x198>)
  40659a:	4798      	blx	r3
  40659c:	4604      	mov	r4, r0
  40659e:	68fb      	ldr	r3, [r7, #12]
  4065a0:	3304      	adds	r3, #4
  4065a2:	681a      	ldr	r2, [r3, #0]
  4065a4:	68bb      	ldr	r3, [r7, #8]
  4065a6:	3304      	adds	r3, #4
  4065a8:	681b      	ldr	r3, [r3, #0]
  4065aa:	4619      	mov	r1, r3
  4065ac:	4610      	mov	r0, r2
  4065ae:	4b5a      	ldr	r3, [pc, #360]	; (406718 <invn_convert_quat_mult_fxp+0x198>)
  4065b0:	4798      	blx	r3
  4065b2:	4603      	mov	r3, r0
  4065b4:	1ae4      	subs	r4, r4, r3
               inv_icm20948_convert_mult_q30_fxp(quat1_q30[2], quat2_q30[2]) - inv_icm20948_convert_mult_q30_fxp(quat1_q30[3], quat2_q30[3]);
  4065b6:	68fb      	ldr	r3, [r7, #12]
  4065b8:	3308      	adds	r3, #8
  4065ba:	681a      	ldr	r2, [r3, #0]
  4065bc:	68bb      	ldr	r3, [r7, #8]
  4065be:	3308      	adds	r3, #8
  4065c0:	681b      	ldr	r3, [r3, #0]
  4065c2:	4619      	mov	r1, r3
  4065c4:	4610      	mov	r0, r2
  4065c6:	4b54      	ldr	r3, [pc, #336]	; (406718 <invn_convert_quat_mult_fxp+0x198>)
  4065c8:	4798      	blx	r3
  4065ca:	4603      	mov	r3, r0
    quatProd_q30[0] = inv_icm20948_convert_mult_q30_fxp(quat1_q30[0], quat2_q30[0]) - inv_icm20948_convert_mult_q30_fxp(quat1_q30[1], quat2_q30[1]) -
  4065cc:	1ae4      	subs	r4, r4, r3
               inv_icm20948_convert_mult_q30_fxp(quat1_q30[2], quat2_q30[2]) - inv_icm20948_convert_mult_q30_fxp(quat1_q30[3], quat2_q30[3]);
  4065ce:	68fb      	ldr	r3, [r7, #12]
  4065d0:	330c      	adds	r3, #12
  4065d2:	681a      	ldr	r2, [r3, #0]
  4065d4:	68bb      	ldr	r3, [r7, #8]
  4065d6:	330c      	adds	r3, #12
  4065d8:	681b      	ldr	r3, [r3, #0]
  4065da:	4619      	mov	r1, r3
  4065dc:	4610      	mov	r0, r2
  4065de:	4b4e      	ldr	r3, [pc, #312]	; (406718 <invn_convert_quat_mult_fxp+0x198>)
  4065e0:	4798      	blx	r3
  4065e2:	4603      	mov	r3, r0
  4065e4:	1ae2      	subs	r2, r4, r3
    quatProd_q30[0] = inv_icm20948_convert_mult_q30_fxp(quat1_q30[0], quat2_q30[0]) - inv_icm20948_convert_mult_q30_fxp(quat1_q30[1], quat2_q30[1]) -
  4065e6:	687b      	ldr	r3, [r7, #4]
  4065e8:	601a      	str	r2, [r3, #0]

    quatProd_q30[1] = inv_icm20948_convert_mult_q30_fxp(quat1_q30[0], quat2_q30[1]) + inv_icm20948_convert_mult_q30_fxp(quat1_q30[1], quat2_q30[0]) +
  4065ea:	687b      	ldr	r3, [r7, #4]
  4065ec:	1d1c      	adds	r4, r3, #4
  4065ee:	68fb      	ldr	r3, [r7, #12]
  4065f0:	681a      	ldr	r2, [r3, #0]
  4065f2:	68bb      	ldr	r3, [r7, #8]
  4065f4:	3304      	adds	r3, #4
  4065f6:	681b      	ldr	r3, [r3, #0]
  4065f8:	4619      	mov	r1, r3
  4065fa:	4610      	mov	r0, r2
  4065fc:	4b46      	ldr	r3, [pc, #280]	; (406718 <invn_convert_quat_mult_fxp+0x198>)
  4065fe:	4798      	blx	r3
  406600:	4605      	mov	r5, r0
  406602:	68fb      	ldr	r3, [r7, #12]
  406604:	3304      	adds	r3, #4
  406606:	681a      	ldr	r2, [r3, #0]
  406608:	68bb      	ldr	r3, [r7, #8]
  40660a:	681b      	ldr	r3, [r3, #0]
  40660c:	4619      	mov	r1, r3
  40660e:	4610      	mov	r0, r2
  406610:	4b41      	ldr	r3, [pc, #260]	; (406718 <invn_convert_quat_mult_fxp+0x198>)
  406612:	4798      	blx	r3
  406614:	4603      	mov	r3, r0
  406616:	441d      	add	r5, r3
               inv_icm20948_convert_mult_q30_fxp(quat1_q30[2], quat2_q30[3]) - inv_icm20948_convert_mult_q30_fxp(quat1_q30[3], quat2_q30[2]);
  406618:	68fb      	ldr	r3, [r7, #12]
  40661a:	3308      	adds	r3, #8
  40661c:	681a      	ldr	r2, [r3, #0]
  40661e:	68bb      	ldr	r3, [r7, #8]
  406620:	330c      	adds	r3, #12
  406622:	681b      	ldr	r3, [r3, #0]
  406624:	4619      	mov	r1, r3
  406626:	4610      	mov	r0, r2
  406628:	4b3b      	ldr	r3, [pc, #236]	; (406718 <invn_convert_quat_mult_fxp+0x198>)
  40662a:	4798      	blx	r3
  40662c:	4603      	mov	r3, r0
    quatProd_q30[1] = inv_icm20948_convert_mult_q30_fxp(quat1_q30[0], quat2_q30[1]) + inv_icm20948_convert_mult_q30_fxp(quat1_q30[1], quat2_q30[0]) +
  40662e:	441d      	add	r5, r3
               inv_icm20948_convert_mult_q30_fxp(quat1_q30[2], quat2_q30[3]) - inv_icm20948_convert_mult_q30_fxp(quat1_q30[3], quat2_q30[2]);
  406630:	68fb      	ldr	r3, [r7, #12]
  406632:	330c      	adds	r3, #12
  406634:	681a      	ldr	r2, [r3, #0]
  406636:	68bb      	ldr	r3, [r7, #8]
  406638:	3308      	adds	r3, #8
  40663a:	681b      	ldr	r3, [r3, #0]
  40663c:	4619      	mov	r1, r3
  40663e:	4610      	mov	r0, r2
  406640:	4b35      	ldr	r3, [pc, #212]	; (406718 <invn_convert_quat_mult_fxp+0x198>)
  406642:	4798      	blx	r3
  406644:	4603      	mov	r3, r0
  406646:	1aeb      	subs	r3, r5, r3
    quatProd_q30[1] = inv_icm20948_convert_mult_q30_fxp(quat1_q30[0], quat2_q30[1]) + inv_icm20948_convert_mult_q30_fxp(quat1_q30[1], quat2_q30[0]) +
  406648:	6023      	str	r3, [r4, #0]

    quatProd_q30[2] = inv_icm20948_convert_mult_q30_fxp(quat1_q30[0], quat2_q30[2]) - inv_icm20948_convert_mult_q30_fxp(quat1_q30[1], quat2_q30[3]) +
  40664a:	687b      	ldr	r3, [r7, #4]
  40664c:	f103 0408 	add.w	r4, r3, #8
  406650:	68fb      	ldr	r3, [r7, #12]
  406652:	681a      	ldr	r2, [r3, #0]
  406654:	68bb      	ldr	r3, [r7, #8]
  406656:	3308      	adds	r3, #8
  406658:	681b      	ldr	r3, [r3, #0]
  40665a:	4619      	mov	r1, r3
  40665c:	4610      	mov	r0, r2
  40665e:	4b2e      	ldr	r3, [pc, #184]	; (406718 <invn_convert_quat_mult_fxp+0x198>)
  406660:	4798      	blx	r3
  406662:	4605      	mov	r5, r0
  406664:	68fb      	ldr	r3, [r7, #12]
  406666:	3304      	adds	r3, #4
  406668:	681a      	ldr	r2, [r3, #0]
  40666a:	68bb      	ldr	r3, [r7, #8]
  40666c:	330c      	adds	r3, #12
  40666e:	681b      	ldr	r3, [r3, #0]
  406670:	4619      	mov	r1, r3
  406672:	4610      	mov	r0, r2
  406674:	4b28      	ldr	r3, [pc, #160]	; (406718 <invn_convert_quat_mult_fxp+0x198>)
  406676:	4798      	blx	r3
  406678:	4603      	mov	r3, r0
  40667a:	1aed      	subs	r5, r5, r3
               inv_icm20948_convert_mult_q30_fxp(quat1_q30[2], quat2_q30[0]) + inv_icm20948_convert_mult_q30_fxp(quat1_q30[3], quat2_q30[1]);
  40667c:	68fb      	ldr	r3, [r7, #12]
  40667e:	3308      	adds	r3, #8
  406680:	681a      	ldr	r2, [r3, #0]
  406682:	68bb      	ldr	r3, [r7, #8]
  406684:	681b      	ldr	r3, [r3, #0]
  406686:	4619      	mov	r1, r3
  406688:	4610      	mov	r0, r2
  40668a:	4b23      	ldr	r3, [pc, #140]	; (406718 <invn_convert_quat_mult_fxp+0x198>)
  40668c:	4798      	blx	r3
  40668e:	4603      	mov	r3, r0
    quatProd_q30[2] = inv_icm20948_convert_mult_q30_fxp(quat1_q30[0], quat2_q30[2]) - inv_icm20948_convert_mult_q30_fxp(quat1_q30[1], quat2_q30[3]) +
  406690:	441d      	add	r5, r3
               inv_icm20948_convert_mult_q30_fxp(quat1_q30[2], quat2_q30[0]) + inv_icm20948_convert_mult_q30_fxp(quat1_q30[3], quat2_q30[1]);
  406692:	68fb      	ldr	r3, [r7, #12]
  406694:	330c      	adds	r3, #12
  406696:	681a      	ldr	r2, [r3, #0]
  406698:	68bb      	ldr	r3, [r7, #8]
  40669a:	3304      	adds	r3, #4
  40669c:	681b      	ldr	r3, [r3, #0]
  40669e:	4619      	mov	r1, r3
  4066a0:	4610      	mov	r0, r2
  4066a2:	4b1d      	ldr	r3, [pc, #116]	; (406718 <invn_convert_quat_mult_fxp+0x198>)
  4066a4:	4798      	blx	r3
  4066a6:	4603      	mov	r3, r0
  4066a8:	442b      	add	r3, r5
    quatProd_q30[2] = inv_icm20948_convert_mult_q30_fxp(quat1_q30[0], quat2_q30[2]) - inv_icm20948_convert_mult_q30_fxp(quat1_q30[1], quat2_q30[3]) +
  4066aa:	6023      	str	r3, [r4, #0]

    quatProd_q30[3] = inv_icm20948_convert_mult_q30_fxp(quat1_q30[0], quat2_q30[3]) + inv_icm20948_convert_mult_q30_fxp(quat1_q30[1], quat2_q30[2]) -
  4066ac:	687b      	ldr	r3, [r7, #4]
  4066ae:	f103 040c 	add.w	r4, r3, #12
  4066b2:	68fb      	ldr	r3, [r7, #12]
  4066b4:	681a      	ldr	r2, [r3, #0]
  4066b6:	68bb      	ldr	r3, [r7, #8]
  4066b8:	330c      	adds	r3, #12
  4066ba:	681b      	ldr	r3, [r3, #0]
  4066bc:	4619      	mov	r1, r3
  4066be:	4610      	mov	r0, r2
  4066c0:	4b15      	ldr	r3, [pc, #84]	; (406718 <invn_convert_quat_mult_fxp+0x198>)
  4066c2:	4798      	blx	r3
  4066c4:	4605      	mov	r5, r0
  4066c6:	68fb      	ldr	r3, [r7, #12]
  4066c8:	3304      	adds	r3, #4
  4066ca:	681a      	ldr	r2, [r3, #0]
  4066cc:	68bb      	ldr	r3, [r7, #8]
  4066ce:	3308      	adds	r3, #8
  4066d0:	681b      	ldr	r3, [r3, #0]
  4066d2:	4619      	mov	r1, r3
  4066d4:	4610      	mov	r0, r2
  4066d6:	4b10      	ldr	r3, [pc, #64]	; (406718 <invn_convert_quat_mult_fxp+0x198>)
  4066d8:	4798      	blx	r3
  4066da:	4603      	mov	r3, r0
  4066dc:	441d      	add	r5, r3
               inv_icm20948_convert_mult_q30_fxp(quat1_q30[2], quat2_q30[1]) + inv_icm20948_convert_mult_q30_fxp(quat1_q30[3], quat2_q30[0]);
  4066de:	68fb      	ldr	r3, [r7, #12]
  4066e0:	3308      	adds	r3, #8
  4066e2:	681a      	ldr	r2, [r3, #0]
  4066e4:	68bb      	ldr	r3, [r7, #8]
  4066e6:	3304      	adds	r3, #4
  4066e8:	681b      	ldr	r3, [r3, #0]
  4066ea:	4619      	mov	r1, r3
  4066ec:	4610      	mov	r0, r2
  4066ee:	4b0a      	ldr	r3, [pc, #40]	; (406718 <invn_convert_quat_mult_fxp+0x198>)
  4066f0:	4798      	blx	r3
  4066f2:	4603      	mov	r3, r0
    quatProd_q30[3] = inv_icm20948_convert_mult_q30_fxp(quat1_q30[0], quat2_q30[3]) + inv_icm20948_convert_mult_q30_fxp(quat1_q30[1], quat2_q30[2]) -
  4066f4:	1aed      	subs	r5, r5, r3
               inv_icm20948_convert_mult_q30_fxp(quat1_q30[2], quat2_q30[1]) + inv_icm20948_convert_mult_q30_fxp(quat1_q30[3], quat2_q30[0]);
  4066f6:	68fb      	ldr	r3, [r7, #12]
  4066f8:	330c      	adds	r3, #12
  4066fa:	681a      	ldr	r2, [r3, #0]
  4066fc:	68bb      	ldr	r3, [r7, #8]
  4066fe:	681b      	ldr	r3, [r3, #0]
  406700:	4619      	mov	r1, r3
  406702:	4610      	mov	r0, r2
  406704:	4b04      	ldr	r3, [pc, #16]	; (406718 <invn_convert_quat_mult_fxp+0x198>)
  406706:	4798      	blx	r3
  406708:	4603      	mov	r3, r0
  40670a:	442b      	add	r3, r5
    quatProd_q30[3] = inv_icm20948_convert_mult_q30_fxp(quat1_q30[0], quat2_q30[3]) + inv_icm20948_convert_mult_q30_fxp(quat1_q30[1], quat2_q30[2]) -
  40670c:	6023      	str	r3, [r4, #0]
}
  40670e:	bf00      	nop
  406710:	3710      	adds	r7, #16
  406712:	46bd      	mov	sp, r7
  406714:	bdb0      	pop	{r4, r5, r7, pc}
  406716:	bf00      	nop
  406718:	00406ce9 	.word	0x00406ce9

0040671c <invn_convert_quat_invert_fxp>:

static void invn_convert_quat_invert_fxp(const long *quat_q30, long *invQuat_q30)
{
  40671c:	b480      	push	{r7}
  40671e:	b083      	sub	sp, #12
  406720:	af00      	add	r7, sp, #0
  406722:	6078      	str	r0, [r7, #4]
  406724:	6039      	str	r1, [r7, #0]
    invQuat_q30[0] = quat_q30[0];
  406726:	687b      	ldr	r3, [r7, #4]
  406728:	681a      	ldr	r2, [r3, #0]
  40672a:	683b      	ldr	r3, [r7, #0]
  40672c:	601a      	str	r2, [r3, #0]
    invQuat_q30[1] = -quat_q30[1];
  40672e:	683b      	ldr	r3, [r7, #0]
  406730:	3304      	adds	r3, #4
  406732:	687a      	ldr	r2, [r7, #4]
  406734:	3204      	adds	r2, #4
  406736:	6812      	ldr	r2, [r2, #0]
  406738:	4252      	negs	r2, r2
  40673a:	601a      	str	r2, [r3, #0]
    invQuat_q30[2] = -quat_q30[2];
  40673c:	683b      	ldr	r3, [r7, #0]
  40673e:	3308      	adds	r3, #8
  406740:	687a      	ldr	r2, [r7, #4]
  406742:	3208      	adds	r2, #8
  406744:	6812      	ldr	r2, [r2, #0]
  406746:	4252      	negs	r2, r2
  406748:	601a      	str	r2, [r3, #0]
    invQuat_q30[3] = -quat_q30[3];
  40674a:	683b      	ldr	r3, [r7, #0]
  40674c:	330c      	adds	r3, #12
  40674e:	687a      	ldr	r2, [r7, #4]
  406750:	320c      	adds	r2, #12
  406752:	6812      	ldr	r2, [r2, #0]
  406754:	4252      	negs	r2, r2
  406756:	601a      	str	r2, [r3, #0]
}
  406758:	bf00      	nop
  40675a:	370c      	adds	r7, #12
  40675c:	46bd      	mov	sp, r7
  40675e:	f85d 7b04 	ldr.w	r7, [sp], #4
  406762:	4770      	bx	lr

00406764 <inv_icm20948_q_mult_q_qi>:

void inv_icm20948_q_mult_q_qi(const long *q1, const long *q2, long *qProd)
{
  406764:	b5b0      	push	{r4, r5, r7, lr}
  406766:	b084      	sub	sp, #16
  406768:	af00      	add	r7, sp, #0
  40676a:	60f8      	str	r0, [r7, #12]
  40676c:	60b9      	str	r1, [r7, #8]
  40676e:	607a      	str	r2, [r7, #4]
    qProd[0] = inv_icm20948_convert_mult_q30_fxp(q1[0], q2[0]) + inv_icm20948_convert_mult_q30_fxp(q1[1], q2[1]) +
  406770:	68fb      	ldr	r3, [r7, #12]
  406772:	681a      	ldr	r2, [r3, #0]
  406774:	68bb      	ldr	r3, [r7, #8]
  406776:	681b      	ldr	r3, [r3, #0]
  406778:	4619      	mov	r1, r3
  40677a:	4610      	mov	r0, r2
  40677c:	4b5f      	ldr	r3, [pc, #380]	; (4068fc <inv_icm20948_q_mult_q_qi+0x198>)
  40677e:	4798      	blx	r3
  406780:	4604      	mov	r4, r0
  406782:	68fb      	ldr	r3, [r7, #12]
  406784:	3304      	adds	r3, #4
  406786:	681a      	ldr	r2, [r3, #0]
  406788:	68bb      	ldr	r3, [r7, #8]
  40678a:	3304      	adds	r3, #4
  40678c:	681b      	ldr	r3, [r3, #0]
  40678e:	4619      	mov	r1, r3
  406790:	4610      	mov	r0, r2
  406792:	4b5a      	ldr	r3, [pc, #360]	; (4068fc <inv_icm20948_q_mult_q_qi+0x198>)
  406794:	4798      	blx	r3
  406796:	4603      	mov	r3, r0
  406798:	441c      	add	r4, r3
               inv_icm20948_convert_mult_q30_fxp(q1[2], q2[2]) + inv_icm20948_convert_mult_q30_fxp(q1[3], q2[3]);
  40679a:	68fb      	ldr	r3, [r7, #12]
  40679c:	3308      	adds	r3, #8
  40679e:	681a      	ldr	r2, [r3, #0]
  4067a0:	68bb      	ldr	r3, [r7, #8]
  4067a2:	3308      	adds	r3, #8
  4067a4:	681b      	ldr	r3, [r3, #0]
  4067a6:	4619      	mov	r1, r3
  4067a8:	4610      	mov	r0, r2
  4067aa:	4b54      	ldr	r3, [pc, #336]	; (4068fc <inv_icm20948_q_mult_q_qi+0x198>)
  4067ac:	4798      	blx	r3
  4067ae:	4603      	mov	r3, r0
    qProd[0] = inv_icm20948_convert_mult_q30_fxp(q1[0], q2[0]) + inv_icm20948_convert_mult_q30_fxp(q1[1], q2[1]) +
  4067b0:	441c      	add	r4, r3
               inv_icm20948_convert_mult_q30_fxp(q1[2], q2[2]) + inv_icm20948_convert_mult_q30_fxp(q1[3], q2[3]);
  4067b2:	68fb      	ldr	r3, [r7, #12]
  4067b4:	330c      	adds	r3, #12
  4067b6:	681a      	ldr	r2, [r3, #0]
  4067b8:	68bb      	ldr	r3, [r7, #8]
  4067ba:	330c      	adds	r3, #12
  4067bc:	681b      	ldr	r3, [r3, #0]
  4067be:	4619      	mov	r1, r3
  4067c0:	4610      	mov	r0, r2
  4067c2:	4b4e      	ldr	r3, [pc, #312]	; (4068fc <inv_icm20948_q_mult_q_qi+0x198>)
  4067c4:	4798      	blx	r3
  4067c6:	4603      	mov	r3, r0
  4067c8:	18e2      	adds	r2, r4, r3
    qProd[0] = inv_icm20948_convert_mult_q30_fxp(q1[0], q2[0]) + inv_icm20948_convert_mult_q30_fxp(q1[1], q2[1]) +
  4067ca:	687b      	ldr	r3, [r7, #4]
  4067cc:	601a      	str	r2, [r3, #0]

    qProd[1] = -inv_icm20948_convert_mult_q30_fxp(q1[0], q2[1]) + inv_icm20948_convert_mult_q30_fxp(q1[1], q2[0]) -
  4067ce:	687b      	ldr	r3, [r7, #4]
  4067d0:	1d1c      	adds	r4, r3, #4
  4067d2:	68fb      	ldr	r3, [r7, #12]
  4067d4:	3304      	adds	r3, #4
  4067d6:	681a      	ldr	r2, [r3, #0]
  4067d8:	68bb      	ldr	r3, [r7, #8]
  4067da:	681b      	ldr	r3, [r3, #0]
  4067dc:	4619      	mov	r1, r3
  4067de:	4610      	mov	r0, r2
  4067e0:	4b46      	ldr	r3, [pc, #280]	; (4068fc <inv_icm20948_q_mult_q_qi+0x198>)
  4067e2:	4798      	blx	r3
  4067e4:	4605      	mov	r5, r0
  4067e6:	68fb      	ldr	r3, [r7, #12]
  4067e8:	681a      	ldr	r2, [r3, #0]
  4067ea:	68bb      	ldr	r3, [r7, #8]
  4067ec:	3304      	adds	r3, #4
  4067ee:	681b      	ldr	r3, [r3, #0]
  4067f0:	4619      	mov	r1, r3
  4067f2:	4610      	mov	r0, r2
  4067f4:	4b41      	ldr	r3, [pc, #260]	; (4068fc <inv_icm20948_q_mult_q_qi+0x198>)
  4067f6:	4798      	blx	r3
  4067f8:	4603      	mov	r3, r0
  4067fa:	1aed      	subs	r5, r5, r3
               inv_icm20948_convert_mult_q30_fxp(q1[2], q2[3]) + inv_icm20948_convert_mult_q30_fxp(q1[3], q2[2]);
  4067fc:	68fb      	ldr	r3, [r7, #12]
  4067fe:	3308      	adds	r3, #8
  406800:	681a      	ldr	r2, [r3, #0]
  406802:	68bb      	ldr	r3, [r7, #8]
  406804:	330c      	adds	r3, #12
  406806:	681b      	ldr	r3, [r3, #0]
  406808:	4619      	mov	r1, r3
  40680a:	4610      	mov	r0, r2
  40680c:	4b3b      	ldr	r3, [pc, #236]	; (4068fc <inv_icm20948_q_mult_q_qi+0x198>)
  40680e:	4798      	blx	r3
  406810:	4603      	mov	r3, r0
    qProd[1] = -inv_icm20948_convert_mult_q30_fxp(q1[0], q2[1]) + inv_icm20948_convert_mult_q30_fxp(q1[1], q2[0]) -
  406812:	1aed      	subs	r5, r5, r3
               inv_icm20948_convert_mult_q30_fxp(q1[2], q2[3]) + inv_icm20948_convert_mult_q30_fxp(q1[3], q2[2]);
  406814:	68fb      	ldr	r3, [r7, #12]
  406816:	330c      	adds	r3, #12
  406818:	681a      	ldr	r2, [r3, #0]
  40681a:	68bb      	ldr	r3, [r7, #8]
  40681c:	3308      	adds	r3, #8
  40681e:	681b      	ldr	r3, [r3, #0]
  406820:	4619      	mov	r1, r3
  406822:	4610      	mov	r0, r2
  406824:	4b35      	ldr	r3, [pc, #212]	; (4068fc <inv_icm20948_q_mult_q_qi+0x198>)
  406826:	4798      	blx	r3
  406828:	4603      	mov	r3, r0
  40682a:	442b      	add	r3, r5
    qProd[1] = -inv_icm20948_convert_mult_q30_fxp(q1[0], q2[1]) + inv_icm20948_convert_mult_q30_fxp(q1[1], q2[0]) -
  40682c:	6023      	str	r3, [r4, #0]

    qProd[2] = -inv_icm20948_convert_mult_q30_fxp(q1[0], q2[2]) + inv_icm20948_convert_mult_q30_fxp(q1[1], q2[3]) +
  40682e:	687b      	ldr	r3, [r7, #4]
  406830:	f103 0408 	add.w	r4, r3, #8
  406834:	68fb      	ldr	r3, [r7, #12]
  406836:	3304      	adds	r3, #4
  406838:	681a      	ldr	r2, [r3, #0]
  40683a:	68bb      	ldr	r3, [r7, #8]
  40683c:	330c      	adds	r3, #12
  40683e:	681b      	ldr	r3, [r3, #0]
  406840:	4619      	mov	r1, r3
  406842:	4610      	mov	r0, r2
  406844:	4b2d      	ldr	r3, [pc, #180]	; (4068fc <inv_icm20948_q_mult_q_qi+0x198>)
  406846:	4798      	blx	r3
  406848:	4605      	mov	r5, r0
  40684a:	68fb      	ldr	r3, [r7, #12]
  40684c:	681a      	ldr	r2, [r3, #0]
  40684e:	68bb      	ldr	r3, [r7, #8]
  406850:	3308      	adds	r3, #8
  406852:	681b      	ldr	r3, [r3, #0]
  406854:	4619      	mov	r1, r3
  406856:	4610      	mov	r0, r2
  406858:	4b28      	ldr	r3, [pc, #160]	; (4068fc <inv_icm20948_q_mult_q_qi+0x198>)
  40685a:	4798      	blx	r3
  40685c:	4603      	mov	r3, r0
  40685e:	1aed      	subs	r5, r5, r3
               inv_icm20948_convert_mult_q30_fxp(q1[2], q2[0]) - inv_icm20948_convert_mult_q30_fxp(q1[3], q2[1]);
  406860:	68fb      	ldr	r3, [r7, #12]
  406862:	3308      	adds	r3, #8
  406864:	681a      	ldr	r2, [r3, #0]
  406866:	68bb      	ldr	r3, [r7, #8]
  406868:	681b      	ldr	r3, [r3, #0]
  40686a:	4619      	mov	r1, r3
  40686c:	4610      	mov	r0, r2
  40686e:	4b23      	ldr	r3, [pc, #140]	; (4068fc <inv_icm20948_q_mult_q_qi+0x198>)
  406870:	4798      	blx	r3
  406872:	4603      	mov	r3, r0
    qProd[2] = -inv_icm20948_convert_mult_q30_fxp(q1[0], q2[2]) + inv_icm20948_convert_mult_q30_fxp(q1[1], q2[3]) +
  406874:	441d      	add	r5, r3
               inv_icm20948_convert_mult_q30_fxp(q1[2], q2[0]) - inv_icm20948_convert_mult_q30_fxp(q1[3], q2[1]);
  406876:	68fb      	ldr	r3, [r7, #12]
  406878:	330c      	adds	r3, #12
  40687a:	681a      	ldr	r2, [r3, #0]
  40687c:	68bb      	ldr	r3, [r7, #8]
  40687e:	3304      	adds	r3, #4
  406880:	681b      	ldr	r3, [r3, #0]
  406882:	4619      	mov	r1, r3
  406884:	4610      	mov	r0, r2
  406886:	4b1d      	ldr	r3, [pc, #116]	; (4068fc <inv_icm20948_q_mult_q_qi+0x198>)
  406888:	4798      	blx	r3
  40688a:	4603      	mov	r3, r0
  40688c:	1aeb      	subs	r3, r5, r3
    qProd[2] = -inv_icm20948_convert_mult_q30_fxp(q1[0], q2[2]) + inv_icm20948_convert_mult_q30_fxp(q1[1], q2[3]) +
  40688e:	6023      	str	r3, [r4, #0]

    qProd[3] = -inv_icm20948_convert_mult_q30_fxp(q1[0], q2[3]) - inv_icm20948_convert_mult_q30_fxp(q1[1], q2[2]) +
  406890:	687b      	ldr	r3, [r7, #4]
  406892:	f103 040c 	add.w	r4, r3, #12
  406896:	68fb      	ldr	r3, [r7, #12]
  406898:	681a      	ldr	r2, [r3, #0]
  40689a:	68bb      	ldr	r3, [r7, #8]
  40689c:	330c      	adds	r3, #12
  40689e:	681b      	ldr	r3, [r3, #0]
  4068a0:	4619      	mov	r1, r3
  4068a2:	4610      	mov	r0, r2
  4068a4:	4b15      	ldr	r3, [pc, #84]	; (4068fc <inv_icm20948_q_mult_q_qi+0x198>)
  4068a6:	4798      	blx	r3
  4068a8:	4603      	mov	r3, r0
  4068aa:	425d      	negs	r5, r3
  4068ac:	68fb      	ldr	r3, [r7, #12]
  4068ae:	3304      	adds	r3, #4
  4068b0:	681a      	ldr	r2, [r3, #0]
  4068b2:	68bb      	ldr	r3, [r7, #8]
  4068b4:	3308      	adds	r3, #8
  4068b6:	681b      	ldr	r3, [r3, #0]
  4068b8:	4619      	mov	r1, r3
  4068ba:	4610      	mov	r0, r2
  4068bc:	4b0f      	ldr	r3, [pc, #60]	; (4068fc <inv_icm20948_q_mult_q_qi+0x198>)
  4068be:	4798      	blx	r3
  4068c0:	4603      	mov	r3, r0
  4068c2:	1aed      	subs	r5, r5, r3
               inv_icm20948_convert_mult_q30_fxp(q1[2], q2[1]) + inv_icm20948_convert_mult_q30_fxp(q1[3], q2[0]);
  4068c4:	68fb      	ldr	r3, [r7, #12]
  4068c6:	3308      	adds	r3, #8
  4068c8:	681a      	ldr	r2, [r3, #0]
  4068ca:	68bb      	ldr	r3, [r7, #8]
  4068cc:	3304      	adds	r3, #4
  4068ce:	681b      	ldr	r3, [r3, #0]
  4068d0:	4619      	mov	r1, r3
  4068d2:	4610      	mov	r0, r2
  4068d4:	4b09      	ldr	r3, [pc, #36]	; (4068fc <inv_icm20948_q_mult_q_qi+0x198>)
  4068d6:	4798      	blx	r3
  4068d8:	4603      	mov	r3, r0
    qProd[3] = -inv_icm20948_convert_mult_q30_fxp(q1[0], q2[3]) - inv_icm20948_convert_mult_q30_fxp(q1[1], q2[2]) +
  4068da:	441d      	add	r5, r3
               inv_icm20948_convert_mult_q30_fxp(q1[2], q2[1]) + inv_icm20948_convert_mult_q30_fxp(q1[3], q2[0]);
  4068dc:	68fb      	ldr	r3, [r7, #12]
  4068de:	330c      	adds	r3, #12
  4068e0:	681a      	ldr	r2, [r3, #0]
  4068e2:	68bb      	ldr	r3, [r7, #8]
  4068e4:	681b      	ldr	r3, [r3, #0]
  4068e6:	4619      	mov	r1, r3
  4068e8:	4610      	mov	r0, r2
  4068ea:	4b04      	ldr	r3, [pc, #16]	; (4068fc <inv_icm20948_q_mult_q_qi+0x198>)
  4068ec:	4798      	blx	r3
  4068ee:	4603      	mov	r3, r0
  4068f0:	442b      	add	r3, r5
    qProd[3] = -inv_icm20948_convert_mult_q30_fxp(q1[0], q2[3]) - inv_icm20948_convert_mult_q30_fxp(q1[1], q2[2]) +
  4068f2:	6023      	str	r3, [r4, #0]
}
  4068f4:	bf00      	nop
  4068f6:	3710      	adds	r7, #16
  4068f8:	46bd      	mov	sp, r7
  4068fa:	bdb0      	pop	{r4, r5, r7, pc}
  4068fc:	00406ce9 	.word	0x00406ce9

00406900 <inv_icm20948_convert_quat_rotate_fxp>:

void inv_icm20948_convert_quat_rotate_fxp(const long *quat_q30, const long *in, long *out)
{
  406900:	b580      	push	{r7, lr}
  406902:	b094      	sub	sp, #80	; 0x50
  406904:	af00      	add	r7, sp, #0
  406906:	60f8      	str	r0, [r7, #12]
  406908:	60b9      	str	r1, [r7, #8]
  40690a:	607a      	str	r2, [r7, #4]
    long q_temp1[4], q_temp2[4];
    long in4[4], out4[4];

    // Fixme optimize
    in4[0] = 0;
  40690c:	2300      	movs	r3, #0
  40690e:	623b      	str	r3, [r7, #32]
    memcpy(&in4[1], in, 3 * sizeof(long));
  406910:	f107 0320 	add.w	r3, r7, #32
  406914:	3304      	adds	r3, #4
  406916:	220c      	movs	r2, #12
  406918:	68b9      	ldr	r1, [r7, #8]
  40691a:	4618      	mov	r0, r3
  40691c:	4b12      	ldr	r3, [pc, #72]	; (406968 <inv_icm20948_convert_quat_rotate_fxp+0x68>)
  40691e:	4798      	blx	r3
    invn_convert_quat_mult_fxp(quat_q30, in4, q_temp1);
  406920:	f107 0240 	add.w	r2, r7, #64	; 0x40
  406924:	f107 0320 	add.w	r3, r7, #32
  406928:	4619      	mov	r1, r3
  40692a:	68f8      	ldr	r0, [r7, #12]
  40692c:	4b0f      	ldr	r3, [pc, #60]	; (40696c <inv_icm20948_convert_quat_rotate_fxp+0x6c>)
  40692e:	4798      	blx	r3
    invn_convert_quat_invert_fxp(quat_q30, q_temp2);
  406930:	f107 0330 	add.w	r3, r7, #48	; 0x30
  406934:	4619      	mov	r1, r3
  406936:	68f8      	ldr	r0, [r7, #12]
  406938:	4b0d      	ldr	r3, [pc, #52]	; (406970 <inv_icm20948_convert_quat_rotate_fxp+0x70>)
  40693a:	4798      	blx	r3
    invn_convert_quat_mult_fxp(q_temp1, q_temp2, out4);
  40693c:	f107 0210 	add.w	r2, r7, #16
  406940:	f107 0130 	add.w	r1, r7, #48	; 0x30
  406944:	f107 0340 	add.w	r3, r7, #64	; 0x40
  406948:	4618      	mov	r0, r3
  40694a:	4b08      	ldr	r3, [pc, #32]	; (40696c <inv_icm20948_convert_quat_rotate_fxp+0x6c>)
  40694c:	4798      	blx	r3
    memcpy(out, &out4[1], 3 * sizeof(long));
  40694e:	f107 0310 	add.w	r3, r7, #16
  406952:	3304      	adds	r3, #4
  406954:	220c      	movs	r2, #12
  406956:	4619      	mov	r1, r3
  406958:	6878      	ldr	r0, [r7, #4]
  40695a:	4b03      	ldr	r3, [pc, #12]	; (406968 <inv_icm20948_convert_quat_rotate_fxp+0x68>)
  40695c:	4798      	blx	r3
}
  40695e:	bf00      	nop
  406960:	3750      	adds	r7, #80	; 0x50
  406962:	46bd      	mov	sp, r7
  406964:	bd80      	pop	{r7, pc}
  406966:	bf00      	nop
  406968:	00414045 	.word	0x00414045
  40696c:	00406581 	.word	0x00406581
  406970:	0040671d 	.word	0x0040671d

00406974 <inv_icm20948_set_chip_to_body>:

/** Set the transformation used for chip to body frame
*/
void inv_icm20948_set_chip_to_body(struct inv_icm20948 * s, long *quat)
{
  406974:	b580      	push	{r7, lr}
  406976:	b082      	sub	sp, #8
  406978:	af00      	add	r7, sp, #0
  40697a:	6078      	str	r0, [r7, #4]
  40697c:	6039      	str	r1, [r7, #0]
    memcpy(s->s_quat_chip_to_body, quat, sizeof(s->s_quat_chip_to_body));
  40697e:	687b      	ldr	r3, [r7, #4]
  406980:	33a8      	adds	r3, #168	; 0xa8
  406982:	2210      	movs	r2, #16
  406984:	6839      	ldr	r1, [r7, #0]
  406986:	4618      	mov	r0, r3
  406988:	4b02      	ldr	r3, [pc, #8]	; (406994 <inv_icm20948_set_chip_to_body+0x20>)
  40698a:	4798      	blx	r3
}
  40698c:	bf00      	nop
  40698e:	3708      	adds	r7, #8
  406990:	46bd      	mov	sp, r7
  406992:	bd80      	pop	{r7, pc}
  406994:	00414045 	.word	0x00414045

00406998 <inv_icm20948_convert_rotation_vector>:
/** Convert fixed point DMP rotation vector to floating point android notation
* @param[in] quat 3 element rotation vector from DMP, missing the scalar part. Converts from Chip frame to World frame
* @param[out] values 4 element quaternion in Android format
*/
void inv_icm20948_convert_rotation_vector(struct inv_icm20948 * s, const long *quat, float *values)
{
  406998:	b580      	push	{r7, lr}
  40699a:	b08c      	sub	sp, #48	; 0x30
  40699c:	af00      	add	r7, sp, #0
  40699e:	60f8      	str	r0, [r7, #12]
  4069a0:	60b9      	str	r1, [r7, #8]
  4069a2:	607a      	str	r2, [r7, #4]
    long quat4[4];
    long quat_body_to_world[4];

    inv_icm20948_convert_compute_scalar_part_fxp(quat, quat4);
  4069a4:	f107 0320 	add.w	r3, r7, #32
  4069a8:	4619      	mov	r1, r3
  4069aa:	68b8      	ldr	r0, [r7, #8]
  4069ac:	4b3e      	ldr	r3, [pc, #248]	; (406aa8 <inv_icm20948_convert_rotation_vector+0x110>)
  4069ae:	4798      	blx	r3
    inv_icm20948_q_mult_q_qi(quat4, s->s_quat_chip_to_body, quat_body_to_world);
  4069b0:	68fb      	ldr	r3, [r7, #12]
  4069b2:	f103 01a8 	add.w	r1, r3, #168	; 0xa8
  4069b6:	f107 0210 	add.w	r2, r7, #16
  4069ba:	f107 0320 	add.w	r3, r7, #32
  4069be:	4618      	mov	r0, r3
  4069c0:	4b3a      	ldr	r3, [pc, #232]	; (406aac <inv_icm20948_convert_rotation_vector+0x114>)
  4069c2:	4798      	blx	r3
    if (quat_body_to_world[0] >= 0) {
  4069c4:	693b      	ldr	r3, [r7, #16]
  4069c6:	2b00      	cmp	r3, #0
  4069c8:	db33      	blt.n	406a32 <inv_icm20948_convert_rotation_vector+0x9a>
        values[0] = quat_body_to_world[1] * INV_TWO_POWER_NEG_30;
  4069ca:	697b      	ldr	r3, [r7, #20]
  4069cc:	ee07 3a90 	vmov	s15, r3
  4069d0:	eef8 7ae7 	vcvt.f32.s32	s15, s15
  4069d4:	ed9f 7a36 	vldr	s14, [pc, #216]	; 406ab0 <inv_icm20948_convert_rotation_vector+0x118>
  4069d8:	ee67 7a87 	vmul.f32	s15, s15, s14
  4069dc:	687b      	ldr	r3, [r7, #4]
  4069de:	edc3 7a00 	vstr	s15, [r3]
        values[1] = quat_body_to_world[2] * INV_TWO_POWER_NEG_30;
  4069e2:	687b      	ldr	r3, [r7, #4]
  4069e4:	3304      	adds	r3, #4
  4069e6:	69ba      	ldr	r2, [r7, #24]
  4069e8:	ee07 2a90 	vmov	s15, r2
  4069ec:	eef8 7ae7 	vcvt.f32.s32	s15, s15
  4069f0:	ed9f 7a2f 	vldr	s14, [pc, #188]	; 406ab0 <inv_icm20948_convert_rotation_vector+0x118>
  4069f4:	ee67 7a87 	vmul.f32	s15, s15, s14
  4069f8:	edc3 7a00 	vstr	s15, [r3]
        values[2] = quat_body_to_world[3] * INV_TWO_POWER_NEG_30;
  4069fc:	687b      	ldr	r3, [r7, #4]
  4069fe:	3308      	adds	r3, #8
  406a00:	69fa      	ldr	r2, [r7, #28]
  406a02:	ee07 2a90 	vmov	s15, r2
  406a06:	eef8 7ae7 	vcvt.f32.s32	s15, s15
  406a0a:	ed9f 7a29 	vldr	s14, [pc, #164]	; 406ab0 <inv_icm20948_convert_rotation_vector+0x118>
  406a0e:	ee67 7a87 	vmul.f32	s15, s15, s14
  406a12:	edc3 7a00 	vstr	s15, [r3]
        values[3] = quat_body_to_world[0] * INV_TWO_POWER_NEG_30;
  406a16:	687b      	ldr	r3, [r7, #4]
  406a18:	330c      	adds	r3, #12
  406a1a:	693a      	ldr	r2, [r7, #16]
  406a1c:	ee07 2a90 	vmov	s15, r2
  406a20:	eef8 7ae7 	vcvt.f32.s32	s15, s15
  406a24:	ed9f 7a22 	vldr	s14, [pc, #136]	; 406ab0 <inv_icm20948_convert_rotation_vector+0x118>
  406a28:	ee67 7a87 	vmul.f32	s15, s15, s14
  406a2c:	edc3 7a00 	vstr	s15, [r3]
        values[0] = -quat_body_to_world[1] * INV_TWO_POWER_NEG_30;
        values[1] = -quat_body_to_world[2] * INV_TWO_POWER_NEG_30;
        values[2] = -quat_body_to_world[3] * INV_TWO_POWER_NEG_30;
        values[3] = -quat_body_to_world[0] * INV_TWO_POWER_NEG_30;
    }
}
  406a30:	e036      	b.n	406aa0 <inv_icm20948_convert_rotation_vector+0x108>
        values[0] = -quat_body_to_world[1] * INV_TWO_POWER_NEG_30;
  406a32:	697b      	ldr	r3, [r7, #20]
  406a34:	425b      	negs	r3, r3
  406a36:	ee07 3a90 	vmov	s15, r3
  406a3a:	eef8 7ae7 	vcvt.f32.s32	s15, s15
  406a3e:	ed9f 7a1c 	vldr	s14, [pc, #112]	; 406ab0 <inv_icm20948_convert_rotation_vector+0x118>
  406a42:	ee67 7a87 	vmul.f32	s15, s15, s14
  406a46:	687b      	ldr	r3, [r7, #4]
  406a48:	edc3 7a00 	vstr	s15, [r3]
        values[1] = -quat_body_to_world[2] * INV_TWO_POWER_NEG_30;
  406a4c:	687b      	ldr	r3, [r7, #4]
  406a4e:	3304      	adds	r3, #4
  406a50:	69ba      	ldr	r2, [r7, #24]
  406a52:	4252      	negs	r2, r2
  406a54:	ee07 2a90 	vmov	s15, r2
  406a58:	eef8 7ae7 	vcvt.f32.s32	s15, s15
  406a5c:	ed9f 7a14 	vldr	s14, [pc, #80]	; 406ab0 <inv_icm20948_convert_rotation_vector+0x118>
  406a60:	ee67 7a87 	vmul.f32	s15, s15, s14
  406a64:	edc3 7a00 	vstr	s15, [r3]
        values[2] = -quat_body_to_world[3] * INV_TWO_POWER_NEG_30;
  406a68:	687b      	ldr	r3, [r7, #4]
  406a6a:	3308      	adds	r3, #8
  406a6c:	69fa      	ldr	r2, [r7, #28]
  406a6e:	4252      	negs	r2, r2
  406a70:	ee07 2a90 	vmov	s15, r2
  406a74:	eef8 7ae7 	vcvt.f32.s32	s15, s15
  406a78:	ed9f 7a0d 	vldr	s14, [pc, #52]	; 406ab0 <inv_icm20948_convert_rotation_vector+0x118>
  406a7c:	ee67 7a87 	vmul.f32	s15, s15, s14
  406a80:	edc3 7a00 	vstr	s15, [r3]
        values[3] = -quat_body_to_world[0] * INV_TWO_POWER_NEG_30;
  406a84:	687b      	ldr	r3, [r7, #4]
  406a86:	330c      	adds	r3, #12
  406a88:	693a      	ldr	r2, [r7, #16]
  406a8a:	4252      	negs	r2, r2
  406a8c:	ee07 2a90 	vmov	s15, r2
  406a90:	eef8 7ae7 	vcvt.f32.s32	s15, s15
  406a94:	ed9f 7a06 	vldr	s14, [pc, #24]	; 406ab0 <inv_icm20948_convert_rotation_vector+0x118>
  406a98:	ee67 7a87 	vmul.f32	s15, s15, s14
  406a9c:	edc3 7a00 	vstr	s15, [r3]
}
  406aa0:	bf00      	nop
  406aa2:	3730      	adds	r7, #48	; 0x30
  406aa4:	46bd      	mov	sp, r7
  406aa6:	bd80      	pop	{r7, pc}
  406aa8:	00406d35 	.word	0x00406d35
  406aac:	00406765 	.word	0x00406765
  406ab0:	30800000 	.word	0x30800000

00406ab4 <inv_rotation_to_quaternion>:
        values[2] = -quat4_world[3] * INV_TWO_POWER_NEG_30;
        values[3] = -quat4_world[0] * INV_TWO_POWER_NEG_30;
    }
}

static void inv_rotation_to_quaternion(float Rcb[9], long Qcb_fp[4]) {	
  406ab4:	b580      	push	{r7, lr}
  406ab6:	b088      	sub	sp, #32
  406ab8:	af00      	add	r7, sp, #0
  406aba:	6078      	str	r0, [r7, #4]
  406abc:	6039      	str	r1, [r7, #0]
	float q[4]; 
	inv_icm20948_convert_matrix_to_quat_flt(Rcb, q); 
  406abe:	f107 030c 	add.w	r3, r7, #12
  406ac2:	4619      	mov	r1, r3
  406ac4:	6878      	ldr	r0, [r7, #4]
  406ac6:	4b1c      	ldr	r3, [pc, #112]	; (406b38 <inv_rotation_to_quaternion+0x84>)
  406ac8:	4798      	blx	r3
	INVN_CONVERT_FLT_TO_FXP(q, Qcb_fp, 4, 30); 
  406aca:	2300      	movs	r3, #0
  406acc:	61fb      	str	r3, [r7, #28]
  406ace:	e02b      	b.n	406b28 <inv_rotation_to_quaternion+0x74>
  406ad0:	69fb      	ldr	r3, [r7, #28]
  406ad2:	009b      	lsls	r3, r3, #2
  406ad4:	683a      	ldr	r2, [r7, #0]
  406ad6:	4413      	add	r3, r2
  406ad8:	69fa      	ldr	r2, [r7, #28]
  406ada:	0092      	lsls	r2, r2, #2
  406adc:	f107 0120 	add.w	r1, r7, #32
  406ae0:	440a      	add	r2, r1
  406ae2:	3a14      	subs	r2, #20
  406ae4:	edd2 7a00 	vldr	s15, [r2]
  406ae8:	ed9f 7a14 	vldr	s14, [pc, #80]	; 406b3c <inv_rotation_to_quaternion+0x88>
  406aec:	ee27 7a87 	vmul.f32	s14, s15, s14
  406af0:	69fa      	ldr	r2, [r7, #28]
  406af2:	0092      	lsls	r2, r2, #2
  406af4:	f107 0120 	add.w	r1, r7, #32
  406af8:	440a      	add	r2, r1
  406afa:	3a14      	subs	r2, #20
  406afc:	edd2 7a00 	vldr	s15, [r2]
  406b00:	eef5 7ac0 	vcmpe.f32	s15, #0.0
  406b04:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
  406b08:	db02      	blt.n	406b10 <inv_rotation_to_quaternion+0x5c>
  406b0a:	eef6 7a00 	vmov.f32	s15, #96	; 0x3f000000  0.5
  406b0e:	e001      	b.n	406b14 <inv_rotation_to_quaternion+0x60>
  406b10:	eefe 7a00 	vmov.f32	s15, #224	; 0xbf000000 -0.5
  406b14:	ee77 7a27 	vadd.f32	s15, s14, s15
  406b18:	eefd 7ae7 	vcvt.s32.f32	s15, s15
  406b1c:	ee17 2a90 	vmov	r2, s15
  406b20:	601a      	str	r2, [r3, #0]
  406b22:	69fb      	ldr	r3, [r7, #28]
  406b24:	3301      	adds	r3, #1
  406b26:	61fb      	str	r3, [r7, #28]
  406b28:	69fb      	ldr	r3, [r7, #28]
  406b2a:	2b03      	cmp	r3, #3
  406b2c:	ddd0      	ble.n	406ad0 <inv_rotation_to_quaternion+0x1c>
}
  406b2e:	bf00      	nop
  406b30:	3720      	adds	r7, #32
  406b32:	46bd      	mov	sp, r7
  406b34:	bd80      	pop	{r7, pc}
  406b36:	bf00      	nop
  406b38:	004070a5 	.word	0x004070a5
  406b3c:	4e800000 	.word	0x4e800000

00406b40 <inv_icm20948_set_chip_to_body_axis_quaternion>:

void inv_icm20948_set_chip_to_body_axis_quaternion(struct inv_icm20948 * s, signed char *accel_gyro_matrix, float angle)
{
  406b40:	b580      	push	{r7, lr}
  406b42:	b09a      	sub	sp, #104	; 0x68
  406b44:	af00      	add	r7, sp, #0
  406b46:	60f8      	str	r0, [r7, #12]
  406b48:	60b9      	str	r1, [r7, #8]
  406b4a:	ed87 0a01 	vstr	s0, [r7, #4]
    int i;
    float rot[9];
    long qcb[4],q_all[4];
    long q_adjust[4];
    for (i=0; i<9; i++) {
  406b4e:	2300      	movs	r3, #0
  406b50:	667b      	str	r3, [r7, #100]	; 0x64
  406b52:	e013      	b.n	406b7c <inv_icm20948_set_chip_to_body_axis_quaternion+0x3c>
        rot[i] = (float)accel_gyro_matrix[i];
  406b54:	6e7b      	ldr	r3, [r7, #100]	; 0x64
  406b56:	68ba      	ldr	r2, [r7, #8]
  406b58:	4413      	add	r3, r2
  406b5a:	f993 3000 	ldrsb.w	r3, [r3]
  406b5e:	ee07 3a90 	vmov	s15, r3
  406b62:	eef8 7ae7 	vcvt.f32.s32	s15, s15
  406b66:	6e7b      	ldr	r3, [r7, #100]	; 0x64
  406b68:	009b      	lsls	r3, r3, #2
  406b6a:	f107 0268 	add.w	r2, r7, #104	; 0x68
  406b6e:	4413      	add	r3, r2
  406b70:	3b28      	subs	r3, #40	; 0x28
  406b72:	edc3 7a00 	vstr	s15, [r3]
    for (i=0; i<9; i++) {
  406b76:	6e7b      	ldr	r3, [r7, #100]	; 0x64
  406b78:	3301      	adds	r3, #1
  406b7a:	667b      	str	r3, [r7, #100]	; 0x64
  406b7c:	6e7b      	ldr	r3, [r7, #100]	; 0x64
  406b7e:	2b08      	cmp	r3, #8
  406b80:	dde8      	ble.n	406b54 <inv_icm20948_set_chip_to_body_axis_quaternion+0x14>
    }
    // Convert Chip to Body transformation matrix to quaternion
    // inv_icm20948_convert_matrix_to_quat_fxp(rot, qcb);
	inv_rotation_to_quaternion(rot, qcb);
  406b82:	f107 0230 	add.w	r2, r7, #48	; 0x30
  406b86:	f107 0340 	add.w	r3, r7, #64	; 0x40
  406b8a:	4611      	mov	r1, r2
  406b8c:	4618      	mov	r0, r3
  406b8e:	4b30      	ldr	r3, [pc, #192]	; (406c50 <inv_icm20948_set_chip_to_body_axis_quaternion+0x110>)
  406b90:	4798      	blx	r3
	
    // The quaterion generated is the inverse, take the inverse again.
    qcb[1] = -qcb[1];
  406b92:	6b7b      	ldr	r3, [r7, #52]	; 0x34
  406b94:	425b      	negs	r3, r3
  406b96:	637b      	str	r3, [r7, #52]	; 0x34
    qcb[2] = -qcb[2];
  406b98:	6bbb      	ldr	r3, [r7, #56]	; 0x38
  406b9a:	425b      	negs	r3, r3
  406b9c:	63bb      	str	r3, [r7, #56]	; 0x38
    qcb[3] = -qcb[3];
  406b9e:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
  406ba0:	425b      	negs	r3, r3
  406ba2:	63fb      	str	r3, [r7, #60]	; 0x3c

    // Now rotate by angle, negate angle to rotate other way
    q_adjust[0] = (long)((1L<<30) * cosf(-angle*(float)M_PI/180.f/2.f));
  406ba4:	edd7 7a01 	vldr	s15, [r7, #4]
  406ba8:	eef1 7a67 	vneg.f32	s15, s15
  406bac:	ed9f 7a29 	vldr	s14, [pc, #164]	; 406c54 <inv_icm20948_set_chip_to_body_axis_quaternion+0x114>
  406bb0:	ee27 7a87 	vmul.f32	s14, s15, s14
  406bb4:	eddf 6a28 	vldr	s13, [pc, #160]	; 406c58 <inv_icm20948_set_chip_to_body_axis_quaternion+0x118>
  406bb8:	eec7 7a26 	vdiv.f32	s15, s14, s13
  406bbc:	eeb0 7a00 	vmov.f32	s14, #0	; 0x40000000  2.0
  406bc0:	eec7 6a87 	vdiv.f32	s13, s15, s14
  406bc4:	eeb0 0a66 	vmov.f32	s0, s13
  406bc8:	4b24      	ldr	r3, [pc, #144]	; (406c5c <inv_icm20948_set_chip_to_body_axis_quaternion+0x11c>)
  406bca:	4798      	blx	r3
  406bcc:	eeb0 7a40 	vmov.f32	s14, s0
  406bd0:	eddf 7a23 	vldr	s15, [pc, #140]	; 406c60 <inv_icm20948_set_chip_to_body_axis_quaternion+0x120>
  406bd4:	ee67 7a27 	vmul.f32	s15, s14, s15
  406bd8:	eefd 7ae7 	vcvt.s32.f32	s15, s15
  406bdc:	ee17 3a90 	vmov	r3, s15
  406be0:	613b      	str	r3, [r7, #16]
    q_adjust[1] = 0;
  406be2:	2300      	movs	r3, #0
  406be4:	617b      	str	r3, [r7, #20]
    q_adjust[2] = (long)((1L<<30)*sinf(-angle*(float)M_PI/180.f/2.f));
  406be6:	edd7 7a01 	vldr	s15, [r7, #4]
  406bea:	eef1 7a67 	vneg.f32	s15, s15
  406bee:	ed9f 7a19 	vldr	s14, [pc, #100]	; 406c54 <inv_icm20948_set_chip_to_body_axis_quaternion+0x114>
  406bf2:	ee27 7a87 	vmul.f32	s14, s15, s14
  406bf6:	eddf 6a18 	vldr	s13, [pc, #96]	; 406c58 <inv_icm20948_set_chip_to_body_axis_quaternion+0x118>
  406bfa:	eec7 7a26 	vdiv.f32	s15, s14, s13
  406bfe:	eeb0 7a00 	vmov.f32	s14, #0	; 0x40000000  2.0
  406c02:	eec7 6a87 	vdiv.f32	s13, s15, s14
  406c06:	eeb0 0a66 	vmov.f32	s0, s13
  406c0a:	4b16      	ldr	r3, [pc, #88]	; (406c64 <inv_icm20948_set_chip_to_body_axis_quaternion+0x124>)
  406c0c:	4798      	blx	r3
  406c0e:	eeb0 7a40 	vmov.f32	s14, s0
  406c12:	eddf 7a13 	vldr	s15, [pc, #76]	; 406c60 <inv_icm20948_set_chip_to_body_axis_quaternion+0x120>
  406c16:	ee67 7a27 	vmul.f32	s15, s14, s15
  406c1a:	eefd 7ae7 	vcvt.s32.f32	s15, s15
  406c1e:	ee17 3a90 	vmov	r3, s15
  406c22:	61bb      	str	r3, [r7, #24]
    q_adjust[3] = 0;
  406c24:	2300      	movs	r3, #0
  406c26:	61fb      	str	r3, [r7, #28]
    invn_convert_quat_mult_fxp(q_adjust, qcb, q_all);
  406c28:	f107 0220 	add.w	r2, r7, #32
  406c2c:	f107 0130 	add.w	r1, r7, #48	; 0x30
  406c30:	f107 0310 	add.w	r3, r7, #16
  406c34:	4618      	mov	r0, r3
  406c36:	4b0c      	ldr	r3, [pc, #48]	; (406c68 <inv_icm20948_set_chip_to_body_axis_quaternion+0x128>)
  406c38:	4798      	blx	r3
    inv_icm20948_set_chip_to_body(s, q_all);
  406c3a:	f107 0320 	add.w	r3, r7, #32
  406c3e:	4619      	mov	r1, r3
  406c40:	68f8      	ldr	r0, [r7, #12]
  406c42:	4b0a      	ldr	r3, [pc, #40]	; (406c6c <inv_icm20948_set_chip_to_body_axis_quaternion+0x12c>)
  406c44:	4798      	blx	r3
}
  406c46:	bf00      	nop
  406c48:	3768      	adds	r7, #104	; 0x68
  406c4a:	46bd      	mov	sp, r7
  406c4c:	bd80      	pop	{r7, pc}
  406c4e:	bf00      	nop
  406c50:	00406ab5 	.word	0x00406ab5
  406c54:	40490fdb 	.word	0x40490fdb
  406c58:	43340000 	.word	0x43340000
  406c5c:	0041262d 	.word	0x0041262d
  406c60:	4e800000 	.word	0x4e800000
  406c64:	004126bd 	.word	0x004126bd
  406c68:	00406581 	.word	0x00406581
  406c6c:	00406975 	.word	0x00406975

00406c70 <inv_icm20948_convert_dmp3_to_body>:

void inv_icm20948_convert_dmp3_to_body(struct inv_icm20948 * s, const long *vec3, float scale, float *values)
{
  406c70:	b580      	push	{r7, lr}
  406c72:	b088      	sub	sp, #32
  406c74:	af00      	add	r7, sp, #0
  406c76:	60f8      	str	r0, [r7, #12]
  406c78:	60b9      	str	r1, [r7, #8]
  406c7a:	ed87 0a01 	vstr	s0, [r7, #4]
  406c7e:	603a      	str	r2, [r7, #0]
    long out[3];
    inv_icm20948_convert_quat_rotate_fxp(s->s_quat_chip_to_body, vec3, out);
  406c80:	68fb      	ldr	r3, [r7, #12]
  406c82:	33a8      	adds	r3, #168	; 0xa8
  406c84:	f107 0214 	add.w	r2, r7, #20
  406c88:	68b9      	ldr	r1, [r7, #8]
  406c8a:	4618      	mov	r0, r3
  406c8c:	4b15      	ldr	r3, [pc, #84]	; (406ce4 <inv_icm20948_convert_dmp3_to_body+0x74>)
  406c8e:	4798      	blx	r3
    values[0] = out[0] * scale;
  406c90:	697b      	ldr	r3, [r7, #20]
  406c92:	ee07 3a90 	vmov	s15, r3
  406c96:	eeb8 7ae7 	vcvt.f32.s32	s14, s15
  406c9a:	edd7 7a01 	vldr	s15, [r7, #4]
  406c9e:	ee67 7a27 	vmul.f32	s15, s14, s15
  406ca2:	683b      	ldr	r3, [r7, #0]
  406ca4:	edc3 7a00 	vstr	s15, [r3]
    values[1] = out[1] * scale;
  406ca8:	683b      	ldr	r3, [r7, #0]
  406caa:	3304      	adds	r3, #4
  406cac:	69ba      	ldr	r2, [r7, #24]
  406cae:	ee07 2a90 	vmov	s15, r2
  406cb2:	eeb8 7ae7 	vcvt.f32.s32	s14, s15
  406cb6:	edd7 7a01 	vldr	s15, [r7, #4]
  406cba:	ee67 7a27 	vmul.f32	s15, s14, s15
  406cbe:	edc3 7a00 	vstr	s15, [r3]
    values[2] = out[2] * scale;
  406cc2:	683b      	ldr	r3, [r7, #0]
  406cc4:	3308      	adds	r3, #8
  406cc6:	69fa      	ldr	r2, [r7, #28]
  406cc8:	ee07 2a90 	vmov	s15, r2
  406ccc:	eeb8 7ae7 	vcvt.f32.s32	s14, s15
  406cd0:	edd7 7a01 	vldr	s15, [r7, #4]
  406cd4:	ee67 7a27 	vmul.f32	s15, s14, s15
  406cd8:	edc3 7a00 	vstr	s15, [r3]
}
  406cdc:	bf00      	nop
  406cde:	3720      	adds	r7, #32
  406ce0:	46bd      	mov	sp, r7
  406ce2:	bd80      	pop	{r7, pc}
  406ce4:	00406901 	.word	0x00406901

00406ce8 <inv_icm20948_convert_mult_q30_fxp>:
    rad_val = deg_val*(float)M_PI / 180.f;
	return rad_val;
}

long inv_icm20948_convert_mult_q30_fxp(long a_q30, long b_q30)
{
  406ce8:	b5f0      	push	{r4, r5, r6, r7, lr}
  406cea:	b087      	sub	sp, #28
  406cec:	af00      	add	r7, sp, #0
  406cee:	6078      	str	r0, [r7, #4]
  406cf0:	6039      	str	r1, [r7, #0]
	long long temp;
	long result;
	temp = (long long)a_q30 * b_q30;
  406cf2:	687a      	ldr	r2, [r7, #4]
  406cf4:	4615      	mov	r5, r2
  406cf6:	ea4f 76e5 	mov.w	r6, r5, asr #31
  406cfa:	683a      	ldr	r2, [r7, #0]
  406cfc:	4611      	mov	r1, r2
  406cfe:	ea4f 72e1 	mov.w	r2, r1, asr #31
  406d02:	fb01 fe06 	mul.w	lr, r1, r6
  406d06:	fb05 f002 	mul.w	r0, r5, r2
  406d0a:	4470      	add	r0, lr
  406d0c:	fba5 1201 	umull	r1, r2, r5, r1
  406d10:	4410      	add	r0, r2
  406d12:	4602      	mov	r2, r0
  406d14:	e9c7 1204 	strd	r1, r2, [r7, #16]
  406d18:	e9c7 1204 	strd	r1, r2, [r7, #16]
	result = (long)(temp >> 30);
  406d1c:	e9d7 1204 	ldrd	r1, r2, [r7, #16]
  406d20:	0f8b      	lsrs	r3, r1, #30
  406d22:	ea43 0382 	orr.w	r3, r3, r2, lsl #2
  406d26:	1794      	asrs	r4, r2, #30
  406d28:	60fb      	str	r3, [r7, #12]
	return result;
  406d2a:	68fb      	ldr	r3, [r7, #12]
}
  406d2c:	4618      	mov	r0, r3
  406d2e:	371c      	adds	r7, #28
  406d30:	46bd      	mov	sp, r7
  406d32:	bdf0      	pop	{r4, r5, r6, r7, pc}

00406d34 <inv_icm20948_convert_compute_scalar_part_fxp>:

int inv_icm20948_convert_compute_scalar_part_fxp(const long * inQuat_q30, long* outQuat_q30)
{
  406d34:	b590      	push	{r4, r7, lr}
  406d36:	b085      	sub	sp, #20
  406d38:	af00      	add	r7, sp, #0
  406d3a:	6078      	str	r0, [r7, #4]
  406d3c:	6039      	str	r1, [r7, #0]
    long scalarPart = 0;
  406d3e:	2300      	movs	r3, #0
  406d40:	60fb      	str	r3, [r7, #12]

    scalarPart = inv_icm20948_convert_fast_sqrt_fxp((1L<<30) - inv_icm20948_convert_mult_q30_fxp(inQuat_q30[0], inQuat_q30[0])
  406d42:	687b      	ldr	r3, [r7, #4]
  406d44:	681a      	ldr	r2, [r3, #0]
  406d46:	687b      	ldr	r3, [r7, #4]
  406d48:	681b      	ldr	r3, [r3, #0]
  406d4a:	4619      	mov	r1, r3
  406d4c:	4610      	mov	r0, r2
  406d4e:	4b1c      	ldr	r3, [pc, #112]	; (406dc0 <inv_icm20948_convert_compute_scalar_part_fxp+0x8c>)
  406d50:	4798      	blx	r3
  406d52:	4603      	mov	r3, r0
  406d54:	f1c3 4480 	rsb	r4, r3, #1073741824	; 0x40000000
                                        - inv_icm20948_convert_mult_q30_fxp(inQuat_q30[1], inQuat_q30[1])
  406d58:	687b      	ldr	r3, [r7, #4]
  406d5a:	3304      	adds	r3, #4
  406d5c:	681a      	ldr	r2, [r3, #0]
  406d5e:	687b      	ldr	r3, [r7, #4]
  406d60:	3304      	adds	r3, #4
  406d62:	681b      	ldr	r3, [r3, #0]
  406d64:	4619      	mov	r1, r3
  406d66:	4610      	mov	r0, r2
  406d68:	4b15      	ldr	r3, [pc, #84]	; (406dc0 <inv_icm20948_convert_compute_scalar_part_fxp+0x8c>)
  406d6a:	4798      	blx	r3
  406d6c:	4603      	mov	r3, r0
  406d6e:	1ae4      	subs	r4, r4, r3
                                        - inv_icm20948_convert_mult_q30_fxp(inQuat_q30[2], inQuat_q30[2]) );
  406d70:	687b      	ldr	r3, [r7, #4]
  406d72:	3308      	adds	r3, #8
  406d74:	681a      	ldr	r2, [r3, #0]
  406d76:	687b      	ldr	r3, [r7, #4]
  406d78:	3308      	adds	r3, #8
  406d7a:	681b      	ldr	r3, [r3, #0]
  406d7c:	4619      	mov	r1, r3
  406d7e:	4610      	mov	r0, r2
  406d80:	4b0f      	ldr	r3, [pc, #60]	; (406dc0 <inv_icm20948_convert_compute_scalar_part_fxp+0x8c>)
  406d82:	4798      	blx	r3
  406d84:	4603      	mov	r3, r0
    scalarPart = inv_icm20948_convert_fast_sqrt_fxp((1L<<30) - inv_icm20948_convert_mult_q30_fxp(inQuat_q30[0], inQuat_q30[0])
  406d86:	1ae3      	subs	r3, r4, r3
  406d88:	4618      	mov	r0, r3
  406d8a:	4b0e      	ldr	r3, [pc, #56]	; (406dc4 <inv_icm20948_convert_compute_scalar_part_fxp+0x90>)
  406d8c:	4798      	blx	r3
  406d8e:	60f8      	str	r0, [r7, #12]
    outQuat_q30[0] = scalarPart;
  406d90:	683b      	ldr	r3, [r7, #0]
  406d92:	68fa      	ldr	r2, [r7, #12]
  406d94:	601a      	str	r2, [r3, #0]
    outQuat_q30[1] = inQuat_q30[0];
  406d96:	683b      	ldr	r3, [r7, #0]
  406d98:	3304      	adds	r3, #4
  406d9a:	687a      	ldr	r2, [r7, #4]
  406d9c:	6812      	ldr	r2, [r2, #0]
  406d9e:	601a      	str	r2, [r3, #0]
    outQuat_q30[2] = inQuat_q30[1];
  406da0:	683b      	ldr	r3, [r7, #0]
  406da2:	3308      	adds	r3, #8
  406da4:	687a      	ldr	r2, [r7, #4]
  406da6:	6852      	ldr	r2, [r2, #4]
  406da8:	601a      	str	r2, [r3, #0]
    outQuat_q30[3] = inQuat_q30[2];
  406daa:	683b      	ldr	r3, [r7, #0]
  406dac:	330c      	adds	r3, #12
  406dae:	687a      	ldr	r2, [r7, #4]
  406db0:	6892      	ldr	r2, [r2, #8]
  406db2:	601a      	str	r2, [r3, #0]

    return 0;
  406db4:	2300      	movs	r3, #0
}
  406db6:	4618      	mov	r0, r3
  406db8:	3714      	adds	r7, #20
  406dba:	46bd      	mov	sp, r7
  406dbc:	bd90      	pop	{r4, r7, pc}
  406dbe:	bf00      	nop
  406dc0:	00406ce9 	.word	0x00406ce9
  406dc4:	00406dc9 	.word	0x00406dc9

00406dc8 <inv_icm20948_convert_fast_sqrt_fxp>:

long inv_icm20948_convert_fast_sqrt_fxp(long x0_q30)
{
  406dc8:	b590      	push	{r4, r7, lr}
  406dca:	b08b      	sub	sp, #44	; 0x2c
  406dcc:	af00      	add	r7, sp, #0
  406dce:	6078      	str	r0, [r7, #4]
	long sqrt2, oneoversqrt2, one_pt5;
	long xx, cc;
	int pow2, sq2scale, nr_iters;

	// Return if input is zero. Negative should really error out. 
	if (x0_q30 <= 0L) {
  406dd0:	687b      	ldr	r3, [r7, #4]
  406dd2:	2b00      	cmp	r3, #0
  406dd4:	dc01      	bgt.n	406dda <inv_icm20948_convert_fast_sqrt_fxp+0x12>
		return 0L;
  406dd6:	2300      	movs	r3, #0
  406dd8:	e080      	b.n	406edc <inv_icm20948_convert_fast_sqrt_fxp+0x114>
	}

	sqrt2 =1518500250L;
  406dda:	4b42      	ldr	r3, [pc, #264]	; (406ee4 <inv_icm20948_convert_fast_sqrt_fxp+0x11c>)
  406ddc:	61fb      	str	r3, [r7, #28]
	oneoversqrt2=759250125L;
  406dde:	4b42      	ldr	r3, [pc, #264]	; (406ee8 <inv_icm20948_convert_fast_sqrt_fxp+0x120>)
  406de0:	61bb      	str	r3, [r7, #24]
	one_pt5=1610612736L;
  406de2:	f04f 43c0 	mov.w	r3, #1610612736	; 0x60000000
  406de6:	617b      	str	r3, [r7, #20]

	nr_iters = inv_icm20948_convert_test_limits_and_scale_fxp(&x0_q30, &pow2);
  406de8:	f107 0208 	add.w	r2, r7, #8
  406dec:	1d3b      	adds	r3, r7, #4
  406dee:	4611      	mov	r1, r2
  406df0:	4618      	mov	r0, r3
  406df2:	4b3e      	ldr	r3, [pc, #248]	; (406eec <inv_icm20948_convert_fast_sqrt_fxp+0x124>)
  406df4:	4798      	blx	r3
  406df6:	6138      	str	r0, [r7, #16]
	
	sq2scale = 0;
  406df8:	2300      	movs	r3, #0
  406dfa:	623b      	str	r3, [r7, #32]
	if (pow2 > 0) 
  406dfc:	68bb      	ldr	r3, [r7, #8]
  406dfe:	2b00      	cmp	r3, #0
  406e00:	dd06      	ble.n	406e10 <inv_icm20948_convert_fast_sqrt_fxp+0x48>
		sq2scale=pow2%2;  // Find remainder. Is it even or odd?
  406e02:	68bb      	ldr	r3, [r7, #8]
  406e04:	2b00      	cmp	r3, #0
  406e06:	f003 0301 	and.w	r3, r3, #1
  406e0a:	bfb8      	it	lt
  406e0c:	425b      	neglt	r3, r3
  406e0e:	623b      	str	r3, [r7, #32]
	pow2 = pow2-sq2scale; // Now pow2 is even. Note we are adding because result is scaled with sqrt(2)
  406e10:	68ba      	ldr	r2, [r7, #8]
  406e12:	6a3b      	ldr	r3, [r7, #32]
  406e14:	1ad3      	subs	r3, r2, r3
  406e16:	60bb      	str	r3, [r7, #8]

	// Sqrt 1st NR iteration
	cc = x0_q30 - (1L<<30);
  406e18:	687b      	ldr	r3, [r7, #4]
  406e1a:	f103 4340 	add.w	r3, r3, #3221225472	; 0xc0000000
  406e1e:	60fb      	str	r3, [r7, #12]
	xx = x0_q30 - (inv_icm20948_convert_mult_q30_fxp(x0_q30, cc)>>1);
  406e20:	687c      	ldr	r4, [r7, #4]
  406e22:	687b      	ldr	r3, [r7, #4]
  406e24:	68f9      	ldr	r1, [r7, #12]
  406e26:	4618      	mov	r0, r3
  406e28:	4b31      	ldr	r3, [pc, #196]	; (406ef0 <inv_icm20948_convert_fast_sqrt_fxp+0x128>)
  406e2a:	4798      	blx	r3
  406e2c:	4603      	mov	r3, r0
  406e2e:	105b      	asrs	r3, r3, #1
  406e30:	1ae3      	subs	r3, r4, r3
  406e32:	627b      	str	r3, [r7, #36]	; 0x24
 	if ( nr_iters>=2 ) {
  406e34:	693b      	ldr	r3, [r7, #16]
  406e36:	2b01      	cmp	r3, #1
  406e38:	dd34      	ble.n	406ea4 <inv_icm20948_convert_fast_sqrt_fxp+0xdc>
		// Sqrt second NR iteration
		// cc = cc*cc*(cc-3)/4; = cc*cc*(cc/2 - 3/2)/2;
		// cc = ( cc*cc*((cc>>1) - onePt5) ) >> 1
		cc = inv_icm20948_convert_mult_q30_fxp( cc, inv_icm20948_convert_mult_q30_fxp(cc, (cc>>1) - one_pt5) ) >> 1;
  406e3a:	68fb      	ldr	r3, [r7, #12]
  406e3c:	105a      	asrs	r2, r3, #1
  406e3e:	697b      	ldr	r3, [r7, #20]
  406e40:	1ad3      	subs	r3, r2, r3
  406e42:	4619      	mov	r1, r3
  406e44:	68f8      	ldr	r0, [r7, #12]
  406e46:	4b2a      	ldr	r3, [pc, #168]	; (406ef0 <inv_icm20948_convert_fast_sqrt_fxp+0x128>)
  406e48:	4798      	blx	r3
  406e4a:	4603      	mov	r3, r0
  406e4c:	4619      	mov	r1, r3
  406e4e:	68f8      	ldr	r0, [r7, #12]
  406e50:	4b27      	ldr	r3, [pc, #156]	; (406ef0 <inv_icm20948_convert_fast_sqrt_fxp+0x128>)
  406e52:	4798      	blx	r3
  406e54:	4603      	mov	r3, r0
  406e56:	105b      	asrs	r3, r3, #1
  406e58:	60fb      	str	r3, [r7, #12]
		xx = xx - (inv_icm20948_convert_mult_q30_fxp(xx, cc)>>1);
  406e5a:	68f9      	ldr	r1, [r7, #12]
  406e5c:	6a78      	ldr	r0, [r7, #36]	; 0x24
  406e5e:	4b24      	ldr	r3, [pc, #144]	; (406ef0 <inv_icm20948_convert_fast_sqrt_fxp+0x128>)
  406e60:	4798      	blx	r3
  406e62:	4603      	mov	r3, r0
  406e64:	105b      	asrs	r3, r3, #1
  406e66:	6a7a      	ldr	r2, [r7, #36]	; 0x24
  406e68:	1ad3      	subs	r3, r2, r3
  406e6a:	627b      	str	r3, [r7, #36]	; 0x24
		if ( nr_iters==3 ) {
  406e6c:	693b      	ldr	r3, [r7, #16]
  406e6e:	2b03      	cmp	r3, #3
  406e70:	d118      	bne.n	406ea4 <inv_icm20948_convert_fast_sqrt_fxp+0xdc>
			// Sqrt third NR iteration
			cc = inv_icm20948_convert_mult_q30_fxp( cc, inv_icm20948_convert_mult_q30_fxp(cc, (cc>>1) - one_pt5) ) >> 1;
  406e72:	68fb      	ldr	r3, [r7, #12]
  406e74:	105a      	asrs	r2, r3, #1
  406e76:	697b      	ldr	r3, [r7, #20]
  406e78:	1ad3      	subs	r3, r2, r3
  406e7a:	4619      	mov	r1, r3
  406e7c:	68f8      	ldr	r0, [r7, #12]
  406e7e:	4b1c      	ldr	r3, [pc, #112]	; (406ef0 <inv_icm20948_convert_fast_sqrt_fxp+0x128>)
  406e80:	4798      	blx	r3
  406e82:	4603      	mov	r3, r0
  406e84:	4619      	mov	r1, r3
  406e86:	68f8      	ldr	r0, [r7, #12]
  406e88:	4b19      	ldr	r3, [pc, #100]	; (406ef0 <inv_icm20948_convert_fast_sqrt_fxp+0x128>)
  406e8a:	4798      	blx	r3
  406e8c:	4603      	mov	r3, r0
  406e8e:	105b      	asrs	r3, r3, #1
  406e90:	60fb      	str	r3, [r7, #12]
			xx = xx - (inv_icm20948_convert_mult_q30_fxp(xx, cc)>>1);
  406e92:	68f9      	ldr	r1, [r7, #12]
  406e94:	6a78      	ldr	r0, [r7, #36]	; 0x24
  406e96:	4b16      	ldr	r3, [pc, #88]	; (406ef0 <inv_icm20948_convert_fast_sqrt_fxp+0x128>)
  406e98:	4798      	blx	r3
  406e9a:	4603      	mov	r3, r0
  406e9c:	105b      	asrs	r3, r3, #1
  406e9e:	6a7a      	ldr	r2, [r7, #36]	; 0x24
  406ea0:	1ad3      	subs	r3, r2, r3
  406ea2:	627b      	str	r3, [r7, #36]	; 0x24
		}
	}
	if (sq2scale)
  406ea4:	6a3b      	ldr	r3, [r7, #32]
  406ea6:	2b00      	cmp	r3, #0
  406ea8:	d004      	beq.n	406eb4 <inv_icm20948_convert_fast_sqrt_fxp+0xec>
		xx = inv_icm20948_convert_mult_q30_fxp(xx,oneoversqrt2);
  406eaa:	69b9      	ldr	r1, [r7, #24]
  406eac:	6a78      	ldr	r0, [r7, #36]	; 0x24
  406eae:	4b10      	ldr	r3, [pc, #64]	; (406ef0 <inv_icm20948_convert_fast_sqrt_fxp+0x128>)
  406eb0:	4798      	blx	r3
  406eb2:	6278      	str	r0, [r7, #36]	; 0x24
	// Scale the number with the half of the power of 2 scaling
	if (pow2>0)
  406eb4:	68bb      	ldr	r3, [r7, #8]
  406eb6:	2b00      	cmp	r3, #0
  406eb8:	dd06      	ble.n	406ec8 <inv_icm20948_convert_fast_sqrt_fxp+0x100>
		xx = (xx >> (pow2>>1)); 
  406eba:	68bb      	ldr	r3, [r7, #8]
  406ebc:	105b      	asrs	r3, r3, #1
  406ebe:	6a7a      	ldr	r2, [r7, #36]	; 0x24
  406ec0:	fa42 f303 	asr.w	r3, r2, r3
  406ec4:	627b      	str	r3, [r7, #36]	; 0x24
  406ec6:	e008      	b.n	406eda <inv_icm20948_convert_fast_sqrt_fxp+0x112>
	else if (pow2 == -1)
  406ec8:	68bb      	ldr	r3, [r7, #8]
  406eca:	f1b3 3fff 	cmp.w	r3, #4294967295
  406ece:	d104      	bne.n	406eda <inv_icm20948_convert_fast_sqrt_fxp+0x112>
		xx = inv_icm20948_convert_mult_q30_fxp(xx,sqrt2);
  406ed0:	69f9      	ldr	r1, [r7, #28]
  406ed2:	6a78      	ldr	r0, [r7, #36]	; 0x24
  406ed4:	4b06      	ldr	r3, [pc, #24]	; (406ef0 <inv_icm20948_convert_fast_sqrt_fxp+0x128>)
  406ed6:	4798      	blx	r3
  406ed8:	6278      	str	r0, [r7, #36]	; 0x24
	return xx;
  406eda:	6a7b      	ldr	r3, [r7, #36]	; 0x24
}
  406edc:	4618      	mov	r0, r3
  406ede:	372c      	adds	r7, #44	; 0x2c
  406ee0:	46bd      	mov	sp, r7
  406ee2:	bd90      	pop	{r4, r7, pc}
  406ee4:	5a82799a 	.word	0x5a82799a
  406ee8:	2d413ccd 	.word	0x2d413ccd
  406eec:	00406ef5 	.word	0x00406ef5
  406ef0:	00406ce9 	.word	0x00406ce9

00406ef4 <inv_icm20948_convert_test_limits_and_scale_fxp>:

int inv_icm20948_convert_test_limits_and_scale_fxp(long *x0_q30, int *pow)
{
  406ef4:	b580      	push	{r7, lr}
  406ef6:	b088      	sub	sp, #32
  406ef8:	af00      	add	r7, sp, #0
  406efa:	6078      	str	r0, [r7, #4]
  406efc:	6039      	str	r1, [r7, #0]
    long lowerlimit, upperlimit, oneiterlothr, oneiterhithr, zeroiterlothr, zeroiterhithr;

    // Lower Limit: ll = int32(log(2)*2^30);
    lowerlimit = 744261118L;
  406efe:	4b33      	ldr	r3, [pc, #204]	; (406fcc <inv_icm20948_convert_test_limits_and_scale_fxp+0xd8>)
  406f00:	61fb      	str	r3, [r7, #28]
    //Upper Limit ul = int32(log(4)*2^30);
    upperlimit = 1488522236L;
  406f02:	4b33      	ldr	r3, [pc, #204]	; (406fd0 <inv_icm20948_convert_test_limits_and_scale_fxp+0xdc>)
  406f04:	61bb      	str	r3, [r7, #24]
    //  int32(0.9*2^30)
    oneiterlothr = 966367642L;
  406f06:	4b33      	ldr	r3, [pc, #204]	; (406fd4 <inv_icm20948_convert_test_limits_and_scale_fxp+0xe0>)
  406f08:	617b      	str	r3, [r7, #20]
    // int32(1.1*2^30)
    oneiterhithr = 1181116006L;
  406f0a:	4b33      	ldr	r3, [pc, #204]	; (406fd8 <inv_icm20948_convert_test_limits_and_scale_fxp+0xe4>)
  406f0c:	613b      	str	r3, [r7, #16]
    // int32(0.99*2^30)
    zeroiterlothr=1063004406L;
  406f0e:	4b33      	ldr	r3, [pc, #204]	; (406fdc <inv_icm20948_convert_test_limits_and_scale_fxp+0xe8>)
  406f10:	60fb      	str	r3, [r7, #12]
    //int32(1.01*2^30)
    zeroiterhithr=1084479242L;
  406f12:	4b33      	ldr	r3, [pc, #204]	; (406fe0 <inv_icm20948_convert_test_limits_and_scale_fxp+0xec>)
  406f14:	60bb      	str	r3, [r7, #8]

    // Scale number such that Newton Raphson iteration works best:
    // Find the power of two scaling that leaves the number in the optimal range,
    // ll <= number <= ul. Note odd powers have special scaling further below
	if (*x0_q30 > upperlimit) {
  406f16:	687b      	ldr	r3, [r7, #4]
  406f18:	681a      	ldr	r2, [r3, #0]
  406f1a:	69bb      	ldr	r3, [r7, #24]
  406f1c:	429a      	cmp	r2, r3
  406f1e:	dd09      	ble.n	406f34 <inv_icm20948_convert_test_limits_and_scale_fxp+0x40>
		// Halving the number will push it in the optimal range since largest value is 2
		*x0_q30 = *x0_q30>>1;
  406f20:	687b      	ldr	r3, [r7, #4]
  406f22:	681b      	ldr	r3, [r3, #0]
  406f24:	105a      	asrs	r2, r3, #1
  406f26:	687b      	ldr	r3, [r7, #4]
  406f28:	601a      	str	r2, [r3, #0]
		*pow=-1;
  406f2a:	683b      	ldr	r3, [r7, #0]
  406f2c:	f04f 32ff 	mov.w	r2, #4294967295
  406f30:	601a      	str	r2, [r3, #0]
  406f32:	e02e      	b.n	406f92 <inv_icm20948_convert_test_limits_and_scale_fxp+0x9e>
	} else if (*x0_q30 < lowerlimit) {
  406f34:	687b      	ldr	r3, [r7, #4]
  406f36:	681a      	ldr	r2, [r3, #0]
  406f38:	69fb      	ldr	r3, [r7, #28]
  406f3a:	429a      	cmp	r2, r3
  406f3c:	da26      	bge.n	406f8c <inv_icm20948_convert_test_limits_and_scale_fxp+0x98>
		// Find position of highest bit, counting from left, and scale number 
		*pow=inv_icm20948_convert_get_highest_bit_position((uint32_t*)x0_q30);
  406f3e:	6878      	ldr	r0, [r7, #4]
  406f40:	4b28      	ldr	r3, [pc, #160]	; (406fe4 <inv_icm20948_convert_test_limits_and_scale_fxp+0xf0>)
  406f42:	4798      	blx	r3
  406f44:	4603      	mov	r3, r0
  406f46:	461a      	mov	r2, r3
  406f48:	683b      	ldr	r3, [r7, #0]
  406f4a:	601a      	str	r2, [r3, #0]
		if (*x0_q30 >= upperlimit) {
  406f4c:	687b      	ldr	r3, [r7, #4]
  406f4e:	681a      	ldr	r2, [r3, #0]
  406f50:	69bb      	ldr	r3, [r7, #24]
  406f52:	429a      	cmp	r2, r3
  406f54:	db0a      	blt.n	406f6c <inv_icm20948_convert_test_limits_and_scale_fxp+0x78>
			// Halving the number will push it in the optimal range
			*x0_q30 = *x0_q30>>1;
  406f56:	687b      	ldr	r3, [r7, #4]
  406f58:	681b      	ldr	r3, [r3, #0]
  406f5a:	105a      	asrs	r2, r3, #1
  406f5c:	687b      	ldr	r3, [r7, #4]
  406f5e:	601a      	str	r2, [r3, #0]
			*pow=*pow-1;
  406f60:	683b      	ldr	r3, [r7, #0]
  406f62:	681b      	ldr	r3, [r3, #0]
  406f64:	1e5a      	subs	r2, r3, #1
  406f66:	683b      	ldr	r3, [r7, #0]
  406f68:	601a      	str	r2, [r3, #0]
  406f6a:	e012      	b.n	406f92 <inv_icm20948_convert_test_limits_and_scale_fxp+0x9e>
		}
		else if (*x0_q30 < lowerlimit) {
  406f6c:	687b      	ldr	r3, [r7, #4]
  406f6e:	681a      	ldr	r2, [r3, #0]
  406f70:	69fb      	ldr	r3, [r7, #28]
  406f72:	429a      	cmp	r2, r3
  406f74:	da0d      	bge.n	406f92 <inv_icm20948_convert_test_limits_and_scale_fxp+0x9e>
			// Doubling the number will push it in the optimal range
			*x0_q30 = *x0_q30<<1;
  406f76:	687b      	ldr	r3, [r7, #4]
  406f78:	681b      	ldr	r3, [r3, #0]
  406f7a:	005a      	lsls	r2, r3, #1
  406f7c:	687b      	ldr	r3, [r7, #4]
  406f7e:	601a      	str	r2, [r3, #0]
			*pow=*pow+1;
  406f80:	683b      	ldr	r3, [r7, #0]
  406f82:	681b      	ldr	r3, [r3, #0]
  406f84:	1c5a      	adds	r2, r3, #1
  406f86:	683b      	ldr	r3, [r7, #0]
  406f88:	601a      	str	r2, [r3, #0]
  406f8a:	e002      	b.n	406f92 <inv_icm20948_convert_test_limits_and_scale_fxp+0x9e>
		}
	} else {
		*pow = 0;
  406f8c:	683b      	ldr	r3, [r7, #0]
  406f8e:	2200      	movs	r2, #0
  406f90:	601a      	str	r2, [r3, #0]
	}
    
    if ( *x0_q30<oneiterlothr || *x0_q30>oneiterhithr )
  406f92:	687b      	ldr	r3, [r7, #4]
  406f94:	681a      	ldr	r2, [r3, #0]
  406f96:	697b      	ldr	r3, [r7, #20]
  406f98:	429a      	cmp	r2, r3
  406f9a:	db04      	blt.n	406fa6 <inv_icm20948_convert_test_limits_and_scale_fxp+0xb2>
  406f9c:	687b      	ldr	r3, [r7, #4]
  406f9e:	681a      	ldr	r2, [r3, #0]
  406fa0:	693b      	ldr	r3, [r7, #16]
  406fa2:	429a      	cmp	r2, r3
  406fa4:	dd01      	ble.n	406faa <inv_icm20948_convert_test_limits_and_scale_fxp+0xb6>
        return 3; // 3 NR iterations
  406fa6:	2303      	movs	r3, #3
  406fa8:	e00c      	b.n	406fc4 <inv_icm20948_convert_test_limits_and_scale_fxp+0xd0>
    if ( *x0_q30<zeroiterlothr || *x0_q30>zeroiterhithr )
  406faa:	687b      	ldr	r3, [r7, #4]
  406fac:	681a      	ldr	r2, [r3, #0]
  406fae:	68fb      	ldr	r3, [r7, #12]
  406fb0:	429a      	cmp	r2, r3
  406fb2:	db04      	blt.n	406fbe <inv_icm20948_convert_test_limits_and_scale_fxp+0xca>
  406fb4:	687b      	ldr	r3, [r7, #4]
  406fb6:	681a      	ldr	r2, [r3, #0]
  406fb8:	68bb      	ldr	r3, [r7, #8]
  406fba:	429a      	cmp	r2, r3
  406fbc:	dd01      	ble.n	406fc2 <inv_icm20948_convert_test_limits_and_scale_fxp+0xce>
        return 2; // 2 NR iteration
  406fbe:	2302      	movs	r3, #2
  406fc0:	e000      	b.n	406fc4 <inv_icm20948_convert_test_limits_and_scale_fxp+0xd0>

    return 1; // 1 NR iteration
  406fc2:	2301      	movs	r3, #1
}
  406fc4:	4618      	mov	r0, r3
  406fc6:	3720      	adds	r7, #32
  406fc8:	46bd      	mov	sp, r7
  406fca:	bd80      	pop	{r7, pc}
  406fcc:	2c5c85fe 	.word	0x2c5c85fe
  406fd0:	58b90bfc 	.word	0x58b90bfc
  406fd4:	3999999a 	.word	0x3999999a
  406fd8:	46666666 	.word	0x46666666
  406fdc:	3f5c28f6 	.word	0x3f5c28f6
  406fe0:	40a3d70a 	.word	0x40a3d70a
  406fe4:	00406fe9 	.word	0x00406fe9

00406fe8 <inv_icm20948_convert_get_highest_bit_position>:
* @return highest bit position.
* \note This function performs the log2 of an interger as well. 
* \ingroup binary
**/
int16_t inv_icm20948_convert_get_highest_bit_position(uint32_t *value)
{
  406fe8:	b480      	push	{r7}
  406fea:	b085      	sub	sp, #20
  406fec:	af00      	add	r7, sp, #0
  406fee:	6078      	str	r0, [r7, #4]
    int16_t position;
    position = 0;
  406ff0:	2300      	movs	r3, #0
  406ff2:	81fb      	strh	r3, [r7, #14]
    if (*value == 0) return 0;
  406ff4:	687b      	ldr	r3, [r7, #4]
  406ff6:	681b      	ldr	r3, [r3, #0]
  406ff8:	2b00      	cmp	r3, #0
  406ffa:	d101      	bne.n	407000 <inv_icm20948_convert_get_highest_bit_position+0x18>
  406ffc:	2300      	movs	r3, #0
  406ffe:	e04a      	b.n	407096 <inv_icm20948_convert_get_highest_bit_position+0xae>

    if ((*value & 0xFFFF0000) == 0) {
  407000:	687b      	ldr	r3, [r7, #4]
  407002:	681b      	ldr	r3, [r3, #0]
  407004:	0c1b      	lsrs	r3, r3, #16
  407006:	041b      	lsls	r3, r3, #16
  407008:	2b00      	cmp	r3, #0
  40700a:	d108      	bne.n	40701e <inv_icm20948_convert_get_highest_bit_position+0x36>
        position += 16;
  40700c:	89fb      	ldrh	r3, [r7, #14]
  40700e:	3310      	adds	r3, #16
  407010:	b29b      	uxth	r3, r3
  407012:	81fb      	strh	r3, [r7, #14]
        *value=*value<<16;
  407014:	687b      	ldr	r3, [r7, #4]
  407016:	681b      	ldr	r3, [r3, #0]
  407018:	041a      	lsls	r2, r3, #16
  40701a:	687b      	ldr	r3, [r7, #4]
  40701c:	601a      	str	r2, [r3, #0]
    }
    if ((*value & 0xFF000000) == 0) {
  40701e:	687b      	ldr	r3, [r7, #4]
  407020:	681b      	ldr	r3, [r3, #0]
  407022:	f003 437f 	and.w	r3, r3, #4278190080	; 0xff000000
  407026:	2b00      	cmp	r3, #0
  407028:	d108      	bne.n	40703c <inv_icm20948_convert_get_highest_bit_position+0x54>
        position += 8;
  40702a:	89fb      	ldrh	r3, [r7, #14]
  40702c:	3308      	adds	r3, #8
  40702e:	b29b      	uxth	r3, r3
  407030:	81fb      	strh	r3, [r7, #14]
        *value=*value<<8;
  407032:	687b      	ldr	r3, [r7, #4]
  407034:	681b      	ldr	r3, [r3, #0]
  407036:	021a      	lsls	r2, r3, #8
  407038:	687b      	ldr	r3, [r7, #4]
  40703a:	601a      	str	r2, [r3, #0]
    }
    if ((*value & 0xF0000000) == 0) {
  40703c:	687b      	ldr	r3, [r7, #4]
  40703e:	681b      	ldr	r3, [r3, #0]
  407040:	f003 4370 	and.w	r3, r3, #4026531840	; 0xf0000000
  407044:	2b00      	cmp	r3, #0
  407046:	d108      	bne.n	40705a <inv_icm20948_convert_get_highest_bit_position+0x72>
        position += 4;
  407048:	89fb      	ldrh	r3, [r7, #14]
  40704a:	3304      	adds	r3, #4
  40704c:	b29b      	uxth	r3, r3
  40704e:	81fb      	strh	r3, [r7, #14]
        *value=*value<<4;
  407050:	687b      	ldr	r3, [r7, #4]
  407052:	681b      	ldr	r3, [r3, #0]
  407054:	011a      	lsls	r2, r3, #4
  407056:	687b      	ldr	r3, [r7, #4]
  407058:	601a      	str	r2, [r3, #0]
    }
    if ((*value & 0xC0000000) == 0) {
  40705a:	687b      	ldr	r3, [r7, #4]
  40705c:	681b      	ldr	r3, [r3, #0]
  40705e:	f003 4340 	and.w	r3, r3, #3221225472	; 0xc0000000
  407062:	2b00      	cmp	r3, #0
  407064:	d108      	bne.n	407078 <inv_icm20948_convert_get_highest_bit_position+0x90>
        position += 2;
  407066:	89fb      	ldrh	r3, [r7, #14]
  407068:	3302      	adds	r3, #2
  40706a:	b29b      	uxth	r3, r3
  40706c:	81fb      	strh	r3, [r7, #14]
        *value=*value<<2;
  40706e:	687b      	ldr	r3, [r7, #4]
  407070:	681b      	ldr	r3, [r3, #0]
  407072:	009a      	lsls	r2, r3, #2
  407074:	687b      	ldr	r3, [r7, #4]
  407076:	601a      	str	r2, [r3, #0]
    }

    // If we got too far into sign bit, shift back. Note we are using an
    // unsigned long here, so right shift is going to shift all the bits.
    if ((*value & 0x80000000)) { 
  407078:	687b      	ldr	r3, [r7, #4]
  40707a:	681b      	ldr	r3, [r3, #0]
  40707c:	2b00      	cmp	r3, #0
  40707e:	da08      	bge.n	407092 <inv_icm20948_convert_get_highest_bit_position+0xaa>
        position -= 1;
  407080:	89fb      	ldrh	r3, [r7, #14]
  407082:	3b01      	subs	r3, #1
  407084:	b29b      	uxth	r3, r3
  407086:	81fb      	strh	r3, [r7, #14]
        *value=*value>>1;
  407088:	687b      	ldr	r3, [r7, #4]
  40708a:	681b      	ldr	r3, [r3, #0]
  40708c:	085a      	lsrs	r2, r3, #1
  40708e:	687b      	ldr	r3, [r7, #4]
  407090:	601a      	str	r2, [r3, #0]
    }
    return position;
  407092:	f9b7 300e 	ldrsh.w	r3, [r7, #14]
}
  407096:	4618      	mov	r0, r3
  407098:	3714      	adds	r7, #20
  40709a:	46bd      	mov	sp, r7
  40709c:	f85d 7b04 	ldr.w	r7, [sp], #4
  4070a0:	4770      	bx	lr
	...

004070a4 <inv_icm20948_convert_matrix_to_quat_flt>:
        y=-y;
    return y;
}

void inv_icm20948_convert_matrix_to_quat_flt(float *R, float *q)
{
  4070a4:	b590      	push	{r4, r7, lr}
  4070a6:	b08d      	sub	sp, #52	; 0x34
  4070a8:	af00      	add	r7, sp, #0
  4070aa:	6078      	str	r0, [r7, #4]
  4070ac:	6039      	str	r1, [r7, #0]
	float r11,r12,r13, r21,r22,r23, r31,r32,r33;

	r11 = R[0]; //assume matrix is stored row wise first, that is rot[1] is row 1, col 2
  4070ae:	687b      	ldr	r3, [r7, #4]
  4070b0:	681b      	ldr	r3, [r3, #0]
  4070b2:	62fb      	str	r3, [r7, #44]	; 0x2c
	r12 = R[1];
  4070b4:	687b      	ldr	r3, [r7, #4]
  4070b6:	685b      	ldr	r3, [r3, #4]
  4070b8:	62bb      	str	r3, [r7, #40]	; 0x28
	r13 = R[2];
  4070ba:	687b      	ldr	r3, [r7, #4]
  4070bc:	689b      	ldr	r3, [r3, #8]
  4070be:	627b      	str	r3, [r7, #36]	; 0x24

	r21 = R[3];
  4070c0:	687b      	ldr	r3, [r7, #4]
  4070c2:	68db      	ldr	r3, [r3, #12]
  4070c4:	623b      	str	r3, [r7, #32]
	r22 = R[4];
  4070c6:	687b      	ldr	r3, [r7, #4]
  4070c8:	691b      	ldr	r3, [r3, #16]
  4070ca:	61fb      	str	r3, [r7, #28]
	r23 = R[5];
  4070cc:	687b      	ldr	r3, [r7, #4]
  4070ce:	695b      	ldr	r3, [r3, #20]
  4070d0:	61bb      	str	r3, [r7, #24]

	r31 = R[6];
  4070d2:	687b      	ldr	r3, [r7, #4]
  4070d4:	699b      	ldr	r3, [r3, #24]
  4070d6:	617b      	str	r3, [r7, #20]
	r32 = R[7];
  4070d8:	687b      	ldr	r3, [r7, #4]
  4070da:	69db      	ldr	r3, [r3, #28]
  4070dc:	613b      	str	r3, [r7, #16]
	r33 = R[8];
  4070de:	687b      	ldr	r3, [r7, #4]
  4070e0:	6a1b      	ldr	r3, [r3, #32]
  4070e2:	60fb      	str	r3, [r7, #12]

	q[0] = (1.f + r11 + r22 + r33) / 4.f;
  4070e4:	edd7 7a0b 	vldr	s15, [r7, #44]	; 0x2c
  4070e8:	eeb7 7a00 	vmov.f32	s14, #112	; 0x3f800000  1.0
  4070ec:	ee37 7a87 	vadd.f32	s14, s15, s14
  4070f0:	edd7 7a07 	vldr	s15, [r7, #28]
  4070f4:	ee37 7a27 	vadd.f32	s14, s14, s15
  4070f8:	edd7 7a03 	vldr	s15, [r7, #12]
  4070fc:	ee37 7a27 	vadd.f32	s14, s14, s15
  407100:	eef1 6a00 	vmov.f32	s13, #16	; 0x40800000  4.0
  407104:	eec7 7a26 	vdiv.f32	s15, s14, s13
  407108:	683b      	ldr	r3, [r7, #0]
  40710a:	edc3 7a00 	vstr	s15, [r3]
	q[1] = (1.f + r11 - r22 - r33) / 4.f;
  40710e:	683b      	ldr	r3, [r7, #0]
  407110:	3304      	adds	r3, #4
  407112:	edd7 7a0b 	vldr	s15, [r7, #44]	; 0x2c
  407116:	eeb7 7a00 	vmov.f32	s14, #112	; 0x3f800000  1.0
  40711a:	ee37 7a87 	vadd.f32	s14, s15, s14
  40711e:	edd7 7a07 	vldr	s15, [r7, #28]
  407122:	ee37 7a67 	vsub.f32	s14, s14, s15
  407126:	edd7 7a03 	vldr	s15, [r7, #12]
  40712a:	ee37 7a67 	vsub.f32	s14, s14, s15
  40712e:	eef1 6a00 	vmov.f32	s13, #16	; 0x40800000  4.0
  407132:	eec7 7a26 	vdiv.f32	s15, s14, s13
  407136:	edc3 7a00 	vstr	s15, [r3]
	q[2] = (1.f - r11 + r22 - r33) / 4.f;
  40713a:	683b      	ldr	r3, [r7, #0]
  40713c:	3308      	adds	r3, #8
  40713e:	eeb7 7a00 	vmov.f32	s14, #112	; 0x3f800000  1.0
  407142:	edd7 7a0b 	vldr	s15, [r7, #44]	; 0x2c
  407146:	ee37 7a67 	vsub.f32	s14, s14, s15
  40714a:	edd7 7a07 	vldr	s15, [r7, #28]
  40714e:	ee37 7a27 	vadd.f32	s14, s14, s15
  407152:	edd7 7a03 	vldr	s15, [r7, #12]
  407156:	ee37 7a67 	vsub.f32	s14, s14, s15
  40715a:	eef1 6a00 	vmov.f32	s13, #16	; 0x40800000  4.0
  40715e:	eec7 7a26 	vdiv.f32	s15, s14, s13
  407162:	edc3 7a00 	vstr	s15, [r3]
	q[3] = (1.f - r11 - r22 + r33) / 4.f;
  407166:	683b      	ldr	r3, [r7, #0]
  407168:	330c      	adds	r3, #12
  40716a:	eeb7 7a00 	vmov.f32	s14, #112	; 0x3f800000  1.0
  40716e:	edd7 7a0b 	vldr	s15, [r7, #44]	; 0x2c
  407172:	ee37 7a67 	vsub.f32	s14, s14, s15
  407176:	edd7 7a07 	vldr	s15, [r7, #28]
  40717a:	ee37 7a67 	vsub.f32	s14, s14, s15
  40717e:	edd7 7a03 	vldr	s15, [r7, #12]
  407182:	ee37 7a27 	vadd.f32	s14, s14, s15
  407186:	eef1 6a00 	vmov.f32	s13, #16	; 0x40800000  4.0
  40718a:	eec7 7a26 	vdiv.f32	s15, s14, s13
  40718e:	edc3 7a00 	vstr	s15, [r3]

	if(q[0] < 0.0f) q[0] = 0.0f;
  407192:	683b      	ldr	r3, [r7, #0]
  407194:	edd3 7a00 	vldr	s15, [r3]
  407198:	eef5 7ac0 	vcmpe.f32	s15, #0.0
  40719c:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
  4071a0:	d503      	bpl.n	4071aa <inv_icm20948_convert_matrix_to_quat_flt+0x106>
  4071a2:	683b      	ldr	r3, [r7, #0]
  4071a4:	f04f 0200 	mov.w	r2, #0
  4071a8:	601a      	str	r2, [r3, #0]
	if(q[1] < 0.0f) q[1] = 0.0f;
  4071aa:	683b      	ldr	r3, [r7, #0]
  4071ac:	3304      	adds	r3, #4
  4071ae:	edd3 7a00 	vldr	s15, [r3]
  4071b2:	eef5 7ac0 	vcmpe.f32	s15, #0.0
  4071b6:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
  4071ba:	d504      	bpl.n	4071c6 <inv_icm20948_convert_matrix_to_quat_flt+0x122>
  4071bc:	683b      	ldr	r3, [r7, #0]
  4071be:	3304      	adds	r3, #4
  4071c0:	f04f 0200 	mov.w	r2, #0
  4071c4:	601a      	str	r2, [r3, #0]
	if(q[2] < 0.0f) q[2] = 0.0f;
  4071c6:	683b      	ldr	r3, [r7, #0]
  4071c8:	3308      	adds	r3, #8
  4071ca:	edd3 7a00 	vldr	s15, [r3]
  4071ce:	eef5 7ac0 	vcmpe.f32	s15, #0.0
  4071d2:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
  4071d6:	d504      	bpl.n	4071e2 <inv_icm20948_convert_matrix_to_quat_flt+0x13e>
  4071d8:	683b      	ldr	r3, [r7, #0]
  4071da:	3308      	adds	r3, #8
  4071dc:	f04f 0200 	mov.w	r2, #0
  4071e0:	601a      	str	r2, [r3, #0]
	if(q[3] < 0.0f) q[3] = 0.0f;
  4071e2:	683b      	ldr	r3, [r7, #0]
  4071e4:	330c      	adds	r3, #12
  4071e6:	edd3 7a00 	vldr	s15, [r3]
  4071ea:	eef5 7ac0 	vcmpe.f32	s15, #0.0
  4071ee:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
  4071f2:	d504      	bpl.n	4071fe <inv_icm20948_convert_matrix_to_quat_flt+0x15a>
  4071f4:	683b      	ldr	r3, [r7, #0]
  4071f6:	330c      	adds	r3, #12
  4071f8:	f04f 0200 	mov.w	r2, #0
  4071fc:	601a      	str	r2, [r3, #0]
	q[0] = sqrtf(q[0]);
  4071fe:	683b      	ldr	r3, [r7, #0]
  407200:	edd3 7a00 	vldr	s15, [r3]
  407204:	eeb0 0a67 	vmov.f32	s0, s15
  407208:	4bbe      	ldr	r3, [pc, #760]	; (407504 <inv_icm20948_convert_matrix_to_quat_flt+0x460>)
  40720a:	4798      	blx	r3
  40720c:	eef0 7a40 	vmov.f32	s15, s0
  407210:	683b      	ldr	r3, [r7, #0]
  407212:	edc3 7a00 	vstr	s15, [r3]
	q[1] = sqrtf(q[1]);
  407216:	683b      	ldr	r3, [r7, #0]
  407218:	1d1c      	adds	r4, r3, #4
  40721a:	683b      	ldr	r3, [r7, #0]
  40721c:	3304      	adds	r3, #4
  40721e:	edd3 7a00 	vldr	s15, [r3]
  407222:	eeb0 0a67 	vmov.f32	s0, s15
  407226:	4bb7      	ldr	r3, [pc, #732]	; (407504 <inv_icm20948_convert_matrix_to_quat_flt+0x460>)
  407228:	4798      	blx	r3
  40722a:	eef0 7a40 	vmov.f32	s15, s0
  40722e:	edc4 7a00 	vstr	s15, [r4]
	q[2] = sqrtf(q[2]);
  407232:	683b      	ldr	r3, [r7, #0]
  407234:	f103 0408 	add.w	r4, r3, #8
  407238:	683b      	ldr	r3, [r7, #0]
  40723a:	3308      	adds	r3, #8
  40723c:	edd3 7a00 	vldr	s15, [r3]
  407240:	eeb0 0a67 	vmov.f32	s0, s15
  407244:	4baf      	ldr	r3, [pc, #700]	; (407504 <inv_icm20948_convert_matrix_to_quat_flt+0x460>)
  407246:	4798      	blx	r3
  407248:	eef0 7a40 	vmov.f32	s15, s0
  40724c:	edc4 7a00 	vstr	s15, [r4]
	q[3] = sqrtf(q[3]);
  407250:	683b      	ldr	r3, [r7, #0]
  407252:	f103 040c 	add.w	r4, r3, #12
  407256:	683b      	ldr	r3, [r7, #0]
  407258:	330c      	adds	r3, #12
  40725a:	edd3 7a00 	vldr	s15, [r3]
  40725e:	eeb0 0a67 	vmov.f32	s0, s15
  407262:	4ba8      	ldr	r3, [pc, #672]	; (407504 <inv_icm20948_convert_matrix_to_quat_flt+0x460>)
  407264:	4798      	blx	r3
  407266:	eef0 7a40 	vmov.f32	s15, s0
  40726a:	edc4 7a00 	vstr	s15, [r4]
	q[1] =(q[1] < 0.0f) ? q[1] = 0.0f : sqrtf(q[1]);
	q[2] =(q[2] < 0.0f) ? q[2] = 0.0f : sqrtf(q[2]);
	q[3] =(q[3] < 0.0f) ? q[3] = 0.0f : sqrtf(q[3]);
	*/
	
	if(q[0] >= q[1] && q[0] >= q[2] && q[0] >= q[3]) //q[0] is max
  40726e:	683b      	ldr	r3, [r7, #0]
  407270:	ed93 7a00 	vldr	s14, [r3]
  407274:	683b      	ldr	r3, [r7, #0]
  407276:	3304      	adds	r3, #4
  407278:	edd3 7a00 	vldr	s15, [r3]
  40727c:	eeb4 7ae7 	vcmpe.f32	s14, s15
  407280:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
  407284:	db51      	blt.n	40732a <inv_icm20948_convert_matrix_to_quat_flt+0x286>
  407286:	683b      	ldr	r3, [r7, #0]
  407288:	ed93 7a00 	vldr	s14, [r3]
  40728c:	683b      	ldr	r3, [r7, #0]
  40728e:	3308      	adds	r3, #8
  407290:	edd3 7a00 	vldr	s15, [r3]
  407294:	eeb4 7ae7 	vcmpe.f32	s14, s15
  407298:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
  40729c:	db45      	blt.n	40732a <inv_icm20948_convert_matrix_to_quat_flt+0x286>
  40729e:	683b      	ldr	r3, [r7, #0]
  4072a0:	ed93 7a00 	vldr	s14, [r3]
  4072a4:	683b      	ldr	r3, [r7, #0]
  4072a6:	330c      	adds	r3, #12
  4072a8:	edd3 7a00 	vldr	s15, [r3]
  4072ac:	eeb4 7ae7 	vcmpe.f32	s14, s15
  4072b0:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
  4072b4:	db39      	blt.n	40732a <inv_icm20948_convert_matrix_to_quat_flt+0x286>
	{
		 q[1] = (r23 - r32)/(4.f*q[0]);
  4072b6:	683b      	ldr	r3, [r7, #0]
  4072b8:	3304      	adds	r3, #4
  4072ba:	ed97 7a06 	vldr	s14, [r7, #24]
  4072be:	edd7 7a04 	vldr	s15, [r7, #16]
  4072c2:	ee77 6a67 	vsub.f32	s13, s14, s15
  4072c6:	683a      	ldr	r2, [r7, #0]
  4072c8:	edd2 7a00 	vldr	s15, [r2]
  4072cc:	eeb1 7a00 	vmov.f32	s14, #16	; 0x40800000  4.0
  4072d0:	ee27 7a87 	vmul.f32	s14, s15, s14
  4072d4:	eec6 7a87 	vdiv.f32	s15, s13, s14
  4072d8:	edc3 7a00 	vstr	s15, [r3]
		 q[2] = (r31 - r13)/(4.f*q[0]);
  4072dc:	683b      	ldr	r3, [r7, #0]
  4072de:	3308      	adds	r3, #8
  4072e0:	ed97 7a05 	vldr	s14, [r7, #20]
  4072e4:	edd7 7a09 	vldr	s15, [r7, #36]	; 0x24
  4072e8:	ee77 6a67 	vsub.f32	s13, s14, s15
  4072ec:	683a      	ldr	r2, [r7, #0]
  4072ee:	edd2 7a00 	vldr	s15, [r2]
  4072f2:	eeb1 7a00 	vmov.f32	s14, #16	; 0x40800000  4.0
  4072f6:	ee27 7a87 	vmul.f32	s14, s15, s14
  4072fa:	eec6 7a87 	vdiv.f32	s15, s13, s14
  4072fe:	edc3 7a00 	vstr	s15, [r3]
		 q[3] = (r12 - r21)/(4.f*q[0]);
  407302:	683b      	ldr	r3, [r7, #0]
  407304:	330c      	adds	r3, #12
  407306:	ed97 7a0a 	vldr	s14, [r7, #40]	; 0x28
  40730a:	edd7 7a08 	vldr	s15, [r7, #32]
  40730e:	ee77 6a67 	vsub.f32	s13, s14, s15
  407312:	683a      	ldr	r2, [r7, #0]
  407314:	edd2 7a00 	vldr	s15, [r2]
  407318:	eeb1 7a00 	vmov.f32	s14, #16	; 0x40800000  4.0
  40731c:	ee27 7a87 	vmul.f32	s14, s15, s14
  407320:	eec6 7a87 	vdiv.f32	s15, s13, s14
  407324:	edc3 7a00 	vstr	s15, [r3]
  407328:	e12a      	b.n	407580 <inv_icm20948_convert_matrix_to_quat_flt+0x4dc>
	}
	else if(q[1] >= q[0] && q[1] >= q[2] && q[1] >= q[3]) //q[1] is max
  40732a:	683b      	ldr	r3, [r7, #0]
  40732c:	3304      	adds	r3, #4
  40732e:	ed93 7a00 	vldr	s14, [r3]
  407332:	683b      	ldr	r3, [r7, #0]
  407334:	edd3 7a00 	vldr	s15, [r3]
  407338:	eeb4 7ae7 	vcmpe.f32	s14, s15
  40733c:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
  407340:	db55      	blt.n	4073ee <inv_icm20948_convert_matrix_to_quat_flt+0x34a>
  407342:	683b      	ldr	r3, [r7, #0]
  407344:	3304      	adds	r3, #4
  407346:	ed93 7a00 	vldr	s14, [r3]
  40734a:	683b      	ldr	r3, [r7, #0]
  40734c:	3308      	adds	r3, #8
  40734e:	edd3 7a00 	vldr	s15, [r3]
  407352:	eeb4 7ae7 	vcmpe.f32	s14, s15
  407356:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
  40735a:	db48      	blt.n	4073ee <inv_icm20948_convert_matrix_to_quat_flt+0x34a>
  40735c:	683b      	ldr	r3, [r7, #0]
  40735e:	3304      	adds	r3, #4
  407360:	ed93 7a00 	vldr	s14, [r3]
  407364:	683b      	ldr	r3, [r7, #0]
  407366:	330c      	adds	r3, #12
  407368:	edd3 7a00 	vldr	s15, [r3]
  40736c:	eeb4 7ae7 	vcmpe.f32	s14, s15
  407370:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
  407374:	db3b      	blt.n	4073ee <inv_icm20948_convert_matrix_to_quat_flt+0x34a>
	{
		 q[0] = (r23 - r32)/(4.f*q[1]);
  407376:	ed97 7a06 	vldr	s14, [r7, #24]
  40737a:	edd7 7a04 	vldr	s15, [r7, #16]
  40737e:	ee77 6a67 	vsub.f32	s13, s14, s15
  407382:	683b      	ldr	r3, [r7, #0]
  407384:	3304      	adds	r3, #4
  407386:	edd3 7a00 	vldr	s15, [r3]
  40738a:	eeb1 7a00 	vmov.f32	s14, #16	; 0x40800000  4.0
  40738e:	ee27 7a87 	vmul.f32	s14, s15, s14
  407392:	eec6 7a87 	vdiv.f32	s15, s13, s14
  407396:	683b      	ldr	r3, [r7, #0]
  407398:	edc3 7a00 	vstr	s15, [r3]
		 q[2] = (r12 + r21)/(4.f*q[1]);
  40739c:	683b      	ldr	r3, [r7, #0]
  40739e:	3308      	adds	r3, #8
  4073a0:	ed97 7a0a 	vldr	s14, [r7, #40]	; 0x28
  4073a4:	edd7 7a08 	vldr	s15, [r7, #32]
  4073a8:	ee77 6a27 	vadd.f32	s13, s14, s15
  4073ac:	683a      	ldr	r2, [r7, #0]
  4073ae:	3204      	adds	r2, #4
  4073b0:	edd2 7a00 	vldr	s15, [r2]
  4073b4:	eeb1 7a00 	vmov.f32	s14, #16	; 0x40800000  4.0
  4073b8:	ee27 7a87 	vmul.f32	s14, s15, s14
  4073bc:	eec6 7a87 	vdiv.f32	s15, s13, s14
  4073c0:	edc3 7a00 	vstr	s15, [r3]
		 q[3] = (r31 + r13)/(4.f*q[1]);
  4073c4:	683b      	ldr	r3, [r7, #0]
  4073c6:	330c      	adds	r3, #12
  4073c8:	ed97 7a05 	vldr	s14, [r7, #20]
  4073cc:	edd7 7a09 	vldr	s15, [r7, #36]	; 0x24
  4073d0:	ee77 6a27 	vadd.f32	s13, s14, s15
  4073d4:	683a      	ldr	r2, [r7, #0]
  4073d6:	3204      	adds	r2, #4
  4073d8:	edd2 7a00 	vldr	s15, [r2]
  4073dc:	eeb1 7a00 	vmov.f32	s14, #16	; 0x40800000  4.0
  4073e0:	ee27 7a87 	vmul.f32	s14, s15, s14
  4073e4:	eec6 7a87 	vdiv.f32	s15, s13, s14
  4073e8:	edc3 7a00 	vstr	s15, [r3]
  4073ec:	e0c8      	b.n	407580 <inv_icm20948_convert_matrix_to_quat_flt+0x4dc>
	}
	else if(q[2] >= q[0] && q[2] >= q[1] && q[2] >= q[3]) //q[2] is max
  4073ee:	683b      	ldr	r3, [r7, #0]
  4073f0:	3308      	adds	r3, #8
  4073f2:	ed93 7a00 	vldr	s14, [r3]
  4073f6:	683b      	ldr	r3, [r7, #0]
  4073f8:	edd3 7a00 	vldr	s15, [r3]
  4073fc:	eeb4 7ae7 	vcmpe.f32	s14, s15
  407400:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
  407404:	db55      	blt.n	4074b2 <inv_icm20948_convert_matrix_to_quat_flt+0x40e>
  407406:	683b      	ldr	r3, [r7, #0]
  407408:	3308      	adds	r3, #8
  40740a:	ed93 7a00 	vldr	s14, [r3]
  40740e:	683b      	ldr	r3, [r7, #0]
  407410:	3304      	adds	r3, #4
  407412:	edd3 7a00 	vldr	s15, [r3]
  407416:	eeb4 7ae7 	vcmpe.f32	s14, s15
  40741a:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
  40741e:	db48      	blt.n	4074b2 <inv_icm20948_convert_matrix_to_quat_flt+0x40e>
  407420:	683b      	ldr	r3, [r7, #0]
  407422:	3308      	adds	r3, #8
  407424:	ed93 7a00 	vldr	s14, [r3]
  407428:	683b      	ldr	r3, [r7, #0]
  40742a:	330c      	adds	r3, #12
  40742c:	edd3 7a00 	vldr	s15, [r3]
  407430:	eeb4 7ae7 	vcmpe.f32	s14, s15
  407434:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
  407438:	db3b      	blt.n	4074b2 <inv_icm20948_convert_matrix_to_quat_flt+0x40e>
	{
		 q[0] = (r31 - r13)/(4.f*q[2]);
  40743a:	ed97 7a05 	vldr	s14, [r7, #20]
  40743e:	edd7 7a09 	vldr	s15, [r7, #36]	; 0x24
  407442:	ee77 6a67 	vsub.f32	s13, s14, s15
  407446:	683b      	ldr	r3, [r7, #0]
  407448:	3308      	adds	r3, #8
  40744a:	edd3 7a00 	vldr	s15, [r3]
  40744e:	eeb1 7a00 	vmov.f32	s14, #16	; 0x40800000  4.0
  407452:	ee27 7a87 	vmul.f32	s14, s15, s14
  407456:	eec6 7a87 	vdiv.f32	s15, s13, s14
  40745a:	683b      	ldr	r3, [r7, #0]
  40745c:	edc3 7a00 	vstr	s15, [r3]
		 q[1] = (r12 + r21)/(4.f*q[2]);
  407460:	683b      	ldr	r3, [r7, #0]
  407462:	3304      	adds	r3, #4
  407464:	ed97 7a0a 	vldr	s14, [r7, #40]	; 0x28
  407468:	edd7 7a08 	vldr	s15, [r7, #32]
  40746c:	ee77 6a27 	vadd.f32	s13, s14, s15
  407470:	683a      	ldr	r2, [r7, #0]
  407472:	3208      	adds	r2, #8
  407474:	edd2 7a00 	vldr	s15, [r2]
  407478:	eeb1 7a00 	vmov.f32	s14, #16	; 0x40800000  4.0
  40747c:	ee27 7a87 	vmul.f32	s14, s15, s14
  407480:	eec6 7a87 	vdiv.f32	s15, s13, s14
  407484:	edc3 7a00 	vstr	s15, [r3]
		 q[3] = (r23 + r32)/(4.f*q[2]);
  407488:	683b      	ldr	r3, [r7, #0]
  40748a:	330c      	adds	r3, #12
  40748c:	ed97 7a06 	vldr	s14, [r7, #24]
  407490:	edd7 7a04 	vldr	s15, [r7, #16]
  407494:	ee77 6a27 	vadd.f32	s13, s14, s15
  407498:	683a      	ldr	r2, [r7, #0]
  40749a:	3208      	adds	r2, #8
  40749c:	edd2 7a00 	vldr	s15, [r2]
  4074a0:	eeb1 7a00 	vmov.f32	s14, #16	; 0x40800000  4.0
  4074a4:	ee27 7a87 	vmul.f32	s14, s15, s14
  4074a8:	eec6 7a87 	vdiv.f32	s15, s13, s14
  4074ac:	edc3 7a00 	vstr	s15, [r3]
  4074b0:	e066      	b.n	407580 <inv_icm20948_convert_matrix_to_quat_flt+0x4dc>
	}
	else if(q[3] >= q[0] && q[3] >= q[1] && q[3] >= q[2]) //q[3] is max
  4074b2:	683b      	ldr	r3, [r7, #0]
  4074b4:	330c      	adds	r3, #12
  4074b6:	ed93 7a00 	vldr	s14, [r3]
  4074ba:	683b      	ldr	r3, [r7, #0]
  4074bc:	edd3 7a00 	vldr	s15, [r3]
  4074c0:	eeb4 7ae7 	vcmpe.f32	s14, s15
  4074c4:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
  4074c8:	da00      	bge.n	4074cc <inv_icm20948_convert_matrix_to_quat_flt+0x428>
	{
		 q[0] = (r12 - r21)/(4.f*q[3]);
		 q[1] = (r31 + r13)/(4.f*q[3]);
		 q[2] = (r23 + r32)/(4.f*q[3]);
	}
}
  4074ca:	e059      	b.n	407580 <inv_icm20948_convert_matrix_to_quat_flt+0x4dc>
	else if(q[3] >= q[0] && q[3] >= q[1] && q[3] >= q[2]) //q[3] is max
  4074cc:	683b      	ldr	r3, [r7, #0]
  4074ce:	330c      	adds	r3, #12
  4074d0:	ed93 7a00 	vldr	s14, [r3]
  4074d4:	683b      	ldr	r3, [r7, #0]
  4074d6:	3304      	adds	r3, #4
  4074d8:	edd3 7a00 	vldr	s15, [r3]
  4074dc:	eeb4 7ae7 	vcmpe.f32	s14, s15
  4074e0:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
  4074e4:	da00      	bge.n	4074e8 <inv_icm20948_convert_matrix_to_quat_flt+0x444>
}
  4074e6:	e04b      	b.n	407580 <inv_icm20948_convert_matrix_to_quat_flt+0x4dc>
	else if(q[3] >= q[0] && q[3] >= q[1] && q[3] >= q[2]) //q[3] is max
  4074e8:	683b      	ldr	r3, [r7, #0]
  4074ea:	330c      	adds	r3, #12
  4074ec:	ed93 7a00 	vldr	s14, [r3]
  4074f0:	683b      	ldr	r3, [r7, #0]
  4074f2:	3308      	adds	r3, #8
  4074f4:	edd3 7a00 	vldr	s15, [r3]
  4074f8:	eeb4 7ae7 	vcmpe.f32	s14, s15
  4074fc:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
  407500:	da02      	bge.n	407508 <inv_icm20948_convert_matrix_to_quat_flt+0x464>
}
  407502:	e03d      	b.n	407580 <inv_icm20948_convert_matrix_to_quat_flt+0x4dc>
  407504:	00412751 	.word	0x00412751
		 q[0] = (r12 - r21)/(4.f*q[3]);
  407508:	ed97 7a0a 	vldr	s14, [r7, #40]	; 0x28
  40750c:	edd7 7a08 	vldr	s15, [r7, #32]
  407510:	ee77 6a67 	vsub.f32	s13, s14, s15
  407514:	683b      	ldr	r3, [r7, #0]
  407516:	330c      	adds	r3, #12
  407518:	edd3 7a00 	vldr	s15, [r3]
  40751c:	eeb1 7a00 	vmov.f32	s14, #16	; 0x40800000  4.0
  407520:	ee27 7a87 	vmul.f32	s14, s15, s14
  407524:	eec6 7a87 	vdiv.f32	s15, s13, s14
  407528:	683b      	ldr	r3, [r7, #0]
  40752a:	edc3 7a00 	vstr	s15, [r3]
		 q[1] = (r31 + r13)/(4.f*q[3]);
  40752e:	683b      	ldr	r3, [r7, #0]
  407530:	3304      	adds	r3, #4
  407532:	ed97 7a05 	vldr	s14, [r7, #20]
  407536:	edd7 7a09 	vldr	s15, [r7, #36]	; 0x24
  40753a:	ee77 6a27 	vadd.f32	s13, s14, s15
  40753e:	683a      	ldr	r2, [r7, #0]
  407540:	320c      	adds	r2, #12
  407542:	edd2 7a00 	vldr	s15, [r2]
  407546:	eeb1 7a00 	vmov.f32	s14, #16	; 0x40800000  4.0
  40754a:	ee27 7a87 	vmul.f32	s14, s15, s14
  40754e:	eec6 7a87 	vdiv.f32	s15, s13, s14
  407552:	edc3 7a00 	vstr	s15, [r3]
		 q[2] = (r23 + r32)/(4.f*q[3]);
  407556:	683b      	ldr	r3, [r7, #0]
  407558:	3308      	adds	r3, #8
  40755a:	ed97 7a06 	vldr	s14, [r7, #24]
  40755e:	edd7 7a04 	vldr	s15, [r7, #16]
  407562:	ee77 6a27 	vadd.f32	s13, s14, s15
  407566:	683a      	ldr	r2, [r7, #0]
  407568:	320c      	adds	r2, #12
  40756a:	edd2 7a00 	vldr	s15, [r2]
  40756e:	eeb1 7a00 	vmov.f32	s14, #16	; 0x40800000  4.0
  407572:	ee27 7a87 	vmul.f32	s14, s15, s14
  407576:	eec6 7a87 	vdiv.f32	s15, s13, s14
  40757a:	edc3 7a00 	vstr	s15, [r3]
}
  40757e:	e7ff      	b.n	407580 <inv_icm20948_convert_matrix_to_quat_flt+0x4dc>
  407580:	bf00      	nop
  407582:	3734      	adds	r7, #52	; 0x34
  407584:	46bd      	mov	sp, r7
  407586:	bd90      	pop	{r4, r7, pc}

00407588 <inv_icm20948_convert_mult_qfix_fxp>:

long inv_icm20948_convert_mult_qfix_fxp(long a, long b, unsigned char qfix)
{
  407588:	b5f0      	push	{r4, r5, r6, r7, lr}
  40758a:	b089      	sub	sp, #36	; 0x24
  40758c:	af00      	add	r7, sp, #0
  40758e:	60f8      	str	r0, [r7, #12]
  407590:	60b9      	str	r1, [r7, #8]
  407592:	71fa      	strb	r2, [r7, #7]
    long long temp;
    long result;
    temp = (long long)a * b;
  407594:	68fa      	ldr	r2, [r7, #12]
  407596:	4615      	mov	r5, r2
  407598:	ea4f 76e5 	mov.w	r6, r5, asr #31
  40759c:	68ba      	ldr	r2, [r7, #8]
  40759e:	4611      	mov	r1, r2
  4075a0:	ea4f 72e1 	mov.w	r2, r1, asr #31
  4075a4:	fb01 fe06 	mul.w	lr, r1, r6
  4075a8:	fb05 f002 	mul.w	r0, r5, r2
  4075ac:	4470      	add	r0, lr
  4075ae:	fba5 1201 	umull	r1, r2, r5, r1
  4075b2:	4410      	add	r0, r2
  4075b4:	4602      	mov	r2, r0
  4075b6:	e9c7 1206 	strd	r1, r2, [r7, #24]
  4075ba:	e9c7 1206 	strd	r1, r2, [r7, #24]
    result = (long)(temp >> qfix);
  4075be:	79f8      	ldrb	r0, [r7, #7]
  4075c0:	e9d7 1206 	ldrd	r1, r2, [r7, #24]
  4075c4:	f1c0 0620 	rsb	r6, r0, #32
  4075c8:	f1b0 0520 	subs.w	r5, r0, #32
  4075cc:	fa21 f300 	lsr.w	r3, r1, r0
  4075d0:	fa02 f606 	lsl.w	r6, r2, r6
  4075d4:	ea43 0306 	orr.w	r3, r3, r6
  4075d8:	d402      	bmi.n	4075e0 <inv_icm20948_convert_mult_qfix_fxp+0x58>
  4075da:	fa42 f505 	asr.w	r5, r2, r5
  4075de:	432b      	orrs	r3, r5
  4075e0:	fa42 f400 	asr.w	r4, r2, r0
  4075e4:	617b      	str	r3, [r7, #20]
    return result;
  4075e6:	697b      	ldr	r3, [r7, #20]
}
  4075e8:	4618      	mov	r0, r3
  4075ea:	3724      	adds	r7, #36	; 0x24
  4075ec:	46bd      	mov	sp, r7
  4075ee:	bdf0      	pop	{r4, r5, r6, r7, pc}

004075f0 <invn_convert_mult_q29_fxp>:

static long invn_convert_mult_q29_fxp(long a_q29, long b_q29)
{
  4075f0:	b5f0      	push	{r4, r5, r6, r7, lr}
  4075f2:	b087      	sub	sp, #28
  4075f4:	af00      	add	r7, sp, #0
  4075f6:	6078      	str	r0, [r7, #4]
  4075f8:	6039      	str	r1, [r7, #0]
	long long temp;
	long result;
	temp = (long long)a_q29 * b_q29;
  4075fa:	687a      	ldr	r2, [r7, #4]
  4075fc:	4615      	mov	r5, r2
  4075fe:	ea4f 76e5 	mov.w	r6, r5, asr #31
  407602:	683a      	ldr	r2, [r7, #0]
  407604:	4611      	mov	r1, r2
  407606:	ea4f 72e1 	mov.w	r2, r1, asr #31
  40760a:	fb01 fe06 	mul.w	lr, r1, r6
  40760e:	fb05 f002 	mul.w	r0, r5, r2
  407612:	4470      	add	r0, lr
  407614:	fba5 1201 	umull	r1, r2, r5, r1
  407618:	4410      	add	r0, r2
  40761a:	4602      	mov	r2, r0
  40761c:	e9c7 1204 	strd	r1, r2, [r7, #16]
  407620:	e9c7 1204 	strd	r1, r2, [r7, #16]
	result = (long)(temp >> 29);
  407624:	e9d7 1204 	ldrd	r1, r2, [r7, #16]
  407628:	0f4b      	lsrs	r3, r1, #29
  40762a:	ea43 03c2 	orr.w	r3, r3, r2, lsl #3
  40762e:	1754      	asrs	r4, r2, #29
  407630:	60fb      	str	r3, [r7, #12]
	return result;
  407632:	68fb      	ldr	r3, [r7, #12]

}
  407634:	4618      	mov	r0, r3
  407636:	371c      	adds	r7, #28
  407638:	46bd      	mov	sp, r7
  40763a:	bdf0      	pop	{r4, r5, r6, r7, pc}

0040763c <inv_icm20948_convert_quat_to_col_major_matrix_fxp>:

void inv_icm20948_convert_quat_to_col_major_matrix_fxp(const long *quat_q30, long *rot_q30)
{
  40763c:	b5b0      	push	{r4, r5, r7, lr}
  40763e:	b082      	sub	sp, #8
  407640:	af00      	add	r7, sp, #0
  407642:	6078      	str	r0, [r7, #4]
  407644:	6039      	str	r1, [r7, #0]
	//Use q29 in order to skip a multiplication by 2
    rot_q30[0] =
        invn_convert_mult_q29_fxp(quat_q30[1], quat_q30[1]) + invn_convert_mult_q29_fxp(quat_q30[0], quat_q30[0]) - 1073741824L;
  407646:	687b      	ldr	r3, [r7, #4]
  407648:	3304      	adds	r3, #4
  40764a:	681a      	ldr	r2, [r3, #0]
  40764c:	687b      	ldr	r3, [r7, #4]
  40764e:	3304      	adds	r3, #4
  407650:	681b      	ldr	r3, [r3, #0]
  407652:	4619      	mov	r1, r3
  407654:	4610      	mov	r0, r2
  407656:	4b73      	ldr	r3, [pc, #460]	; (407824 <inv_icm20948_convert_quat_to_col_major_matrix_fxp+0x1e8>)
  407658:	4798      	blx	r3
  40765a:	4604      	mov	r4, r0
  40765c:	687b      	ldr	r3, [r7, #4]
  40765e:	681a      	ldr	r2, [r3, #0]
  407660:	687b      	ldr	r3, [r7, #4]
  407662:	681b      	ldr	r3, [r3, #0]
  407664:	4619      	mov	r1, r3
  407666:	4610      	mov	r0, r2
  407668:	4b6e      	ldr	r3, [pc, #440]	; (407824 <inv_icm20948_convert_quat_to_col_major_matrix_fxp+0x1e8>)
  40766a:	4798      	blx	r3
  40766c:	4603      	mov	r3, r0
  40766e:	4423      	add	r3, r4
  407670:	f103 4240 	add.w	r2, r3, #3221225472	; 0xc0000000
    rot_q30[0] =
  407674:	683b      	ldr	r3, [r7, #0]
  407676:	601a      	str	r2, [r3, #0]
    rot_q30[1] =
  407678:	683b      	ldr	r3, [r7, #0]
  40767a:	1d1c      	adds	r4, r3, #4
        invn_convert_mult_q29_fxp(quat_q30[1], quat_q30[2]) - invn_convert_mult_q29_fxp(quat_q30[3], quat_q30[0]);
  40767c:	687b      	ldr	r3, [r7, #4]
  40767e:	3304      	adds	r3, #4
  407680:	681a      	ldr	r2, [r3, #0]
  407682:	687b      	ldr	r3, [r7, #4]
  407684:	3308      	adds	r3, #8
  407686:	681b      	ldr	r3, [r3, #0]
  407688:	4619      	mov	r1, r3
  40768a:	4610      	mov	r0, r2
  40768c:	4b65      	ldr	r3, [pc, #404]	; (407824 <inv_icm20948_convert_quat_to_col_major_matrix_fxp+0x1e8>)
  40768e:	4798      	blx	r3
  407690:	4605      	mov	r5, r0
  407692:	687b      	ldr	r3, [r7, #4]
  407694:	330c      	adds	r3, #12
  407696:	681a      	ldr	r2, [r3, #0]
  407698:	687b      	ldr	r3, [r7, #4]
  40769a:	681b      	ldr	r3, [r3, #0]
  40769c:	4619      	mov	r1, r3
  40769e:	4610      	mov	r0, r2
  4076a0:	4b60      	ldr	r3, [pc, #384]	; (407824 <inv_icm20948_convert_quat_to_col_major_matrix_fxp+0x1e8>)
  4076a2:	4798      	blx	r3
  4076a4:	4603      	mov	r3, r0
  4076a6:	1aeb      	subs	r3, r5, r3
    rot_q30[1] =
  4076a8:	6023      	str	r3, [r4, #0]
    rot_q30[2] =
  4076aa:	683b      	ldr	r3, [r7, #0]
  4076ac:	f103 0408 	add.w	r4, r3, #8
        invn_convert_mult_q29_fxp(quat_q30[1], quat_q30[3]) + invn_convert_mult_q29_fxp(quat_q30[2], quat_q30[0]);
  4076b0:	687b      	ldr	r3, [r7, #4]
  4076b2:	3304      	adds	r3, #4
  4076b4:	681a      	ldr	r2, [r3, #0]
  4076b6:	687b      	ldr	r3, [r7, #4]
  4076b8:	330c      	adds	r3, #12
  4076ba:	681b      	ldr	r3, [r3, #0]
  4076bc:	4619      	mov	r1, r3
  4076be:	4610      	mov	r0, r2
  4076c0:	4b58      	ldr	r3, [pc, #352]	; (407824 <inv_icm20948_convert_quat_to_col_major_matrix_fxp+0x1e8>)
  4076c2:	4798      	blx	r3
  4076c4:	4605      	mov	r5, r0
  4076c6:	687b      	ldr	r3, [r7, #4]
  4076c8:	3308      	adds	r3, #8
  4076ca:	681a      	ldr	r2, [r3, #0]
  4076cc:	687b      	ldr	r3, [r7, #4]
  4076ce:	681b      	ldr	r3, [r3, #0]
  4076d0:	4619      	mov	r1, r3
  4076d2:	4610      	mov	r0, r2
  4076d4:	4b53      	ldr	r3, [pc, #332]	; (407824 <inv_icm20948_convert_quat_to_col_major_matrix_fxp+0x1e8>)
  4076d6:	4798      	blx	r3
  4076d8:	4603      	mov	r3, r0
  4076da:	442b      	add	r3, r5
    rot_q30[2] =
  4076dc:	6023      	str	r3, [r4, #0]
    rot_q30[3] =
  4076de:	683b      	ldr	r3, [r7, #0]
  4076e0:	f103 040c 	add.w	r4, r3, #12
        invn_convert_mult_q29_fxp(quat_q30[1], quat_q30[2]) + invn_convert_mult_q29_fxp(quat_q30[3], quat_q30[0]);
  4076e4:	687b      	ldr	r3, [r7, #4]
  4076e6:	3304      	adds	r3, #4
  4076e8:	681a      	ldr	r2, [r3, #0]
  4076ea:	687b      	ldr	r3, [r7, #4]
  4076ec:	3308      	adds	r3, #8
  4076ee:	681b      	ldr	r3, [r3, #0]
  4076f0:	4619      	mov	r1, r3
  4076f2:	4610      	mov	r0, r2
  4076f4:	4b4b      	ldr	r3, [pc, #300]	; (407824 <inv_icm20948_convert_quat_to_col_major_matrix_fxp+0x1e8>)
  4076f6:	4798      	blx	r3
  4076f8:	4605      	mov	r5, r0
  4076fa:	687b      	ldr	r3, [r7, #4]
  4076fc:	330c      	adds	r3, #12
  4076fe:	681a      	ldr	r2, [r3, #0]
  407700:	687b      	ldr	r3, [r7, #4]
  407702:	681b      	ldr	r3, [r3, #0]
  407704:	4619      	mov	r1, r3
  407706:	4610      	mov	r0, r2
  407708:	4b46      	ldr	r3, [pc, #280]	; (407824 <inv_icm20948_convert_quat_to_col_major_matrix_fxp+0x1e8>)
  40770a:	4798      	blx	r3
  40770c:	4603      	mov	r3, r0
  40770e:	442b      	add	r3, r5
    rot_q30[3] =
  407710:	6023      	str	r3, [r4, #0]
    rot_q30[4] =
  407712:	683b      	ldr	r3, [r7, #0]
  407714:	f103 0410 	add.w	r4, r3, #16
        invn_convert_mult_q29_fxp(quat_q30[2], quat_q30[2]) + invn_convert_mult_q29_fxp(quat_q30[0], quat_q30[0]) - 1073741824L;
  407718:	687b      	ldr	r3, [r7, #4]
  40771a:	3308      	adds	r3, #8
  40771c:	681a      	ldr	r2, [r3, #0]
  40771e:	687b      	ldr	r3, [r7, #4]
  407720:	3308      	adds	r3, #8
  407722:	681b      	ldr	r3, [r3, #0]
  407724:	4619      	mov	r1, r3
  407726:	4610      	mov	r0, r2
  407728:	4b3e      	ldr	r3, [pc, #248]	; (407824 <inv_icm20948_convert_quat_to_col_major_matrix_fxp+0x1e8>)
  40772a:	4798      	blx	r3
  40772c:	4605      	mov	r5, r0
  40772e:	687b      	ldr	r3, [r7, #4]
  407730:	681a      	ldr	r2, [r3, #0]
  407732:	687b      	ldr	r3, [r7, #4]
  407734:	681b      	ldr	r3, [r3, #0]
  407736:	4619      	mov	r1, r3
  407738:	4610      	mov	r0, r2
  40773a:	4b3a      	ldr	r3, [pc, #232]	; (407824 <inv_icm20948_convert_quat_to_col_major_matrix_fxp+0x1e8>)
  40773c:	4798      	blx	r3
  40773e:	4603      	mov	r3, r0
  407740:	442b      	add	r3, r5
  407742:	f103 4340 	add.w	r3, r3, #3221225472	; 0xc0000000
    rot_q30[4] =
  407746:	6023      	str	r3, [r4, #0]
    rot_q30[5] =
  407748:	683b      	ldr	r3, [r7, #0]
  40774a:	f103 0414 	add.w	r4, r3, #20
        invn_convert_mult_q29_fxp(quat_q30[2], quat_q30[3]) - invn_convert_mult_q29_fxp(quat_q30[1], quat_q30[0]);
  40774e:	687b      	ldr	r3, [r7, #4]
  407750:	3308      	adds	r3, #8
  407752:	681a      	ldr	r2, [r3, #0]
  407754:	687b      	ldr	r3, [r7, #4]
  407756:	330c      	adds	r3, #12
  407758:	681b      	ldr	r3, [r3, #0]
  40775a:	4619      	mov	r1, r3
  40775c:	4610      	mov	r0, r2
  40775e:	4b31      	ldr	r3, [pc, #196]	; (407824 <inv_icm20948_convert_quat_to_col_major_matrix_fxp+0x1e8>)
  407760:	4798      	blx	r3
  407762:	4605      	mov	r5, r0
  407764:	687b      	ldr	r3, [r7, #4]
  407766:	3304      	adds	r3, #4
  407768:	681a      	ldr	r2, [r3, #0]
  40776a:	687b      	ldr	r3, [r7, #4]
  40776c:	681b      	ldr	r3, [r3, #0]
  40776e:	4619      	mov	r1, r3
  407770:	4610      	mov	r0, r2
  407772:	4b2c      	ldr	r3, [pc, #176]	; (407824 <inv_icm20948_convert_quat_to_col_major_matrix_fxp+0x1e8>)
  407774:	4798      	blx	r3
  407776:	4603      	mov	r3, r0
  407778:	1aeb      	subs	r3, r5, r3
    rot_q30[5] =
  40777a:	6023      	str	r3, [r4, #0]
    rot_q30[6] =
  40777c:	683b      	ldr	r3, [r7, #0]
  40777e:	f103 0418 	add.w	r4, r3, #24
        invn_convert_mult_q29_fxp(quat_q30[1], quat_q30[3]) - invn_convert_mult_q29_fxp(quat_q30[2], quat_q30[0]);
  407782:	687b      	ldr	r3, [r7, #4]
  407784:	3304      	adds	r3, #4
  407786:	681a      	ldr	r2, [r3, #0]
  407788:	687b      	ldr	r3, [r7, #4]
  40778a:	330c      	adds	r3, #12
  40778c:	681b      	ldr	r3, [r3, #0]
  40778e:	4619      	mov	r1, r3
  407790:	4610      	mov	r0, r2
  407792:	4b24      	ldr	r3, [pc, #144]	; (407824 <inv_icm20948_convert_quat_to_col_major_matrix_fxp+0x1e8>)
  407794:	4798      	blx	r3
  407796:	4605      	mov	r5, r0
  407798:	687b      	ldr	r3, [r7, #4]
  40779a:	3308      	adds	r3, #8
  40779c:	681a      	ldr	r2, [r3, #0]
  40779e:	687b      	ldr	r3, [r7, #4]
  4077a0:	681b      	ldr	r3, [r3, #0]
  4077a2:	4619      	mov	r1, r3
  4077a4:	4610      	mov	r0, r2
  4077a6:	4b1f      	ldr	r3, [pc, #124]	; (407824 <inv_icm20948_convert_quat_to_col_major_matrix_fxp+0x1e8>)
  4077a8:	4798      	blx	r3
  4077aa:	4603      	mov	r3, r0
  4077ac:	1aeb      	subs	r3, r5, r3
    rot_q30[6] =
  4077ae:	6023      	str	r3, [r4, #0]
    rot_q30[7] =
  4077b0:	683b      	ldr	r3, [r7, #0]
  4077b2:	f103 041c 	add.w	r4, r3, #28
        invn_convert_mult_q29_fxp(quat_q30[2], quat_q30[3]) + invn_convert_mult_q29_fxp(quat_q30[1], quat_q30[0]);
  4077b6:	687b      	ldr	r3, [r7, #4]
  4077b8:	3308      	adds	r3, #8
  4077ba:	681a      	ldr	r2, [r3, #0]
  4077bc:	687b      	ldr	r3, [r7, #4]
  4077be:	330c      	adds	r3, #12
  4077c0:	681b      	ldr	r3, [r3, #0]
  4077c2:	4619      	mov	r1, r3
  4077c4:	4610      	mov	r0, r2
  4077c6:	4b17      	ldr	r3, [pc, #92]	; (407824 <inv_icm20948_convert_quat_to_col_major_matrix_fxp+0x1e8>)
  4077c8:	4798      	blx	r3
  4077ca:	4605      	mov	r5, r0
  4077cc:	687b      	ldr	r3, [r7, #4]
  4077ce:	3304      	adds	r3, #4
  4077d0:	681a      	ldr	r2, [r3, #0]
  4077d2:	687b      	ldr	r3, [r7, #4]
  4077d4:	681b      	ldr	r3, [r3, #0]
  4077d6:	4619      	mov	r1, r3
  4077d8:	4610      	mov	r0, r2
  4077da:	4b12      	ldr	r3, [pc, #72]	; (407824 <inv_icm20948_convert_quat_to_col_major_matrix_fxp+0x1e8>)
  4077dc:	4798      	blx	r3
  4077de:	4603      	mov	r3, r0
  4077e0:	442b      	add	r3, r5
    rot_q30[7] =
  4077e2:	6023      	str	r3, [r4, #0]
    rot_q30[8] =
  4077e4:	683b      	ldr	r3, [r7, #0]
  4077e6:	f103 0420 	add.w	r4, r3, #32
        invn_convert_mult_q29_fxp(quat_q30[3], quat_q30[3]) + invn_convert_mult_q29_fxp(quat_q30[0], quat_q30[0]) - 1073741824L;
  4077ea:	687b      	ldr	r3, [r7, #4]
  4077ec:	330c      	adds	r3, #12
  4077ee:	681a      	ldr	r2, [r3, #0]
  4077f0:	687b      	ldr	r3, [r7, #4]
  4077f2:	330c      	adds	r3, #12
  4077f4:	681b      	ldr	r3, [r3, #0]
  4077f6:	4619      	mov	r1, r3
  4077f8:	4610      	mov	r0, r2
  4077fa:	4b0a      	ldr	r3, [pc, #40]	; (407824 <inv_icm20948_convert_quat_to_col_major_matrix_fxp+0x1e8>)
  4077fc:	4798      	blx	r3
  4077fe:	4605      	mov	r5, r0
  407800:	687b      	ldr	r3, [r7, #4]
  407802:	681a      	ldr	r2, [r3, #0]
  407804:	687b      	ldr	r3, [r7, #4]
  407806:	681b      	ldr	r3, [r3, #0]
  407808:	4619      	mov	r1, r3
  40780a:	4610      	mov	r0, r2
  40780c:	4b05      	ldr	r3, [pc, #20]	; (407824 <inv_icm20948_convert_quat_to_col_major_matrix_fxp+0x1e8>)
  40780e:	4798      	blx	r3
  407810:	4603      	mov	r3, r0
  407812:	442b      	add	r3, r5
  407814:	f103 4340 	add.w	r3, r3, #3221225472	; 0xc0000000
    rot_q30[8] =
  407818:	6023      	str	r3, [r4, #0]
}
  40781a:	bf00      	nop
  40781c:	3708      	adds	r7, #8
  40781e:	46bd      	mov	sp, r7
  407820:	bdb0      	pop	{r4, r5, r7, pc}
  407822:	bf00      	nop
  407824:	004075f1 	.word	0x004075f1

00407828 <invn_convert_mult_q15_fxp>:

static long invn_convert_mult_q15_fxp(long a_q15, long b_q15)
{
  407828:	b5f0      	push	{r4, r5, r6, r7, lr}
  40782a:	b085      	sub	sp, #20
  40782c:	af00      	add	r7, sp, #0
  40782e:	6078      	str	r0, [r7, #4]
  407830:	6039      	str	r1, [r7, #0]
	long out = (long)(((long long)a_q15 * (long long)b_q15) >> 15);
  407832:	687b      	ldr	r3, [r7, #4]
  407834:	4619      	mov	r1, r3
  407836:	ea4f 72e1 	mov.w	r2, r1, asr #31
  40783a:	683b      	ldr	r3, [r7, #0]
  40783c:	ea4f 74e3 	mov.w	r4, r3, asr #31
  407840:	fb03 fe02 	mul.w	lr, r3, r2
  407844:	fb01 f004 	mul.w	r0, r1, r4
  407848:	4470      	add	r0, lr
  40784a:	fba1 3403 	umull	r3, r4, r1, r3
  40784e:	1902      	adds	r2, r0, r4
  407850:	4614      	mov	r4, r2
  407852:	0bdd      	lsrs	r5, r3, #15
  407854:	ea45 4544 	orr.w	r5, r5, r4, lsl #17
  407858:	13e6      	asrs	r6, r4, #15
  40785a:	462b      	mov	r3, r5
  40785c:	60fb      	str	r3, [r7, #12]
	return out;
  40785e:	68fb      	ldr	r3, [r7, #12]
}
  407860:	4618      	mov	r0, r3
  407862:	3714      	adds	r7, #20
  407864:	46bd      	mov	sp, r7
  407866:	bdf0      	pop	{r4, r5, r6, r7, pc}

00407868 <invn_convert_inv_sqrt_q15_fxp>:

static long invn_convert_inv_sqrt_q15_fxp(long x_q15)
{
  407868:	b580      	push	{r7, lr}
  40786a:	b08a      	sub	sp, #40	; 0x28
  40786c:	af00      	add	r7, sp, #0
  40786e:	6078      	str	r0, [r7, #4]
    long oneoversqrt2 = 23170L; // int32(2^15*1/sqrt(2))
  407870:	f645 2382 	movw	r3, #23170	; 0x5a82
  407874:	61bb      	str	r3, [r7, #24]
    long oneandhalf = 49152L; // int32(1.5*2^15);
  407876:	f44f 4340 	mov.w	r3, #49152	; 0xc000
  40787a:	617b      	str	r3, [r7, #20]
    long upperlimit = 45426; // int32(log(4)*2^15);
  40787c:	f24b 1372 	movw	r3, #45426	; 0xb172
  407880:	613b      	str	r3, [r7, #16]
    long lowerlimit = 22713; // int32(log(2)*2^15); 
  407882:	f645 03b9 	movw	r3, #22713	; 0x58b9
  407886:	60fb      	str	r3, [r7, #12]
    long xx, x0_2, invsqrtx;
    int pow2;

    if (x_q15 <= 0)
  407888:	687b      	ldr	r3, [r7, #4]
  40788a:	2b00      	cmp	r3, #0
  40788c:	dc01      	bgt.n	407892 <invn_convert_inv_sqrt_q15_fxp+0x2a>
        return 0L;
  40788e:	2300      	movs	r3, #0
  407890:	e078      	b.n	407984 <invn_convert_inv_sqrt_q15_fxp+0x11c>

    pow2 = 0;
  407892:	2300      	movs	r3, #0
  407894:	61fb      	str	r3, [r7, #28]
    xx = x_q15;
  407896:	687b      	ldr	r3, [r7, #4]
  407898:	627b      	str	r3, [r7, #36]	; 0x24
    if (xx > upperlimit) {
  40789a:	6a7a      	ldr	r2, [r7, #36]	; 0x24
  40789c:	693b      	ldr	r3, [r7, #16]
  40789e:	429a      	cmp	r2, r3
  4078a0:	dd0c      	ble.n	4078bc <invn_convert_inv_sqrt_q15_fxp+0x54>
downscale:
        if (xx > upperlimit) {
  4078a2:	6a7a      	ldr	r2, [r7, #36]	; 0x24
  4078a4:	693b      	ldr	r3, [r7, #16]
  4078a6:	429a      	cmp	r2, r3
  4078a8:	dd17      	ble.n	4078da <invn_convert_inv_sqrt_q15_fxp+0x72>
            xx = xx/2;
  4078aa:	6a7b      	ldr	r3, [r7, #36]	; 0x24
  4078ac:	0fda      	lsrs	r2, r3, #31
  4078ae:	4413      	add	r3, r2
  4078b0:	105b      	asrs	r3, r3, #1
  4078b2:	627b      	str	r3, [r7, #36]	; 0x24
            pow2 = pow2 - 1;
  4078b4:	69fb      	ldr	r3, [r7, #28]
  4078b6:	3b01      	subs	r3, #1
  4078b8:	61fb      	str	r3, [r7, #28]
            goto downscale;
  4078ba:	e7f2      	b.n	4078a2 <invn_convert_inv_sqrt_q15_fxp+0x3a>
        }
        goto newton_raphson;
    }

    if (xx < lowerlimit) {
  4078bc:	6a7a      	ldr	r2, [r7, #36]	; 0x24
  4078be:	68fb      	ldr	r3, [r7, #12]
  4078c0:	429a      	cmp	r2, r3
  4078c2:	da0d      	bge.n	4078e0 <invn_convert_inv_sqrt_q15_fxp+0x78>
upscale:
        if (xx < lowerlimit) {
  4078c4:	6a7a      	ldr	r2, [r7, #36]	; 0x24
  4078c6:	68fb      	ldr	r3, [r7, #12]
  4078c8:	429a      	cmp	r2, r3
  4078ca:	da08      	bge.n	4078de <invn_convert_inv_sqrt_q15_fxp+0x76>
            xx = xx*2;
  4078cc:	6a7b      	ldr	r3, [r7, #36]	; 0x24
  4078ce:	005b      	lsls	r3, r3, #1
  4078d0:	627b      	str	r3, [r7, #36]	; 0x24
            pow2 = pow2 + 1;
  4078d2:	69fb      	ldr	r3, [r7, #28]
  4078d4:	3301      	adds	r3, #1
  4078d6:	61fb      	str	r3, [r7, #28]
            goto upscale;
  4078d8:	e7f4      	b.n	4078c4 <invn_convert_inv_sqrt_q15_fxp+0x5c>
        goto newton_raphson;
  4078da:	bf00      	nop
  4078dc:	e000      	b.n	4078e0 <invn_convert_inv_sqrt_q15_fxp+0x78>
        }
        goto newton_raphson;
  4078de:	bf00      	nop
    }

newton_raphson:
    // 3 NR iterations. In some cases second and/or third iteration may not be needed, however
    // for code simplicity always iterate three times. Fourth iteration is below bit precision.
    x0_2 = xx >>1;
  4078e0:	6a7b      	ldr	r3, [r7, #36]	; 0x24
  4078e2:	105b      	asrs	r3, r3, #1
  4078e4:	60bb      	str	r3, [r7, #8]
    xx = oneandhalf - x0_2;
  4078e6:	697a      	ldr	r2, [r7, #20]
  4078e8:	68bb      	ldr	r3, [r7, #8]
  4078ea:	1ad3      	subs	r3, r2, r3
  4078ec:	627b      	str	r3, [r7, #36]	; 0x24
    xx = invn_convert_mult_q15_fxp( xx, ( oneandhalf - invn_convert_mult_q15_fxp(x0_2, invn_convert_mult_q15_fxp(xx,xx) ) ) );
  4078ee:	6a79      	ldr	r1, [r7, #36]	; 0x24
  4078f0:	6a78      	ldr	r0, [r7, #36]	; 0x24
  4078f2:	4b26      	ldr	r3, [pc, #152]	; (40798c <invn_convert_inv_sqrt_q15_fxp+0x124>)
  4078f4:	4798      	blx	r3
  4078f6:	4603      	mov	r3, r0
  4078f8:	4619      	mov	r1, r3
  4078fa:	68b8      	ldr	r0, [r7, #8]
  4078fc:	4b23      	ldr	r3, [pc, #140]	; (40798c <invn_convert_inv_sqrt_q15_fxp+0x124>)
  4078fe:	4798      	blx	r3
  407900:	4602      	mov	r2, r0
  407902:	697b      	ldr	r3, [r7, #20]
  407904:	1a9b      	subs	r3, r3, r2
  407906:	4619      	mov	r1, r3
  407908:	6a78      	ldr	r0, [r7, #36]	; 0x24
  40790a:	4b20      	ldr	r3, [pc, #128]	; (40798c <invn_convert_inv_sqrt_q15_fxp+0x124>)
  40790c:	4798      	blx	r3
  40790e:	6278      	str	r0, [r7, #36]	; 0x24
    xx = invn_convert_mult_q15_fxp( xx, ( oneandhalf - invn_convert_mult_q15_fxp(x0_2, invn_convert_mult_q15_fxp(xx,xx) ) ) );
  407910:	6a79      	ldr	r1, [r7, #36]	; 0x24
  407912:	6a78      	ldr	r0, [r7, #36]	; 0x24
  407914:	4b1d      	ldr	r3, [pc, #116]	; (40798c <invn_convert_inv_sqrt_q15_fxp+0x124>)
  407916:	4798      	blx	r3
  407918:	4603      	mov	r3, r0
  40791a:	4619      	mov	r1, r3
  40791c:	68b8      	ldr	r0, [r7, #8]
  40791e:	4b1b      	ldr	r3, [pc, #108]	; (40798c <invn_convert_inv_sqrt_q15_fxp+0x124>)
  407920:	4798      	blx	r3
  407922:	4602      	mov	r2, r0
  407924:	697b      	ldr	r3, [r7, #20]
  407926:	1a9b      	subs	r3, r3, r2
  407928:	4619      	mov	r1, r3
  40792a:	6a78      	ldr	r0, [r7, #36]	; 0x24
  40792c:	4b17      	ldr	r3, [pc, #92]	; (40798c <invn_convert_inv_sqrt_q15_fxp+0x124>)
  40792e:	4798      	blx	r3
  407930:	6278      	str	r0, [r7, #36]	; 0x24

    if (pow2 & 1) { // This checks if the number is even or odd.
  407932:	69fb      	ldr	r3, [r7, #28]
  407934:	f003 0301 	and.w	r3, r3, #1
  407938:	2b00      	cmp	r3, #0
  40793a:	d009      	beq.n	407950 <invn_convert_inv_sqrt_q15_fxp+0xe8>
        pow2 = (pow2>>1) + 1; // Account for sqrt(2) in denominator
  40793c:	69fb      	ldr	r3, [r7, #28]
  40793e:	105b      	asrs	r3, r3, #1
  407940:	3301      	adds	r3, #1
  407942:	61fb      	str	r3, [r7, #28]
        invsqrtx = (invn_convert_mult_q15_fxp(xx,oneoversqrt2));
  407944:	69b9      	ldr	r1, [r7, #24]
  407946:	6a78      	ldr	r0, [r7, #36]	; 0x24
  407948:	4b10      	ldr	r3, [pc, #64]	; (40798c <invn_convert_inv_sqrt_q15_fxp+0x124>)
  40794a:	4798      	blx	r3
  40794c:	6238      	str	r0, [r7, #32]
  40794e:	e004      	b.n	40795a <invn_convert_inv_sqrt_q15_fxp+0xf2>
    }
    else {
        pow2 = pow2>>1;
  407950:	69fb      	ldr	r3, [r7, #28]
  407952:	105b      	asrs	r3, r3, #1
  407954:	61fb      	str	r3, [r7, #28]
        invsqrtx =  xx;
  407956:	6a7b      	ldr	r3, [r7, #36]	; 0x24
  407958:	623b      	str	r3, [r7, #32]
    }

    if (pow2 < 0)
  40795a:	69fb      	ldr	r3, [r7, #28]
  40795c:	2b00      	cmp	r3, #0
  40795e:	da08      	bge.n	407972 <invn_convert_inv_sqrt_q15_fxp+0x10a>
        invsqrtx = invsqrtx>>ABS(pow2);
  407960:	69fb      	ldr	r3, [r7, #28]
  407962:	2b00      	cmp	r3, #0
  407964:	bfb8      	it	lt
  407966:	425b      	neglt	r3, r3
  407968:	6a3a      	ldr	r2, [r7, #32]
  40796a:	fa42 f303 	asr.w	r3, r2, r3
  40796e:	623b      	str	r3, [r7, #32]
  407970:	e007      	b.n	407982 <invn_convert_inv_sqrt_q15_fxp+0x11a>
    else if (pow2>0)
  407972:	69fb      	ldr	r3, [r7, #28]
  407974:	2b00      	cmp	r3, #0
  407976:	dd04      	ble.n	407982 <invn_convert_inv_sqrt_q15_fxp+0x11a>
        invsqrtx = invsqrtx <<pow2;
  407978:	6a3a      	ldr	r2, [r7, #32]
  40797a:	69fb      	ldr	r3, [r7, #28]
  40797c:	fa02 f303 	lsl.w	r3, r2, r3
  407980:	623b      	str	r3, [r7, #32]

    return invsqrtx;
  407982:	6a3b      	ldr	r3, [r7, #32]
}
  407984:	4618      	mov	r0, r3
  407986:	3728      	adds	r7, #40	; 0x28
  407988:	46bd      	mov	sp, r7
  40798a:	bd80      	pop	{r7, pc}
  40798c:	00407829 	.word	0x00407829

00407990 <invn_convert_inverse_q15_fxp>:

static long invn_convert_inverse_q15_fxp(long x_q15)
{
  407990:	b580      	push	{r7, lr}
  407992:	b084      	sub	sp, #16
  407994:	af00      	add	r7, sp, #0
  407996:	6078      	str	r0, [r7, #4]
    long y;
    int negx;

	if (x_q15 == 0) {
  407998:	687b      	ldr	r3, [r7, #4]
  40799a:	2b00      	cmp	r3, #0
  40799c:	d103      	bne.n	4079a6 <invn_convert_inverse_q15_fxp+0x16>
		y = 0L;
  40799e:	2300      	movs	r3, #0
  4079a0:	60fb      	str	r3, [r7, #12]
		return y;
  4079a2:	68fb      	ldr	r3, [r7, #12]
  4079a4:	e028      	b.n	4079f8 <invn_convert_inverse_q15_fxp+0x68>
	}

    negx=0;
  4079a6:	2300      	movs	r3, #0
  4079a8:	60bb      	str	r3, [r7, #8]
    if (x_q15 < 0 ) {
  4079aa:	687b      	ldr	r3, [r7, #4]
  4079ac:	2b00      	cmp	r3, #0
  4079ae:	da04      	bge.n	4079ba <invn_convert_inverse_q15_fxp+0x2a>
        x_q15 = -x_q15;
  4079b0:	687b      	ldr	r3, [r7, #4]
  4079b2:	425b      	negs	r3, r3
  4079b4:	607b      	str	r3, [r7, #4]
        negx = 1;
  4079b6:	2301      	movs	r3, #1
  4079b8:	60bb      	str	r3, [r7, #8]
    }

	if(x_q15 >= 1073741824L) { // 2^15 in Q15; underflow number
  4079ba:	687b      	ldr	r3, [r7, #4]
  4079bc:	f1b3 4f80 	cmp.w	r3, #1073741824	; 0x40000000
  4079c0:	db0a      	blt.n	4079d8 <invn_convert_inverse_q15_fxp+0x48>
        if (negx)
  4079c2:	68bb      	ldr	r3, [r7, #8]
  4079c4:	2b00      	cmp	r3, #0
  4079c6:	d003      	beq.n	4079d0 <invn_convert_inverse_q15_fxp+0x40>
            y=-1L;
  4079c8:	f04f 33ff 	mov.w	r3, #4294967295
  4079cc:	60fb      	str	r3, [r7, #12]
  4079ce:	e001      	b.n	4079d4 <invn_convert_inverse_q15_fxp+0x44>
        else
            y = 1L;
  4079d0:	2301      	movs	r3, #1
  4079d2:	60fb      	str	r3, [r7, #12]
		return y;
  4079d4:	68fb      	ldr	r3, [r7, #12]
  4079d6:	e00f      	b.n	4079f8 <invn_convert_inverse_q15_fxp+0x68>
	}

    y = invn_convert_inv_sqrt_q15_fxp(x_q15); // sqrt(y)
  4079d8:	6878      	ldr	r0, [r7, #4]
  4079da:	4b09      	ldr	r3, [pc, #36]	; (407a00 <invn_convert_inverse_q15_fxp+0x70>)
  4079dc:	4798      	blx	r3
  4079de:	60f8      	str	r0, [r7, #12]
    y = invn_convert_mult_q15_fxp(y, y);
  4079e0:	68f9      	ldr	r1, [r7, #12]
  4079e2:	68f8      	ldr	r0, [r7, #12]
  4079e4:	4b07      	ldr	r3, [pc, #28]	; (407a04 <invn_convert_inverse_q15_fxp+0x74>)
  4079e6:	4798      	blx	r3
  4079e8:	60f8      	str	r0, [r7, #12]

    if (negx)
  4079ea:	68bb      	ldr	r3, [r7, #8]
  4079ec:	2b00      	cmp	r3, #0
  4079ee:	d002      	beq.n	4079f6 <invn_convert_inverse_q15_fxp+0x66>
        y=-y;
  4079f0:	68fb      	ldr	r3, [r7, #12]
  4079f2:	425b      	negs	r3, r3
  4079f4:	60fb      	str	r3, [r7, #12]
    return y;
  4079f6:	68fb      	ldr	r3, [r7, #12]
}
  4079f8:	4618      	mov	r0, r3
  4079fa:	3710      	adds	r7, #16
  4079fc:	46bd      	mov	sp, r7
  4079fe:	bd80      	pop	{r7, pc}
  407a00:	00407869 	.word	0x00407869
  407a04:	00407829 	.word	0x00407829

00407a08 <inv_icm20948_math_atan2_q15_fxp>:

long inv_icm20948_math_atan2_q15_fxp(long y_q15, long x_q15)
{
  407a08:	b580      	push	{r7, lr}
  407a0a:	b08a      	sub	sp, #40	; 0x28
  407a0c:	af00      	add	r7, sp, #0
  407a0e:	6078      	str	r0, [r7, #4]
  407a10:	6039      	str	r1, [r7, #0]
    long absy, absx, maxABS, tmp, tmp2, tmp3, Z, angle;
    static long constA7[4] = {32740, -10503,  4751, -1254}; // int32(2^15*[0.999133448222780 -0.320533292381664 0.144982490144465,-0.038254464970299]); %7th order
    static long PI15 = 102944; // int32(2^15*pi): pi in Q15

    absx=ABS(x_q15);
  407a12:	683b      	ldr	r3, [r7, #0]
  407a14:	2b00      	cmp	r3, #0
  407a16:	bfb8      	it	lt
  407a18:	425b      	neglt	r3, r3
  407a1a:	623b      	str	r3, [r7, #32]
    absy=ABS(y_q15);
  407a1c:	687b      	ldr	r3, [r7, #4]
  407a1e:	2b00      	cmp	r3, #0
  407a20:	bfb8      	it	lt
  407a22:	425b      	neglt	r3, r3
  407a24:	627b      	str	r3, [r7, #36]	; 0x24

    maxABS=MAX(absx, absy);
  407a26:	6a7a      	ldr	r2, [r7, #36]	; 0x24
  407a28:	6a3b      	ldr	r3, [r7, #32]
  407a2a:	4293      	cmp	r3, r2
  407a2c:	bfb8      	it	lt
  407a2e:	4613      	movlt	r3, r2
  407a30:	61fb      	str	r3, [r7, #28]
    // SCALE arguments down to protect from roundoff loss due to 1/x operation.
    //% Threshold for scaling found by numericaly simulating arguments
    //% to yield optimal (minimal) error of less than 0.01 deg through
    //% entire range (for Chebycheff order 7).
//    while ( maxABS >> 13) {  --> Or it can be done this way if DMP code is more efficient
    while ( maxABS > 8192L) {
  407a32:	e00e      	b.n	407a52 <inv_icm20948_math_atan2_q15_fxp+0x4a>
            maxABS=maxABS/2;
  407a34:	69fb      	ldr	r3, [r7, #28]
  407a36:	0fda      	lsrs	r2, r3, #31
  407a38:	4413      	add	r3, r2
  407a3a:	105b      	asrs	r3, r3, #1
  407a3c:	61fb      	str	r3, [r7, #28]
            absx=absx/2;
  407a3e:	6a3b      	ldr	r3, [r7, #32]
  407a40:	0fda      	lsrs	r2, r3, #31
  407a42:	4413      	add	r3, r2
  407a44:	105b      	asrs	r3, r3, #1
  407a46:	623b      	str	r3, [r7, #32]
            absy=absy/2;
  407a48:	6a7b      	ldr	r3, [r7, #36]	; 0x24
  407a4a:	0fda      	lsrs	r2, r3, #31
  407a4c:	4413      	add	r3, r2
  407a4e:	105b      	asrs	r3, r3, #1
  407a50:	627b      	str	r3, [r7, #36]	; 0x24
    while ( maxABS > 8192L) {
  407a52:	69fb      	ldr	r3, [r7, #28]
  407a54:	f5b3 5f00 	cmp.w	r3, #8192	; 0x2000
  407a58:	dcec      	bgt.n	407a34 <inv_icm20948_math_atan2_q15_fxp+0x2c>
    }

    {
        if (absx >= absy) // (0, pi/4]: tmp = abs(y)/abs(x);
  407a5a:	6a3a      	ldr	r2, [r7, #32]
  407a5c:	6a7b      	ldr	r3, [r7, #36]	; 0x24
  407a5e:	429a      	cmp	r2, r3
  407a60:	db09      	blt.n	407a76 <inv_icm20948_math_atan2_q15_fxp+0x6e>
            tmp = invn_convert_mult_q15_fxp(absy, invn_convert_inverse_q15_fxp(absx));
  407a62:	6a38      	ldr	r0, [r7, #32]
  407a64:	4b32      	ldr	r3, [pc, #200]	; (407b30 <inv_icm20948_math_atan2_q15_fxp+0x128>)
  407a66:	4798      	blx	r3
  407a68:	4603      	mov	r3, r0
  407a6a:	4619      	mov	r1, r3
  407a6c:	6a78      	ldr	r0, [r7, #36]	; 0x24
  407a6e:	4b31      	ldr	r3, [pc, #196]	; (407b34 <inv_icm20948_math_atan2_q15_fxp+0x12c>)
  407a70:	4798      	blx	r3
  407a72:	61b8      	str	r0, [r7, #24]
  407a74:	e008      	b.n	407a88 <inv_icm20948_math_atan2_q15_fxp+0x80>
        else             // (pi/4, pi/2): tmp = abs(x)/abs(y);
            tmp = invn_convert_mult_q15_fxp(absx, invn_convert_inverse_q15_fxp(absy));
  407a76:	6a78      	ldr	r0, [r7, #36]	; 0x24
  407a78:	4b2d      	ldr	r3, [pc, #180]	; (407b30 <inv_icm20948_math_atan2_q15_fxp+0x128>)
  407a7a:	4798      	blx	r3
  407a7c:	4603      	mov	r3, r0
  407a7e:	4619      	mov	r1, r3
  407a80:	6a38      	ldr	r0, [r7, #32]
  407a82:	4b2c      	ldr	r3, [pc, #176]	; (407b34 <inv_icm20948_math_atan2_q15_fxp+0x12c>)
  407a84:	4798      	blx	r3
  407a86:	61b8      	str	r0, [r7, #24]

        tmp2=invn_convert_mult_q15_fxp(tmp, tmp);
  407a88:	69b9      	ldr	r1, [r7, #24]
  407a8a:	69b8      	ldr	r0, [r7, #24]
  407a8c:	4b29      	ldr	r3, [pc, #164]	; (407b34 <inv_icm20948_math_atan2_q15_fxp+0x12c>)
  407a8e:	4798      	blx	r3
  407a90:	6138      	str	r0, [r7, #16]
         // Alternatively:
        tmp3 = invn_convert_mult_q15_fxp(constA7[3], tmp2);
  407a92:	4b29      	ldr	r3, [pc, #164]	; (407b38 <inv_icm20948_math_atan2_q15_fxp+0x130>)
  407a94:	68db      	ldr	r3, [r3, #12]
  407a96:	6939      	ldr	r1, [r7, #16]
  407a98:	4618      	mov	r0, r3
  407a9a:	4b26      	ldr	r3, [pc, #152]	; (407b34 <inv_icm20948_math_atan2_q15_fxp+0x12c>)
  407a9c:	4798      	blx	r3
  407a9e:	60f8      	str	r0, [r7, #12]
        tmp3 = invn_convert_mult_q15_fxp(constA7[2] + tmp3, tmp2);
  407aa0:	4b25      	ldr	r3, [pc, #148]	; (407b38 <inv_icm20948_math_atan2_q15_fxp+0x130>)
  407aa2:	689a      	ldr	r2, [r3, #8]
  407aa4:	68fb      	ldr	r3, [r7, #12]
  407aa6:	4413      	add	r3, r2
  407aa8:	6939      	ldr	r1, [r7, #16]
  407aaa:	4618      	mov	r0, r3
  407aac:	4b21      	ldr	r3, [pc, #132]	; (407b34 <inv_icm20948_math_atan2_q15_fxp+0x12c>)
  407aae:	4798      	blx	r3
  407ab0:	60f8      	str	r0, [r7, #12]
        tmp3 = invn_convert_mult_q15_fxp(constA7[1] + tmp3, tmp2);
  407ab2:	4b21      	ldr	r3, [pc, #132]	; (407b38 <inv_icm20948_math_atan2_q15_fxp+0x130>)
  407ab4:	685a      	ldr	r2, [r3, #4]
  407ab6:	68fb      	ldr	r3, [r7, #12]
  407ab8:	4413      	add	r3, r2
  407aba:	6939      	ldr	r1, [r7, #16]
  407abc:	4618      	mov	r0, r3
  407abe:	4b1d      	ldr	r3, [pc, #116]	; (407b34 <inv_icm20948_math_atan2_q15_fxp+0x12c>)
  407ac0:	4798      	blx	r3
  407ac2:	60f8      	str	r0, [r7, #12]
        Z    = invn_convert_mult_q15_fxp(constA7[0] + tmp3, tmp);
  407ac4:	4b1c      	ldr	r3, [pc, #112]	; (407b38 <inv_icm20948_math_atan2_q15_fxp+0x130>)
  407ac6:	681a      	ldr	r2, [r3, #0]
  407ac8:	68fb      	ldr	r3, [r7, #12]
  407aca:	4413      	add	r3, r2
  407acc:	69b9      	ldr	r1, [r7, #24]
  407ace:	4618      	mov	r0, r3
  407ad0:	4b18      	ldr	r3, [pc, #96]	; (407b34 <inv_icm20948_math_atan2_q15_fxp+0x12c>)
  407ad2:	4798      	blx	r3
  407ad4:	6178      	str	r0, [r7, #20]

        if (absx < absy)
  407ad6:	6a3a      	ldr	r2, [r7, #32]
  407ad8:	6a7b      	ldr	r3, [r7, #36]	; 0x24
  407ada:	429a      	cmp	r2, r3
  407adc:	da08      	bge.n	407af0 <inv_icm20948_math_atan2_q15_fxp+0xe8>
            Z = PI15/2 - Z;
  407ade:	4b17      	ldr	r3, [pc, #92]	; (407b3c <inv_icm20948_math_atan2_q15_fxp+0x134>)
  407ae0:	681b      	ldr	r3, [r3, #0]
  407ae2:	0fda      	lsrs	r2, r3, #31
  407ae4:	4413      	add	r3, r2
  407ae6:	105b      	asrs	r3, r3, #1
  407ae8:	461a      	mov	r2, r3
  407aea:	697b      	ldr	r3, [r7, #20]
  407aec:	1ad3      	subs	r3, r2, r3
  407aee:	617b      	str	r3, [r7, #20]

        if (x_q15 < 0) { // second and third quadrant
  407af0:	683b      	ldr	r3, [r7, #0]
  407af2:	2b00      	cmp	r3, #0
  407af4:	da0e      	bge.n	407b14 <inv_icm20948_math_atan2_q15_fxp+0x10c>
            if (y_q15 < 0)
  407af6:	687b      	ldr	r3, [r7, #4]
  407af8:	2b00      	cmp	r3, #0
  407afa:	da05      	bge.n	407b08 <inv_icm20948_math_atan2_q15_fxp+0x100>
                Z = -PI15 + Z;
  407afc:	4b0f      	ldr	r3, [pc, #60]	; (407b3c <inv_icm20948_math_atan2_q15_fxp+0x134>)
  407afe:	681b      	ldr	r3, [r3, #0]
  407b00:	697a      	ldr	r2, [r7, #20]
  407b02:	1ad3      	subs	r3, r2, r3
  407b04:	617b      	str	r3, [r7, #20]
  407b06:	e00b      	b.n	407b20 <inv_icm20948_math_atan2_q15_fxp+0x118>
            else
                Z = PI15 - Z;
  407b08:	4b0c      	ldr	r3, [pc, #48]	; (407b3c <inv_icm20948_math_atan2_q15_fxp+0x134>)
  407b0a:	681a      	ldr	r2, [r3, #0]
  407b0c:	697b      	ldr	r3, [r7, #20]
  407b0e:	1ad3      	subs	r3, r2, r3
  407b10:	617b      	str	r3, [r7, #20]
  407b12:	e005      	b.n	407b20 <inv_icm20948_math_atan2_q15_fxp+0x118>
        }
        else { // fourth quadrant
            if (y_q15 < 0)
  407b14:	687b      	ldr	r3, [r7, #4]
  407b16:	2b00      	cmp	r3, #0
  407b18:	da02      	bge.n	407b20 <inv_icm20948_math_atan2_q15_fxp+0x118>
                Z = -Z;
  407b1a:	697b      	ldr	r3, [r7, #20]
  407b1c:	425b      	negs	r3, r3
  407b1e:	617b      	str	r3, [r7, #20]
        }
        angle = Z; // Note the result is angle in radians, expressed in Q15.
  407b20:	697b      	ldr	r3, [r7, #20]
  407b22:	60bb      	str	r3, [r7, #8]
    }
    return angle;
  407b24:	68bb      	ldr	r3, [r7, #8]
}
  407b26:	4618      	mov	r0, r3
  407b28:	3728      	adds	r7, #40	; 0x28
  407b2a:	46bd      	mov	sp, r7
  407b2c:	bd80      	pop	{r7, pc}
  407b2e:	bf00      	nop
  407b30:	00407991 	.word	0x00407991
  407b34:	00407829 	.word	0x00407829
  407b38:	20000120 	.word	0x20000120
  407b3c:	20000130 	.word	0x20000130

00407b40 <inv_icm20948_convert_int16_to_big8>:

uint8_t *inv_icm20948_convert_int16_to_big8(int16_t x, uint8_t *big8)
{
  407b40:	b480      	push	{r7}
  407b42:	b083      	sub	sp, #12
  407b44:	af00      	add	r7, sp, #0
  407b46:	4603      	mov	r3, r0
  407b48:	6039      	str	r1, [r7, #0]
  407b4a:	80fb      	strh	r3, [r7, #6]
    big8[0] = (uint8_t)((x >> 8) & 0xff);
  407b4c:	f9b7 3006 	ldrsh.w	r3, [r7, #6]
  407b50:	121b      	asrs	r3, r3, #8
  407b52:	b21b      	sxth	r3, r3
  407b54:	b2da      	uxtb	r2, r3
  407b56:	683b      	ldr	r3, [r7, #0]
  407b58:	701a      	strb	r2, [r3, #0]
    big8[1] = (uint8_t)(x & 0xff);
  407b5a:	683b      	ldr	r3, [r7, #0]
  407b5c:	3301      	adds	r3, #1
  407b5e:	88fa      	ldrh	r2, [r7, #6]
  407b60:	b2d2      	uxtb	r2, r2
  407b62:	701a      	strb	r2, [r3, #0]
    return big8;
  407b64:	683b      	ldr	r3, [r7, #0]
}
  407b66:	4618      	mov	r0, r3
  407b68:	370c      	adds	r7, #12
  407b6a:	46bd      	mov	sp, r7
  407b6c:	f85d 7b04 	ldr.w	r7, [sp], #4
  407b70:	4770      	bx	lr

00407b72 <inv_icm20948_convert_int32_to_big8>:

uint8_t *inv_icm20948_convert_int32_to_big8(int32_t x, uint8_t *big8)
{
  407b72:	b480      	push	{r7}
  407b74:	b083      	sub	sp, #12
  407b76:	af00      	add	r7, sp, #0
  407b78:	6078      	str	r0, [r7, #4]
  407b7a:	6039      	str	r1, [r7, #0]
    big8[0] = (uint8_t)((x >> 24) & 0xff);
  407b7c:	687b      	ldr	r3, [r7, #4]
  407b7e:	161b      	asrs	r3, r3, #24
  407b80:	b2da      	uxtb	r2, r3
  407b82:	683b      	ldr	r3, [r7, #0]
  407b84:	701a      	strb	r2, [r3, #0]
    big8[1] = (uint8_t)((x >> 16) & 0xff);
  407b86:	683b      	ldr	r3, [r7, #0]
  407b88:	3301      	adds	r3, #1
  407b8a:	687a      	ldr	r2, [r7, #4]
  407b8c:	1412      	asrs	r2, r2, #16
  407b8e:	b2d2      	uxtb	r2, r2
  407b90:	701a      	strb	r2, [r3, #0]
    big8[2] = (uint8_t)((x >> 8) & 0xff);
  407b92:	683b      	ldr	r3, [r7, #0]
  407b94:	3302      	adds	r3, #2
  407b96:	687a      	ldr	r2, [r7, #4]
  407b98:	1212      	asrs	r2, r2, #8
  407b9a:	b2d2      	uxtb	r2, r2
  407b9c:	701a      	strb	r2, [r3, #0]
    big8[3] = (uint8_t)(x & 0xff);
  407b9e:	683b      	ldr	r3, [r7, #0]
  407ba0:	3303      	adds	r3, #3
  407ba2:	687a      	ldr	r2, [r7, #4]
  407ba4:	b2d2      	uxtb	r2, r2
  407ba6:	701a      	strb	r2, [r3, #0]
    return big8;
  407ba8:	683b      	ldr	r3, [r7, #0]
}
  407baa:	4618      	mov	r0, r3
  407bac:	370c      	adds	r7, #12
  407bae:	46bd      	mov	sp, r7
  407bb0:	f85d 7b04 	ldr.w	r7, [sp], #4
  407bb4:	4770      	bx	lr

00407bb6 <inv_icm20948_convert_big8_to_int32>:

int32_t inv_icm20948_convert_big8_to_int32(const uint8_t *big8)
{
  407bb6:	b480      	push	{r7}
  407bb8:	b085      	sub	sp, #20
  407bba:	af00      	add	r7, sp, #0
  407bbc:	6078      	str	r0, [r7, #4]
    int32_t x;
    x = ((int32_t)big8[0] << 24) | ((int32_t)big8[1] << 16) | ((int32_t)big8[2] << 8)
  407bbe:	687b      	ldr	r3, [r7, #4]
  407bc0:	781b      	ldrb	r3, [r3, #0]
  407bc2:	061a      	lsls	r2, r3, #24
  407bc4:	687b      	ldr	r3, [r7, #4]
  407bc6:	3301      	adds	r3, #1
  407bc8:	781b      	ldrb	r3, [r3, #0]
  407bca:	041b      	lsls	r3, r3, #16
  407bcc:	431a      	orrs	r2, r3
  407bce:	687b      	ldr	r3, [r7, #4]
  407bd0:	3302      	adds	r3, #2
  407bd2:	781b      	ldrb	r3, [r3, #0]
  407bd4:	021b      	lsls	r3, r3, #8
  407bd6:	4313      	orrs	r3, r2
        | ((int32_t)big8[3]);
  407bd8:	687a      	ldr	r2, [r7, #4]
  407bda:	3203      	adds	r2, #3
  407bdc:	7812      	ldrb	r2, [r2, #0]
    x = ((int32_t)big8[0] << 24) | ((int32_t)big8[1] << 16) | ((int32_t)big8[2] << 8)
  407bde:	4313      	orrs	r3, r2
  407be0:	60fb      	str	r3, [r7, #12]
    return x;
  407be2:	68fb      	ldr	r3, [r7, #12]
}
  407be4:	4618      	mov	r0, r3
  407be6:	3714      	adds	r7, #20
  407be8:	46bd      	mov	sp, r7
  407bea:	f85d 7b04 	ldr.w	r7, [sp], #4
  407bee:	4770      	bx	lr

00407bf0 <inv_icm20948_load_firmware>:

/** Loads the dmp firmware for the icm20948 part.
* @param[in] dmp_image_sram Load DMP3 image from SRAM.
*/
int inv_icm20948_load_firmware(struct inv_icm20948 * s, const unsigned char *dmp3_image, unsigned int dmp3_image_size)
{
  407bf0:	b590      	push	{r4, r7, lr}
  407bf2:	b085      	sub	sp, #20
  407bf4:	af00      	add	r7, sp, #0
  407bf6:	60f8      	str	r0, [r7, #12]
  407bf8:	60b9      	str	r1, [r7, #8]
  407bfa:	607a      	str	r2, [r7, #4]
	return inv_icm20948_firmware_load(s, dmp3_image, dmp3_image_size, DMP_LOAD_START);
  407bfc:	687b      	ldr	r3, [r7, #4]
  407bfe:	b29a      	uxth	r2, r3
  407c00:	2390      	movs	r3, #144	; 0x90
  407c02:	68b9      	ldr	r1, [r7, #8]
  407c04:	68f8      	ldr	r0, [r7, #12]
  407c06:	4c03      	ldr	r4, [pc, #12]	; (407c14 <inv_icm20948_load_firmware+0x24>)
  407c08:	47a0      	blx	r4
  407c0a:	4603      	mov	r3, r0
}
  407c0c:	4618      	mov	r0, r3
  407c0e:	3714      	adds	r7, #20
  407c10:	46bd      	mov	sp, r7
  407c12:	bd90      	pop	{r4, r7, pc}
  407c14:	0040885d 	.word	0x0040885d

00407c18 <inv_icm20948_get_dmp_start_address>:

/** Loads the dmp firmware for the icm20948 part.
* @param[out] dmp_cnfg The config item
*/
void inv_icm20948_get_dmp_start_address(struct inv_icm20948 * s, unsigned short *dmp_cnfg)
{
  407c18:	b480      	push	{r7}
  407c1a:	b083      	sub	sp, #12
  407c1c:	af00      	add	r7, sp, #0
  407c1e:	6078      	str	r0, [r7, #4]
  407c20:	6039      	str	r1, [r7, #0]

	(void)s;

	*dmp_cnfg = DMP_START_ADDRESS;
  407c22:	683b      	ldr	r3, [r7, #0]
  407c24:	f44f 5280 	mov.w	r2, #4096	; 0x1000
  407c28:	801a      	strh	r2, [r3, #0]
}
  407c2a:	bf00      	nop
  407c2c:	370c      	adds	r7, #12
  407c2e:	46bd      	mov	sp, r7
  407c30:	f85d 7b04 	ldr.w	r7, [sp], #4
  407c34:	4770      	bx	lr
	...

00407c38 <dmp_icm20948_set_data_output_control1>:
*	PED_STEPDET_SET		0x0010 - timestamp when each step is detected
*	HEADER2_SET			0x0008 - enable/disable data output in data output control register 2
*	PED_STEPIND_SET		0x0007 - number of steps detected will be attached to the 3 least significant bits of header
*/
int dmp_icm20948_set_data_output_control1(struct inv_icm20948 * s, int output_mask)
{
  407c38:	b590      	push	{r4, r7, lr}
  407c3a:	b085      	sub	sp, #20
  407c3c:	af00      	add	r7, sp, #0
  407c3e:	6078      	str	r0, [r7, #4]
  407c40:	6039      	str	r1, [r7, #0]

	int result;
	unsigned char data_output_control_reg1[2];

	data_output_control_reg1[0] = (unsigned char)(output_mask >> 8);
  407c42:	683b      	ldr	r3, [r7, #0]
  407c44:	121b      	asrs	r3, r3, #8
  407c46:	b2db      	uxtb	r3, r3
  407c48:	723b      	strb	r3, [r7, #8]
	data_output_control_reg1[1] = (unsigned char)(output_mask & 0xff);
  407c4a:	683b      	ldr	r3, [r7, #0]
  407c4c:	b2db      	uxtb	r3, r3
  407c4e:	727b      	strb	r3, [r7, #9]

	result = inv_icm20948_write_mems(s, DATA_OUT_CTL1, 2, data_output_control_reg1);
  407c50:	f107 0308 	add.w	r3, r7, #8
  407c54:	2202      	movs	r2, #2
  407c56:	2140      	movs	r1, #64	; 0x40
  407c58:	6878      	ldr	r0, [r7, #4]
  407c5a:	4c04      	ldr	r4, [pc, #16]	; (407c6c <dmp_icm20948_set_data_output_control1+0x34>)
  407c5c:	47a0      	blx	r4
  407c5e:	60f8      	str	r0, [r7, #12]

	return result;
  407c60:	68fb      	ldr	r3, [r7, #12]
}
  407c62:	4618      	mov	r0, r3
  407c64:	3714      	adds	r7, #20
  407c66:	46bd      	mov	sp, r7
  407c68:	bd90      	pop	{r4, r7, pc}
  407c6a:	bf00      	nop
  407c6c:	0040cab1 	.word	0x0040cab1

00407c70 <dmp_icm20948_set_data_output_control2>:
*	GYRO_ACCURACY_SET	0x2000 - gyro accuracy when changes, HEADER2_SET also needs to be set in data output control regsiter 1
*	CPASS_ACCURACY_SET	0x1000 - compass accuracy when changes, HEADER2_SET also needs to be set in data output control regsiter 1
*	BATCH_MODE_EN		0x0100 - enable batching
*/
int dmp_icm20948_set_data_output_control2(struct inv_icm20948 * s, int output_mask)
{
  407c70:	b590      	push	{r4, r7, lr}
  407c72:	b085      	sub	sp, #20
  407c74:	af00      	add	r7, sp, #0
  407c76:	6078      	str	r0, [r7, #4]
  407c78:	6039      	str	r1, [r7, #0]
	int result;
	static unsigned char data_output_control_reg2[2]={0};

	data_output_control_reg2[0] = (unsigned char)(output_mask >> 8);
  407c7a:	683b      	ldr	r3, [r7, #0]
  407c7c:	121b      	asrs	r3, r3, #8
  407c7e:	b2da      	uxtb	r2, r3
  407c80:	4b08      	ldr	r3, [pc, #32]	; (407ca4 <dmp_icm20948_set_data_output_control2+0x34>)
  407c82:	701a      	strb	r2, [r3, #0]
	data_output_control_reg2[1] = (unsigned char)(output_mask & 0xff);
  407c84:	683b      	ldr	r3, [r7, #0]
  407c86:	b2da      	uxtb	r2, r3
  407c88:	4b06      	ldr	r3, [pc, #24]	; (407ca4 <dmp_icm20948_set_data_output_control2+0x34>)
  407c8a:	705a      	strb	r2, [r3, #1]

	result = inv_icm20948_write_mems(s, DATA_OUT_CTL2, 2, data_output_control_reg2);
  407c8c:	4b05      	ldr	r3, [pc, #20]	; (407ca4 <dmp_icm20948_set_data_output_control2+0x34>)
  407c8e:	2202      	movs	r2, #2
  407c90:	2142      	movs	r1, #66	; 0x42
  407c92:	6878      	ldr	r0, [r7, #4]
  407c94:	4c04      	ldr	r4, [pc, #16]	; (407ca8 <dmp_icm20948_set_data_output_control2+0x38>)
  407c96:	47a0      	blx	r4
  407c98:	60f8      	str	r0, [r7, #12]

	return result;
  407c9a:	68fb      	ldr	r3, [r7, #12]
}
  407c9c:	4618      	mov	r0, r3
  407c9e:	3714      	adds	r7, #20
  407ca0:	46bd      	mov	sp, r7
  407ca2:	bd90      	pop	{r4, r7, pc}
  407ca4:	2000143c 	.word	0x2000143c
  407ca8:	0040cab1 	.word	0x0040cab1

00407cac <dmp_icm20948_reset_control_registers>:
/**
* Clears all output control registers:
*	data output control register 1, data output control register 2, data interrupt control register, motion event control regsiter, data ready status register
*/
int dmp_icm20948_reset_control_registers(struct inv_icm20948 * s)
{
  407cac:	b590      	push	{r4, r7, lr}
  407cae:	b085      	sub	sp, #20
  407cb0:	af00      	add	r7, sp, #0
  407cb2:	6078      	str	r0, [r7, #4]
	int result;
	unsigned char data[4]={0};
  407cb4:	2300      	movs	r3, #0
  407cb6:	60bb      	str	r3, [r7, #8]

	//reset data output control registers
	result = inv_icm20948_write_mems(s, DATA_OUT_CTL1, 2, &data[0]);
  407cb8:	f107 0308 	add.w	r3, r7, #8
  407cbc:	2202      	movs	r2, #2
  407cbe:	2140      	movs	r1, #64	; 0x40
  407cc0:	6878      	ldr	r0, [r7, #4]
  407cc2:	4c1c      	ldr	r4, [pc, #112]	; (407d34 <dmp_icm20948_reset_control_registers+0x88>)
  407cc4:	47a0      	blx	r4
  407cc6:	60f8      	str	r0, [r7, #12]
	result += inv_icm20948_write_mems(s, DATA_OUT_CTL2, 2, &data[0]);
  407cc8:	f107 0308 	add.w	r3, r7, #8
  407ccc:	2202      	movs	r2, #2
  407cce:	2142      	movs	r1, #66	; 0x42
  407cd0:	6878      	ldr	r0, [r7, #4]
  407cd2:	4c18      	ldr	r4, [pc, #96]	; (407d34 <dmp_icm20948_reset_control_registers+0x88>)
  407cd4:	47a0      	blx	r4
  407cd6:	4602      	mov	r2, r0
  407cd8:	68fb      	ldr	r3, [r7, #12]
  407cda:	4413      	add	r3, r2
  407cdc:	60fb      	str	r3, [r7, #12]

	//reset data interrupt control register
	result += inv_icm20948_write_mems(s, DATA_INTR_CTL, 2, &data[0]);
  407cde:	f107 0308 	add.w	r3, r7, #8
  407ce2:	2202      	movs	r2, #2
  407ce4:	214c      	movs	r1, #76	; 0x4c
  407ce6:	6878      	ldr	r0, [r7, #4]
  407ce8:	4c12      	ldr	r4, [pc, #72]	; (407d34 <dmp_icm20948_reset_control_registers+0x88>)
  407cea:	47a0      	blx	r4
  407cec:	4602      	mov	r2, r0
  407cee:	68fb      	ldr	r3, [r7, #12]
  407cf0:	4413      	add	r3, r2
  407cf2:	60fb      	str	r3, [r7, #12]

	//reset motion event control register
	result += inv_icm20948_write_mems(s, MOTION_EVENT_CTL, 2, &data[0]);
  407cf4:	f107 0308 	add.w	r3, r7, #8
  407cf8:	2202      	movs	r2, #2
  407cfa:	214e      	movs	r1, #78	; 0x4e
  407cfc:	6878      	ldr	r0, [r7, #4]
  407cfe:	4c0d      	ldr	r4, [pc, #52]	; (407d34 <dmp_icm20948_reset_control_registers+0x88>)
  407d00:	47a0      	blx	r4
  407d02:	4602      	mov	r2, r0
  407d04:	68fb      	ldr	r3, [r7, #12]
  407d06:	4413      	add	r3, r2
  407d08:	60fb      	str	r3, [r7, #12]

	//reset data ready status register
	result += inv_icm20948_write_mems(s, DATA_RDY_STATUS, 2, &data[0]);
  407d0a:	f107 0308 	add.w	r3, r7, #8
  407d0e:	2202      	movs	r2, #2
  407d10:	218a      	movs	r1, #138	; 0x8a
  407d12:	6878      	ldr	r0, [r7, #4]
  407d14:	4c07      	ldr	r4, [pc, #28]	; (407d34 <dmp_icm20948_reset_control_registers+0x88>)
  407d16:	47a0      	blx	r4
  407d18:	4602      	mov	r2, r0
  407d1a:	68fb      	ldr	r3, [r7, #12]
  407d1c:	4413      	add	r3, r2
  407d1e:	60fb      	str	r3, [r7, #12]
	//result += inv_icm20948_write_mems(s, DATA_RDY_STATUS, 2, inv_icm20948_convert_int16_to_big8(3, data)); //fixme

	if (result) 
  407d20:	68fb      	ldr	r3, [r7, #12]
  407d22:	2b00      	cmp	r3, #0
  407d24:	d001      	beq.n	407d2a <dmp_icm20948_reset_control_registers+0x7e>
		return result;
  407d26:	68fb      	ldr	r3, [r7, #12]
  407d28:	e000      	b.n	407d2c <dmp_icm20948_reset_control_registers+0x80>

	return 0;
  407d2a:	2300      	movs	r3, #0
}
  407d2c:	4618      	mov	r0, r3
  407d2e:	3714      	adds	r7, #20
  407d30:	46bd      	mov	sp, r7
  407d32:	bd90      	pop	{r4, r7, pc}
  407d34:	0040cab1 	.word	0x0040cab1

00407d38 <dmp_icm20948_set_data_interrupt_control>:
*	PED_STEPDET_SET		0x0010 - timestamp when each step is detected
*	HEADER2_SET			0x0008 - data output defined in data output control register 2
*	PED_STEPIND_SET		0x0007 - number of steps detected will be attached to the 3 least significant bits of header
*/
int dmp_icm20948_set_data_interrupt_control(struct inv_icm20948 * s, uint32_t interrupt_ctl)
{
  407d38:	b590      	push	{r4, r7, lr}
  407d3a:	b085      	sub	sp, #20
  407d3c:	af00      	add	r7, sp, #0
  407d3e:	6078      	str	r0, [r7, #4]
  407d40:	6039      	str	r1, [r7, #0]
	int result;
	unsigned char big8[2]={0};
  407d42:	2300      	movs	r3, #0
  407d44:	813b      	strh	r3, [r7, #8]

	result = inv_icm20948_write_mems(s, DATA_INTR_CTL, 2, inv_icm20948_convert_int16_to_big8(interrupt_ctl, big8));
  407d46:	683b      	ldr	r3, [r7, #0]
  407d48:	b21b      	sxth	r3, r3
  407d4a:	f107 0208 	add.w	r2, r7, #8
  407d4e:	4611      	mov	r1, r2
  407d50:	4618      	mov	r0, r3
  407d52:	4b09      	ldr	r3, [pc, #36]	; (407d78 <dmp_icm20948_set_data_interrupt_control+0x40>)
  407d54:	4798      	blx	r3
  407d56:	4603      	mov	r3, r0
  407d58:	2202      	movs	r2, #2
  407d5a:	214c      	movs	r1, #76	; 0x4c
  407d5c:	6878      	ldr	r0, [r7, #4]
  407d5e:	4c07      	ldr	r4, [pc, #28]	; (407d7c <dmp_icm20948_set_data_interrupt_control+0x44>)
  407d60:	47a0      	blx	r4
  407d62:	60f8      	str	r0, [r7, #12]

	if (result) 
  407d64:	68fb      	ldr	r3, [r7, #12]
  407d66:	2b00      	cmp	r3, #0
  407d68:	d001      	beq.n	407d6e <dmp_icm20948_set_data_interrupt_control+0x36>
		return result;
  407d6a:	68fb      	ldr	r3, [r7, #12]
  407d6c:	e000      	b.n	407d70 <dmp_icm20948_set_data_interrupt_control+0x38>

	return 0;
  407d6e:	2300      	movs	r3, #0
}
  407d70:	4618      	mov	r0, r3
  407d72:	3714      	adds	r7, #20
  407d74:	46bd      	mov	sp, r7
  407d76:	bd90      	pop	{r4, r7, pc}
  407d78:	00407b41 	.word	0x00407b41
  407d7c:	0040cab1 	.word	0x0040cab1

00407d80 <dmp_icm20948_set_FIFO_watermark>:
/**
* Sets FIFO watermark. DMP will send FIFO interrupt if FIFO count > FIFO watermark
* @param[in] fifo_wm	FIFO watermark set to 80% of actual FIFO size by default
*/
int dmp_icm20948_set_FIFO_watermark(struct inv_icm20948 * s, unsigned short fifo_wm)
{
  407d80:	b590      	push	{r4, r7, lr}
  407d82:	b085      	sub	sp, #20
  407d84:	af00      	add	r7, sp, #0
  407d86:	6078      	str	r0, [r7, #4]
  407d88:	460b      	mov	r3, r1
  407d8a:	807b      	strh	r3, [r7, #2]
	int result;
	unsigned char big8[2]={0};
  407d8c:	2300      	movs	r3, #0
  407d8e:	813b      	strh	r3, [r7, #8]

	result = inv_icm20948_write_mems(s, FIFO_WATERMARK, 2, inv_icm20948_convert_int16_to_big8(fifo_wm,big8));
  407d90:	f9b7 3002 	ldrsh.w	r3, [r7, #2]
  407d94:	f107 0208 	add.w	r2, r7, #8
  407d98:	4611      	mov	r1, r2
  407d9a:	4618      	mov	r0, r3
  407d9c:	4b09      	ldr	r3, [pc, #36]	; (407dc4 <dmp_icm20948_set_FIFO_watermark+0x44>)
  407d9e:	4798      	blx	r3
  407da0:	4603      	mov	r3, r0
  407da2:	2202      	movs	r2, #2
  407da4:	f44f 71ff 	mov.w	r1, #510	; 0x1fe
  407da8:	6878      	ldr	r0, [r7, #4]
  407daa:	4c07      	ldr	r4, [pc, #28]	; (407dc8 <dmp_icm20948_set_FIFO_watermark+0x48>)
  407dac:	47a0      	blx	r4
  407dae:	60f8      	str	r0, [r7, #12]

	if (result)
  407db0:	68fb      	ldr	r3, [r7, #12]
  407db2:	2b00      	cmp	r3, #0
  407db4:	d001      	beq.n	407dba <dmp_icm20948_set_FIFO_watermark+0x3a>
		return result;
  407db6:	68fb      	ldr	r3, [r7, #12]
  407db8:	e000      	b.n	407dbc <dmp_icm20948_set_FIFO_watermark+0x3c>

	return 0;
  407dba:	2300      	movs	r3, #0
}
  407dbc:	4618      	mov	r0, r3
  407dbe:	3714      	adds	r7, #20
  407dc0:	46bd      	mov	sp, r7
  407dc2:	bd90      	pop	{r4, r7, pc}
  407dc4:	00407b41 	.word	0x00407b41
  407dc8:	0040cab1 	.word	0x0040cab1

00407dcc <dmp_icm20948_set_data_rdy_status>:
*	gyro samples available		0x1
*	accel samples available		0x2
*	secondary samples available	0x8
*/
int dmp_icm20948_set_data_rdy_status(struct inv_icm20948 * s, unsigned short data_rdy)
{
  407dcc:	b590      	push	{r4, r7, lr}
  407dce:	b085      	sub	sp, #20
  407dd0:	af00      	add	r7, sp, #0
  407dd2:	6078      	str	r0, [r7, #4]
  407dd4:	460b      	mov	r3, r1
  407dd6:	807b      	strh	r3, [r7, #2]
	int result;
	unsigned char big8[2]={0};
  407dd8:	2300      	movs	r3, #0
  407dda:	813b      	strh	r3, [r7, #8]

	result = inv_icm20948_write_mems(s, DATA_RDY_STATUS, 2, inv_icm20948_convert_int16_to_big8(data_rdy, big8));
  407ddc:	f9b7 3002 	ldrsh.w	r3, [r7, #2]
  407de0:	f107 0208 	add.w	r2, r7, #8
  407de4:	4611      	mov	r1, r2
  407de6:	4618      	mov	r0, r3
  407de8:	4b09      	ldr	r3, [pc, #36]	; (407e10 <dmp_icm20948_set_data_rdy_status+0x44>)
  407dea:	4798      	blx	r3
  407dec:	4603      	mov	r3, r0
  407dee:	2202      	movs	r2, #2
  407df0:	218a      	movs	r1, #138	; 0x8a
  407df2:	6878      	ldr	r0, [r7, #4]
  407df4:	4c07      	ldr	r4, [pc, #28]	; (407e14 <dmp_icm20948_set_data_rdy_status+0x48>)
  407df6:	47a0      	blx	r4
  407df8:	60f8      	str	r0, [r7, #12]

	if (result) 
  407dfa:	68fb      	ldr	r3, [r7, #12]
  407dfc:	2b00      	cmp	r3, #0
  407dfe:	d001      	beq.n	407e04 <dmp_icm20948_set_data_rdy_status+0x38>
		return result;
  407e00:	68fb      	ldr	r3, [r7, #12]
  407e02:	e000      	b.n	407e06 <dmp_icm20948_set_data_rdy_status+0x3a>

	return 0;
  407e04:	2300      	movs	r3, #0
}
  407e06:	4618      	mov	r0, r3
  407e08:	3714      	adds	r7, #20
  407e0a:	46bd      	mov	sp, r7
  407e0c:	bd90      	pop	{r4, r7, pc}
  407e0e:	bf00      	nop
  407e10:	00407b41 	.word	0x00407b41
  407e14:	0040cab1 	.word	0x0040cab1

00407e18 <dmp_icm20948_set_motion_event_control>:
*	GEOMAG_EN			0x0008 - Geomag algorithm execution
*	BTS_LTS_EN          0x0004 - bring & look to see
*	BAC_ACCEL_ONLY_EN   0x0002 - run BAC as accel only
*/
int dmp_icm20948_set_motion_event_control(struct inv_icm20948 * s, unsigned short output_mask)
{
  407e18:	b590      	push	{r4, r7, lr}
  407e1a:	b085      	sub	sp, #20
  407e1c:	af00      	add	r7, sp, #0
  407e1e:	6078      	str	r0, [r7, #4]
  407e20:	460b      	mov	r3, r1
  407e22:	807b      	strh	r3, [r7, #2]
	int result;
	unsigned char motion_event_control_reg[2];

	motion_event_control_reg[0] = (unsigned char)(output_mask >> 8);
  407e24:	887b      	ldrh	r3, [r7, #2]
  407e26:	0a1b      	lsrs	r3, r3, #8
  407e28:	b29b      	uxth	r3, r3
  407e2a:	b2db      	uxtb	r3, r3
  407e2c:	723b      	strb	r3, [r7, #8]
	motion_event_control_reg[1] = (unsigned char)(output_mask & 0xff);
  407e2e:	887b      	ldrh	r3, [r7, #2]
  407e30:	b2db      	uxtb	r3, r3
  407e32:	727b      	strb	r3, [r7, #9]

	result = inv_icm20948_write_mems(s, MOTION_EVENT_CTL, 2, motion_event_control_reg);
  407e34:	f107 0308 	add.w	r3, r7, #8
  407e38:	2202      	movs	r2, #2
  407e3a:	214e      	movs	r1, #78	; 0x4e
  407e3c:	6878      	ldr	r0, [r7, #4]
  407e3e:	4c04      	ldr	r4, [pc, #16]	; (407e50 <dmp_icm20948_set_motion_event_control+0x38>)
  407e40:	47a0      	blx	r4
  407e42:	60f8      	str	r0, [r7, #12]

	return result;
  407e44:	68fb      	ldr	r3, [r7, #12]
}
  407e46:	4618      	mov	r0, r3
  407e48:	3714      	adds	r7, #20
  407e4a:	46bd      	mov	sp, r7
  407e4c:	bd90      	pop	{r4, r7, pc}
  407e4e:	bf00      	nop
  407e50:	0040cab1 	.word	0x0040cab1

00407e54 <dmp_icm20948_set_sensor_rate>:
*		INV_SENSOR_INVALID,
*	};					
* @param[in] divider	desired ODR = base engine rate/(divider + 1)
*/
int dmp_icm20948_set_sensor_rate(struct inv_icm20948 * s, int invSensor, short divider)
{
  407e54:	b590      	push	{r4, r7, lr}
  407e56:	b089      	sub	sp, #36	; 0x24
  407e58:	af00      	add	r7, sp, #0
  407e5a:	60f8      	str	r0, [r7, #12]
  407e5c:	60b9      	str	r1, [r7, #8]
  407e5e:	4613      	mov	r3, r2
  407e60:	80fb      	strh	r3, [r7, #6]
	int result;
	unsigned char big8[2]={0};
  407e62:	2300      	movs	r3, #0
  407e64:	82bb      	strh	r3, [r7, #20]
	int odr_addr = 0;
  407e66:	2300      	movs	r3, #0
  407e68:	61fb      	str	r3, [r7, #28]

	switch (invSensor) {
  407e6a:	68bb      	ldr	r3, [r7, #8]
  407e6c:	2b0c      	cmp	r3, #12
  407e6e:	d83e      	bhi.n	407eee <dmp_icm20948_set_sensor_rate+0x9a>
  407e70:	a201      	add	r2, pc, #4	; (adr r2, 407e78 <dmp_icm20948_set_sensor_rate+0x24>)
  407e72:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
  407e76:	bf00      	nop
  407e78:	00407ead 	.word	0x00407ead
  407e7c:	00407eb3 	.word	0x00407eb3
  407e80:	00407eef 	.word	0x00407eef
  407e84:	00407eb9 	.word	0x00407eb9
  407e88:	00407ebf 	.word	0x00407ebf
  407e8c:	00407ec5 	.word	0x00407ec5
  407e90:	00407ecb 	.word	0x00407ecb
  407e94:	00407ed1 	.word	0x00407ed1
  407e98:	00407ed7 	.word	0x00407ed7
  407e9c:	00407edd 	.word	0x00407edd
  407ea0:	00407ee3 	.word	0x00407ee3
  407ea4:	00407ee9 	.word	0x00407ee9
  407ea8:	00407eef 	.word	0x00407eef
	case INV_SENSOR_ACCEL:
		odr_addr = ODR_ACCEL;
  407eac:	23be      	movs	r3, #190	; 0xbe
  407eae:	61fb      	str	r3, [r7, #28]
		break;
  407eb0:	e01d      	b.n	407eee <dmp_icm20948_set_sensor_rate+0x9a>
	case INV_SENSOR_GYRO:
		odr_addr = ODR_GYRO;
  407eb2:	23ba      	movs	r3, #186	; 0xba
  407eb4:	61fb      	str	r3, [r7, #28]
		break;
  407eb6:	e01a      	b.n	407eee <dmp_icm20948_set_sensor_rate+0x9a>
	case INV_SENSOR_COMPASS:
		odr_addr = ODR_CPASS;
  407eb8:	23b6      	movs	r3, #182	; 0xb6
  407eba:	61fb      	str	r3, [r7, #28]
		break;
  407ebc:	e017      	b.n	407eee <dmp_icm20948_set_sensor_rate+0x9a>
	case INV_SENSOR_ALS:
		odr_addr = ODR_ALS;
  407ebe:	23b2      	movs	r3, #178	; 0xb2
  407ec0:	61fb      	str	r3, [r7, #28]
		break;
  407ec2:	e014      	b.n	407eee <dmp_icm20948_set_sensor_rate+0x9a>
	case INV_SENSOR_SIXQ:
		odr_addr = ODR_QUAT6;
  407ec4:	23ac      	movs	r3, #172	; 0xac
  407ec6:	61fb      	str	r3, [r7, #28]
		break;
  407ec8:	e011      	b.n	407eee <dmp_icm20948_set_sensor_rate+0x9a>
	case INV_SENSOR_NINEQ:
		odr_addr = ODR_QUAT9;
  407eca:	23a8      	movs	r3, #168	; 0xa8
  407ecc:	61fb      	str	r3, [r7, #28]
		break;
  407ece:	e00e      	b.n	407eee <dmp_icm20948_set_sensor_rate+0x9a>
	case INV_SENSOR_GEOMAG:
		odr_addr = ODR_GEOMAG;
  407ed0:	23a0      	movs	r3, #160	; 0xa0
  407ed2:	61fb      	str	r3, [r7, #28]
		break;
  407ed4:	e00b      	b.n	407eee <dmp_icm20948_set_sensor_rate+0x9a>
	case INV_SENSOR_PEDQ:
		odr_addr = ODR_PQUAT6;
  407ed6:	23a4      	movs	r3, #164	; 0xa4
  407ed8:	61fb      	str	r3, [r7, #28]
		break;
  407eda:	e008      	b.n	407eee <dmp_icm20948_set_sensor_rate+0x9a>
	case INV_SENSOR_PRESSURE:
		odr_addr = ODR_PRESSURE;
  407edc:	23bc      	movs	r3, #188	; 0xbc
  407ede:	61fb      	str	r3, [r7, #28]
		break;
  407ee0:	e005      	b.n	407eee <dmp_icm20948_set_sensor_rate+0x9a>
	case INV_SENSOR_CALIB_GYRO:
		odr_addr = ODR_GYRO_CALIBR;
  407ee2:	23b8      	movs	r3, #184	; 0xb8
  407ee4:	61fb      	str	r3, [r7, #28]
		break;
  407ee6:	e002      	b.n	407eee <dmp_icm20948_set_sensor_rate+0x9a>
	case INV_SENSOR_CALIB_COMPASS:
		odr_addr = ODR_CPASS_CALIBR;
  407ee8:	23b4      	movs	r3, #180	; 0xb4
  407eea:	61fb      	str	r3, [r7, #28]
		break;
  407eec:	bf00      	nop
	case INV_SENSOR_STEP_COUNTER:
		//odr_addr = PED_RATE + 2; //PED_RATE is a 4-byte address but only writing 2 bytes here
		break;
	}	

	result = inv_icm20948_write_mems(s, odr_addr, 2, inv_icm20948_convert_int16_to_big8(divider, big8));
  407eee:	69fb      	ldr	r3, [r7, #28]
  407ef0:	b29c      	uxth	r4, r3
  407ef2:	f107 0214 	add.w	r2, r7, #20
  407ef6:	f9b7 3006 	ldrsh.w	r3, [r7, #6]
  407efa:	4611      	mov	r1, r2
  407efc:	4618      	mov	r0, r3
  407efe:	4b09      	ldr	r3, [pc, #36]	; (407f24 <dmp_icm20948_set_sensor_rate+0xd0>)
  407f00:	4798      	blx	r3
  407f02:	4603      	mov	r3, r0
  407f04:	2202      	movs	r2, #2
  407f06:	4621      	mov	r1, r4
  407f08:	68f8      	ldr	r0, [r7, #12]
  407f0a:	4c07      	ldr	r4, [pc, #28]	; (407f28 <dmp_icm20948_set_sensor_rate+0xd4>)
  407f0c:	47a0      	blx	r4
  407f0e:	61b8      	str	r0, [r7, #24]

	if (result)
  407f10:	69bb      	ldr	r3, [r7, #24]
  407f12:	2b00      	cmp	r3, #0
  407f14:	d001      	beq.n	407f1a <dmp_icm20948_set_sensor_rate+0xc6>
		return result;
  407f16:	69bb      	ldr	r3, [r7, #24]
  407f18:	e000      	b.n	407f1c <dmp_icm20948_set_sensor_rate+0xc8>

	return 0;
  407f1a:	2300      	movs	r3, #0
}
  407f1c:	4618      	mov	r0, r3
  407f1e:	3724      	adds	r7, #36	; 0x24
  407f20:	46bd      	mov	sp, r7
  407f22:	bd90      	pop	{r4, r7, pc}
  407f24:	00407b41 	.word	0x00407b41
  407f28:	0040cab1 	.word	0x0040cab1

00407f2c <dmp_icm20948_get_bias_cmp>:
*	[0] compass_x
*	[1] compass_y
*	[2] compass_z
*/
int dmp_icm20948_get_bias_cmp(struct inv_icm20948 * s, int *bias)
{
  407f2c:	b590      	push	{r4, r7, lr}
  407f2e:	b085      	sub	sp, #20
  407f30:	af00      	add	r7, sp, #0
  407f32:	6078      	str	r0, [r7, #4]
  407f34:	6039      	str	r1, [r7, #0]
	int result;
	unsigned char big8[4]={0};
  407f36:	2300      	movs	r3, #0
  407f38:	60bb      	str	r3, [r7, #8]

	result = inv_icm20948_read_mems(s, CPASS_BIAS_X, 4, big8);
  407f3a:	f107 0308 	add.w	r3, r7, #8
  407f3e:	2204      	movs	r2, #4
  407f40:	f240 71e4 	movw	r1, #2020	; 0x7e4
  407f44:	6878      	ldr	r0, [r7, #4]
  407f46:	4c20      	ldr	r4, [pc, #128]	; (407fc8 <dmp_icm20948_get_bias_cmp+0x9c>)
  407f48:	47a0      	blx	r4
  407f4a:	60f8      	str	r0, [r7, #12]
	bias[0] = inv_icm20948_convert_big8_to_int32(big8);
  407f4c:	f107 0308 	add.w	r3, r7, #8
  407f50:	4618      	mov	r0, r3
  407f52:	4b1e      	ldr	r3, [pc, #120]	; (407fcc <dmp_icm20948_get_bias_cmp+0xa0>)
  407f54:	4798      	blx	r3
  407f56:	4602      	mov	r2, r0
  407f58:	683b      	ldr	r3, [r7, #0]
  407f5a:	601a      	str	r2, [r3, #0]
	result += inv_icm20948_read_mems(s, CPASS_BIAS_Y, 4, big8);
  407f5c:	f107 0308 	add.w	r3, r7, #8
  407f60:	2204      	movs	r2, #4
  407f62:	f44f 61fd 	mov.w	r1, #2024	; 0x7e8
  407f66:	6878      	ldr	r0, [r7, #4]
  407f68:	4c17      	ldr	r4, [pc, #92]	; (407fc8 <dmp_icm20948_get_bias_cmp+0x9c>)
  407f6a:	47a0      	blx	r4
  407f6c:	4602      	mov	r2, r0
  407f6e:	68fb      	ldr	r3, [r7, #12]
  407f70:	4413      	add	r3, r2
  407f72:	60fb      	str	r3, [r7, #12]
	bias[1] = inv_icm20948_convert_big8_to_int32(big8);
  407f74:	683b      	ldr	r3, [r7, #0]
  407f76:	1d1c      	adds	r4, r3, #4
  407f78:	f107 0308 	add.w	r3, r7, #8
  407f7c:	4618      	mov	r0, r3
  407f7e:	4b13      	ldr	r3, [pc, #76]	; (407fcc <dmp_icm20948_get_bias_cmp+0xa0>)
  407f80:	4798      	blx	r3
  407f82:	4603      	mov	r3, r0
  407f84:	6023      	str	r3, [r4, #0]
	result += inv_icm20948_read_mems(s, CPASS_BIAS_Z, 4, big8);
  407f86:	f107 0308 	add.w	r3, r7, #8
  407f8a:	2204      	movs	r2, #4
  407f8c:	f240 71ec 	movw	r1, #2028	; 0x7ec
  407f90:	6878      	ldr	r0, [r7, #4]
  407f92:	4c0d      	ldr	r4, [pc, #52]	; (407fc8 <dmp_icm20948_get_bias_cmp+0x9c>)
  407f94:	47a0      	blx	r4
  407f96:	4602      	mov	r2, r0
  407f98:	68fb      	ldr	r3, [r7, #12]
  407f9a:	4413      	add	r3, r2
  407f9c:	60fb      	str	r3, [r7, #12]
	bias[2] = inv_icm20948_convert_big8_to_int32(big8);
  407f9e:	683b      	ldr	r3, [r7, #0]
  407fa0:	f103 0408 	add.w	r4, r3, #8
  407fa4:	f107 0308 	add.w	r3, r7, #8
  407fa8:	4618      	mov	r0, r3
  407faa:	4b08      	ldr	r3, [pc, #32]	; (407fcc <dmp_icm20948_get_bias_cmp+0xa0>)
  407fac:	4798      	blx	r3
  407fae:	4603      	mov	r3, r0
  407fb0:	6023      	str	r3, [r4, #0]

	if (result)
  407fb2:	68fb      	ldr	r3, [r7, #12]
  407fb4:	2b00      	cmp	r3, #0
  407fb6:	d001      	beq.n	407fbc <dmp_icm20948_get_bias_cmp+0x90>
		return result;
  407fb8:	68fb      	ldr	r3, [r7, #12]
  407fba:	e000      	b.n	407fbe <dmp_icm20948_get_bias_cmp+0x92>

	return 0; 
  407fbc:	2300      	movs	r3, #0
}
  407fbe:	4618      	mov	r0, r3
  407fc0:	3714      	adds	r7, #20
  407fc2:	46bd      	mov	sp, r7
  407fc4:	bd90      	pop	{r4, r7, pc}
  407fc6:	bf00      	nop
  407fc8:	0040c8d1 	.word	0x0040c8d1
  407fcc:	00407bb7 	.word	0x00407bb7

00407fd0 <dmp_icm20948_set_gyro_sf>:
/**
* Sets the gyro_sf used by quaternions on the DMP.
* @param[in] gyro_sf	see inv_icm20948_set_gyro_sf() for value to set based on gyro rate and gyro fullscale range
*/
int dmp_icm20948_set_gyro_sf(struct inv_icm20948 * s, long gyro_sf)
{
  407fd0:	b590      	push	{r4, r7, lr}
  407fd2:	b085      	sub	sp, #20
  407fd4:	af00      	add	r7, sp, #0
  407fd6:	6078      	str	r0, [r7, #4]
  407fd8:	6039      	str	r1, [r7, #0]
	int result;
	unsigned char big8[4];

	result = inv_icm20948_write_mems(s, GYRO_SF, 4, inv_icm20948_convert_int32_to_big8(gyro_sf, big8));
  407fda:	f107 0308 	add.w	r3, r7, #8
  407fde:	4619      	mov	r1, r3
  407fe0:	6838      	ldr	r0, [r7, #0]
  407fe2:	4b07      	ldr	r3, [pc, #28]	; (408000 <dmp_icm20948_set_gyro_sf+0x30>)
  407fe4:	4798      	blx	r3
  407fe6:	4603      	mov	r3, r0
  407fe8:	2204      	movs	r2, #4
  407fea:	f44f 7198 	mov.w	r1, #304	; 0x130
  407fee:	6878      	ldr	r0, [r7, #4]
  407ff0:	4c04      	ldr	r4, [pc, #16]	; (408004 <dmp_icm20948_set_gyro_sf+0x34>)
  407ff2:	47a0      	blx	r4
  407ff4:	60f8      	str	r0, [r7, #12]

	return result;
  407ff6:	68fb      	ldr	r3, [r7, #12]
}
  407ff8:	4618      	mov	r0, r3
  407ffa:	3714      	adds	r7, #20
  407ffc:	46bd      	mov	sp, r7
  407ffe:	bd90      	pop	{r4, r7, pc}
  408000:	00407b73 	.word	0x00407b73
  408004:	0040cab1 	.word	0x0040cab1

00408008 <dmp_icm20948_set_accel_feedback_gain>:
/**
* Sets the accel gain used by accel quaternion on the DMP.
* @param[in] accel_gain		value changes with accel engine rate
*/
int dmp_icm20948_set_accel_feedback_gain(struct inv_icm20948 * s, int accel_gain)
{
  408008:	b590      	push	{r4, r7, lr}
  40800a:	b085      	sub	sp, #20
  40800c:	af00      	add	r7, sp, #0
  40800e:	6078      	str	r0, [r7, #4]
  408010:	6039      	str	r1, [r7, #0]
	int result;
	unsigned char big8[4]={0};
  408012:	2300      	movs	r3, #0
  408014:	60bb      	str	r3, [r7, #8]

	result = inv_icm20948_write_mems(s, ACCEL_ONLY_GAIN, 4, inv_icm20948_convert_int32_to_big8(accel_gain, big8));
  408016:	f107 0308 	add.w	r3, r7, #8
  40801a:	4619      	mov	r1, r3
  40801c:	6838      	ldr	r0, [r7, #0]
  40801e:	4b0a      	ldr	r3, [pc, #40]	; (408048 <dmp_icm20948_set_accel_feedback_gain+0x40>)
  408020:	4798      	blx	r3
  408022:	4603      	mov	r3, r0
  408024:	2204      	movs	r2, #4
  408026:	f44f 7186 	mov.w	r1, #268	; 0x10c
  40802a:	6878      	ldr	r0, [r7, #4]
  40802c:	4c07      	ldr	r4, [pc, #28]	; (40804c <dmp_icm20948_set_accel_feedback_gain+0x44>)
  40802e:	47a0      	blx	r4
  408030:	60f8      	str	r0, [r7, #12]

	if (result)
  408032:	68fb      	ldr	r3, [r7, #12]
  408034:	2b00      	cmp	r3, #0
  408036:	d001      	beq.n	40803c <dmp_icm20948_set_accel_feedback_gain+0x34>
		return result;
  408038:	68fb      	ldr	r3, [r7, #12]
  40803a:	e000      	b.n	40803e <dmp_icm20948_set_accel_feedback_gain+0x36>

	return 0;
  40803c:	2300      	movs	r3, #0
}
  40803e:	4618      	mov	r0, r3
  408040:	3714      	adds	r7, #20
  408042:	46bd      	mov	sp, r7
  408044:	bd90      	pop	{r4, r7, pc}
  408046:	bf00      	nop
  408048:	00407b73 	.word	0x00407b73
  40804c:	0040cab1 	.word	0x0040cab1

00408050 <dmp_icm20948_set_accel_cal_params>:
*	[0] = ACCEL_CAL_ALPHA_VAR
*	[1] = ACCEL_CAL_A_VAR
*   [2] = ACCEL_CAL_DIV - divider from hardware accel engine rate such that acce cal runs at accel_engine_rate/(divider+1)
*/
int dmp_icm20948_set_accel_cal_params(struct inv_icm20948 * s, int *accel_cal)
{
  408050:	b590      	push	{r4, r7, lr}
  408052:	b085      	sub	sp, #20
  408054:	af00      	add	r7, sp, #0
  408056:	6078      	str	r0, [r7, #4]
  408058:	6039      	str	r1, [r7, #0]
	int result;
	unsigned char big8[4]={0};
  40805a:	2300      	movs	r3, #0
  40805c:	60bb      	str	r3, [r7, #8]

	result  = inv_icm20948_write_mems(s, ACCEL_ALPHA_VAR, 4, inv_icm20948_convert_int32_to_big8(accel_cal[ACCEL_CAL_ALPHA_VAR], big8));
  40805e:	683b      	ldr	r3, [r7, #0]
  408060:	681b      	ldr	r3, [r3, #0]
  408062:	f107 0208 	add.w	r2, r7, #8
  408066:	4611      	mov	r1, r2
  408068:	4618      	mov	r0, r3
  40806a:	4b1e      	ldr	r3, [pc, #120]	; (4080e4 <dmp_icm20948_set_accel_cal_params+0x94>)
  40806c:	4798      	blx	r3
  40806e:	4603      	mov	r3, r0
  408070:	2204      	movs	r2, #4
  408072:	f44f 61b6 	mov.w	r1, #1456	; 0x5b0
  408076:	6878      	ldr	r0, [r7, #4]
  408078:	4c1b      	ldr	r4, [pc, #108]	; (4080e8 <dmp_icm20948_set_accel_cal_params+0x98>)
  40807a:	47a0      	blx	r4
  40807c:	60f8      	str	r0, [r7, #12]
	result |= inv_icm20948_write_mems(s, ACCEL_A_VAR, 4, inv_icm20948_convert_int32_to_big8(accel_cal[ACCEL_CAL_A_VAR], big8));
  40807e:	683b      	ldr	r3, [r7, #0]
  408080:	3304      	adds	r3, #4
  408082:	681b      	ldr	r3, [r3, #0]
  408084:	f107 0208 	add.w	r2, r7, #8
  408088:	4611      	mov	r1, r2
  40808a:	4618      	mov	r0, r3
  40808c:	4b15      	ldr	r3, [pc, #84]	; (4080e4 <dmp_icm20948_set_accel_cal_params+0x94>)
  40808e:	4798      	blx	r3
  408090:	4603      	mov	r3, r0
  408092:	2204      	movs	r2, #4
  408094:	f44f 61b8 	mov.w	r1, #1472	; 0x5c0
  408098:	6878      	ldr	r0, [r7, #4]
  40809a:	4c13      	ldr	r4, [pc, #76]	; (4080e8 <dmp_icm20948_set_accel_cal_params+0x98>)
  40809c:	47a0      	blx	r4
  40809e:	4602      	mov	r2, r0
  4080a0:	68fb      	ldr	r3, [r7, #12]
  4080a2:	4313      	orrs	r3, r2
  4080a4:	60fb      	str	r3, [r7, #12]
	result |= inv_icm20948_write_mems(s, ACCEL_CAL_RATE, 2, inv_icm20948_convert_int16_to_big8(accel_cal[ACCEL_CAL_DIV], big8));
  4080a6:	683b      	ldr	r3, [r7, #0]
  4080a8:	3308      	adds	r3, #8
  4080aa:	681b      	ldr	r3, [r3, #0]
  4080ac:	b21b      	sxth	r3, r3
  4080ae:	f107 0208 	add.w	r2, r7, #8
  4080b2:	4611      	mov	r1, r2
  4080b4:	4618      	mov	r0, r3
  4080b6:	4b0d      	ldr	r3, [pc, #52]	; (4080ec <dmp_icm20948_set_accel_cal_params+0x9c>)
  4080b8:	4798      	blx	r3
  4080ba:	4603      	mov	r3, r0
  4080bc:	2202      	movs	r2, #2
  4080be:	f240 51e4 	movw	r1, #1508	; 0x5e4
  4080c2:	6878      	ldr	r0, [r7, #4]
  4080c4:	4c08      	ldr	r4, [pc, #32]	; (4080e8 <dmp_icm20948_set_accel_cal_params+0x98>)
  4080c6:	47a0      	blx	r4
  4080c8:	4602      	mov	r2, r0
  4080ca:	68fb      	ldr	r3, [r7, #12]
  4080cc:	4313      	orrs	r3, r2
  4080ce:	60fb      	str	r3, [r7, #12]

	if (result)
  4080d0:	68fb      	ldr	r3, [r7, #12]
  4080d2:	2b00      	cmp	r3, #0
  4080d4:	d001      	beq.n	4080da <dmp_icm20948_set_accel_cal_params+0x8a>
		return result;
  4080d6:	68fb      	ldr	r3, [r7, #12]
  4080d8:	e000      	b.n	4080dc <dmp_icm20948_set_accel_cal_params+0x8c>

	return 0;
  4080da:	2300      	movs	r3, #0
}
  4080dc:	4618      	mov	r0, r3
  4080de:	3714      	adds	r7, #20
  4080e0:	46bd      	mov	sp, r7
  4080e2:	bd90      	pop	{r4, r7, pc}
  4080e4:	00407b73 	.word	0x00407b73
  4080e8:	0040cab1 	.word	0x0040cab1
  4080ec:	00407b41 	.word	0x00407b41

004080f0 <dmp_icm20948_set_compass_matrix>:
/**
* Sets compass orientation matrix to DMP.
* @param[in] compass_mtx
*/
int dmp_icm20948_set_compass_matrix(struct inv_icm20948 * s, int *compass_mtx)
{
  4080f0:	b590      	push	{r4, r7, lr}
  4080f2:	b085      	sub	sp, #20
  4080f4:	af00      	add	r7, sp, #0
  4080f6:	6078      	str	r0, [r7, #4]
  4080f8:	6039      	str	r1, [r7, #0]
	int result;
	unsigned char big8[4]={0};
  4080fa:	2300      	movs	r3, #0
  4080fc:	60bb      	str	r3, [r7, #8]

	result = inv_icm20948_write_mems(s, CPASS_MTX_00, 4, inv_icm20948_convert_int32_to_big8(compass_mtx[0], big8));
  4080fe:	683b      	ldr	r3, [r7, #0]
  408100:	681b      	ldr	r3, [r3, #0]
  408102:	f107 0208 	add.w	r2, r7, #8
  408106:	4611      	mov	r1, r2
  408108:	4618      	mov	r0, r3
  40810a:	4b5a      	ldr	r3, [pc, #360]	; (408274 <dmp_icm20948_set_compass_matrix+0x184>)
  40810c:	4798      	blx	r3
  40810e:	4603      	mov	r3, r0
  408110:	2204      	movs	r2, #4
  408112:	f44f 71b8 	mov.w	r1, #368	; 0x170
  408116:	6878      	ldr	r0, [r7, #4]
  408118:	4c57      	ldr	r4, [pc, #348]	; (408278 <dmp_icm20948_set_compass_matrix+0x188>)
  40811a:	47a0      	blx	r4
  40811c:	60f8      	str	r0, [r7, #12]
	result += inv_icm20948_write_mems(s, CPASS_MTX_01, 4, inv_icm20948_convert_int32_to_big8(compass_mtx[1], big8));
  40811e:	683b      	ldr	r3, [r7, #0]
  408120:	3304      	adds	r3, #4
  408122:	681b      	ldr	r3, [r3, #0]
  408124:	f107 0208 	add.w	r2, r7, #8
  408128:	4611      	mov	r1, r2
  40812a:	4618      	mov	r0, r3
  40812c:	4b51      	ldr	r3, [pc, #324]	; (408274 <dmp_icm20948_set_compass_matrix+0x184>)
  40812e:	4798      	blx	r3
  408130:	4603      	mov	r3, r0
  408132:	2204      	movs	r2, #4
  408134:	f44f 71ba 	mov.w	r1, #372	; 0x174
  408138:	6878      	ldr	r0, [r7, #4]
  40813a:	4c4f      	ldr	r4, [pc, #316]	; (408278 <dmp_icm20948_set_compass_matrix+0x188>)
  40813c:	47a0      	blx	r4
  40813e:	4602      	mov	r2, r0
  408140:	68fb      	ldr	r3, [r7, #12]
  408142:	4413      	add	r3, r2
  408144:	60fb      	str	r3, [r7, #12]
	result += inv_icm20948_write_mems(s, CPASS_MTX_02, 4, inv_icm20948_convert_int32_to_big8(compass_mtx[2], big8));
  408146:	683b      	ldr	r3, [r7, #0]
  408148:	3308      	adds	r3, #8
  40814a:	681b      	ldr	r3, [r3, #0]
  40814c:	f107 0208 	add.w	r2, r7, #8
  408150:	4611      	mov	r1, r2
  408152:	4618      	mov	r0, r3
  408154:	4b47      	ldr	r3, [pc, #284]	; (408274 <dmp_icm20948_set_compass_matrix+0x184>)
  408156:	4798      	blx	r3
  408158:	4603      	mov	r3, r0
  40815a:	2204      	movs	r2, #4
  40815c:	f44f 71bc 	mov.w	r1, #376	; 0x178
  408160:	6878      	ldr	r0, [r7, #4]
  408162:	4c45      	ldr	r4, [pc, #276]	; (408278 <dmp_icm20948_set_compass_matrix+0x188>)
  408164:	47a0      	blx	r4
  408166:	4602      	mov	r2, r0
  408168:	68fb      	ldr	r3, [r7, #12]
  40816a:	4413      	add	r3, r2
  40816c:	60fb      	str	r3, [r7, #12]
	result += inv_icm20948_write_mems(s, CPASS_MTX_10, 4, inv_icm20948_convert_int32_to_big8(compass_mtx[3], big8));
  40816e:	683b      	ldr	r3, [r7, #0]
  408170:	330c      	adds	r3, #12
  408172:	681b      	ldr	r3, [r3, #0]
  408174:	f107 0208 	add.w	r2, r7, #8
  408178:	4611      	mov	r1, r2
  40817a:	4618      	mov	r0, r3
  40817c:	4b3d      	ldr	r3, [pc, #244]	; (408274 <dmp_icm20948_set_compass_matrix+0x184>)
  40817e:	4798      	blx	r3
  408180:	4603      	mov	r3, r0
  408182:	2204      	movs	r2, #4
  408184:	f44f 71be 	mov.w	r1, #380	; 0x17c
  408188:	6878      	ldr	r0, [r7, #4]
  40818a:	4c3b      	ldr	r4, [pc, #236]	; (408278 <dmp_icm20948_set_compass_matrix+0x188>)
  40818c:	47a0      	blx	r4
  40818e:	4602      	mov	r2, r0
  408190:	68fb      	ldr	r3, [r7, #12]
  408192:	4413      	add	r3, r2
  408194:	60fb      	str	r3, [r7, #12]
	result += inv_icm20948_write_mems(s, CPASS_MTX_11, 4, inv_icm20948_convert_int32_to_big8(compass_mtx[4], big8));
  408196:	683b      	ldr	r3, [r7, #0]
  408198:	3310      	adds	r3, #16
  40819a:	681b      	ldr	r3, [r3, #0]
  40819c:	f107 0208 	add.w	r2, r7, #8
  4081a0:	4611      	mov	r1, r2
  4081a2:	4618      	mov	r0, r3
  4081a4:	4b33      	ldr	r3, [pc, #204]	; (408274 <dmp_icm20948_set_compass_matrix+0x184>)
  4081a6:	4798      	blx	r3
  4081a8:	4603      	mov	r3, r0
  4081aa:	2204      	movs	r2, #4
  4081ac:	f44f 71c0 	mov.w	r1, #384	; 0x180
  4081b0:	6878      	ldr	r0, [r7, #4]
  4081b2:	4c31      	ldr	r4, [pc, #196]	; (408278 <dmp_icm20948_set_compass_matrix+0x188>)
  4081b4:	47a0      	blx	r4
  4081b6:	4602      	mov	r2, r0
  4081b8:	68fb      	ldr	r3, [r7, #12]
  4081ba:	4413      	add	r3, r2
  4081bc:	60fb      	str	r3, [r7, #12]
	result += inv_icm20948_write_mems(s, CPASS_MTX_12, 4, inv_icm20948_convert_int32_to_big8(compass_mtx[5], big8));
  4081be:	683b      	ldr	r3, [r7, #0]
  4081c0:	3314      	adds	r3, #20
  4081c2:	681b      	ldr	r3, [r3, #0]
  4081c4:	f107 0208 	add.w	r2, r7, #8
  4081c8:	4611      	mov	r1, r2
  4081ca:	4618      	mov	r0, r3
  4081cc:	4b29      	ldr	r3, [pc, #164]	; (408274 <dmp_icm20948_set_compass_matrix+0x184>)
  4081ce:	4798      	blx	r3
  4081d0:	4603      	mov	r3, r0
  4081d2:	2204      	movs	r2, #4
  4081d4:	f44f 71c2 	mov.w	r1, #388	; 0x184
  4081d8:	6878      	ldr	r0, [r7, #4]
  4081da:	4c27      	ldr	r4, [pc, #156]	; (408278 <dmp_icm20948_set_compass_matrix+0x188>)
  4081dc:	47a0      	blx	r4
  4081de:	4602      	mov	r2, r0
  4081e0:	68fb      	ldr	r3, [r7, #12]
  4081e2:	4413      	add	r3, r2
  4081e4:	60fb      	str	r3, [r7, #12]
	result += inv_icm20948_write_mems(s, CPASS_MTX_20, 4, inv_icm20948_convert_int32_to_big8(compass_mtx[6], big8));
  4081e6:	683b      	ldr	r3, [r7, #0]
  4081e8:	3318      	adds	r3, #24
  4081ea:	681b      	ldr	r3, [r3, #0]
  4081ec:	f107 0208 	add.w	r2, r7, #8
  4081f0:	4611      	mov	r1, r2
  4081f2:	4618      	mov	r0, r3
  4081f4:	4b1f      	ldr	r3, [pc, #124]	; (408274 <dmp_icm20948_set_compass_matrix+0x184>)
  4081f6:	4798      	blx	r3
  4081f8:	4603      	mov	r3, r0
  4081fa:	2204      	movs	r2, #4
  4081fc:	f44f 71c4 	mov.w	r1, #392	; 0x188
  408200:	6878      	ldr	r0, [r7, #4]
  408202:	4c1d      	ldr	r4, [pc, #116]	; (408278 <dmp_icm20948_set_compass_matrix+0x188>)
  408204:	47a0      	blx	r4
  408206:	4602      	mov	r2, r0
  408208:	68fb      	ldr	r3, [r7, #12]
  40820a:	4413      	add	r3, r2
  40820c:	60fb      	str	r3, [r7, #12]
	result += inv_icm20948_write_mems(s, CPASS_MTX_21, 4, inv_icm20948_convert_int32_to_big8(compass_mtx[7], big8));
  40820e:	683b      	ldr	r3, [r7, #0]
  408210:	331c      	adds	r3, #28
  408212:	681b      	ldr	r3, [r3, #0]
  408214:	f107 0208 	add.w	r2, r7, #8
  408218:	4611      	mov	r1, r2
  40821a:	4618      	mov	r0, r3
  40821c:	4b15      	ldr	r3, [pc, #84]	; (408274 <dmp_icm20948_set_compass_matrix+0x184>)
  40821e:	4798      	blx	r3
  408220:	4603      	mov	r3, r0
  408222:	2204      	movs	r2, #4
  408224:	f44f 71c6 	mov.w	r1, #396	; 0x18c
  408228:	6878      	ldr	r0, [r7, #4]
  40822a:	4c13      	ldr	r4, [pc, #76]	; (408278 <dmp_icm20948_set_compass_matrix+0x188>)
  40822c:	47a0      	blx	r4
  40822e:	4602      	mov	r2, r0
  408230:	68fb      	ldr	r3, [r7, #12]
  408232:	4413      	add	r3, r2
  408234:	60fb      	str	r3, [r7, #12]
	result += inv_icm20948_write_mems(s, CPASS_MTX_22, 4, inv_icm20948_convert_int32_to_big8(compass_mtx[8], big8));
  408236:	683b      	ldr	r3, [r7, #0]
  408238:	3320      	adds	r3, #32
  40823a:	681b      	ldr	r3, [r3, #0]
  40823c:	f107 0208 	add.w	r2, r7, #8
  408240:	4611      	mov	r1, r2
  408242:	4618      	mov	r0, r3
  408244:	4b0b      	ldr	r3, [pc, #44]	; (408274 <dmp_icm20948_set_compass_matrix+0x184>)
  408246:	4798      	blx	r3
  408248:	4603      	mov	r3, r0
  40824a:	2204      	movs	r2, #4
  40824c:	f44f 71c8 	mov.w	r1, #400	; 0x190
  408250:	6878      	ldr	r0, [r7, #4]
  408252:	4c09      	ldr	r4, [pc, #36]	; (408278 <dmp_icm20948_set_compass_matrix+0x188>)
  408254:	47a0      	blx	r4
  408256:	4602      	mov	r2, r0
  408258:	68fb      	ldr	r3, [r7, #12]
  40825a:	4413      	add	r3, r2
  40825c:	60fb      	str	r3, [r7, #12]

	if (result)
  40825e:	68fb      	ldr	r3, [r7, #12]
  408260:	2b00      	cmp	r3, #0
  408262:	d001      	beq.n	408268 <dmp_icm20948_set_compass_matrix+0x178>
		return result;
  408264:	68fb      	ldr	r3, [r7, #12]
  408266:	e000      	b.n	40826a <dmp_icm20948_set_compass_matrix+0x17a>

	return 0;
  408268:	2300      	movs	r3, #0
}
  40826a:	4618      	mov	r0, r3
  40826c:	3714      	adds	r7, #20
  40826e:	46bd      	mov	sp, r7
  408270:	bd90      	pop	{r4, r7, pc}
  408272:	bf00      	nop
  408274:	00407b73 	.word	0x00407b73
  408278:	0040cab1 	.word	0x0040cab1

0040827c <dmp_icm20948_get_pedometer_num_of_steps>:
* Gets pedometer step count.
* @param[in] steps
* @param[out] steps
*/
int dmp_icm20948_get_pedometer_num_of_steps(struct inv_icm20948 * s, unsigned long *steps)
{
  40827c:	b590      	push	{r4, r7, lr}
  40827e:	b085      	sub	sp, #20
  408280:	af00      	add	r7, sp, #0
  408282:	6078      	str	r0, [r7, #4]
  408284:	6039      	str	r1, [r7, #0]
	int result;
	unsigned char big8[4]={0};
  408286:	2300      	movs	r3, #0
  408288:	60bb      	str	r3, [r7, #8]
	(void)s;
	result = inv_icm20948_read_mems(s, PEDSTD_STEPCTR, 4, big8);
  40828a:	f107 0308 	add.w	r3, r7, #8
  40828e:	2204      	movs	r2, #4
  408290:	f44f 7158 	mov.w	r1, #864	; 0x360
  408294:	6878      	ldr	r0, [r7, #4]
  408296:	4c0d      	ldr	r4, [pc, #52]	; (4082cc <dmp_icm20948_get_pedometer_num_of_steps+0x50>)
  408298:	47a0      	blx	r4
  40829a:	60f8      	str	r0, [r7, #12]
	if (result) 
  40829c:	68fb      	ldr	r3, [r7, #12]
  40829e:	2b00      	cmp	r3, #0
  4082a0:	d001      	beq.n	4082a6 <dmp_icm20948_get_pedometer_num_of_steps+0x2a>
		return result;
  4082a2:	68fb      	ldr	r3, [r7, #12]
  4082a4:	e00d      	b.n	4082c2 <dmp_icm20948_get_pedometer_num_of_steps+0x46>
	*steps = (big8[0]*(1L<<24)) + (big8[1]*(1L<<16)) + (big8[2]*256) + big8[3];
  4082a6:	7a3b      	ldrb	r3, [r7, #8]
  4082a8:	021b      	lsls	r3, r3, #8
  4082aa:	7a7a      	ldrb	r2, [r7, #9]
  4082ac:	4413      	add	r3, r2
  4082ae:	021b      	lsls	r3, r3, #8
  4082b0:	7aba      	ldrb	r2, [r7, #10]
  4082b2:	4413      	add	r3, r2
  4082b4:	021b      	lsls	r3, r3, #8
  4082b6:	7afa      	ldrb	r2, [r7, #11]
  4082b8:	4413      	add	r3, r2
  4082ba:	461a      	mov	r2, r3
  4082bc:	683b      	ldr	r3, [r7, #0]
  4082be:	601a      	str	r2, [r3, #0]

	return 0;
  4082c0:	2300      	movs	r3, #0
}
  4082c2:	4618      	mov	r0, r3
  4082c4:	3714      	adds	r7, #20
  4082c6:	46bd      	mov	sp, r7
  4082c8:	bd90      	pop	{r4, r7, pc}
  4082ca:	bf00      	nop
  4082cc:	0040c8d1 	.word	0x0040c8d1

004082d0 <dmp_icm20948_set_gyro_fsr>:
DMP takes raw gyro data and left shifts by 16 bits, so (<<16) becomes 2000dps=2^31, to make 4000dps=2^30, >>2 bits.
In Q-30 math, >> 2 equals multiply by 2^28 = 268435456.
*/

int dmp_icm20948_set_gyro_fsr(struct inv_icm20948 * s, short gyro_fsr)
{
  4082d0:	b590      	push	{r4, r7, lr}
  4082d2:	b087      	sub	sp, #28
  4082d4:	af00      	add	r7, sp, #0
  4082d6:	6078      	str	r0, [r7, #4]
  4082d8:	460b      	mov	r3, r1
  4082da:	807b      	strh	r3, [r7, #2]
	unsigned char reg[4];
	int result;
	long scale;

	switch (gyro_fsr) {
  4082dc:	f9b7 3002 	ldrsh.w	r3, [r7, #2]
  4082e0:	f5b3 7f7a 	cmp.w	r3, #1000	; 0x3e8
  4082e4:	d016      	beq.n	408314 <dmp_icm20948_set_gyro_fsr+0x44>
  4082e6:	f5b3 7f7a 	cmp.w	r3, #1000	; 0x3e8
  4082ea:	dc05      	bgt.n	4082f8 <dmp_icm20948_set_gyro_fsr+0x28>
  4082ec:	2bfa      	cmp	r3, #250	; 0xfa
  4082ee:	d019      	beq.n	408324 <dmp_icm20948_set_gyro_fsr+0x54>
  4082f0:	f5b3 7ffa 	cmp.w	r3, #500	; 0x1f4
  4082f4:	d012      	beq.n	40831c <dmp_icm20948_set_gyro_fsr+0x4c>
  4082f6:	e019      	b.n	40832c <dmp_icm20948_set_gyro_fsr+0x5c>
  4082f8:	f5b3 6ffa 	cmp.w	r3, #2000	; 0x7d0
  4082fc:	d006      	beq.n	40830c <dmp_icm20948_set_gyro_fsr+0x3c>
  4082fe:	f5b3 6f7a 	cmp.w	r3, #4000	; 0xfa0
  408302:	d113      	bne.n	40832c <dmp_icm20948_set_gyro_fsr+0x5c>
	case 4000:
		scale =  536870912L;  // 2^29
  408304:	f04f 5300 	mov.w	r3, #536870912	; 0x20000000
  408308:	617b      	str	r3, [r7, #20]
		break;
  40830a:	e012      	b.n	408332 <dmp_icm20948_set_gyro_fsr+0x62>
	case 2000:
		scale =  268435456L;  // 2^28
  40830c:	f04f 5380 	mov.w	r3, #268435456	; 0x10000000
  408310:	617b      	str	r3, [r7, #20]
		break;
  408312:	e00e      	b.n	408332 <dmp_icm20948_set_gyro_fsr+0x62>
	case 1000:
		scale = 134217728L;  // 2^27
  408314:	f04f 6300 	mov.w	r3, #134217728	; 0x8000000
  408318:	617b      	str	r3, [r7, #20]
		break;
  40831a:	e00a      	b.n	408332 <dmp_icm20948_set_gyro_fsr+0x62>
	case 500:
		scale = 67108864L;  // 2^26
  40831c:	f04f 6380 	mov.w	r3, #67108864	; 0x4000000
  408320:	617b      	str	r3, [r7, #20]
		break;
  408322:	e006      	b.n	408332 <dmp_icm20948_set_gyro_fsr+0x62>
	case 250:
		scale = 33554432L;  // 2^25
  408324:	f04f 7300 	mov.w	r3, #33554432	; 0x2000000
  408328:	617b      	str	r3, [r7, #20]
		break;
  40832a:	e002      	b.n	408332 <dmp_icm20948_set_gyro_fsr+0x62>
	default:
		return -1;
  40832c:	f04f 33ff 	mov.w	r3, #4294967295
  408330:	e013      	b.n	40835a <dmp_icm20948_set_gyro_fsr+0x8a>
	}

	result = inv_icm20948_write_mems(s, GYRO_FULLSCALE, 4, inv_icm20948_convert_int32_to_big8(scale,reg));
  408332:	f107 030c 	add.w	r3, r7, #12
  408336:	4619      	mov	r1, r3
  408338:	6978      	ldr	r0, [r7, #20]
  40833a:	4b0a      	ldr	r3, [pc, #40]	; (408364 <dmp_icm20948_set_gyro_fsr+0x94>)
  40833c:	4798      	blx	r3
  40833e:	4603      	mov	r3, r0
  408340:	2204      	movs	r2, #4
  408342:	f240 418c 	movw	r1, #1164	; 0x48c
  408346:	6878      	ldr	r0, [r7, #4]
  408348:	4c07      	ldr	r4, [pc, #28]	; (408368 <dmp_icm20948_set_gyro_fsr+0x98>)
  40834a:	47a0      	blx	r4
  40834c:	6138      	str	r0, [r7, #16]

	if (result) {
  40834e:	693b      	ldr	r3, [r7, #16]
  408350:	2b00      	cmp	r3, #0
  408352:	d001      	beq.n	408358 <dmp_icm20948_set_gyro_fsr+0x88>
		return result;
  408354:	693b      	ldr	r3, [r7, #16]
  408356:	e000      	b.n	40835a <dmp_icm20948_set_gyro_fsr+0x8a>
	} else {
		return 0;
  408358:	2300      	movs	r3, #0
	}
}
  40835a:	4618      	mov	r0, r3
  40835c:	371c      	adds	r7, #28
  40835e:	46bd      	mov	sp, r7
  408360:	bd90      	pop	{r4, r7, pc}
  408362:	bf00      	nop
  408364:	00407b73 	.word	0x00407b73
  408368:	0040cab1 	.word	0x0040cab1

0040836c <dmp_icm20948_set_accel_fsr>:
For 8g parts, 8g = 2^15 -> 1g = 2^12.
DMP takes raw accel data and left shifts by 16 bits, so 1g=2^12 (<<16) becomes 1g=2^28, to make 1g=2^25, >>3bits.
In Q-30 math, >> 3 equals multiply by 2^27 = 134217728.
*/
int dmp_icm20948_set_accel_fsr(struct inv_icm20948 * s, short accel_fsr)
{
  40836c:	b590      	push	{r4, r7, lr}
  40836e:	b087      	sub	sp, #28
  408370:	af00      	add	r7, sp, #0
  408372:	6078      	str	r0, [r7, #4]
  408374:	460b      	mov	r3, r1
  408376:	807b      	strh	r3, [r7, #2]
	unsigned char reg[4];
	int result;
	long scale;

	switch (accel_fsr) {
  408378:	f9b7 3002 	ldrsh.w	r3, [r7, #2]
  40837c:	3b02      	subs	r3, #2
  40837e:	2b1e      	cmp	r3, #30
  408380:	d854      	bhi.n	40842c <dmp_icm20948_set_accel_fsr+0xc0>
  408382:	a201      	add	r2, pc, #4	; (adr r2, 408388 <dmp_icm20948_set_accel_fsr+0x1c>)
  408384:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
  408388:	00408405 	.word	0x00408405
  40838c:	0040842d 	.word	0x0040842d
  408390:	0040840d 	.word	0x0040840d
  408394:	0040842d 	.word	0x0040842d
  408398:	0040842d 	.word	0x0040842d
  40839c:	0040842d 	.word	0x0040842d
  4083a0:	00408415 	.word	0x00408415
  4083a4:	0040842d 	.word	0x0040842d
  4083a8:	0040842d 	.word	0x0040842d
  4083ac:	0040842d 	.word	0x0040842d
  4083b0:	0040842d 	.word	0x0040842d
  4083b4:	0040842d 	.word	0x0040842d
  4083b8:	0040842d 	.word	0x0040842d
  4083bc:	0040842d 	.word	0x0040842d
  4083c0:	0040841d 	.word	0x0040841d
  4083c4:	0040842d 	.word	0x0040842d
  4083c8:	0040842d 	.word	0x0040842d
  4083cc:	0040842d 	.word	0x0040842d
  4083d0:	0040842d 	.word	0x0040842d
  4083d4:	0040842d 	.word	0x0040842d
  4083d8:	0040842d 	.word	0x0040842d
  4083dc:	0040842d 	.word	0x0040842d
  4083e0:	0040842d 	.word	0x0040842d
  4083e4:	0040842d 	.word	0x0040842d
  4083e8:	0040842d 	.word	0x0040842d
  4083ec:	0040842d 	.word	0x0040842d
  4083f0:	0040842d 	.word	0x0040842d
  4083f4:	0040842d 	.word	0x0040842d
  4083f8:	0040842d 	.word	0x0040842d
  4083fc:	0040842d 	.word	0x0040842d
  408400:	00408425 	.word	0x00408425
	case 2:
		scale =  33554432L;  // 2^25
  408404:	f04f 7300 	mov.w	r3, #33554432	; 0x2000000
  408408:	617b      	str	r3, [r7, #20]
		break;
  40840a:	e012      	b.n	408432 <dmp_icm20948_set_accel_fsr+0xc6>
	case 4:
		scale =  67108864L;  // 2^26
  40840c:	f04f 6380 	mov.w	r3, #67108864	; 0x4000000
  408410:	617b      	str	r3, [r7, #20]
		break;
  408412:	e00e      	b.n	408432 <dmp_icm20948_set_accel_fsr+0xc6>
	case 8:
		scale = 134217728L;  // 2^27
  408414:	f04f 6300 	mov.w	r3, #134217728	; 0x8000000
  408418:	617b      	str	r3, [r7, #20]
		break;
  40841a:	e00a      	b.n	408432 <dmp_icm20948_set_accel_fsr+0xc6>
	case 16:
		scale = 268435456L;  // 2^28
  40841c:	f04f 5380 	mov.w	r3, #268435456	; 0x10000000
  408420:	617b      	str	r3, [r7, #20]
		break;
  408422:	e006      	b.n	408432 <dmp_icm20948_set_accel_fsr+0xc6>
	case 32:
		scale = 536870912L;  // 2^29
  408424:	f04f 5300 	mov.w	r3, #536870912	; 0x20000000
  408428:	617b      	str	r3, [r7, #20]
		break;
  40842a:	e002      	b.n	408432 <dmp_icm20948_set_accel_fsr+0xc6>
	default:
		return -1;
  40842c:	f04f 33ff 	mov.w	r3, #4294967295
  408430:	e013      	b.n	40845a <dmp_icm20948_set_accel_fsr+0xee>
	}

	result = inv_icm20948_write_mems(s, ACC_SCALE, 4, inv_icm20948_convert_int32_to_big8(scale,reg));
  408432:	f107 030c 	add.w	r3, r7, #12
  408436:	4619      	mov	r1, r3
  408438:	6978      	ldr	r0, [r7, #20]
  40843a:	4b0a      	ldr	r3, [pc, #40]	; (408464 <dmp_icm20948_set_accel_fsr+0xf8>)
  40843c:	4798      	blx	r3
  40843e:	4603      	mov	r3, r0
  408440:	2204      	movs	r2, #4
  408442:	f44f 71f0 	mov.w	r1, #480	; 0x1e0
  408446:	6878      	ldr	r0, [r7, #4]
  408448:	4c07      	ldr	r4, [pc, #28]	; (408468 <dmp_icm20948_set_accel_fsr+0xfc>)
  40844a:	47a0      	blx	r4
  40844c:	6138      	str	r0, [r7, #16]

	if (result) {
  40844e:	693b      	ldr	r3, [r7, #16]
  408450:	2b00      	cmp	r3, #0
  408452:	d001      	beq.n	408458 <dmp_icm20948_set_accel_fsr+0xec>
		return result;
  408454:	693b      	ldr	r3, [r7, #16]
  408456:	e000      	b.n	40845a <dmp_icm20948_set_accel_fsr+0xee>
	} else {
		return 0;
  408458:	2300      	movs	r3, #0
	}
}
  40845a:	4618      	mov	r0, r3
  40845c:	371c      	adds	r7, #28
  40845e:	46bd      	mov	sp, r7
  408460:	bd90      	pop	{r4, r7, pc}
  408462:	bf00      	nop
  408464:	00407b73 	.word	0x00407b73
  408468:	0040cab1 	.word	0x0040cab1

0040846c <dmp_icm20948_set_accel_scale2>:
* It is a reverse scaling of the scale factor written to ACC_SCALE.
* @param[in] fsr for accel parts
2: 2g. 4: 4g. 8: 8g. 16: 16g. 32: 32g.
*/
int dmp_icm20948_set_accel_scale2(struct inv_icm20948 * s, short accel_fsr)
{
  40846c:	b590      	push	{r4, r7, lr}
  40846e:	b087      	sub	sp, #28
  408470:	af00      	add	r7, sp, #0
  408472:	6078      	str	r0, [r7, #4]
  408474:	460b      	mov	r3, r1
  408476:	807b      	strh	r3, [r7, #2]
	unsigned char reg[4];
	int result;
	long scale;

	switch (accel_fsr) {
  408478:	f9b7 3002 	ldrsh.w	r3, [r7, #2]
  40847c:	3b02      	subs	r3, #2
  40847e:	2b1e      	cmp	r3, #30
  408480:	d854      	bhi.n	40852c <dmp_icm20948_set_accel_scale2+0xc0>
  408482:	a201      	add	r2, pc, #4	; (adr r2, 408488 <dmp_icm20948_set_accel_scale2+0x1c>)
  408484:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
  408488:	00408505 	.word	0x00408505
  40848c:	0040852d 	.word	0x0040852d
  408490:	0040850d 	.word	0x0040850d
  408494:	0040852d 	.word	0x0040852d
  408498:	0040852d 	.word	0x0040852d
  40849c:	0040852d 	.word	0x0040852d
  4084a0:	00408515 	.word	0x00408515
  4084a4:	0040852d 	.word	0x0040852d
  4084a8:	0040852d 	.word	0x0040852d
  4084ac:	0040852d 	.word	0x0040852d
  4084b0:	0040852d 	.word	0x0040852d
  4084b4:	0040852d 	.word	0x0040852d
  4084b8:	0040852d 	.word	0x0040852d
  4084bc:	0040852d 	.word	0x0040852d
  4084c0:	0040851d 	.word	0x0040851d
  4084c4:	0040852d 	.word	0x0040852d
  4084c8:	0040852d 	.word	0x0040852d
  4084cc:	0040852d 	.word	0x0040852d
  4084d0:	0040852d 	.word	0x0040852d
  4084d4:	0040852d 	.word	0x0040852d
  4084d8:	0040852d 	.word	0x0040852d
  4084dc:	0040852d 	.word	0x0040852d
  4084e0:	0040852d 	.word	0x0040852d
  4084e4:	0040852d 	.word	0x0040852d
  4084e8:	0040852d 	.word	0x0040852d
  4084ec:	0040852d 	.word	0x0040852d
  4084f0:	0040852d 	.word	0x0040852d
  4084f4:	0040852d 	.word	0x0040852d
  4084f8:	0040852d 	.word	0x0040852d
  4084fc:	0040852d 	.word	0x0040852d
  408500:	00408525 	.word	0x00408525
	case 2:
		scale = 524288L;  // 2^19
  408504:	f44f 2300 	mov.w	r3, #524288	; 0x80000
  408508:	617b      	str	r3, [r7, #20]
		break;
  40850a:	e012      	b.n	408532 <dmp_icm20948_set_accel_scale2+0xc6>
	case 4:
		scale = 262144L;  // 2^18
  40850c:	f44f 2380 	mov.w	r3, #262144	; 0x40000
  408510:	617b      	str	r3, [r7, #20]
		break;
  408512:	e00e      	b.n	408532 <dmp_icm20948_set_accel_scale2+0xc6>
	case 8:
		scale = 131072L;  // 2^17
  408514:	f44f 3300 	mov.w	r3, #131072	; 0x20000
  408518:	617b      	str	r3, [r7, #20]
		break;
  40851a:	e00a      	b.n	408532 <dmp_icm20948_set_accel_scale2+0xc6>
	case 16:
		scale = 65536L;  // 2^16
  40851c:	f44f 3380 	mov.w	r3, #65536	; 0x10000
  408520:	617b      	str	r3, [r7, #20]
		break;
  408522:	e006      	b.n	408532 <dmp_icm20948_set_accel_scale2+0xc6>
	case 32:
		scale = 32768L;  // 2^15
  408524:	f44f 4300 	mov.w	r3, #32768	; 0x8000
  408528:	617b      	str	r3, [r7, #20]
		break;
  40852a:	e002      	b.n	408532 <dmp_icm20948_set_accel_scale2+0xc6>
	default:
		return -1;
  40852c:	f04f 33ff 	mov.w	r3, #4294967295
  408530:	e013      	b.n	40855a <dmp_icm20948_set_accel_scale2+0xee>
	}

	result = inv_icm20948_write_mems(s, ACC_SCALE2, 4, inv_icm20948_convert_int32_to_big8(scale,reg));
  408532:	f107 030c 	add.w	r3, r7, #12
  408536:	4619      	mov	r1, r3
  408538:	6978      	ldr	r0, [r7, #20]
  40853a:	4b0a      	ldr	r3, [pc, #40]	; (408564 <dmp_icm20948_set_accel_scale2+0xf8>)
  40853c:	4798      	blx	r3
  40853e:	4603      	mov	r3, r0
  408540:	2204      	movs	r2, #4
  408542:	f240 41f4 	movw	r1, #1268	; 0x4f4
  408546:	6878      	ldr	r0, [r7, #4]
  408548:	4c07      	ldr	r4, [pc, #28]	; (408568 <dmp_icm20948_set_accel_scale2+0xfc>)
  40854a:	47a0      	blx	r4
  40854c:	6138      	str	r0, [r7, #16]

	if (result) {
  40854e:	693b      	ldr	r3, [r7, #16]
  408550:	2b00      	cmp	r3, #0
  408552:	d001      	beq.n	408558 <dmp_icm20948_set_accel_scale2+0xec>
		return result;
  408554:	693b      	ldr	r3, [r7, #16]
  408556:	e000      	b.n	40855a <dmp_icm20948_set_accel_scale2+0xee>
	} else {
		return 0;
  408558:	2300      	movs	r3, #0
	}
}
  40855a:	4618      	mov	r0, r3
  40855c:	371c      	adds	r7, #28
  40855e:	46bd      	mov	sp, r7
  408560:	bd90      	pop	{r4, r7, pc}
  408562:	bf00      	nop
  408564:	00407b73 	.word	0x00407b73
  408568:	0040cab1 	.word	0x0040cab1

0040856c <dmp_icm20948_set_bac_rate>:
/**
* BAC only works in 56 Hz. Set divider to make sure accel ODR into BAC is 56Hz.
* @param[in] bac_odr. the values are 56 , 112 , 225 450 or 900 Hz
*/
int dmp_icm20948_set_bac_rate(struct inv_icm20948 * s, short bac_odr)
{
  40856c:	b590      	push	{r4, r7, lr}
  40856e:	b087      	sub	sp, #28
  408570:	af00      	add	r7, sp, #0
  408572:	6078      	str	r0, [r7, #4]
  408574:	460b      	mov	r3, r1
  408576:	807b      	strh	r3, [r7, #2]
	unsigned char reg[4]={0,0,0,0};
  408578:	2300      	movs	r3, #0
  40857a:	60fb      	str	r3, [r7, #12]
	int result;
	short odr;

	switch (bac_odr) {
  40857c:	f9b7 3002 	ldrsh.w	r3, [r7, #2]
  408580:	2be1      	cmp	r3, #225	; 0xe1
  408582:	d013      	beq.n	4085ac <dmp_icm20948_set_bac_rate+0x40>
  408584:	2be1      	cmp	r3, #225	; 0xe1
  408586:	dc04      	bgt.n	408592 <dmp_icm20948_set_bac_rate+0x26>
  408588:	2b38      	cmp	r3, #56	; 0x38
  40858a:	d009      	beq.n	4085a0 <dmp_icm20948_set_bac_rate+0x34>
  40858c:	2b70      	cmp	r3, #112	; 0x70
  40858e:	d00a      	beq.n	4085a6 <dmp_icm20948_set_bac_rate+0x3a>
  408590:	e015      	b.n	4085be <dmp_icm20948_set_bac_rate+0x52>
  408592:	f5b3 7fe1 	cmp.w	r3, #450	; 0x1c2
  408596:	d00c      	beq.n	4085b2 <dmp_icm20948_set_bac_rate+0x46>
  408598:	f5b3 7f61 	cmp.w	r3, #900	; 0x384
  40859c:	d00c      	beq.n	4085b8 <dmp_icm20948_set_bac_rate+0x4c>
  40859e:	e00e      	b.n	4085be <dmp_icm20948_set_bac_rate+0x52>
	case DMP_ALGO_FREQ_56:
		odr = 0;
  4085a0:	2300      	movs	r3, #0
  4085a2:	82fb      	strh	r3, [r7, #22]
		break;
  4085a4:	e00e      	b.n	4085c4 <dmp_icm20948_set_bac_rate+0x58>
	case DMP_ALGO_FREQ_112:
		odr = 1;
  4085a6:	2301      	movs	r3, #1
  4085a8:	82fb      	strh	r3, [r7, #22]
		break;
  4085aa:	e00b      	b.n	4085c4 <dmp_icm20948_set_bac_rate+0x58>
	case DMP_ALGO_FREQ_225:
		odr = 3;
  4085ac:	2303      	movs	r3, #3
  4085ae:	82fb      	strh	r3, [r7, #22]
		break;
  4085b0:	e008      	b.n	4085c4 <dmp_icm20948_set_bac_rate+0x58>
	case DMP_ALGO_FREQ_450:
		odr = 7;
  4085b2:	2307      	movs	r3, #7
  4085b4:	82fb      	strh	r3, [r7, #22]
		break;
  4085b6:	e005      	b.n	4085c4 <dmp_icm20948_set_bac_rate+0x58>
	case DMP_ALGO_FREQ_900:
		odr = 15;
  4085b8:	230f      	movs	r3, #15
  4085ba:	82fb      	strh	r3, [r7, #22]
		break;
  4085bc:	e002      	b.n	4085c4 <dmp_icm20948_set_bac_rate+0x58>
	default:
		return -1;
  4085be:	f04f 33ff 	mov.w	r3, #4294967295
  4085c2:	e015      	b.n	4085f0 <dmp_icm20948_set_bac_rate+0x84>
	}

	result = inv_icm20948_write_mems(s, BAC_RATE, 2, inv_icm20948_convert_int16_to_big8(odr,reg));
  4085c4:	f107 020c 	add.w	r2, r7, #12
  4085c8:	f9b7 3016 	ldrsh.w	r3, [r7, #22]
  4085cc:	4611      	mov	r1, r2
  4085ce:	4618      	mov	r0, r3
  4085d0:	4b09      	ldr	r3, [pc, #36]	; (4085f8 <dmp_icm20948_set_bac_rate+0x8c>)
  4085d2:	4798      	blx	r3
  4085d4:	4603      	mov	r3, r0
  4085d6:	2202      	movs	r2, #2
  4085d8:	f240 310a 	movw	r1, #778	; 0x30a
  4085dc:	6878      	ldr	r0, [r7, #4]
  4085de:	4c07      	ldr	r4, [pc, #28]	; (4085fc <dmp_icm20948_set_bac_rate+0x90>)
  4085e0:	47a0      	blx	r4
  4085e2:	6138      	str	r0, [r7, #16]
	if (result) {
  4085e4:	693b      	ldr	r3, [r7, #16]
  4085e6:	2b00      	cmp	r3, #0
  4085e8:	d001      	beq.n	4085ee <dmp_icm20948_set_bac_rate+0x82>
		return result;
  4085ea:	693b      	ldr	r3, [r7, #16]
  4085ec:	e000      	b.n	4085f0 <dmp_icm20948_set_bac_rate+0x84>
	} else {
		return 0;
  4085ee:	2300      	movs	r3, #0
	}
}
  4085f0:	4618      	mov	r0, r3
  4085f2:	371c      	adds	r7, #28
  4085f4:	46bd      	mov	sp, r7
  4085f6:	bd90      	pop	{r4, r7, pc}
  4085f8:	00407b41 	.word	0x00407b41
  4085fc:	0040cab1 	.word	0x0040cab1

00408600 <dmp_icm20948_set_b2s_rate>:
/**
* B2S only works in 56 Hz. Set divider to make sure accel ODR into B2S is 56Hz.
* @param[in] bac_odr. the values are 56 , 112 , 225 450 or 900 Hz
*/
int dmp_icm20948_set_b2s_rate(struct inv_icm20948 * s, short accel_odr)
{
  408600:	b590      	push	{r4, r7, lr}
  408602:	b087      	sub	sp, #28
  408604:	af00      	add	r7, sp, #0
  408606:	6078      	str	r0, [r7, #4]
  408608:	460b      	mov	r3, r1
  40860a:	807b      	strh	r3, [r7, #2]
	unsigned char reg[4]={0,0,0,0};
  40860c:	2300      	movs	r3, #0
  40860e:	60fb      	str	r3, [r7, #12]
	int result;
	short odr;

	switch (accel_odr) {
  408610:	f9b7 3002 	ldrsh.w	r3, [r7, #2]
  408614:	2be1      	cmp	r3, #225	; 0xe1
  408616:	d013      	beq.n	408640 <dmp_icm20948_set_b2s_rate+0x40>
  408618:	2be1      	cmp	r3, #225	; 0xe1
  40861a:	dc04      	bgt.n	408626 <dmp_icm20948_set_b2s_rate+0x26>
  40861c:	2b38      	cmp	r3, #56	; 0x38
  40861e:	d009      	beq.n	408634 <dmp_icm20948_set_b2s_rate+0x34>
  408620:	2b70      	cmp	r3, #112	; 0x70
  408622:	d00a      	beq.n	40863a <dmp_icm20948_set_b2s_rate+0x3a>
  408624:	e015      	b.n	408652 <dmp_icm20948_set_b2s_rate+0x52>
  408626:	f5b3 7fe1 	cmp.w	r3, #450	; 0x1c2
  40862a:	d00c      	beq.n	408646 <dmp_icm20948_set_b2s_rate+0x46>
  40862c:	f5b3 7f61 	cmp.w	r3, #900	; 0x384
  408630:	d00c      	beq.n	40864c <dmp_icm20948_set_b2s_rate+0x4c>
  408632:	e00e      	b.n	408652 <dmp_icm20948_set_b2s_rate+0x52>
	case DMP_ALGO_FREQ_56:
		odr = 0;
  408634:	2300      	movs	r3, #0
  408636:	82fb      	strh	r3, [r7, #22]
		break;
  408638:	e00e      	b.n	408658 <dmp_icm20948_set_b2s_rate+0x58>
	case DMP_ALGO_FREQ_112:
		odr = 1;
  40863a:	2301      	movs	r3, #1
  40863c:	82fb      	strh	r3, [r7, #22]
		break;
  40863e:	e00b      	b.n	408658 <dmp_icm20948_set_b2s_rate+0x58>
	case DMP_ALGO_FREQ_225:
		odr = 3;
  408640:	2303      	movs	r3, #3
  408642:	82fb      	strh	r3, [r7, #22]
		break;
  408644:	e008      	b.n	408658 <dmp_icm20948_set_b2s_rate+0x58>
	case DMP_ALGO_FREQ_450:
		odr = 7;
  408646:	2307      	movs	r3, #7
  408648:	82fb      	strh	r3, [r7, #22]
		break;
  40864a:	e005      	b.n	408658 <dmp_icm20948_set_b2s_rate+0x58>
	case DMP_ALGO_FREQ_900:
		odr = 15;
  40864c:	230f      	movs	r3, #15
  40864e:	82fb      	strh	r3, [r7, #22]
		break;
  408650:	e002      	b.n	408658 <dmp_icm20948_set_b2s_rate+0x58>
	default:
		return -1;
  408652:	f04f 33ff 	mov.w	r3, #4294967295
  408656:	e015      	b.n	408684 <dmp_icm20948_set_b2s_rate+0x84>
	}

	result = inv_icm20948_write_mems(s, B2S_RATE, 2, inv_icm20948_convert_int16_to_big8(odr,reg));
  408658:	f107 020c 	add.w	r2, r7, #12
  40865c:	f9b7 3016 	ldrsh.w	r3, [r7, #22]
  408660:	4611      	mov	r1, r2
  408662:	4618      	mov	r0, r3
  408664:	4b09      	ldr	r3, [pc, #36]	; (40868c <dmp_icm20948_set_b2s_rate+0x8c>)
  408666:	4798      	blx	r3
  408668:	4603      	mov	r3, r0
  40866a:	2202      	movs	r2, #2
  40866c:	f44f 7142 	mov.w	r1, #776	; 0x308
  408670:	6878      	ldr	r0, [r7, #4]
  408672:	4c07      	ldr	r4, [pc, #28]	; (408690 <dmp_icm20948_set_b2s_rate+0x90>)
  408674:	47a0      	blx	r4
  408676:	6138      	str	r0, [r7, #16]
	if (result) {
  408678:	693b      	ldr	r3, [r7, #16]
  40867a:	2b00      	cmp	r3, #0
  40867c:	d001      	beq.n	408682 <dmp_icm20948_set_b2s_rate+0x82>
		return result;
  40867e:	693b      	ldr	r3, [r7, #16]
  408680:	e000      	b.n	408684 <dmp_icm20948_set_b2s_rate+0x84>
	} else {
		return 0;
  408682:	2300      	movs	r3, #0
	}
}
  408684:	4618      	mov	r0, r3
  408686:	371c      	adds	r7, #28
  408688:	46bd      	mov	sp, r7
  40868a:	bd90      	pop	{r4, r7, pc}
  40868c:	00407b41 	.word	0x00407b41
  408690:	0040cab1 	.word	0x0040cab1

00408694 <dmp_icm20948_set_B2S_matrix>:
/**
* Sets B2S accel orientation matrix to DMP.
* @param[in] b2s_mtx. Unit: 1 = 2^30.
*/
int dmp_icm20948_set_B2S_matrix(struct inv_icm20948 * s, int *b2s_mtx)
{
  408694:	b590      	push	{r4, r7, lr}
  408696:	b085      	sub	sp, #20
  408698:	af00      	add	r7, sp, #0
  40869a:	6078      	str	r0, [r7, #4]
  40869c:	6039      	str	r1, [r7, #0]
	int result;
	unsigned char big8[4]={0};
  40869e:	2300      	movs	r3, #0
  4086a0:	60bb      	str	r3, [r7, #8]

	result  = inv_icm20948_write_mems(s, B2S_MTX_00, 4, inv_icm20948_convert_int32_to_big8(b2s_mtx[0], big8));
  4086a2:	683b      	ldr	r3, [r7, #0]
  4086a4:	681b      	ldr	r3, [r3, #0]
  4086a6:	f107 0208 	add.w	r2, r7, #8
  4086aa:	4611      	mov	r1, r2
  4086ac:	4618      	mov	r0, r3
  4086ae:	4b5a      	ldr	r3, [pc, #360]	; (408818 <dmp_icm20948_set_B2S_matrix+0x184>)
  4086b0:	4798      	blx	r3
  4086b2:	4603      	mov	r3, r0
  4086b4:	2204      	movs	r2, #4
  4086b6:	f44f 6150 	mov.w	r1, #3328	; 0xd00
  4086ba:	6878      	ldr	r0, [r7, #4]
  4086bc:	4c57      	ldr	r4, [pc, #348]	; (40881c <dmp_icm20948_set_B2S_matrix+0x188>)
  4086be:	47a0      	blx	r4
  4086c0:	60f8      	str	r0, [r7, #12]
	result += inv_icm20948_write_mems(s, B2S_MTX_01, 4, inv_icm20948_convert_int32_to_big8(b2s_mtx[1], big8));
  4086c2:	683b      	ldr	r3, [r7, #0]
  4086c4:	3304      	adds	r3, #4
  4086c6:	681b      	ldr	r3, [r3, #0]
  4086c8:	f107 0208 	add.w	r2, r7, #8
  4086cc:	4611      	mov	r1, r2
  4086ce:	4618      	mov	r0, r3
  4086d0:	4b51      	ldr	r3, [pc, #324]	; (408818 <dmp_icm20948_set_B2S_matrix+0x184>)
  4086d2:	4798      	blx	r3
  4086d4:	4603      	mov	r3, r0
  4086d6:	2204      	movs	r2, #4
  4086d8:	f640 5104 	movw	r1, #3332	; 0xd04
  4086dc:	6878      	ldr	r0, [r7, #4]
  4086de:	4c4f      	ldr	r4, [pc, #316]	; (40881c <dmp_icm20948_set_B2S_matrix+0x188>)
  4086e0:	47a0      	blx	r4
  4086e2:	4602      	mov	r2, r0
  4086e4:	68fb      	ldr	r3, [r7, #12]
  4086e6:	4413      	add	r3, r2
  4086e8:	60fb      	str	r3, [r7, #12]
	result += inv_icm20948_write_mems(s, B2S_MTX_02, 4, inv_icm20948_convert_int32_to_big8(b2s_mtx[2], big8));
  4086ea:	683b      	ldr	r3, [r7, #0]
  4086ec:	3308      	adds	r3, #8
  4086ee:	681b      	ldr	r3, [r3, #0]
  4086f0:	f107 0208 	add.w	r2, r7, #8
  4086f4:	4611      	mov	r1, r2
  4086f6:	4618      	mov	r0, r3
  4086f8:	4b47      	ldr	r3, [pc, #284]	; (408818 <dmp_icm20948_set_B2S_matrix+0x184>)
  4086fa:	4798      	blx	r3
  4086fc:	4603      	mov	r3, r0
  4086fe:	2204      	movs	r2, #4
  408700:	f640 5108 	movw	r1, #3336	; 0xd08
  408704:	6878      	ldr	r0, [r7, #4]
  408706:	4c45      	ldr	r4, [pc, #276]	; (40881c <dmp_icm20948_set_B2S_matrix+0x188>)
  408708:	47a0      	blx	r4
  40870a:	4602      	mov	r2, r0
  40870c:	68fb      	ldr	r3, [r7, #12]
  40870e:	4413      	add	r3, r2
  408710:	60fb      	str	r3, [r7, #12]
	result += inv_icm20948_write_mems(s, B2S_MTX_10, 4, inv_icm20948_convert_int32_to_big8(b2s_mtx[3], big8));
  408712:	683b      	ldr	r3, [r7, #0]
  408714:	330c      	adds	r3, #12
  408716:	681b      	ldr	r3, [r3, #0]
  408718:	f107 0208 	add.w	r2, r7, #8
  40871c:	4611      	mov	r1, r2
  40871e:	4618      	mov	r0, r3
  408720:	4b3d      	ldr	r3, [pc, #244]	; (408818 <dmp_icm20948_set_B2S_matrix+0x184>)
  408722:	4798      	blx	r3
  408724:	4603      	mov	r3, r0
  408726:	2204      	movs	r2, #4
  408728:	f640 510c 	movw	r1, #3340	; 0xd0c
  40872c:	6878      	ldr	r0, [r7, #4]
  40872e:	4c3b      	ldr	r4, [pc, #236]	; (40881c <dmp_icm20948_set_B2S_matrix+0x188>)
  408730:	47a0      	blx	r4
  408732:	4602      	mov	r2, r0
  408734:	68fb      	ldr	r3, [r7, #12]
  408736:	4413      	add	r3, r2
  408738:	60fb      	str	r3, [r7, #12]
	result += inv_icm20948_write_mems(s, B2S_MTX_11, 4, inv_icm20948_convert_int32_to_big8(b2s_mtx[4], big8));
  40873a:	683b      	ldr	r3, [r7, #0]
  40873c:	3310      	adds	r3, #16
  40873e:	681b      	ldr	r3, [r3, #0]
  408740:	f107 0208 	add.w	r2, r7, #8
  408744:	4611      	mov	r1, r2
  408746:	4618      	mov	r0, r3
  408748:	4b33      	ldr	r3, [pc, #204]	; (408818 <dmp_icm20948_set_B2S_matrix+0x184>)
  40874a:	4798      	blx	r3
  40874c:	4603      	mov	r3, r0
  40874e:	2204      	movs	r2, #4
  408750:	f44f 6151 	mov.w	r1, #3344	; 0xd10
  408754:	6878      	ldr	r0, [r7, #4]
  408756:	4c31      	ldr	r4, [pc, #196]	; (40881c <dmp_icm20948_set_B2S_matrix+0x188>)
  408758:	47a0      	blx	r4
  40875a:	4602      	mov	r2, r0
  40875c:	68fb      	ldr	r3, [r7, #12]
  40875e:	4413      	add	r3, r2
  408760:	60fb      	str	r3, [r7, #12]
	result += inv_icm20948_write_mems(s, B2S_MTX_12, 4, inv_icm20948_convert_int32_to_big8(b2s_mtx[5], big8));
  408762:	683b      	ldr	r3, [r7, #0]
  408764:	3314      	adds	r3, #20
  408766:	681b      	ldr	r3, [r3, #0]
  408768:	f107 0208 	add.w	r2, r7, #8
  40876c:	4611      	mov	r1, r2
  40876e:	4618      	mov	r0, r3
  408770:	4b29      	ldr	r3, [pc, #164]	; (408818 <dmp_icm20948_set_B2S_matrix+0x184>)
  408772:	4798      	blx	r3
  408774:	4603      	mov	r3, r0
  408776:	2204      	movs	r2, #4
  408778:	f640 5114 	movw	r1, #3348	; 0xd14
  40877c:	6878      	ldr	r0, [r7, #4]
  40877e:	4c27      	ldr	r4, [pc, #156]	; (40881c <dmp_icm20948_set_B2S_matrix+0x188>)
  408780:	47a0      	blx	r4
  408782:	4602      	mov	r2, r0
  408784:	68fb      	ldr	r3, [r7, #12]
  408786:	4413      	add	r3, r2
  408788:	60fb      	str	r3, [r7, #12]
	result += inv_icm20948_write_mems(s, B2S_MTX_20, 4, inv_icm20948_convert_int32_to_big8(b2s_mtx[6], big8));
  40878a:	683b      	ldr	r3, [r7, #0]
  40878c:	3318      	adds	r3, #24
  40878e:	681b      	ldr	r3, [r3, #0]
  408790:	f107 0208 	add.w	r2, r7, #8
  408794:	4611      	mov	r1, r2
  408796:	4618      	mov	r0, r3
  408798:	4b1f      	ldr	r3, [pc, #124]	; (408818 <dmp_icm20948_set_B2S_matrix+0x184>)
  40879a:	4798      	blx	r3
  40879c:	4603      	mov	r3, r0
  40879e:	2204      	movs	r2, #4
  4087a0:	f640 5118 	movw	r1, #3352	; 0xd18
  4087a4:	6878      	ldr	r0, [r7, #4]
  4087a6:	4c1d      	ldr	r4, [pc, #116]	; (40881c <dmp_icm20948_set_B2S_matrix+0x188>)
  4087a8:	47a0      	blx	r4
  4087aa:	4602      	mov	r2, r0
  4087ac:	68fb      	ldr	r3, [r7, #12]
  4087ae:	4413      	add	r3, r2
  4087b0:	60fb      	str	r3, [r7, #12]
	result += inv_icm20948_write_mems(s, B2S_MTX_21, 4, inv_icm20948_convert_int32_to_big8(b2s_mtx[7], big8));
  4087b2:	683b      	ldr	r3, [r7, #0]
  4087b4:	331c      	adds	r3, #28
  4087b6:	681b      	ldr	r3, [r3, #0]
  4087b8:	f107 0208 	add.w	r2, r7, #8
  4087bc:	4611      	mov	r1, r2
  4087be:	4618      	mov	r0, r3
  4087c0:	4b15      	ldr	r3, [pc, #84]	; (408818 <dmp_icm20948_set_B2S_matrix+0x184>)
  4087c2:	4798      	blx	r3
  4087c4:	4603      	mov	r3, r0
  4087c6:	2204      	movs	r2, #4
  4087c8:	f640 511c 	movw	r1, #3356	; 0xd1c
  4087cc:	6878      	ldr	r0, [r7, #4]
  4087ce:	4c13      	ldr	r4, [pc, #76]	; (40881c <dmp_icm20948_set_B2S_matrix+0x188>)
  4087d0:	47a0      	blx	r4
  4087d2:	4602      	mov	r2, r0
  4087d4:	68fb      	ldr	r3, [r7, #12]
  4087d6:	4413      	add	r3, r2
  4087d8:	60fb      	str	r3, [r7, #12]
	result += inv_icm20948_write_mems(s, B2S_MTX_22, 4, inv_icm20948_convert_int32_to_big8(b2s_mtx[8], big8));
  4087da:	683b      	ldr	r3, [r7, #0]
  4087dc:	3320      	adds	r3, #32
  4087de:	681b      	ldr	r3, [r3, #0]
  4087e0:	f107 0208 	add.w	r2, r7, #8
  4087e4:	4611      	mov	r1, r2
  4087e6:	4618      	mov	r0, r3
  4087e8:	4b0b      	ldr	r3, [pc, #44]	; (408818 <dmp_icm20948_set_B2S_matrix+0x184>)
  4087ea:	4798      	blx	r3
  4087ec:	4603      	mov	r3, r0
  4087ee:	2204      	movs	r2, #4
  4087f0:	f44f 6152 	mov.w	r1, #3360	; 0xd20
  4087f4:	6878      	ldr	r0, [r7, #4]
  4087f6:	4c09      	ldr	r4, [pc, #36]	; (40881c <dmp_icm20948_set_B2S_matrix+0x188>)
  4087f8:	47a0      	blx	r4
  4087fa:	4602      	mov	r2, r0
  4087fc:	68fb      	ldr	r3, [r7, #12]
  4087fe:	4413      	add	r3, r2
  408800:	60fb      	str	r3, [r7, #12]

	if (result)
  408802:	68fb      	ldr	r3, [r7, #12]
  408804:	2b00      	cmp	r3, #0
  408806:	d001      	beq.n	40880c <dmp_icm20948_set_B2S_matrix+0x178>
		return result;
  408808:	68fb      	ldr	r3, [r7, #12]
  40880a:	e000      	b.n	40880e <dmp_icm20948_set_B2S_matrix+0x17a>

	return 0;
  40880c:	2300      	movs	r3, #0
}
  40880e:	4618      	mov	r0, r3
  408810:	3714      	adds	r7, #20
  408812:	46bd      	mov	sp, r7
  408814:	bd90      	pop	{r4, r7, pc}
  408816:	bf00      	nop
  408818:	00407b73 	.word	0x00407b73
  40881c:	0040cab1 	.word	0x0040cab1

00408820 <dmp_icm20948_set_ped_y_ratio>:
/**
* Set BAC ped y ration
* @param[in] ped_y_ratio: value will influence pedometer result
*/
int dmp_icm20948_set_ped_y_ratio(struct inv_icm20948 * s, long ped_y_ratio)
{
  408820:	b590      	push	{r4, r7, lr}
  408822:	b085      	sub	sp, #20
  408824:	af00      	add	r7, sp, #0
  408826:	6078      	str	r0, [r7, #4]
  408828:	6039      	str	r1, [r7, #0]
	int result;
	unsigned char big8[4]={0, 0, 0, 0};
  40882a:	2300      	movs	r3, #0
  40882c:	60bb      	str	r3, [r7, #8]

	result = inv_icm20948_write_mems(s, PED_Y_RATIO, 4, inv_icm20948_convert_int32_to_big8(ped_y_ratio, big8));
  40882e:	f107 0308 	add.w	r3, r7, #8
  408832:	4619      	mov	r1, r3
  408834:	6838      	ldr	r0, [r7, #0]
  408836:	4b07      	ldr	r3, [pc, #28]	; (408854 <dmp_icm20948_set_ped_y_ratio+0x34>)
  408838:	4798      	blx	r3
  40883a:	4603      	mov	r3, r0
  40883c:	2204      	movs	r2, #4
  40883e:	f44f 7188 	mov.w	r1, #272	; 0x110
  408842:	6878      	ldr	r0, [r7, #4]
  408844:	4c04      	ldr	r4, [pc, #16]	; (408858 <dmp_icm20948_set_ped_y_ratio+0x38>)
  408846:	47a0      	blx	r4
  408848:	60f8      	str	r0, [r7, #12]

	return result;
  40884a:	68fb      	ldr	r3, [r7, #12]
}
  40884c:	4618      	mov	r0, r3
  40884e:	3714      	adds	r7, #20
  408850:	46bd      	mov	sp, r7
  408852:	bd90      	pop	{r4, r7, pc}
  408854:	00407b73 	.word	0x00407b73
  408858:	0040cab1 	.word	0x0040cab1

0040885c <inv_icm20948_firmware_load>:
#include "Icm20948LoadFirmware.h"
#include "Icm20948Defs.h"
#include "Icm20948DataBaseDriver.h"

int inv_icm20948_firmware_load(struct inv_icm20948 * s, const unsigned char *data_start, unsigned short size_start, unsigned short load_addr)
{ 
  40885c:	b590      	push	{r4, r7, lr}
  40885e:	b08f      	sub	sp, #60	; 0x3c
  408860:	af00      	add	r7, sp, #0
  408862:	60f8      	str	r0, [r7, #12]
  408864:	60b9      	str	r1, [r7, #8]
  408866:	4611      	mov	r1, r2
  408868:	461a      	mov	r2, r3
  40886a:	460b      	mov	r3, r1
  40886c:	80fb      	strh	r3, [r7, #6]
  40886e:	4613      	mov	r3, r2
  408870:	80bb      	strh	r3, [r7, #4]
    int result;
    unsigned short memaddr;
    const unsigned char *data;
    unsigned short size;
    unsigned char data_cmp[INV_MAX_SERIAL_READ];
    int flag = 0;
  408872:	2300      	movs	r3, #0
  408874:	627b      	str	r3, [r7, #36]	; 0x24

	if(s->base_state.firmware_loaded)
  408876:	68fb      	ldr	r3, [r7, #12]
  408878:	f893 3026 	ldrb.w	r3, [r3, #38]	; 0x26
  40887c:	f003 0302 	and.w	r3, r3, #2
  408880:	b2db      	uxtb	r3, r3
  408882:	2b00      	cmp	r3, #0
  408884:	d001      	beq.n	40888a <inv_icm20948_firmware_load+0x2e>
		return 0;
  408886:	2300      	movs	r3, #0
  408888:	e081      	b.n	40898e <inv_icm20948_firmware_load+0x132>
		
    // Write DMP memory
    data = data_start;
  40888a:	68bb      	ldr	r3, [r7, #8]
  40888c:	62fb      	str	r3, [r7, #44]	; 0x2c
    size = size_start;
  40888e:	88fb      	ldrh	r3, [r7, #6]
  408890:	857b      	strh	r3, [r7, #42]	; 0x2a
    memaddr = load_addr;
  408892:	88bb      	ldrh	r3, [r7, #4]
  408894:	867b      	strh	r3, [r7, #50]	; 0x32
    while (size > 0) {
  408896:	e02e      	b.n	4088f6 <inv_icm20948_firmware_load+0x9a>
        write_size = min(size, INV_MAX_SERIAL_WRITE);
  408898:	8d7b      	ldrh	r3, [r7, #42]	; 0x2a
  40889a:	2b0f      	cmp	r3, #15
  40889c:	d801      	bhi.n	4088a2 <inv_icm20948_firmware_load+0x46>
  40889e:	8d7b      	ldrh	r3, [r7, #42]	; 0x2a
  4088a0:	e000      	b.n	4088a4 <inv_icm20948_firmware_load+0x48>
  4088a2:	2310      	movs	r3, #16
  4088a4:	637b      	str	r3, [r7, #52]	; 0x34
        if ((memaddr & 0xff) + write_size > 0x100) {
  4088a6:	8e7b      	ldrh	r3, [r7, #50]	; 0x32
  4088a8:	b2da      	uxtb	r2, r3
  4088aa:	6b7b      	ldr	r3, [r7, #52]	; 0x34
  4088ac:	4413      	add	r3, r2
  4088ae:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
  4088b2:	dd06      	ble.n	4088c2 <inv_icm20948_firmware_load+0x66>
            // Moved across a bank
            write_size = (memaddr & 0xff) + write_size - 0x100;
  4088b4:	8e7b      	ldrh	r3, [r7, #50]	; 0x32
  4088b6:	b2da      	uxtb	r2, r3
  4088b8:	6b7b      	ldr	r3, [r7, #52]	; 0x34
  4088ba:	4413      	add	r3, r2
  4088bc:	f5a3 7380 	sub.w	r3, r3, #256	; 0x100
  4088c0:	637b      	str	r3, [r7, #52]	; 0x34
        }
        result = inv_icm20948_write_mems(s, memaddr, write_size, (unsigned char *)data);
  4088c2:	6b7a      	ldr	r2, [r7, #52]	; 0x34
  4088c4:	8e79      	ldrh	r1, [r7, #50]	; 0x32
  4088c6:	6afb      	ldr	r3, [r7, #44]	; 0x2c
  4088c8:	68f8      	ldr	r0, [r7, #12]
  4088ca:	4c33      	ldr	r4, [pc, #204]	; (408998 <inv_icm20948_firmware_load+0x13c>)
  4088cc:	47a0      	blx	r4
  4088ce:	6238      	str	r0, [r7, #32]
        if (result)  
  4088d0:	6a3b      	ldr	r3, [r7, #32]
  4088d2:	2b00      	cmp	r3, #0
  4088d4:	d001      	beq.n	4088da <inv_icm20948_firmware_load+0x7e>
            return result;
  4088d6:	6a3b      	ldr	r3, [r7, #32]
  4088d8:	e059      	b.n	40898e <inv_icm20948_firmware_load+0x132>
        data += write_size;
  4088da:	6b7b      	ldr	r3, [r7, #52]	; 0x34
  4088dc:	6afa      	ldr	r2, [r7, #44]	; 0x2c
  4088de:	4413      	add	r3, r2
  4088e0:	62fb      	str	r3, [r7, #44]	; 0x2c
        size -= write_size;
  4088e2:	6b7b      	ldr	r3, [r7, #52]	; 0x34
  4088e4:	b29b      	uxth	r3, r3
  4088e6:	8d7a      	ldrh	r2, [r7, #42]	; 0x2a
  4088e8:	1ad3      	subs	r3, r2, r3
  4088ea:	857b      	strh	r3, [r7, #42]	; 0x2a
        memaddr += write_size;
  4088ec:	6b7b      	ldr	r3, [r7, #52]	; 0x34
  4088ee:	b29a      	uxth	r2, r3
  4088f0:	8e7b      	ldrh	r3, [r7, #50]	; 0x32
  4088f2:	4413      	add	r3, r2
  4088f4:	867b      	strh	r3, [r7, #50]	; 0x32
    while (size > 0) {
  4088f6:	8d7b      	ldrh	r3, [r7, #42]	; 0x2a
  4088f8:	2b00      	cmp	r3, #0
  4088fa:	d1cd      	bne.n	408898 <inv_icm20948_firmware_load+0x3c>
    }

    // Verify DMP memory

    data = data_start;
  4088fc:	68bb      	ldr	r3, [r7, #8]
  4088fe:	62fb      	str	r3, [r7, #44]	; 0x2c
    size = size_start;
  408900:	88fb      	ldrh	r3, [r7, #6]
  408902:	857b      	strh	r3, [r7, #42]	; 0x2a
    memaddr = load_addr;
  408904:	88bb      	ldrh	r3, [r7, #4]
  408906:	867b      	strh	r3, [r7, #50]	; 0x32
    while (size > 0) {
  408908:	e03d      	b.n	408986 <inv_icm20948_firmware_load+0x12a>
        write_size = min(size, INV_MAX_SERIAL_READ);
  40890a:	8d7b      	ldrh	r3, [r7, #42]	; 0x2a
  40890c:	2b0f      	cmp	r3, #15
  40890e:	d801      	bhi.n	408914 <inv_icm20948_firmware_load+0xb8>
  408910:	8d7b      	ldrh	r3, [r7, #42]	; 0x2a
  408912:	e000      	b.n	408916 <inv_icm20948_firmware_load+0xba>
  408914:	2310      	movs	r3, #16
  408916:	637b      	str	r3, [r7, #52]	; 0x34
        if ((memaddr & 0xff) + write_size > 0x100) {
  408918:	8e7b      	ldrh	r3, [r7, #50]	; 0x32
  40891a:	b2da      	uxtb	r2, r3
  40891c:	6b7b      	ldr	r3, [r7, #52]	; 0x34
  40891e:	4413      	add	r3, r2
  408920:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
  408924:	dd06      	ble.n	408934 <inv_icm20948_firmware_load+0xd8>
            // Moved across a bank
            write_size = (memaddr & 0xff) + write_size - 0x100;
  408926:	8e7b      	ldrh	r3, [r7, #50]	; 0x32
  408928:	b2da      	uxtb	r2, r3
  40892a:	6b7b      	ldr	r3, [r7, #52]	; 0x34
  40892c:	4413      	add	r3, r2
  40892e:	f5a3 7380 	sub.w	r3, r3, #256	; 0x100
  408932:	637b      	str	r3, [r7, #52]	; 0x34
        }
        result = inv_icm20948_read_mems(s, memaddr, write_size, data_cmp);
  408934:	6b7a      	ldr	r2, [r7, #52]	; 0x34
  408936:	f107 0310 	add.w	r3, r7, #16
  40893a:	8e79      	ldrh	r1, [r7, #50]	; 0x32
  40893c:	68f8      	ldr	r0, [r7, #12]
  40893e:	4c17      	ldr	r4, [pc, #92]	; (40899c <inv_icm20948_firmware_load+0x140>)
  408940:	47a0      	blx	r4
  408942:	6238      	str	r0, [r7, #32]
        if (result)
  408944:	6a3b      	ldr	r3, [r7, #32]
  408946:	2b00      	cmp	r3, #0
  408948:	d002      	beq.n	408950 <inv_icm20948_firmware_load+0xf4>
            flag++; // Error, DMP not written correctly
  40894a:	6a7b      	ldr	r3, [r7, #36]	; 0x24
  40894c:	3301      	adds	r3, #1
  40894e:	627b      	str	r3, [r7, #36]	; 0x24
        if (memcmp(data_cmp, data, write_size))
  408950:	6b7a      	ldr	r2, [r7, #52]	; 0x34
  408952:	f107 0310 	add.w	r3, r7, #16
  408956:	6af9      	ldr	r1, [r7, #44]	; 0x2c
  408958:	4618      	mov	r0, r3
  40895a:	4b11      	ldr	r3, [pc, #68]	; (4089a0 <inv_icm20948_firmware_load+0x144>)
  40895c:	4798      	blx	r3
  40895e:	4603      	mov	r3, r0
  408960:	2b00      	cmp	r3, #0
  408962:	d002      	beq.n	40896a <inv_icm20948_firmware_load+0x10e>
            return -1;
  408964:	f04f 33ff 	mov.w	r3, #4294967295
  408968:	e011      	b.n	40898e <inv_icm20948_firmware_load+0x132>
        data += write_size;
  40896a:	6b7b      	ldr	r3, [r7, #52]	; 0x34
  40896c:	6afa      	ldr	r2, [r7, #44]	; 0x2c
  40896e:	4413      	add	r3, r2
  408970:	62fb      	str	r3, [r7, #44]	; 0x2c
        size -= write_size;
  408972:	6b7b      	ldr	r3, [r7, #52]	; 0x34
  408974:	b29b      	uxth	r3, r3
  408976:	8d7a      	ldrh	r2, [r7, #42]	; 0x2a
  408978:	1ad3      	subs	r3, r2, r3
  40897a:	857b      	strh	r3, [r7, #42]	; 0x2a
        memaddr += write_size;
  40897c:	6b7b      	ldr	r3, [r7, #52]	; 0x34
  40897e:	b29a      	uxth	r2, r3
  408980:	8e7b      	ldrh	r3, [r7, #50]	; 0x32
  408982:	4413      	add	r3, r2
  408984:	867b      	strh	r3, [r7, #50]	; 0x32
    while (size > 0) {
  408986:	8d7b      	ldrh	r3, [r7, #42]	; 0x2a
  408988:	2b00      	cmp	r3, #0
  40898a:	d1be      	bne.n	40890a <inv_icm20948_firmware_load+0xae>
#if defined(WIN32)   
    //if(!flag)
      // inv_log("DMP Firmware was updated successfully..\r\n");
#endif

    return 0;
  40898c:	2300      	movs	r3, #0
}
  40898e:	4618      	mov	r0, r3
  408990:	373c      	adds	r7, #60	; 0x3c
  408992:	46bd      	mov	sp, r7
  408994:	bd90      	pop	{r4, r7, pc}
  408996:	bf00      	nop
  408998:	0040cab1 	.word	0x0040cab1
  40899c:	0040c8d1 	.word	0x0040c8d1
  4089a0:	00413fe5 	.word	0x00413fe5

004089a4 <inv_icm20948_mpu_set_FIFO_RST_Diamond>:

static void inv_decode_3_16bit_elements(short *out_data, const unsigned char *in_data);
static void inv_decode_3_32bit_elements(long *out_data, const unsigned char *in_data);

int inv_icm20948_mpu_set_FIFO_RST_Diamond(struct inv_icm20948 * s, unsigned char value)
{
  4089a4:	b590      	push	{r4, r7, lr}
  4089a6:	b085      	sub	sp, #20
  4089a8:	af00      	add	r7, sp, #0
  4089aa:	6078      	str	r0, [r7, #4]
  4089ac:	460b      	mov	r3, r1
  4089ae:	70fb      	strb	r3, [r7, #3]
	int result = 0;
  4089b0:	2300      	movs	r3, #0
  4089b2:	60fb      	str	r3, [r7, #12]
	unsigned char reg;

	result |= inv_icm20948_read_mems_reg(s, REG_FIFO_RST, 1, &reg);
  4089b4:	f107 030b 	add.w	r3, r7, #11
  4089b8:	2201      	movs	r2, #1
  4089ba:	2168      	movs	r1, #104	; 0x68
  4089bc:	6878      	ldr	r0, [r7, #4]
  4089be:	4c10      	ldr	r4, [pc, #64]	; (408a00 <inv_icm20948_mpu_set_FIFO_RST_Diamond+0x5c>)
  4089c0:	47a0      	blx	r4
  4089c2:	4602      	mov	r2, r0
  4089c4:	68fb      	ldr	r3, [r7, #12]
  4089c6:	4313      	orrs	r3, r2
  4089c8:	60fb      	str	r3, [r7, #12]
    
	reg &= 0xe0;
  4089ca:	7afb      	ldrb	r3, [r7, #11]
  4089cc:	f023 031f 	bic.w	r3, r3, #31
  4089d0:	b2db      	uxtb	r3, r3
  4089d2:	72fb      	strb	r3, [r7, #11]
	reg |= value;
  4089d4:	7afa      	ldrb	r2, [r7, #11]
  4089d6:	78fb      	ldrb	r3, [r7, #3]
  4089d8:	4313      	orrs	r3, r2
  4089da:	b2db      	uxtb	r3, r3
  4089dc:	72fb      	strb	r3, [r7, #11]
	result |= inv_icm20948_write_mems_reg(s, REG_FIFO_RST, 1, &reg);
  4089de:	f107 030b 	add.w	r3, r7, #11
  4089e2:	2201      	movs	r2, #1
  4089e4:	2168      	movs	r1, #104	; 0x68
  4089e6:	6878      	ldr	r0, [r7, #4]
  4089e8:	4c06      	ldr	r4, [pc, #24]	; (408a04 <inv_icm20948_mpu_set_FIFO_RST_Diamond+0x60>)
  4089ea:	47a0      	blx	r4
  4089ec:	4602      	mov	r2, r0
  4089ee:	68fb      	ldr	r3, [r7, #12]
  4089f0:	4313      	orrs	r3, r2
  4089f2:	60fb      	str	r3, [r7, #12]
    
	return result;
  4089f4:	68fb      	ldr	r3, [r7, #12]
}
  4089f6:	4618      	mov	r0, r3
  4089f8:	3714      	adds	r7, #20
  4089fa:	46bd      	mov	sp, r7
  4089fc:	bd90      	pop	{r4, r7, pc}
  4089fe:	bf00      	nop
  408a00:	0040c755 	.word	0x0040c755
  408a04:	0040c581 	.word	0x0040c581

00408a08 <inv_icm20948_identify_interrupt>:

int inv_icm20948_identify_interrupt(struct inv_icm20948 * s, short *int_read)
{
  408a08:	b590      	push	{r4, r7, lr}
  408a0a:	b085      	sub	sp, #20
  408a0c:	af00      	add	r7, sp, #0
  408a0e:	6078      	str	r0, [r7, #4]
  408a10:	6039      	str	r1, [r7, #0]
	unsigned char int_status;
    int result=0 ;
  408a12:	2300      	movs	r3, #0
  408a14:	60fb      	str	r3, [r7, #12]
    
    if(int_read)
  408a16:	683b      	ldr	r3, [r7, #0]
  408a18:	2b00      	cmp	r3, #0
  408a1a:	d002      	beq.n	408a22 <inv_icm20948_identify_interrupt+0x1a>
        *int_read = 0;
  408a1c:	683b      	ldr	r3, [r7, #0]
  408a1e:	2200      	movs	r2, #0
  408a20:	801a      	strh	r2, [r3, #0]
    
    result = inv_icm20948_read_mems_reg(s, REG_INT_STATUS, 1, &int_status);
  408a22:	f107 030b 	add.w	r3, r7, #11
  408a26:	2201      	movs	r2, #1
  408a28:	2119      	movs	r1, #25
  408a2a:	6878      	ldr	r0, [r7, #4]
  408a2c:	4c11      	ldr	r4, [pc, #68]	; (408a74 <inv_icm20948_identify_interrupt+0x6c>)
  408a2e:	47a0      	blx	r4
  408a30:	60f8      	str	r0, [r7, #12]
    if(int_read)
  408a32:	683b      	ldr	r3, [r7, #0]
  408a34:	2b00      	cmp	r3, #0
  408a36:	d003      	beq.n	408a40 <inv_icm20948_identify_interrupt+0x38>
        *int_read = int_status;
  408a38:	7afb      	ldrb	r3, [r7, #11]
  408a3a:	b21a      	sxth	r2, r3
  408a3c:	683b      	ldr	r3, [r7, #0]
  408a3e:	801a      	strh	r2, [r3, #0]

    result = inv_icm20948_read_mems_reg(s, REG_DMP_INT_STATUS, 1, &int_status); // DMP_INT_STATUS
  408a40:	f107 030b 	add.w	r3, r7, #11
  408a44:	2201      	movs	r2, #1
  408a46:	2118      	movs	r1, #24
  408a48:	6878      	ldr	r0, [r7, #4]
  408a4a:	4c0a      	ldr	r4, [pc, #40]	; (408a74 <inv_icm20948_identify_interrupt+0x6c>)
  408a4c:	47a0      	blx	r4
  408a4e:	60f8      	str	r0, [r7, #12]
	if(int_read)
  408a50:	683b      	ldr	r3, [r7, #0]
  408a52:	2b00      	cmp	r3, #0
  408a54:	d009      	beq.n	408a6a <inv_icm20948_identify_interrupt+0x62>
		*int_read |= (int_status << 8);
  408a56:	683b      	ldr	r3, [r7, #0]
  408a58:	f9b3 2000 	ldrsh.w	r2, [r3]
  408a5c:	7afb      	ldrb	r3, [r7, #11]
  408a5e:	021b      	lsls	r3, r3, #8
  408a60:	b21b      	sxth	r3, r3
  408a62:	4313      	orrs	r3, r2
  408a64:	b21a      	sxth	r2, r3
  408a66:	683b      	ldr	r3, [r7, #0]
  408a68:	801a      	strh	r2, [r3, #0]
     * We do not need to handle FIFO overflow here. 
     * When we read FIFO_SIZE we can determine if FIFO overflow has occured.
     */
    //result = inv_icm20948_read_mems_reg(s, 0x1B, 1, &int_status);
    
	return result;
  408a6a:	68fb      	ldr	r3, [r7, #12]
}
  408a6c:	4618      	mov	r0, r3
  408a6e:	3714      	adds	r7, #20
  408a70:	46bd      	mov	sp, r7
  408a72:	bd90      	pop	{r4, r7, pc}
  408a74:	0040c755 	.word	0x0040c755

00408a78 <dmp_get_fifo_length>:
* @param[out] len amount of data currently stored in the fifo.
*
* @return MPU_SUCCESS or non-zero error code.
**/
static int dmp_get_fifo_length(struct inv_icm20948 * s, uint_fast16_t * len )
{
  408a78:	b590      	push	{r4, r7, lr}
  408a7a:	b085      	sub	sp, #20
  408a7c:	af00      	add	r7, sp, #0
  408a7e:	6078      	str	r0, [r7, #4]
  408a80:	6039      	str	r1, [r7, #0]
	unsigned char fifoBuf[2];
	int result = 0;
  408a82:	2300      	movs	r3, #0
  408a84:	60fb      	str	r3, [r7, #12]
    
	if (NULL == len)
  408a86:	683b      	ldr	r3, [r7, #0]
  408a88:	2b00      	cmp	r3, #0
  408a8a:	d102      	bne.n	408a92 <dmp_get_fifo_length+0x1a>
		return -1;
  408a8c:	f04f 33ff 	mov.w	r3, #4294967295
  408a90:	e020      	b.n	408ad4 <dmp_get_fifo_length+0x5c>
    
	/*---- read the 2 'count' registers and
	burst read the data from the FIFO ----*/
	result = inv_icm20948_read_mems_reg(s, REG_FIFO_COUNT_H, 2, fifoBuf);
  408a92:	f107 0308 	add.w	r3, r7, #8
  408a96:	2202      	movs	r2, #2
  408a98:	2170      	movs	r1, #112	; 0x70
  408a9a:	6878      	ldr	r0, [r7, #4]
  408a9c:	4c0f      	ldr	r4, [pc, #60]	; (408adc <dmp_get_fifo_length+0x64>)
  408a9e:	47a0      	blx	r4
  408aa0:	60f8      	str	r0, [r7, #12]
	if (result) 
  408aa2:	68fb      	ldr	r3, [r7, #12]
  408aa4:	2b00      	cmp	r3, #0
  408aa6:	d009      	beq.n	408abc <dmp_get_fifo_length+0x44>
	{
		s->fifo_info.fifoError = -1;
  408aa8:	687b      	ldr	r3, [r7, #4]
  408aaa:	f04f 32ff 	mov.w	r2, #4294967295
  408aae:	f8c3 2098 	str.w	r2, [r3, #152]	; 0x98
		*len = 0;
  408ab2:	683b      	ldr	r3, [r7, #0]
  408ab4:	2200      	movs	r2, #0
  408ab6:	601a      	str	r2, [r3, #0]
		return result;
  408ab8:	68fb      	ldr	r3, [r7, #12]
  408aba:	e00b      	b.n	408ad4 <dmp_get_fifo_length+0x5c>
	}
    
	*len = (uint_fast16_t) (fifoBuf[0] << 8);
  408abc:	7a3b      	ldrb	r3, [r7, #8]
  408abe:	021b      	lsls	r3, r3, #8
  408ac0:	461a      	mov	r2, r3
  408ac2:	683b      	ldr	r3, [r7, #0]
  408ac4:	601a      	str	r2, [r3, #0]
	*len += (uint_fast16_t) (fifoBuf[1]);
  408ac6:	683b      	ldr	r3, [r7, #0]
  408ac8:	681b      	ldr	r3, [r3, #0]
  408aca:	7a7a      	ldrb	r2, [r7, #9]
  408acc:	441a      	add	r2, r3
  408ace:	683b      	ldr	r3, [r7, #0]
  408ad0:	601a      	str	r2, [r3, #0]

	return result;
  408ad2:	68fb      	ldr	r3, [r7, #12]
}
  408ad4:	4618      	mov	r0, r3
  408ad6:	3714      	adds	r7, #20
  408ad8:	46bd      	mov	sp, r7
  408ada:	bd90      	pop	{r4, r7, pc}
  408adc:	0040c755 	.word	0x0040c755

00408ae0 <dmp_reset_fifo>:
*  @note   Halt the DMP writing into the FIFO for the time
*          needed to reset the FIFO.
*  @return MPU_SUCCESS if successful, a non-zero error code otherwise.
*/
static int dmp_reset_fifo(struct inv_icm20948 * s)
{
  408ae0:	b580      	push	{r7, lr}
  408ae2:	b086      	sub	sp, #24
  408ae4:	af00      	add	r7, sp, #0
  408ae6:	6078      	str	r0, [r7, #4]
    uint_fast16_t len = HARDWARE_FIFO_SIZE;
  408ae8:	f44f 6380 	mov.w	r3, #1024	; 0x400
  408aec:	60fb      	str	r3, [r7, #12]
	unsigned char tries = 0;
  408aee:	2300      	movs	r3, #0
  408af0:	75fb      	strb	r3, [r7, #23]
	int result = 0;
  408af2:	2300      	movs	r3, #0
  408af4:	613b      	str	r3, [r7, #16]
    
	while (len != 0 && tries < 6) 
  408af6:	e03e      	b.n	408b76 <dmp_reset_fifo+0x96>
	{ 
		s->base_state.user_ctrl &= (~BIT_FIFO_EN);
  408af8:	687b      	ldr	r3, [r7, #4]
  408afa:	7f1b      	ldrb	r3, [r3, #28]
  408afc:	f023 0340 	bic.w	r3, r3, #64	; 0x40
  408b00:	b2da      	uxtb	r2, r3
  408b02:	687b      	ldr	r3, [r7, #4]
  408b04:	771a      	strb	r2, [r3, #28]
		s->base_state.user_ctrl &= (~BIT_DMP_EN);
  408b06:	687b      	ldr	r3, [r7, #4]
  408b08:	7f1b      	ldrb	r3, [r3, #28]
  408b0a:	f003 037f 	and.w	r3, r3, #127	; 0x7f
  408b0e:	b2da      	uxtb	r2, r3
  408b10:	687b      	ldr	r3, [r7, #4]
  408b12:	771a      	strb	r2, [r3, #28]
		result |= inv_icm20948_write_single_mems_reg(s, REG_USER_CTRL, s->base_state.user_ctrl);
  408b14:	687b      	ldr	r3, [r7, #4]
  408b16:	7f1b      	ldrb	r3, [r3, #28]
  408b18:	461a      	mov	r2, r3
  408b1a:	2103      	movs	r1, #3
  408b1c:	6878      	ldr	r0, [r7, #4]
  408b1e:	4b28      	ldr	r3, [pc, #160]	; (408bc0 <dmp_reset_fifo+0xe0>)
  408b20:	4798      	blx	r3
  408b22:	4602      	mov	r2, r0
  408b24:	693b      	ldr	r3, [r7, #16]
  408b26:	4313      	orrs	r3, r2
  408b28:	613b      	str	r3, [r7, #16]
		result |= inv_icm20948_mpu_set_FIFO_RST_Diamond(s, 0x1f);
  408b2a:	211f      	movs	r1, #31
  408b2c:	6878      	ldr	r0, [r7, #4]
  408b2e:	4b25      	ldr	r3, [pc, #148]	; (408bc4 <dmp_reset_fifo+0xe4>)
  408b30:	4798      	blx	r3
  408b32:	4602      	mov	r2, r0
  408b34:	693b      	ldr	r3, [r7, #16]
  408b36:	4313      	orrs	r3, r2
  408b38:	613b      	str	r3, [r7, #16]
		result |= inv_icm20948_mpu_set_FIFO_RST_Diamond(s, 0x1e);
  408b3a:	211e      	movs	r1, #30
  408b3c:	6878      	ldr	r0, [r7, #4]
  408b3e:	4b21      	ldr	r3, [pc, #132]	; (408bc4 <dmp_reset_fifo+0xe4>)
  408b40:	4798      	blx	r3
  408b42:	4602      	mov	r2, r0
  408b44:	693b      	ldr	r3, [r7, #16]
  408b46:	4313      	orrs	r3, r2
  408b48:	613b      	str	r3, [r7, #16]
        
		// Reset overflow flag
		s->fifo_info.fifo_overflow = 0;
  408b4a:	687b      	ldr	r3, [r7, #4]
  408b4c:	2200      	movs	r2, #0
  408b4e:	f883 209c 	strb.w	r2, [r3, #156]	; 0x9c
        
		result |= dmp_get_fifo_length(s, &len);
  408b52:	f107 030c 	add.w	r3, r7, #12
  408b56:	4619      	mov	r1, r3
  408b58:	6878      	ldr	r0, [r7, #4]
  408b5a:	4b1b      	ldr	r3, [pc, #108]	; (408bc8 <dmp_reset_fifo+0xe8>)
  408b5c:	4798      	blx	r3
  408b5e:	4602      	mov	r2, r0
  408b60:	693b      	ldr	r3, [r7, #16]
  408b62:	4313      	orrs	r3, r2
  408b64:	613b      	str	r3, [r7, #16]
		if (result) 
  408b66:	693b      	ldr	r3, [r7, #16]
  408b68:	2b00      	cmp	r3, #0
  408b6a:	d001      	beq.n	408b70 <dmp_reset_fifo+0x90>
			return result;
  408b6c:	693b      	ldr	r3, [r7, #16]
  408b6e:	e022      	b.n	408bb6 <dmp_reset_fifo+0xd6>
        
		tries++;
  408b70:	7dfb      	ldrb	r3, [r7, #23]
  408b72:	3301      	adds	r3, #1
  408b74:	75fb      	strb	r3, [r7, #23]
	while (len != 0 && tries < 6) 
  408b76:	68fb      	ldr	r3, [r7, #12]
  408b78:	2b00      	cmp	r3, #0
  408b7a:	d002      	beq.n	408b82 <dmp_reset_fifo+0xa2>
  408b7c:	7dfb      	ldrb	r3, [r7, #23]
  408b7e:	2b05      	cmp	r3, #5
  408b80:	d9ba      	bls.n	408af8 <dmp_reset_fifo+0x18>
	}
    
	s->base_state.user_ctrl |= BIT_FIFO_EN;
  408b82:	687b      	ldr	r3, [r7, #4]
  408b84:	7f1b      	ldrb	r3, [r3, #28]
  408b86:	f043 0340 	orr.w	r3, r3, #64	; 0x40
  408b8a:	b2da      	uxtb	r2, r3
  408b8c:	687b      	ldr	r3, [r7, #4]
  408b8e:	771a      	strb	r2, [r3, #28]
	s->base_state.user_ctrl |= BIT_DMP_EN;
  408b90:	687b      	ldr	r3, [r7, #4]
  408b92:	7f1b      	ldrb	r3, [r3, #28]
  408b94:	f063 037f 	orn	r3, r3, #127	; 0x7f
  408b98:	b2da      	uxtb	r2, r3
  408b9a:	687b      	ldr	r3, [r7, #4]
  408b9c:	771a      	strb	r2, [r3, #28]
	result |= inv_icm20948_write_single_mems_reg(s, REG_USER_CTRL, s->base_state.user_ctrl);
  408b9e:	687b      	ldr	r3, [r7, #4]
  408ba0:	7f1b      	ldrb	r3, [r3, #28]
  408ba2:	461a      	mov	r2, r3
  408ba4:	2103      	movs	r1, #3
  408ba6:	6878      	ldr	r0, [r7, #4]
  408ba8:	4b05      	ldr	r3, [pc, #20]	; (408bc0 <dmp_reset_fifo+0xe0>)
  408baa:	4798      	blx	r3
  408bac:	4602      	mov	r2, r0
  408bae:	693b      	ldr	r3, [r7, #16]
  408bb0:	4313      	orrs	r3, r2
  408bb2:	613b      	str	r3, [r7, #16]
    
	return result;
  408bb4:	693b      	ldr	r3, [r7, #16]
}
  408bb6:	4618      	mov	r0, r3
  408bb8:	3718      	adds	r7, #24
  408bba:	46bd      	mov	sp, r7
  408bbc:	bd80      	pop	{r7, pc}
  408bbe:	bf00      	nop
  408bc0:	0040c689 	.word	0x0040c689
  408bc4:	004089a5 	.word	0x004089a5
  408bc8:	00408a79 	.word	0x00408a79

00408bcc <dmp_read_fifo>:
*  @param[in] len   Amount of data to read out of the fifo
*
*  @return MPU_SUCCESS or non-zero error code
**/
static int dmp_read_fifo(struct inv_icm20948 * s, unsigned char *data, uint_fast16_t len)
{
  408bcc:	b590      	push	{r4, r7, lr}
  408bce:	b089      	sub	sp, #36	; 0x24
  408bd0:	af00      	add	r7, sp, #0
  408bd2:	60f8      	str	r0, [r7, #12]
  408bd4:	60b9      	str	r1, [r7, #8]
  408bd6:	607a      	str	r2, [r7, #4]
	int result;
    uint_fast16_t bytesRead = 0;
  408bd8:	2300      	movs	r3, #0
  408bda:	61bb      	str	r3, [r7, #24]

    while (bytesRead<len) 
  408bdc:	e021      	b.n	408c22 <dmp_read_fifo+0x56>
    {
        unsigned short thisLen = min(INV_MAX_SERIAL_READ, len-bytesRead);
  408bde:	687a      	ldr	r2, [r7, #4]
  408be0:	69bb      	ldr	r3, [r7, #24]
  408be2:	1ad3      	subs	r3, r2, r3
  408be4:	2b10      	cmp	r3, #16
  408be6:	bf28      	it	cs
  408be8:	2310      	movcs	r3, #16
  408bea:	82fb      	strh	r3, [r7, #22]
        
        result = inv_icm20948_read_mems_reg(s, REG_FIFO_R_W, thisLen, &data[bytesRead]);
  408bec:	8af9      	ldrh	r1, [r7, #22]
  408bee:	68ba      	ldr	r2, [r7, #8]
  408bf0:	69bb      	ldr	r3, [r7, #24]
  408bf2:	4413      	add	r3, r2
  408bf4:	460a      	mov	r2, r1
  408bf6:	2172      	movs	r1, #114	; 0x72
  408bf8:	68f8      	ldr	r0, [r7, #12]
  408bfa:	4c0e      	ldr	r4, [pc, #56]	; (408c34 <dmp_read_fifo+0x68>)
  408bfc:	47a0      	blx	r4
  408bfe:	61f8      	str	r0, [r7, #28]
        if (result)
  408c00:	69fb      	ldr	r3, [r7, #28]
  408c02:	2b00      	cmp	r3, #0
  408c04:	d009      	beq.n	408c1a <dmp_read_fifo+0x4e>
		{
			dmp_reset_fifo(s);
  408c06:	68f8      	ldr	r0, [r7, #12]
  408c08:	4b0b      	ldr	r3, [pc, #44]	; (408c38 <dmp_read_fifo+0x6c>)
  408c0a:	4798      	blx	r3
			s->fifo_info.fifoError = -1;
  408c0c:	68fb      	ldr	r3, [r7, #12]
  408c0e:	f04f 32ff 	mov.w	r2, #4294967295
  408c12:	f8c3 2098 	str.w	r2, [r3, #152]	; 0x98
			return result;
  408c16:	69fb      	ldr	r3, [r7, #28]
  408c18:	e008      	b.n	408c2c <dmp_read_fifo+0x60>
		}
        
        bytesRead += thisLen;
  408c1a:	8afb      	ldrh	r3, [r7, #22]
  408c1c:	69ba      	ldr	r2, [r7, #24]
  408c1e:	4413      	add	r3, r2
  408c20:	61bb      	str	r3, [r7, #24]
    while (bytesRead<len) 
  408c22:	69ba      	ldr	r2, [r7, #24]
  408c24:	687b      	ldr	r3, [r7, #4]
  408c26:	429a      	cmp	r2, r3
  408c28:	d3d9      	bcc.n	408bde <dmp_read_fifo+0x12>
    }

	return result;
  408c2a:	69fb      	ldr	r3, [r7, #28]
}
  408c2c:	4618      	mov	r0, r3
  408c2e:	3724      	adds	r7, #36	; 0x24
  408c30:	46bd      	mov	sp, r7
  408c32:	bd90      	pop	{r4, r7, pc}
  408c34:	0040c755 	.word	0x0040c755
  408c38:	00408ae1 	.word	0x00408ae1

00408c3c <dmp_get_fifo_all>:
*  @param  buffer Reads up to length into the buffer.
*
*  @return number of bytes of read.
**/
static uint_fast16_t dmp_get_fifo_all(struct inv_icm20948 * s, uint_fast16_t length, unsigned char *buffer, int *reset)
{
  408c3c:	b580      	push	{r7, lr}
  408c3e:	b086      	sub	sp, #24
  408c40:	af00      	add	r7, sp, #0
  408c42:	60f8      	str	r0, [r7, #12]
  408c44:	60b9      	str	r1, [r7, #8]
  408c46:	607a      	str	r2, [r7, #4]
  408c48:	603b      	str	r3, [r7, #0]
	int result;
	uint_fast16_t in_fifo;
    
	if(reset)
  408c4a:	683b      	ldr	r3, [r7, #0]
  408c4c:	2b00      	cmp	r3, #0
  408c4e:	d002      	beq.n	408c56 <dmp_get_fifo_all+0x1a>
		*reset = 0;
  408c50:	683b      	ldr	r3, [r7, #0]
  408c52:	2200      	movs	r2, #0
  408c54:	601a      	str	r2, [r3, #0]
   
	result = dmp_get_fifo_length(s, &in_fifo);
  408c56:	f107 0310 	add.w	r3, r7, #16
  408c5a:	4619      	mov	r1, r3
  408c5c:	68f8      	ldr	r0, [r7, #12]
  408c5e:	4b20      	ldr	r3, [pc, #128]	; (408ce0 <dmp_get_fifo_all+0xa4>)
  408c60:	4798      	blx	r3
  408c62:	6178      	str	r0, [r7, #20]
	if (result) {
  408c64:	697b      	ldr	r3, [r7, #20]
  408c66:	2b00      	cmp	r3, #0
  408c68:	d005      	beq.n	408c76 <dmp_get_fifo_all+0x3a>
		s->fifo_info.fifoError = result;
  408c6a:	68fb      	ldr	r3, [r7, #12]
  408c6c:	697a      	ldr	r2, [r7, #20]
  408c6e:	f8c3 2098 	str.w	r2, [r3, #152]	; 0x98
		return 0;
  408c72:	2300      	movs	r3, #0
  408c74:	e02f      	b.n	408cd6 <dmp_get_fifo_all+0x9a>
	}
    
	// Nothing to read
	if (in_fifo == 0){
  408c76:	693b      	ldr	r3, [r7, #16]
  408c78:	2b00      	cmp	r3, #0
  408c7a:	d107      	bne.n	408c8c <dmp_get_fifo_all+0x50>
		if(reset)
  408c7c:	683b      	ldr	r3, [r7, #0]
  408c7e:	2b00      	cmp	r3, #0
  408c80:	d002      	beq.n	408c88 <dmp_get_fifo_all+0x4c>
			*reset = 1;
  408c82:	683b      	ldr	r3, [r7, #0]
  408c84:	2201      	movs	r2, #1
  408c86:	601a      	str	r2, [r3, #0]
		return 0;
  408c88:	2300      	movs	r3, #0
  408c8a:	e024      	b.n	408cd6 <dmp_get_fifo_all+0x9a>
	}

	/* Check if buffer is able to be filled in with in_fifo bytes */
	if (in_fifo > length) {
  408c8c:	693a      	ldr	r2, [r7, #16]
  408c8e:	68bb      	ldr	r3, [r7, #8]
  408c90:	429a      	cmp	r2, r3
  408c92:	d90f      	bls.n	408cb4 <dmp_get_fifo_all+0x78>
		dmp_reset_fifo(s);
  408c94:	68f8      	ldr	r0, [r7, #12]
  408c96:	4b13      	ldr	r3, [pc, #76]	; (408ce4 <dmp_get_fifo_all+0xa8>)
  408c98:	4798      	blx	r3
		s->fifo_info.fifoError = -1;
  408c9a:	68fb      	ldr	r3, [r7, #12]
  408c9c:	f04f 32ff 	mov.w	r2, #4294967295
  408ca0:	f8c3 2098 	str.w	r2, [r3, #152]	; 0x98
		if(reset)
  408ca4:	683b      	ldr	r3, [r7, #0]
  408ca6:	2b00      	cmp	r3, #0
  408ca8:	d002      	beq.n	408cb0 <dmp_get_fifo_all+0x74>
			*reset = 1;
  408caa:	683b      	ldr	r3, [r7, #0]
  408cac:	2201      	movs	r2, #1
  408cae:	601a      	str	r2, [r3, #0]
		return 0;
  408cb0:	2300      	movs	r3, #0
  408cb2:	e010      	b.n	408cd6 <dmp_get_fifo_all+0x9a>
	}

	result = dmp_read_fifo(s, buffer, in_fifo);
  408cb4:	693b      	ldr	r3, [r7, #16]
  408cb6:	461a      	mov	r2, r3
  408cb8:	6879      	ldr	r1, [r7, #4]
  408cba:	68f8      	ldr	r0, [r7, #12]
  408cbc:	4b0a      	ldr	r3, [pc, #40]	; (408ce8 <dmp_get_fifo_all+0xac>)
  408cbe:	4798      	blx	r3
  408cc0:	6178      	str	r0, [r7, #20]
	if (result) {
  408cc2:	697b      	ldr	r3, [r7, #20]
  408cc4:	2b00      	cmp	r3, #0
  408cc6:	d005      	beq.n	408cd4 <dmp_get_fifo_all+0x98>
		s->fifo_info.fifoError = result;
  408cc8:	68fb      	ldr	r3, [r7, #12]
  408cca:	697a      	ldr	r2, [r7, #20]
  408ccc:	f8c3 2098 	str.w	r2, [r3, #152]	; 0x98
		return 0;
  408cd0:	2300      	movs	r3, #0
  408cd2:	e000      	b.n	408cd6 <dmp_get_fifo_all+0x9a>
	}
	return in_fifo;
  408cd4:	693b      	ldr	r3, [r7, #16]
}
  408cd6:	4618      	mov	r0, r3
  408cd8:	3718      	adds	r7, #24
  408cda:	46bd      	mov	sp, r7
  408cdc:	bd80      	pop	{r7, pc}
  408cde:	bf00      	nop
  408ce0:	00408a79 	.word	0x00408a79
  408ce4:	00408ae1 	.word	0x00408ae1
  408ce8:	00408bcd 	.word	0x00408bcd

00408cec <get_packet_size_and_samplecnt>:

/** Determines the packet size by decoding the header. Both header and header2 are set. header2 is set to zero
*   if it doesn't exist. sample_cnt_array is filled in if not null with number of samples expected for each sensor
*/
static uint_fast16_t get_packet_size_and_samplecnt(unsigned char *data, unsigned short *header, unsigned short *header2, unsigned short * sample_cnt_array)
{
  408cec:	b480      	push	{r7}
  408cee:	b087      	sub	sp, #28
  408cf0:	af00      	add	r7, sp, #0
  408cf2:	60f8      	str	r0, [r7, #12]
  408cf4:	60b9      	str	r1, [r7, #8]
  408cf6:	607a      	str	r2, [r7, #4]
  408cf8:	603b      	str	r3, [r7, #0]
	int sz = HEADER_SZ; // 2 for header
  408cfa:	2302      	movs	r3, #2
  408cfc:	617b      	str	r3, [r7, #20]
    
	*header = (((unsigned short)data[0])<<8) | data[1];
  408cfe:	68fb      	ldr	r3, [r7, #12]
  408d00:	781b      	ldrb	r3, [r3, #0]
  408d02:	021b      	lsls	r3, r3, #8
  408d04:	b21a      	sxth	r2, r3
  408d06:	68fb      	ldr	r3, [r7, #12]
  408d08:	3301      	adds	r3, #1
  408d0a:	781b      	ldrb	r3, [r3, #0]
  408d0c:	b21b      	sxth	r3, r3
  408d0e:	4313      	orrs	r3, r2
  408d10:	b21b      	sxth	r3, r3
  408d12:	b29a      	uxth	r2, r3
  408d14:	68bb      	ldr	r3, [r7, #8]
  408d16:	801a      	strh	r2, [r3, #0]

	if (*header & ACCEL_SET) {
  408d18:	68bb      	ldr	r3, [r7, #8]
  408d1a:	881b      	ldrh	r3, [r3, #0]
  408d1c:	b21b      	sxth	r3, r3
  408d1e:	2b00      	cmp	r3, #0
  408d20:	da14      	bge.n	408d4c <get_packet_size_and_samplecnt+0x60>
		sz += ACCEL_DATA_SZ;
  408d22:	697b      	ldr	r3, [r7, #20]
  408d24:	3306      	adds	r3, #6
  408d26:	617b      	str	r3, [r7, #20]
		if (sample_cnt_array)
  408d28:	683b      	ldr	r3, [r7, #0]
  408d2a:	2b00      	cmp	r3, #0
  408d2c:	d005      	beq.n	408d3a <get_packet_size_and_samplecnt+0x4e>
			sample_cnt_array[ANDROID_SENSOR_ACCELEROMETER]++;
  408d2e:	683b      	ldr	r3, [r7, #0]
  408d30:	3302      	adds	r3, #2
  408d32:	881a      	ldrh	r2, [r3, #0]
  408d34:	3201      	adds	r2, #1
  408d36:	b292      	uxth	r2, r2
  408d38:	801a      	strh	r2, [r3, #0]
		if (sample_cnt_array)
  408d3a:	683b      	ldr	r3, [r7, #0]
  408d3c:	2b00      	cmp	r3, #0
  408d3e:	d005      	beq.n	408d4c <get_packet_size_and_samplecnt+0x60>
			sample_cnt_array[ANDROID_SENSOR_RAW_ACCELEROMETER]++;
  408d40:	683b      	ldr	r3, [r7, #0]
  408d42:	3354      	adds	r3, #84	; 0x54
  408d44:	881a      	ldrh	r2, [r3, #0]
  408d46:	3201      	adds	r2, #1
  408d48:	b292      	uxth	r2, r2
  408d4a:	801a      	strh	r2, [r3, #0]
	}
    
	if (*header & GYRO_SET) {
  408d4c:	68bb      	ldr	r3, [r7, #8]
  408d4e:	881b      	ldrh	r3, [r3, #0]
  408d50:	f403 4380 	and.w	r3, r3, #16384	; 0x4000
  408d54:	2b00      	cmp	r3, #0
  408d56:	d020      	beq.n	408d9a <get_packet_size_and_samplecnt+0xae>
		sz += GYRO_DATA_SZ;
  408d58:	697b      	ldr	r3, [r7, #20]
  408d5a:	3306      	adds	r3, #6
  408d5c:	617b      	str	r3, [r7, #20]
		if (sample_cnt_array)
  408d5e:	683b      	ldr	r3, [r7, #0]
  408d60:	2b00      	cmp	r3, #0
  408d62:	d005      	beq.n	408d70 <get_packet_size_and_samplecnt+0x84>
			sample_cnt_array[ANDROID_SENSOR_GYROSCOPE_UNCALIBRATED]++;
  408d64:	683b      	ldr	r3, [r7, #0]
  408d66:	3320      	adds	r3, #32
  408d68:	881a      	ldrh	r2, [r3, #0]
  408d6a:	3201      	adds	r2, #1
  408d6c:	b292      	uxth	r2, r2
  408d6e:	801a      	strh	r2, [r3, #0]
		sz += GYRO_BIAS_DATA_SZ;
  408d70:	697b      	ldr	r3, [r7, #20]
  408d72:	3306      	adds	r3, #6
  408d74:	617b      	str	r3, [r7, #20]
		if (sample_cnt_array)
  408d76:	683b      	ldr	r3, [r7, #0]
  408d78:	2b00      	cmp	r3, #0
  408d7a:	d005      	beq.n	408d88 <get_packet_size_and_samplecnt+0x9c>
			sample_cnt_array[ANDROID_SENSOR_GYROSCOPE]++;
  408d7c:	683b      	ldr	r3, [r7, #0]
  408d7e:	3308      	adds	r3, #8
  408d80:	881a      	ldrh	r2, [r3, #0]
  408d82:	3201      	adds	r2, #1
  408d84:	b292      	uxth	r2, r2
  408d86:	801a      	strh	r2, [r3, #0]
		if (sample_cnt_array)
  408d88:	683b      	ldr	r3, [r7, #0]
  408d8a:	2b00      	cmp	r3, #0
  408d8c:	d005      	beq.n	408d9a <get_packet_size_and_samplecnt+0xae>
			sample_cnt_array[ANDROID_SENSOR_RAW_GYROSCOPE]++;
  408d8e:	683b      	ldr	r3, [r7, #0]
  408d90:	3356      	adds	r3, #86	; 0x56
  408d92:	881a      	ldrh	r2, [r3, #0]
  408d94:	3201      	adds	r2, #1
  408d96:	b292      	uxth	r2, r2
  408d98:	801a      	strh	r2, [r3, #0]
	}
 
	if (*header & CPASS_SET) {
  408d9a:	68bb      	ldr	r3, [r7, #8]
  408d9c:	881b      	ldrh	r3, [r3, #0]
  408d9e:	f403 5300 	and.w	r3, r3, #8192	; 0x2000
  408da2:	2b00      	cmp	r3, #0
  408da4:	d00b      	beq.n	408dbe <get_packet_size_and_samplecnt+0xd2>
		sz += CPASS_DATA_SZ;
  408da6:	697b      	ldr	r3, [r7, #20]
  408da8:	3306      	adds	r3, #6
  408daa:	617b      	str	r3, [r7, #20]
		if (sample_cnt_array)
  408dac:	683b      	ldr	r3, [r7, #0]
  408dae:	2b00      	cmp	r3, #0
  408db0:	d005      	beq.n	408dbe <get_packet_size_and_samplecnt+0xd2>
			sample_cnt_array[ANDROID_SENSOR_MAGNETIC_FIELD_UNCALIBRATED]++;
  408db2:	683b      	ldr	r3, [r7, #0]
  408db4:	331c      	adds	r3, #28
  408db6:	881a      	ldrh	r2, [r3, #0]
  408db8:	3201      	adds	r2, #1
  408dba:	b292      	uxth	r2, r2
  408dbc:	801a      	strh	r2, [r3, #0]
	}
    
	if (*header & ALS_SET) {
  408dbe:	68bb      	ldr	r3, [r7, #8]
  408dc0:	881b      	ldrh	r3, [r3, #0]
  408dc2:	f403 5380 	and.w	r3, r3, #4096	; 0x1000
  408dc6:	2b00      	cmp	r3, #0
  408dc8:	d00b      	beq.n	408de2 <get_packet_size_and_samplecnt+0xf6>
		sz += ALS_DATA_SZ;
  408dca:	697b      	ldr	r3, [r7, #20]
  408dcc:	3308      	adds	r3, #8
  408dce:	617b      	str	r3, [r7, #20]
		if (sample_cnt_array)
  408dd0:	683b      	ldr	r3, [r7, #0]
  408dd2:	2b00      	cmp	r3, #0
  408dd4:	d005      	beq.n	408de2 <get_packet_size_and_samplecnt+0xf6>
			sample_cnt_array[ANDROID_SENSOR_LIGHT]++;
  408dd6:	683b      	ldr	r3, [r7, #0]
  408dd8:	330a      	adds	r3, #10
  408dda:	881a      	ldrh	r2, [r3, #0]
  408ddc:	3201      	adds	r2, #1
  408dde:	b292      	uxth	r2, r2
  408de0:	801a      	strh	r2, [r3, #0]
	}

	if (*header & QUAT6_SET) {
  408de2:	68bb      	ldr	r3, [r7, #8]
  408de4:	881b      	ldrh	r3, [r3, #0]
  408de6:	f403 6300 	and.w	r3, r3, #2048	; 0x800
  408dea:	2b00      	cmp	r3, #0
  408dec:	d00b      	beq.n	408e06 <get_packet_size_and_samplecnt+0x11a>
		sz += QUAT6_DATA_SZ;
  408dee:	697b      	ldr	r3, [r7, #20]
  408df0:	330c      	adds	r3, #12
  408df2:	617b      	str	r3, [r7, #20]
		if (sample_cnt_array)
  408df4:	683b      	ldr	r3, [r7, #0]
  408df6:	2b00      	cmp	r3, #0
  408df8:	d005      	beq.n	408e06 <get_packet_size_and_samplecnt+0x11a>
			sample_cnt_array[ANDROID_SENSOR_GAME_ROTATION_VECTOR]++;
  408dfa:	683b      	ldr	r3, [r7, #0]
  408dfc:	331e      	adds	r3, #30
  408dfe:	881a      	ldrh	r2, [r3, #0]
  408e00:	3201      	adds	r2, #1
  408e02:	b292      	uxth	r2, r2
  408e04:	801a      	strh	r2, [r3, #0]
	}

	if (*header & QUAT9_SET) {
  408e06:	68bb      	ldr	r3, [r7, #8]
  408e08:	881b      	ldrh	r3, [r3, #0]
  408e0a:	f403 6380 	and.w	r3, r3, #1024	; 0x400
  408e0e:	2b00      	cmp	r3, #0
  408e10:	d00b      	beq.n	408e2a <get_packet_size_and_samplecnt+0x13e>
		sz += QUAT9_DATA_SZ;
  408e12:	697b      	ldr	r3, [r7, #20]
  408e14:	330e      	adds	r3, #14
  408e16:	617b      	str	r3, [r7, #20]
		if (sample_cnt_array)
  408e18:	683b      	ldr	r3, [r7, #0]
  408e1a:	2b00      	cmp	r3, #0
  408e1c:	d005      	beq.n	408e2a <get_packet_size_and_samplecnt+0x13e>
			sample_cnt_array[ANDROID_SENSOR_ROTATION_VECTOR]++;
  408e1e:	683b      	ldr	r3, [r7, #0]
  408e20:	3316      	adds	r3, #22
  408e22:	881a      	ldrh	r2, [r3, #0]
  408e24:	3201      	adds	r2, #1
  408e26:	b292      	uxth	r2, r2
  408e28:	801a      	strh	r2, [r3, #0]
	}

	if (*header & PQUAT6_SET) 
  408e2a:	68bb      	ldr	r3, [r7, #8]
  408e2c:	881b      	ldrh	r3, [r3, #0]
  408e2e:	f403 7300 	and.w	r3, r3, #512	; 0x200
  408e32:	2b00      	cmp	r3, #0
  408e34:	d002      	beq.n	408e3c <get_packet_size_and_samplecnt+0x150>
		sz += PQUAT6_DATA_SZ;
  408e36:	697b      	ldr	r3, [r7, #20]
  408e38:	3306      	adds	r3, #6
  408e3a:	617b      	str	r3, [r7, #20]
    
	if (*header & GEOMAG_SET) {
  408e3c:	68bb      	ldr	r3, [r7, #8]
  408e3e:	881b      	ldrh	r3, [r3, #0]
  408e40:	f403 7380 	and.w	r3, r3, #256	; 0x100
  408e44:	2b00      	cmp	r3, #0
  408e46:	d00b      	beq.n	408e60 <get_packet_size_and_samplecnt+0x174>
		sz += GEOMAG_DATA_SZ;
  408e48:	697b      	ldr	r3, [r7, #20]
  408e4a:	330e      	adds	r3, #14
  408e4c:	617b      	str	r3, [r7, #20]
		if (sample_cnt_array)
  408e4e:	683b      	ldr	r3, [r7, #0]
  408e50:	2b00      	cmp	r3, #0
  408e52:	d005      	beq.n	408e60 <get_packet_size_and_samplecnt+0x174>
			sample_cnt_array[ANDROID_SENSOR_GEOMAGNETIC_ROTATION_VECTOR]++;
  408e54:	683b      	ldr	r3, [r7, #0]
  408e56:	3328      	adds	r3, #40	; 0x28
  408e58:	881a      	ldrh	r2, [r3, #0]
  408e5a:	3201      	adds	r2, #1
  408e5c:	b292      	uxth	r2, r2
  408e5e:	801a      	strh	r2, [r3, #0]
	}
    
	if (*header & CPASS_CALIBR_SET) {
  408e60:	68bb      	ldr	r3, [r7, #8]
  408e62:	881b      	ldrh	r3, [r3, #0]
  408e64:	f003 0320 	and.w	r3, r3, #32
  408e68:	2b00      	cmp	r3, #0
  408e6a:	d00b      	beq.n	408e84 <get_packet_size_and_samplecnt+0x198>
		sz += CPASS_CALIBR_DATA_SZ;
  408e6c:	697b      	ldr	r3, [r7, #20]
  408e6e:	330c      	adds	r3, #12
  408e70:	617b      	str	r3, [r7, #20]
		if (sample_cnt_array)
  408e72:	683b      	ldr	r3, [r7, #0]
  408e74:	2b00      	cmp	r3, #0
  408e76:	d005      	beq.n	408e84 <get_packet_size_and_samplecnt+0x198>
			sample_cnt_array[ANDROID_SENSOR_GEOMAGNETIC_FIELD]++;
  408e78:	683b      	ldr	r3, [r7, #0]
  408e7a:	3304      	adds	r3, #4
  408e7c:	881a      	ldrh	r2, [r3, #0]
  408e7e:	3201      	adds	r2, #1
  408e80:	b292      	uxth	r2, r2
  408e82:	801a      	strh	r2, [r3, #0]
	}

	if (*header & PED_STEPDET_SET) {
  408e84:	68bb      	ldr	r3, [r7, #8]
  408e86:	881b      	ldrh	r3, [r3, #0]
  408e88:	f003 0310 	and.w	r3, r3, #16
  408e8c:	2b00      	cmp	r3, #0
  408e8e:	d00b      	beq.n	408ea8 <get_packet_size_and_samplecnt+0x1bc>
		sz += PED_STEPDET_TIMESTAMP_SZ;
  408e90:	697b      	ldr	r3, [r7, #20]
  408e92:	3304      	adds	r3, #4
  408e94:	617b      	str	r3, [r7, #20]
		if (sample_cnt_array)
  408e96:	683b      	ldr	r3, [r7, #0]
  408e98:	2b00      	cmp	r3, #0
  408e9a:	d005      	beq.n	408ea8 <get_packet_size_and_samplecnt+0x1bc>
			sample_cnt_array[ANDROID_SENSOR_STEP_DETECTOR]++;
  408e9c:	683b      	ldr	r3, [r7, #0]
  408e9e:	3324      	adds	r3, #36	; 0x24
  408ea0:	881a      	ldrh	r2, [r3, #0]
  408ea2:	3201      	adds	r2, #1
  408ea4:	b292      	uxth	r2, r2
  408ea6:	801a      	strh	r2, [r3, #0]
	}

	if (*header & HEADER2_SET) {
  408ea8:	68bb      	ldr	r3, [r7, #8]
  408eaa:	881b      	ldrh	r3, [r3, #0]
  408eac:	f003 0308 	and.w	r3, r3, #8
  408eb0:	2b00      	cmp	r3, #0
  408eb2:	d011      	beq.n	408ed8 <get_packet_size_and_samplecnt+0x1ec>
		*header2 = (((unsigned short)data[2])<<8) | data[3];
  408eb4:	68fb      	ldr	r3, [r7, #12]
  408eb6:	3302      	adds	r3, #2
  408eb8:	781b      	ldrb	r3, [r3, #0]
  408eba:	021b      	lsls	r3, r3, #8
  408ebc:	b21a      	sxth	r2, r3
  408ebe:	68fb      	ldr	r3, [r7, #12]
  408ec0:	3303      	adds	r3, #3
  408ec2:	781b      	ldrb	r3, [r3, #0]
  408ec4:	b21b      	sxth	r3, r3
  408ec6:	4313      	orrs	r3, r2
  408ec8:	b21b      	sxth	r3, r3
  408eca:	b29a      	uxth	r2, r3
  408ecc:	687b      	ldr	r3, [r7, #4]
  408ece:	801a      	strh	r2, [r3, #0]
		sz += HEADER2_SZ;
  408ed0:	697b      	ldr	r3, [r7, #20]
  408ed2:	3302      	adds	r3, #2
  408ed4:	617b      	str	r3, [r7, #20]
  408ed6:	e002      	b.n	408ede <get_packet_size_and_samplecnt+0x1f2>
	} else {
		*header2 = 0;
  408ed8:	687b      	ldr	r3, [r7, #4]
  408eda:	2200      	movs	r2, #0
  408edc:	801a      	strh	r2, [r3, #0]
	}
    
	if (*header2 & ACCEL_ACCURACY_SET) {
  408ede:	687b      	ldr	r3, [r7, #4]
  408ee0:	881b      	ldrh	r3, [r3, #0]
  408ee2:	f403 4380 	and.w	r3, r3, #16384	; 0x4000
  408ee6:	2b00      	cmp	r3, #0
  408ee8:	d002      	beq.n	408ef0 <get_packet_size_and_samplecnt+0x204>
		sz += ACCEL_ACCURACY_SZ;
  408eea:	697b      	ldr	r3, [r7, #20]
  408eec:	3302      	adds	r3, #2
  408eee:	617b      	str	r3, [r7, #20]
	}
	if (*header2 & GYRO_ACCURACY_SET) {
  408ef0:	687b      	ldr	r3, [r7, #4]
  408ef2:	881b      	ldrh	r3, [r3, #0]
  408ef4:	f403 5300 	and.w	r3, r3, #8192	; 0x2000
  408ef8:	2b00      	cmp	r3, #0
  408efa:	d002      	beq.n	408f02 <get_packet_size_and_samplecnt+0x216>
		sz += GYRO_ACCURACY_SZ;
  408efc:	697b      	ldr	r3, [r7, #20]
  408efe:	3302      	adds	r3, #2
  408f00:	617b      	str	r3, [r7, #20]
	}
	if (*header2 & CPASS_ACCURACY_SET) {
  408f02:	687b      	ldr	r3, [r7, #4]
  408f04:	881b      	ldrh	r3, [r3, #0]
  408f06:	f403 5380 	and.w	r3, r3, #4096	; 0x1000
  408f0a:	2b00      	cmp	r3, #0
  408f0c:	d002      	beq.n	408f14 <get_packet_size_and_samplecnt+0x228>
		sz += CPASS_ACCURACY_SZ;
  408f0e:	697b      	ldr	r3, [r7, #20]
  408f10:	3302      	adds	r3, #2
  408f12:	617b      	str	r3, [r7, #20]
	}
	if (*header2 & FLIP_PICKUP_SET) {
  408f14:	687b      	ldr	r3, [r7, #4]
  408f16:	881b      	ldrh	r3, [r3, #0]
  408f18:	f403 6380 	and.w	r3, r3, #1024	; 0x400
  408f1c:	2b00      	cmp	r3, #0
  408f1e:	d00b      	beq.n	408f38 <get_packet_size_and_samplecnt+0x24c>
		sz += FLIP_PICKUP_SZ;
  408f20:	697b      	ldr	r3, [r7, #20]
  408f22:	3302      	adds	r3, #2
  408f24:	617b      	str	r3, [r7, #20]
		if (sample_cnt_array)
  408f26:	683b      	ldr	r3, [r7, #0]
  408f28:	2b00      	cmp	r3, #0
  408f2a:	d005      	beq.n	408f38 <get_packet_size_and_samplecnt+0x24c>
			sample_cnt_array[ANDROID_SENSOR_FLIP_PICKUP]++;
  408f2c:	683b      	ldr	r3, [r7, #0]
  408f2e:	335c      	adds	r3, #92	; 0x5c
  408f30:	881a      	ldrh	r2, [r3, #0]
  408f32:	3201      	adds	r2, #1
  408f34:	b292      	uxth	r2, r2
  408f36:	801a      	strh	r2, [r3, #0]
	}
	if (*header2 & ACT_RECOG_SET) {
  408f38:	687b      	ldr	r3, [r7, #4]
  408f3a:	881b      	ldrh	r3, [r3, #0]
  408f3c:	f003 0380 	and.w	r3, r3, #128	; 0x80
  408f40:	2b00      	cmp	r3, #0
  408f42:	d00b      	beq.n	408f5c <get_packet_size_and_samplecnt+0x270>
		sz += ACT_RECOG_SZ;
  408f44:	697b      	ldr	r3, [r7, #20]
  408f46:	3306      	adds	r3, #6
  408f48:	617b      	str	r3, [r7, #20]
		if (sample_cnt_array)
  408f4a:	683b      	ldr	r3, [r7, #0]
  408f4c:	2b00      	cmp	r3, #0
  408f4e:	d005      	beq.n	408f5c <get_packet_size_and_samplecnt+0x270>
			sample_cnt_array[ANDROID_SENSOR_ACTIVITY_CLASSIFICATON]++;
  408f50:	683b      	ldr	r3, [r7, #0]
  408f52:	335e      	adds	r3, #94	; 0x5e
  408f54:	881a      	ldrh	r2, [r3, #0]
  408f56:	3201      	adds	r2, #1
  408f58:	b292      	uxth	r2, r2
  408f5a:	801a      	strh	r2, [r3, #0]
	}
	sz += ODR_CNT_GYRO_SZ;
  408f5c:	697b      	ldr	r3, [r7, #20]
  408f5e:	3302      	adds	r3, #2
  408f60:	617b      	str	r3, [r7, #20]

	return sz;
  408f62:	697b      	ldr	r3, [r7, #20]
}
  408f64:	4618      	mov	r0, r3
  408f66:	371c      	adds	r7, #28
  408f68:	46bd      	mov	sp, r7
  408f6a:	f85d 7b04 	ldr.w	r7, [sp], #4
  408f6e:	4770      	bx	lr

00408f70 <check_fifo_decoded_headers>:

static int check_fifo_decoded_headers(unsigned short header, unsigned short header2)
{
  408f70:	b480      	push	{r7}
  408f72:	b085      	sub	sp, #20
  408f74:	af00      	add	r7, sp, #0
  408f76:	4603      	mov	r3, r0
  408f78:	460a      	mov	r2, r1
  408f7a:	80fb      	strh	r3, [r7, #6]
  408f7c:	4613      	mov	r3, r2
  408f7e:	80bb      	strh	r3, [r7, #4]
	unsigned short header_bit_mask = 0;
  408f80:	2300      	movs	r3, #0
  408f82:	81fb      	strh	r3, [r7, #14]
	unsigned short header2_bit_mask = 0;
  408f84:	2300      	movs	r3, #0
  408f86:	81bb      	strh	r3, [r7, #12]
	
	// at least 1 bit must be set
	if (header == 0)
  408f88:	88fb      	ldrh	r3, [r7, #6]
  408f8a:	2b00      	cmp	r3, #0
  408f8c:	d102      	bne.n	408f94 <check_fifo_decoded_headers+0x24>
		return -1;
  408f8e:	f04f 33ff 	mov.w	r3, #4294967295
  408f92:	e063      	b.n	40905c <check_fifo_decoded_headers+0xec>
	
	header_bit_mask |= ACCEL_SET;
  408f94:	89fb      	ldrh	r3, [r7, #14]
  408f96:	ea6f 4343 	mvn.w	r3, r3, lsl #17
  408f9a:	ea6f 4353 	mvn.w	r3, r3, lsr #17
  408f9e:	81fb      	strh	r3, [r7, #14]
	header_bit_mask |= GYRO_SET;
  408fa0:	89fb      	ldrh	r3, [r7, #14]
  408fa2:	f443 4380 	orr.w	r3, r3, #16384	; 0x4000
  408fa6:	81fb      	strh	r3, [r7, #14]
	header_bit_mask |= CPASS_SET;
  408fa8:	89fb      	ldrh	r3, [r7, #14]
  408faa:	f443 5300 	orr.w	r3, r3, #8192	; 0x2000
  408fae:	81fb      	strh	r3, [r7, #14]
	header_bit_mask |= ALS_SET;
  408fb0:	89fb      	ldrh	r3, [r7, #14]
  408fb2:	f443 5380 	orr.w	r3, r3, #4096	; 0x1000
  408fb6:	81fb      	strh	r3, [r7, #14]
	header_bit_mask |= QUAT6_SET;
  408fb8:	89fb      	ldrh	r3, [r7, #14]
  408fba:	f443 6300 	orr.w	r3, r3, #2048	; 0x800
  408fbe:	81fb      	strh	r3, [r7, #14]
	header_bit_mask |= QUAT9_SET;
  408fc0:	89fb      	ldrh	r3, [r7, #14]
  408fc2:	f443 6380 	orr.w	r3, r3, #1024	; 0x400
  408fc6:	81fb      	strh	r3, [r7, #14]
	header_bit_mask |= PQUAT6_SET;
  408fc8:	89fb      	ldrh	r3, [r7, #14]
  408fca:	f443 7300 	orr.w	r3, r3, #512	; 0x200
  408fce:	81fb      	strh	r3, [r7, #14]
	header_bit_mask |= GEOMAG_SET;
  408fd0:	89fb      	ldrh	r3, [r7, #14]
  408fd2:	f443 7380 	orr.w	r3, r3, #256	; 0x100
  408fd6:	81fb      	strh	r3, [r7, #14]
	header_bit_mask |= GYRO_CALIBR_SET;
  408fd8:	89fb      	ldrh	r3, [r7, #14]
  408fda:	f043 0340 	orr.w	r3, r3, #64	; 0x40
  408fde:	81fb      	strh	r3, [r7, #14]
	header_bit_mask |= CPASS_CALIBR_SET;
  408fe0:	89fb      	ldrh	r3, [r7, #14]
  408fe2:	f043 0320 	orr.w	r3, r3, #32
  408fe6:	81fb      	strh	r3, [r7, #14]
	header_bit_mask |= PED_STEPDET_SET;
  408fe8:	89fb      	ldrh	r3, [r7, #14]
  408fea:	f043 0310 	orr.w	r3, r3, #16
  408fee:	81fb      	strh	r3, [r7, #14]
	header_bit_mask |= HEADER2_SET;
  408ff0:	89fb      	ldrh	r3, [r7, #14]
  408ff2:	f043 0308 	orr.w	r3, r3, #8
  408ff6:	81fb      	strh	r3, [r7, #14]
	
	if (header & ~header_bit_mask)
  408ff8:	88fa      	ldrh	r2, [r7, #6]
  408ffa:	89fb      	ldrh	r3, [r7, #14]
  408ffc:	43db      	mvns	r3, r3
  408ffe:	4013      	ands	r3, r2
  409000:	2b00      	cmp	r3, #0
  409002:	d002      	beq.n	40900a <check_fifo_decoded_headers+0x9a>
		return -1;
  409004:	f04f 33ff 	mov.w	r3, #4294967295
  409008:	e028      	b.n	40905c <check_fifo_decoded_headers+0xec>
	
	// at least 1 bit must be set if header 2 is set
	if (header & HEADER2_SET) {
  40900a:	88fb      	ldrh	r3, [r7, #6]
  40900c:	f003 0308 	and.w	r3, r3, #8
  409010:	2b00      	cmp	r3, #0
  409012:	d022      	beq.n	40905a <check_fifo_decoded_headers+0xea>
		header2_bit_mask |= ACCEL_ACCURACY_SET;
  409014:	89bb      	ldrh	r3, [r7, #12]
  409016:	f443 4380 	orr.w	r3, r3, #16384	; 0x4000
  40901a:	81bb      	strh	r3, [r7, #12]
		header2_bit_mask |= GYRO_ACCURACY_SET;
  40901c:	89bb      	ldrh	r3, [r7, #12]
  40901e:	f443 5300 	orr.w	r3, r3, #8192	; 0x2000
  409022:	81bb      	strh	r3, [r7, #12]
		header2_bit_mask |= CPASS_ACCURACY_SET;
  409024:	89bb      	ldrh	r3, [r7, #12]
  409026:	f443 5380 	orr.w	r3, r3, #4096	; 0x1000
  40902a:	81bb      	strh	r3, [r7, #12]
		header2_bit_mask |= FLIP_PICKUP_SET;
  40902c:	89bb      	ldrh	r3, [r7, #12]
  40902e:	f443 6380 	orr.w	r3, r3, #1024	; 0x400
  409032:	81bb      	strh	r3, [r7, #12]
		header2_bit_mask |= ACT_RECOG_SET;
  409034:	89bb      	ldrh	r3, [r7, #12]
  409036:	f043 0380 	orr.w	r3, r3, #128	; 0x80
  40903a:	81bb      	strh	r3, [r7, #12]
		if (header2 == 0)
  40903c:	88bb      	ldrh	r3, [r7, #4]
  40903e:	2b00      	cmp	r3, #0
  409040:	d102      	bne.n	409048 <check_fifo_decoded_headers+0xd8>
			return -1;
  409042:	f04f 33ff 	mov.w	r3, #4294967295
  409046:	e009      	b.n	40905c <check_fifo_decoded_headers+0xec>
		if (header2 & ~header2_bit_mask)
  409048:	88ba      	ldrh	r2, [r7, #4]
  40904a:	89bb      	ldrh	r3, [r7, #12]
  40904c:	43db      	mvns	r3, r3
  40904e:	4013      	ands	r3, r2
  409050:	2b00      	cmp	r3, #0
  409052:	d002      	beq.n	40905a <check_fifo_decoded_headers+0xea>
			return -1;
  409054:	f04f 33ff 	mov.w	r3, #4294967295
  409058:	e000      	b.n	40905c <check_fifo_decoded_headers+0xec>
	}

    return 0;
  40905a:	2300      	movs	r3, #0
}
  40905c:	4618      	mov	r0, r3
  40905e:	3714      	adds	r7, #20
  409060:	46bd      	mov	sp, r7
  409062:	f85d 7b04 	ldr.w	r7, [sp], #4
  409066:	4770      	bx	lr

00409068 <extract_sample_cnt>:
    
/** Determine number of samples present in SW FIFO fifo_data containing fifo_size bytes to be analyzed. Total number
* of samples filled in total_sample_cnt, number of samples per sensor filled in sample_cnt_array array
*/
static int extract_sample_cnt(struct inv_icm20948 * s, int fifo_size, unsigned short * total_sample_cnt, unsigned short * sample_cnt_array)
{
  409068:	b590      	push	{r4, r7, lr}
  40906a:	b089      	sub	sp, #36	; 0x24
  40906c:	af00      	add	r7, sp, #0
  40906e:	60f8      	str	r0, [r7, #12]
  409070:	60b9      	str	r1, [r7, #8]
  409072:	607a      	str	r2, [r7, #4]
  409074:	603b      	str	r3, [r7, #0]
	// Next SW FIFO index to be parsed
	int fifo_idx = 0;
  409076:	2300      	movs	r3, #0
  409078:	61fb      	str	r3, [r7, #28]
	
	while (fifo_idx < fifo_size) {
  40907a:	e02a      	b.n	4090d2 <extract_sample_cnt+0x6a>
		unsigned short header;
		unsigned short header2;
		int need_sz = get_packet_size_and_samplecnt(&fifo_data[fifo_idx], &header, &header2, sample_cnt_array);
  40907c:	69fb      	ldr	r3, [r7, #28]
  40907e:	4a2c      	ldr	r2, [pc, #176]	; (409130 <extract_sample_cnt+0xc8>)
  409080:	1898      	adds	r0, r3, r2
  409082:	f107 0214 	add.w	r2, r7, #20
  409086:	f107 0116 	add.w	r1, r7, #22
  40908a:	683b      	ldr	r3, [r7, #0]
  40908c:	4c29      	ldr	r4, [pc, #164]	; (409134 <extract_sample_cnt+0xcc>)
  40908e:	47a0      	blx	r4
  409090:	4603      	mov	r3, r0
  409092:	61bb      	str	r3, [r7, #24]
		
		// Guarantee there is a full packet before continuing to decode the FIFO packet
		if (fifo_size-fifo_idx < need_sz)
  409094:	68ba      	ldr	r2, [r7, #8]
  409096:	69fb      	ldr	r3, [r7, #28]
  409098:	1ad2      	subs	r2, r2, r3
  40909a:	69bb      	ldr	r3, [r7, #24]
  40909c:	429a      	cmp	r2, r3
  40909e:	db1d      	blt.n	4090dc <extract_sample_cnt+0x74>
			goto endSuccess;
		
		// Decode any error
		if (check_fifo_decoded_headers(header, header2)) {
  4090a0:	8afb      	ldrh	r3, [r7, #22]
  4090a2:	8aba      	ldrh	r2, [r7, #20]
  4090a4:	4611      	mov	r1, r2
  4090a6:	4618      	mov	r0, r3
  4090a8:	4b23      	ldr	r3, [pc, #140]	; (409138 <extract_sample_cnt+0xd0>)
  4090aa:	4798      	blx	r3
  4090ac:	4603      	mov	r3, r0
  4090ae:	2b00      	cmp	r3, #0
  4090b0:	d005      	beq.n	4090be <extract_sample_cnt+0x56>
			// in that case, stop processing, we might have overflowed so following bytes are non sense
			dmp_reset_fifo(s);
  4090b2:	68f8      	ldr	r0, [r7, #12]
  4090b4:	4b21      	ldr	r3, [pc, #132]	; (40913c <extract_sample_cnt+0xd4>)
  4090b6:	4798      	blx	r3
			return -1;
  4090b8:	f04f 33ff 	mov.w	r3, #4294967295
  4090bc:	e034      	b.n	409128 <extract_sample_cnt+0xc0>
		}
		
		fifo_idx += need_sz;
  4090be:	69fa      	ldr	r2, [r7, #28]
  4090c0:	69bb      	ldr	r3, [r7, #24]
  4090c2:	4413      	add	r3, r2
  4090c4:	61fb      	str	r3, [r7, #28]
		
		// One sample found, increment total sample counter
		(*total_sample_cnt)++;
  4090c6:	687b      	ldr	r3, [r7, #4]
  4090c8:	881b      	ldrh	r3, [r3, #0]
  4090ca:	3301      	adds	r3, #1
  4090cc:	b29a      	uxth	r2, r3
  4090ce:	687b      	ldr	r3, [r7, #4]
  4090d0:	801a      	strh	r2, [r3, #0]
	while (fifo_idx < fifo_size) {
  4090d2:	69fa      	ldr	r2, [r7, #28]
  4090d4:	68bb      	ldr	r3, [r7, #8]
  4090d6:	429a      	cmp	r2, r3
  4090d8:	dbd0      	blt.n	40907c <extract_sample_cnt+0x14>
  4090da:	e000      	b.n	4090de <extract_sample_cnt+0x76>
			goto endSuccess;
  4090dc:	bf00      	nop
	}

endSuccess:
	// Augmented sensors are not part of DMP FIFO, they are computed by DMP driver based on GRV or RV presence in DMP FIFO
	// So their sample counts must rely on GRV and RV sample counts
	if (sample_cnt_array) {
  4090de:	683b      	ldr	r3, [r7, #0]
  4090e0:	2b00      	cmp	r3, #0
  4090e2:	d020      	beq.n	409126 <extract_sample_cnt+0xbe>
		sample_cnt_array[ANDROID_SENSOR_GRAVITY] += sample_cnt_array[ANDROID_SENSOR_GAME_ROTATION_VECTOR];
  4090e4:	683b      	ldr	r3, [r7, #0]
  4090e6:	3312      	adds	r3, #18
  4090e8:	683a      	ldr	r2, [r7, #0]
  4090ea:	3212      	adds	r2, #18
  4090ec:	8811      	ldrh	r1, [r2, #0]
  4090ee:	683a      	ldr	r2, [r7, #0]
  4090f0:	321e      	adds	r2, #30
  4090f2:	8812      	ldrh	r2, [r2, #0]
  4090f4:	440a      	add	r2, r1
  4090f6:	b292      	uxth	r2, r2
  4090f8:	801a      	strh	r2, [r3, #0]
		sample_cnt_array[ANDROID_SENSOR_LINEAR_ACCELERATION] += sample_cnt_array[ANDROID_SENSOR_GAME_ROTATION_VECTOR];
  4090fa:	683b      	ldr	r3, [r7, #0]
  4090fc:	3314      	adds	r3, #20
  4090fe:	683a      	ldr	r2, [r7, #0]
  409100:	3214      	adds	r2, #20
  409102:	8811      	ldrh	r1, [r2, #0]
  409104:	683a      	ldr	r2, [r7, #0]
  409106:	321e      	adds	r2, #30
  409108:	8812      	ldrh	r2, [r2, #0]
  40910a:	440a      	add	r2, r1
  40910c:	b292      	uxth	r2, r2
  40910e:	801a      	strh	r2, [r3, #0]
		sample_cnt_array[ANDROID_SENSOR_ORIENTATION] += sample_cnt_array[ANDROID_SENSOR_ROTATION_VECTOR];
  409110:	683b      	ldr	r3, [r7, #0]
  409112:	3306      	adds	r3, #6
  409114:	683a      	ldr	r2, [r7, #0]
  409116:	3206      	adds	r2, #6
  409118:	8811      	ldrh	r1, [r2, #0]
  40911a:	683a      	ldr	r2, [r7, #0]
  40911c:	3216      	adds	r2, #22
  40911e:	8812      	ldrh	r2, [r2, #0]
  409120:	440a      	add	r2, r1
  409122:	b292      	uxth	r2, r2
  409124:	801a      	strh	r2, [r3, #0]
	}

	return 0;
  409126:	2300      	movs	r3, #0
}
  409128:	4618      	mov	r0, r3
  40912a:	3724      	adds	r7, #36	; 0x24
  40912c:	46bd      	mov	sp, r7
  40912e:	bd90      	pop	{r4, r7, pc}
  409130:	20001440 	.word	0x20001440
  409134:	00408ced 	.word	0x00408ced
  409138:	00408f71 	.word	0x00408f71
  40913c:	00408ae1 	.word	0x00408ae1

00409140 <inv_icm20948_fifo_swmirror>:

int inv_icm20948_fifo_swmirror(struct inv_icm20948 * s, int *fifo_sw_size, unsigned short * total_sample_cnt, unsigned short * sample_cnt_array)
{
  409140:	b590      	push	{r4, r7, lr}
  409142:	b087      	sub	sp, #28
  409144:	af00      	add	r7, sp, #0
  409146:	60f8      	str	r0, [r7, #12]
  409148:	60b9      	str	r1, [r7, #8]
  40914a:	607a      	str	r2, [r7, #4]
  40914c:	603b      	str	r3, [r7, #0]
	int reset=0; 
  40914e:	2300      	movs	r3, #0
  409150:	617b      	str	r3, [r7, #20]

	*total_sample_cnt = 0;
  409152:	687b      	ldr	r3, [r7, #4]
  409154:	2200      	movs	r2, #0
  409156:	801a      	strh	r2, [r3, #0]

	// Mirror HW FIFO into local SW FIFO, taking into account remaining *fifo_sw_size bytes still present in SW FIFO
	if (*fifo_sw_size < HARDWARE_FIFO_SIZE ) {
  409158:	68bb      	ldr	r3, [r7, #8]
  40915a:	681b      	ldr	r3, [r3, #0]
  40915c:	f5b3 6f80 	cmp.w	r3, #1024	; 0x400
  409160:	da17      	bge.n	409192 <inv_icm20948_fifo_swmirror+0x52>
		*fifo_sw_size += dmp_get_fifo_all(s, (HARDWARE_FIFO_SIZE - *fifo_sw_size),&fifo_data[*fifo_sw_size],&reset);
  409162:	68bb      	ldr	r3, [r7, #8]
  409164:	681b      	ldr	r3, [r3, #0]
  409166:	f5c3 6380 	rsb	r3, r3, #1024	; 0x400
  40916a:	4619      	mov	r1, r3
  40916c:	68bb      	ldr	r3, [r7, #8]
  40916e:	681b      	ldr	r3, [r3, #0]
  409170:	4a14      	ldr	r2, [pc, #80]	; (4091c4 <inv_icm20948_fifo_swmirror+0x84>)
  409172:	441a      	add	r2, r3
  409174:	f107 0314 	add.w	r3, r7, #20
  409178:	68f8      	ldr	r0, [r7, #12]
  40917a:	4c13      	ldr	r4, [pc, #76]	; (4091c8 <inv_icm20948_fifo_swmirror+0x88>)
  40917c:	47a0      	blx	r4
  40917e:	4602      	mov	r2, r0
  409180:	68bb      	ldr	r3, [r7, #8]
  409182:	681b      	ldr	r3, [r3, #0]
  409184:	4413      	add	r3, r2
  409186:	461a      	mov	r2, r3
  409188:	68bb      	ldr	r3, [r7, #8]
  40918a:	601a      	str	r2, [r3, #0]

		if (reset)
  40918c:	697b      	ldr	r3, [r7, #20]
  40918e:	2b00      	cmp	r3, #0
  409190:	d10b      	bne.n	4091aa <inv_icm20948_fifo_swmirror+0x6a>
			goto error;
	}

	// SW FIFO is mirror, we can now parse it to extract total number of samples and number of samples per sensor
	if (extract_sample_cnt(s, *fifo_sw_size, total_sample_cnt, sample_cnt_array))
  409192:	68bb      	ldr	r3, [r7, #8]
  409194:	6819      	ldr	r1, [r3, #0]
  409196:	683b      	ldr	r3, [r7, #0]
  409198:	687a      	ldr	r2, [r7, #4]
  40919a:	68f8      	ldr	r0, [r7, #12]
  40919c:	4c0b      	ldr	r4, [pc, #44]	; (4091cc <inv_icm20948_fifo_swmirror+0x8c>)
  40919e:	47a0      	blx	r4
  4091a0:	4603      	mov	r3, r0
  4091a2:	2b00      	cmp	r3, #0
  4091a4:	d103      	bne.n	4091ae <inv_icm20948_fifo_swmirror+0x6e>
			goto error;

	return MPU_SUCCESS;
  4091a6:	2300      	movs	r3, #0
  4091a8:	e007      	b.n	4091ba <inv_icm20948_fifo_swmirror+0x7a>
			goto error;
  4091aa:	bf00      	nop
  4091ac:	e000      	b.n	4091b0 <inv_icm20948_fifo_swmirror+0x70>
			goto error;
  4091ae:	bf00      	nop
	
error:
	*fifo_sw_size = 0;
  4091b0:	68bb      	ldr	r3, [r7, #8]
  4091b2:	2200      	movs	r2, #0
  4091b4:	601a      	str	r2, [r3, #0]
	return -1;
  4091b6:	f04f 33ff 	mov.w	r3, #4294967295
	
}
  4091ba:	4618      	mov	r0, r3
  4091bc:	371c      	adds	r7, #28
  4091be:	46bd      	mov	sp, r7
  4091c0:	bd90      	pop	{r4, r7, pc}
  4091c2:	bf00      	nop
  4091c4:	20001440 	.word	0x20001440
  4091c8:	00408c3d 	.word	0x00408c3d
  4091cc:	00409069 	.word	0x00409069

004091d0 <inv_icm20948_fifo_pop>:

int inv_icm20948_fifo_pop(struct inv_icm20948 * s, unsigned short *user_header, unsigned short *user_header2, int *fifo_sw_size)  
{
  4091d0:	b590      	push	{r4, r7, lr}
  4091d2:	b087      	sub	sp, #28
  4091d4:	af00      	add	r7, sp, #0
  4091d6:	60f8      	str	r0, [r7, #12]
  4091d8:	60b9      	str	r1, [r7, #8]
  4091da:	607a      	str	r2, [r7, #4]
  4091dc:	603b      	str	r3, [r7, #0]
	int need_sz=0; // size in bytes of packet to be analyzed from FIFO
  4091de:	2300      	movs	r3, #0
  4091e0:	613b      	str	r3, [r7, #16]
	unsigned char *fifo_ptr = fifo_data; // pointer to next byte in SW FIFO to be parsed
  4091e2:	4b28      	ldr	r3, [pc, #160]	; (409284 <inv_icm20948_fifo_pop+0xb4>)
  4091e4:	617b      	str	r3, [r7, #20]
    
	if (*fifo_sw_size > 3) {
  4091e6:	683b      	ldr	r3, [r7, #0]
  4091e8:	681b      	ldr	r3, [r3, #0]
  4091ea:	2b03      	cmp	r3, #3
  4091ec:	dd44      	ble.n	409278 <inv_icm20948_fifo_pop+0xa8>
		// extract headers and number of bytes requested by next sample present in FIFO
		need_sz = get_packet_size_and_samplecnt(fifo_data, &fd.header, &fd.header2, 0);
  4091ee:	2300      	movs	r3, #0
  4091f0:	4a25      	ldr	r2, [pc, #148]	; (409288 <inv_icm20948_fifo_pop+0xb8>)
  4091f2:	4926      	ldr	r1, [pc, #152]	; (40928c <inv_icm20948_fifo_pop+0xbc>)
  4091f4:	4823      	ldr	r0, [pc, #140]	; (409284 <inv_icm20948_fifo_pop+0xb4>)
  4091f6:	4c26      	ldr	r4, [pc, #152]	; (409290 <inv_icm20948_fifo_pop+0xc0>)
  4091f8:	47a0      	blx	r4
  4091fa:	4603      	mov	r3, r0
  4091fc:	613b      	str	r3, [r7, #16]

		// Guarantee there is a full packet before continuing to decode the FIFO packet
		if (*fifo_sw_size < need_sz) {
  4091fe:	683b      	ldr	r3, [r7, #0]
  409200:	681a      	ldr	r2, [r3, #0]
  409202:	693b      	ldr	r3, [r7, #16]
  409204:	429a      	cmp	r2, r3
  409206:	da03      	bge.n	409210 <inv_icm20948_fifo_pop+0x40>
		    return s->fifo_info.fifoError;
  409208:	68fb      	ldr	r3, [r7, #12]
  40920a:	f8d3 3098 	ldr.w	r3, [r3, #152]	; 0x98
  40920e:	e034      	b.n	40927a <inv_icm20948_fifo_pop+0xaa>
		}

		fifo_ptr += HEADER_SZ;        
  409210:	697b      	ldr	r3, [r7, #20]
  409212:	3302      	adds	r3, #2
  409214:	617b      	str	r3, [r7, #20]
		if (fd.header & HEADER2_SET)
  409216:	4b1f      	ldr	r3, [pc, #124]	; (409294 <inv_icm20948_fifo_pop+0xc4>)
  409218:	f8b3 309a 	ldrh.w	r3, [r3, #154]	; 0x9a
  40921c:	f003 0308 	and.w	r3, r3, #8
  409220:	2b00      	cmp	r3, #0
  409222:	d002      	beq.n	40922a <inv_icm20948_fifo_pop+0x5a>
			fifo_ptr += HEADER2_SZ;        
  409224:	697b      	ldr	r3, [r7, #20]
  409226:	3302      	adds	r3, #2
  409228:	617b      	str	r3, [r7, #20]

		// extract payload data from SW FIFO
		fifo_ptr += inv_icm20948_inv_decode_one_ivory_fifo_packet(s, &fd, fifo_ptr);        
  40922a:	697a      	ldr	r2, [r7, #20]
  40922c:	4919      	ldr	r1, [pc, #100]	; (409294 <inv_icm20948_fifo_pop+0xc4>)
  40922e:	68f8      	ldr	r0, [r7, #12]
  409230:	4b19      	ldr	r3, [pc, #100]	; (409298 <inv_icm20948_fifo_pop+0xc8>)
  409232:	4798      	blx	r3
  409234:	4603      	mov	r3, r0
  409236:	461a      	mov	r2, r3
  409238:	697b      	ldr	r3, [r7, #20]
  40923a:	4413      	add	r3, r2
  40923c:	617b      	str	r3, [r7, #20]

		// remove first need_sz bytes from SW FIFO
		*fifo_sw_size -= need_sz;
  40923e:	683b      	ldr	r3, [r7, #0]
  409240:	681a      	ldr	r2, [r3, #0]
  409242:	693b      	ldr	r3, [r7, #16]
  409244:	1ad2      	subs	r2, r2, r3
  409246:	683b      	ldr	r3, [r7, #0]
  409248:	601a      	str	r2, [r3, #0]
		if(*fifo_sw_size)
  40924a:	683b      	ldr	r3, [r7, #0]
  40924c:	681b      	ldr	r3, [r3, #0]
  40924e:	2b00      	cmp	r3, #0
  409250:	d008      	beq.n	409264 <inv_icm20948_fifo_pop+0x94>
			memmove(fifo_data, &fifo_data[need_sz], *fifo_sw_size);// Data left in FIFO
  409252:	693b      	ldr	r3, [r7, #16]
  409254:	4a0b      	ldr	r2, [pc, #44]	; (409284 <inv_icm20948_fifo_pop+0xb4>)
  409256:	1899      	adds	r1, r3, r2
  409258:	683b      	ldr	r3, [r7, #0]
  40925a:	681b      	ldr	r3, [r3, #0]
  40925c:	461a      	mov	r2, r3
  40925e:	4809      	ldr	r0, [pc, #36]	; (409284 <inv_icm20948_fifo_pop+0xb4>)
  409260:	4b0e      	ldr	r3, [pc, #56]	; (40929c <inv_icm20948_fifo_pop+0xcc>)
  409262:	4798      	blx	r3

		*user_header = fd.header;
  409264:	4b0b      	ldr	r3, [pc, #44]	; (409294 <inv_icm20948_fifo_pop+0xc4>)
  409266:	f8b3 209a 	ldrh.w	r2, [r3, #154]	; 0x9a
  40926a:	68bb      	ldr	r3, [r7, #8]
  40926c:	801a      	strh	r2, [r3, #0]
		*user_header2 = fd.header2;
  40926e:	4b09      	ldr	r3, [pc, #36]	; (409294 <inv_icm20948_fifo_pop+0xc4>)
  409270:	f8b3 209c 	ldrh.w	r2, [r3, #156]	; 0x9c
  409274:	687b      	ldr	r3, [r7, #4]
  409276:	801a      	strh	r2, [r3, #0]
	}

	return MPU_SUCCESS;
  409278:	2300      	movs	r3, #0
}
  40927a:	4618      	mov	r0, r3
  40927c:	371c      	adds	r7, #28
  40927e:	46bd      	mov	sp, r7
  409280:	bd90      	pop	{r4, r7, pc}
  409282:	bf00      	nop
  409284:	20001440 	.word	0x20001440
  409288:	20002110 	.word	0x20002110
  40928c:	2000210e 	.word	0x2000210e
  409290:	00408ced 	.word	0x00408ced
  409294:	20002074 	.word	0x20002074
  409298:	00409399 	.word	0x00409399
  40929c:	00414179 	.word	0x00414179

004092a0 <inv_decode_3_32bit_elements>:

    return result;
}

static void inv_decode_3_32bit_elements(long *out_data, const unsigned char *in_data)
{
  4092a0:	b480      	push	{r7}
  4092a2:	b083      	sub	sp, #12
  4092a4:	af00      	add	r7, sp, #0
  4092a6:	6078      	str	r0, [r7, #4]
  4092a8:	6039      	str	r1, [r7, #0]
    out_data[0] = ((long)(0xff & in_data[0]) << 24) | ((long)(0xff & in_data[1]) << 16) | ((long)(0xff & in_data[2]) << 8) | (0xff & in_data[3]);
  4092aa:	683b      	ldr	r3, [r7, #0]
  4092ac:	781b      	ldrb	r3, [r3, #0]
  4092ae:	061a      	lsls	r2, r3, #24
  4092b0:	683b      	ldr	r3, [r7, #0]
  4092b2:	3301      	adds	r3, #1
  4092b4:	781b      	ldrb	r3, [r3, #0]
  4092b6:	041b      	lsls	r3, r3, #16
  4092b8:	431a      	orrs	r2, r3
  4092ba:	683b      	ldr	r3, [r7, #0]
  4092bc:	3302      	adds	r3, #2
  4092be:	781b      	ldrb	r3, [r3, #0]
  4092c0:	021b      	lsls	r3, r3, #8
  4092c2:	4313      	orrs	r3, r2
  4092c4:	683a      	ldr	r2, [r7, #0]
  4092c6:	3203      	adds	r2, #3
  4092c8:	7812      	ldrb	r2, [r2, #0]
  4092ca:	431a      	orrs	r2, r3
  4092cc:	687b      	ldr	r3, [r7, #4]
  4092ce:	601a      	str	r2, [r3, #0]
    out_data[1] = ((long)(0xff & in_data[4]) << 24) | ((long)(0xff & in_data[5]) << 16) | ((long)(0xff & in_data[6]) << 8) | (0xff & in_data[7]);
  4092d0:	687b      	ldr	r3, [r7, #4]
  4092d2:	3304      	adds	r3, #4
  4092d4:	683a      	ldr	r2, [r7, #0]
  4092d6:	3204      	adds	r2, #4
  4092d8:	7812      	ldrb	r2, [r2, #0]
  4092da:	0611      	lsls	r1, r2, #24
  4092dc:	683a      	ldr	r2, [r7, #0]
  4092de:	3205      	adds	r2, #5
  4092e0:	7812      	ldrb	r2, [r2, #0]
  4092e2:	0412      	lsls	r2, r2, #16
  4092e4:	4311      	orrs	r1, r2
  4092e6:	683a      	ldr	r2, [r7, #0]
  4092e8:	3206      	adds	r2, #6
  4092ea:	7812      	ldrb	r2, [r2, #0]
  4092ec:	0212      	lsls	r2, r2, #8
  4092ee:	430a      	orrs	r2, r1
  4092f0:	6839      	ldr	r1, [r7, #0]
  4092f2:	3107      	adds	r1, #7
  4092f4:	7809      	ldrb	r1, [r1, #0]
  4092f6:	430a      	orrs	r2, r1
  4092f8:	601a      	str	r2, [r3, #0]
    out_data[2] = ((long)(0xff & in_data[8]) << 24) | ((long)(0xff & in_data[9]) << 16) | ((long)(0xff & in_data[10]) << 8) | (0xff & in_data[11]);
  4092fa:	687b      	ldr	r3, [r7, #4]
  4092fc:	3308      	adds	r3, #8
  4092fe:	683a      	ldr	r2, [r7, #0]
  409300:	3208      	adds	r2, #8
  409302:	7812      	ldrb	r2, [r2, #0]
  409304:	0611      	lsls	r1, r2, #24
  409306:	683a      	ldr	r2, [r7, #0]
  409308:	3209      	adds	r2, #9
  40930a:	7812      	ldrb	r2, [r2, #0]
  40930c:	0412      	lsls	r2, r2, #16
  40930e:	4311      	orrs	r1, r2
  409310:	683a      	ldr	r2, [r7, #0]
  409312:	320a      	adds	r2, #10
  409314:	7812      	ldrb	r2, [r2, #0]
  409316:	0212      	lsls	r2, r2, #8
  409318:	430a      	orrs	r2, r1
  40931a:	6839      	ldr	r1, [r7, #0]
  40931c:	310b      	adds	r1, #11
  40931e:	7809      	ldrb	r1, [r1, #0]
  409320:	430a      	orrs	r2, r1
  409322:	601a      	str	r2, [r3, #0]
}
  409324:	bf00      	nop
  409326:	370c      	adds	r7, #12
  409328:	46bd      	mov	sp, r7
  40932a:	f85d 7b04 	ldr.w	r7, [sp], #4
  40932e:	4770      	bx	lr

00409330 <inv_decode_3_16bit_elements>:
static void inv_decode_3_16bit_elements(short *out_data, const unsigned char *in_data)
{
  409330:	b480      	push	{r7}
  409332:	b083      	sub	sp, #12
  409334:	af00      	add	r7, sp, #0
  409336:	6078      	str	r0, [r7, #4]
  409338:	6039      	str	r1, [r7, #0]
    out_data[0] = ((short)(0xff & in_data[0]) << 8) | (0xff & in_data[1]);
  40933a:	683b      	ldr	r3, [r7, #0]
  40933c:	781b      	ldrb	r3, [r3, #0]
  40933e:	021b      	lsls	r3, r3, #8
  409340:	b21a      	sxth	r2, r3
  409342:	683b      	ldr	r3, [r7, #0]
  409344:	3301      	adds	r3, #1
  409346:	781b      	ldrb	r3, [r3, #0]
  409348:	b21b      	sxth	r3, r3
  40934a:	4313      	orrs	r3, r2
  40934c:	b21a      	sxth	r2, r3
  40934e:	687b      	ldr	r3, [r7, #4]
  409350:	801a      	strh	r2, [r3, #0]
    out_data[1] = ((short)(0xff & in_data[2]) << 8) | (0xff & in_data[3]);
  409352:	687b      	ldr	r3, [r7, #4]
  409354:	3302      	adds	r3, #2
  409356:	683a      	ldr	r2, [r7, #0]
  409358:	3202      	adds	r2, #2
  40935a:	7812      	ldrb	r2, [r2, #0]
  40935c:	0212      	lsls	r2, r2, #8
  40935e:	b211      	sxth	r1, r2
  409360:	683a      	ldr	r2, [r7, #0]
  409362:	3203      	adds	r2, #3
  409364:	7812      	ldrb	r2, [r2, #0]
  409366:	b212      	sxth	r2, r2
  409368:	430a      	orrs	r2, r1
  40936a:	b212      	sxth	r2, r2
  40936c:	801a      	strh	r2, [r3, #0]
    out_data[2] = ((short)(0xff & in_data[4]) << 8) | (0xff & in_data[5]);
  40936e:	687b      	ldr	r3, [r7, #4]
  409370:	3304      	adds	r3, #4
  409372:	683a      	ldr	r2, [r7, #0]
  409374:	3204      	adds	r2, #4
  409376:	7812      	ldrb	r2, [r2, #0]
  409378:	0212      	lsls	r2, r2, #8
  40937a:	b211      	sxth	r1, r2
  40937c:	683a      	ldr	r2, [r7, #0]
  40937e:	3205      	adds	r2, #5
  409380:	7812      	ldrb	r2, [r2, #0]
  409382:	b212      	sxth	r2, r2
  409384:	430a      	orrs	r2, r1
  409386:	b212      	sxth	r2, r2
  409388:	801a      	strh	r2, [r3, #0]
}
  40938a:	bf00      	nop
  40938c:	370c      	adds	r7, #12
  40938e:	46bd      	mov	sp, r7
  409390:	f85d 7b04 	ldr.w	r7, [sp], #4
  409394:	4770      	bx	lr
	...

00409398 <inv_icm20948_inv_decode_one_ivory_fifo_packet>:
* @param[in] fd Structure to be filled out with data. Assumes header and header2 are already set inside.
* @param[in] fifo_ptr FIFO data, points to just after any header information
* @return Returns the number of bytes consumed in FIFO data.
*/
int inv_icm20948_inv_decode_one_ivory_fifo_packet(struct inv_icm20948 * s, struct inv_fifo_decoded_t *fd, const unsigned char *fifo_ptr)
{
  409398:	b580      	push	{r7, lr}
  40939a:	b086      	sub	sp, #24
  40939c:	af00      	add	r7, sp, #0
  40939e:	60f8      	str	r0, [r7, #12]
  4093a0:	60b9      	str	r1, [r7, #8]
  4093a2:	607a      	str	r2, [r7, #4]
    const unsigned char *fifo_ptr_start = fifo_ptr;  
  4093a4:	687b      	ldr	r3, [r7, #4]
  4093a6:	617b      	str	r3, [r7, #20]
	short odr_cntr;
    if (fd->header & ACCEL_SET) {
  4093a8:	68bb      	ldr	r3, [r7, #8]
  4093aa:	f8b3 309a 	ldrh.w	r3, [r3, #154]	; 0x9a
  4093ae:	b21b      	sxth	r3, r3
  4093b0:	2b00      	cmp	r3, #0
  4093b2:	da1a      	bge.n	4093ea <inv_icm20948_inv_decode_one_ivory_fifo_packet+0x52>
        // do not cast data here, do that when you use it
        inv_decode_3_16bit_elements(fd->accel_s, fifo_ptr);
  4093b4:	68bb      	ldr	r3, [r7, #8]
  4093b6:	332c      	adds	r3, #44	; 0x2c
  4093b8:	6879      	ldr	r1, [r7, #4]
  4093ba:	4618      	mov	r0, r3
  4093bc:	4b9c      	ldr	r3, [pc, #624]	; (409630 <inv_icm20948_inv_decode_one_ivory_fifo_packet+0x298>)
  4093be:	4798      	blx	r3
        fd->accel[0] = fd->accel_s[0] << 15;
  4093c0:	68bb      	ldr	r3, [r7, #8]
  4093c2:	f9b3 302c 	ldrsh.w	r3, [r3, #44]	; 0x2c
  4093c6:	03da      	lsls	r2, r3, #15
  4093c8:	68bb      	ldr	r3, [r7, #8]
  4093ca:	635a      	str	r2, [r3, #52]	; 0x34
        fd->accel[1] = fd->accel_s[1] << 15;
  4093cc:	68bb      	ldr	r3, [r7, #8]
  4093ce:	f9b3 302e 	ldrsh.w	r3, [r3, #46]	; 0x2e
  4093d2:	03da      	lsls	r2, r3, #15
  4093d4:	68bb      	ldr	r3, [r7, #8]
  4093d6:	639a      	str	r2, [r3, #56]	; 0x38
        fd->accel[2] = fd->accel_s[2] << 15;
  4093d8:	68bb      	ldr	r3, [r7, #8]
  4093da:	f9b3 3030 	ldrsh.w	r3, [r3, #48]	; 0x30
  4093de:	03da      	lsls	r2, r3, #15
  4093e0:	68bb      	ldr	r3, [r7, #8]
  4093e2:	63da      	str	r2, [r3, #60]	; 0x3c
        fifo_ptr += ACCEL_DATA_SZ;
  4093e4:	687b      	ldr	r3, [r7, #4]
  4093e6:	3306      	adds	r3, #6
  4093e8:	607b      	str	r3, [r7, #4]
    }

    if (fd->header & GYRO_SET) {
  4093ea:	68bb      	ldr	r3, [r7, #8]
  4093ec:	f8b3 309a 	ldrh.w	r3, [r3, #154]	; 0x9a
  4093f0:	f403 4380 	and.w	r3, r3, #16384	; 0x4000
  4093f4:	2b00      	cmp	r3, #0
  4093f6:	d011      	beq.n	40941c <inv_icm20948_inv_decode_one_ivory_fifo_packet+0x84>
        inv_decode_3_16bit_elements(fd->gyro, fifo_ptr);
  4093f8:	68bb      	ldr	r3, [r7, #8]
  4093fa:	3340      	adds	r3, #64	; 0x40
  4093fc:	6879      	ldr	r1, [r7, #4]
  4093fe:	4618      	mov	r0, r3
  409400:	4b8b      	ldr	r3, [pc, #556]	; (409630 <inv_icm20948_inv_decode_one_ivory_fifo_packet+0x298>)
  409402:	4798      	blx	r3
        fifo_ptr += GYRO_DATA_SZ;
  409404:	687b      	ldr	r3, [r7, #4]
  409406:	3306      	adds	r3, #6
  409408:	607b      	str	r3, [r7, #4]
        inv_decode_3_16bit_elements(fd->gyro_bias, fifo_ptr);
  40940a:	68bb      	ldr	r3, [r7, #8]
  40940c:	3346      	adds	r3, #70	; 0x46
  40940e:	6879      	ldr	r1, [r7, #4]
  409410:	4618      	mov	r0, r3
  409412:	4b87      	ldr	r3, [pc, #540]	; (409630 <inv_icm20948_inv_decode_one_ivory_fifo_packet+0x298>)
  409414:	4798      	blx	r3
        fifo_ptr += GYRO_BIAS_DATA_SZ;
  409416:	687b      	ldr	r3, [r7, #4]
  409418:	3306      	adds	r3, #6
  40941a:	607b      	str	r3, [r7, #4]
    }

    if (fd->header & CPASS_SET) {
  40941c:	68bb      	ldr	r3, [r7, #8]
  40941e:	f8b3 309a 	ldrh.w	r3, [r3, #154]	; 0x9a
  409422:	f403 5300 	and.w	r3, r3, #8192	; 0x2000
  409426:	2b00      	cmp	r3, #0
  409428:	d018      	beq.n	40945c <inv_icm20948_inv_decode_one_ivory_fifo_packet+0xc4>
        inv_decode_3_16bit_elements(fd->cpass_raw_data, fifo_ptr);
  40942a:	68bb      	ldr	r3, [r7, #8]
  40942c:	3374      	adds	r3, #116	; 0x74
  40942e:	6879      	ldr	r1, [r7, #4]
  409430:	4618      	mov	r0, r3
  409432:	4b7f      	ldr	r3, [pc, #508]	; (409630 <inv_icm20948_inv_decode_one_ivory_fifo_packet+0x298>)
  409434:	4798      	blx	r3
        inv_icm20948_apply_raw_compass_matrix(s, fd->cpass_raw_data, fd->compass);
  409436:	68bb      	ldr	r3, [r7, #8]
  409438:	f103 0174 	add.w	r1, r3, #116	; 0x74
  40943c:	68bb      	ldr	r3, [r7, #8]
  40943e:	3358      	adds	r3, #88	; 0x58
  409440:	461a      	mov	r2, r3
  409442:	68f8      	ldr	r0, [r7, #12]
  409444:	4b7b      	ldr	r3, [pc, #492]	; (409634 <inv_icm20948_inv_decode_one_ivory_fifo_packet+0x29c>)
  409446:	4798      	blx	r3
        memcpy( fd->cpass_calibr_6chars, fifo_ptr, 6*sizeof(unsigned char));
  409448:	68bb      	ldr	r3, [r7, #8]
  40944a:	3394      	adds	r3, #148	; 0x94
  40944c:	2206      	movs	r2, #6
  40944e:	6879      	ldr	r1, [r7, #4]
  409450:	4618      	mov	r0, r3
  409452:	4b79      	ldr	r3, [pc, #484]	; (409638 <inv_icm20948_inv_decode_one_ivory_fifo_packet+0x2a0>)
  409454:	4798      	blx	r3
        fifo_ptr += CPASS_DATA_SZ;
  409456:	687b      	ldr	r3, [r7, #4]
  409458:	3306      	adds	r3, #6
  40945a:	607b      	str	r3, [r7, #4]
    }

    if(fd->header & ALS_SET) {
  40945c:	68bb      	ldr	r3, [r7, #8]
  40945e:	f8b3 309a 	ldrh.w	r3, [r3, #154]	; 0x9a
  409462:	f403 5380 	and.w	r3, r3, #4096	; 0x1000
  409466:	2b00      	cmp	r3, #0
  409468:	d002      	beq.n	409470 <inv_icm20948_inv_decode_one_ivory_fifo_packet+0xd8>
        fifo_ptr += ALS_DATA_SZ;
  40946a:	687b      	ldr	r3, [r7, #4]
  40946c:	3308      	adds	r3, #8
  40946e:	607b      	str	r3, [r7, #4]
    }

    if (fd->header & QUAT6_SET) {
  409470:	68bb      	ldr	r3, [r7, #8]
  409472:	f8b3 309a 	ldrh.w	r3, [r3, #154]	; 0x9a
  409476:	f403 6300 	and.w	r3, r3, #2048	; 0x800
  40947a:	2b00      	cmp	r3, #0
  40947c:	d007      	beq.n	40948e <inv_icm20948_inv_decode_one_ivory_fifo_packet+0xf6>
        inv_decode_3_32bit_elements(fd->dmp_3e_6quat, fifo_ptr);
  40947e:	68bb      	ldr	r3, [r7, #8]
  409480:	6879      	ldr	r1, [r7, #4]
  409482:	4618      	mov	r0, r3
  409484:	4b6d      	ldr	r3, [pc, #436]	; (40963c <inv_icm20948_inv_decode_one_ivory_fifo_packet+0x2a4>)
  409486:	4798      	blx	r3
        fifo_ptr += QUAT6_DATA_SZ;
  409488:	687b      	ldr	r3, [r7, #4]
  40948a:	330c      	adds	r3, #12
  40948c:	607b      	str	r3, [r7, #4]
    }

    if (fd->header & QUAT9_SET) {
  40948e:	68bb      	ldr	r3, [r7, #8]
  409490:	f8b3 309a 	ldrh.w	r3, [r3, #154]	; 0x9a
  409494:	f403 6380 	and.w	r3, r3, #1024	; 0x400
  409498:	2b00      	cmp	r3, #0
  40949a:	d013      	beq.n	4094c4 <inv_icm20948_inv_decode_one_ivory_fifo_packet+0x12c>
        inv_decode_3_32bit_elements(fd->dmp_3e_9quat, fifo_ptr);
  40949c:	68bb      	ldr	r3, [r7, #8]
  40949e:	330c      	adds	r3, #12
  4094a0:	6879      	ldr	r1, [r7, #4]
  4094a2:	4618      	mov	r0, r3
  4094a4:	4b65      	ldr	r3, [pc, #404]	; (40963c <inv_icm20948_inv_decode_one_ivory_fifo_packet+0x2a4>)
  4094a6:	4798      	blx	r3
        fd->dmp_rv_accuracyQ29 = ((0xff & fifo_ptr[12]) << 24) | ((0xff & fifo_ptr[13]) << 16);
  4094a8:	687b      	ldr	r3, [r7, #4]
  4094aa:	330c      	adds	r3, #12
  4094ac:	781b      	ldrb	r3, [r3, #0]
  4094ae:	061a      	lsls	r2, r3, #24
  4094b0:	687b      	ldr	r3, [r7, #4]
  4094b2:	330d      	adds	r3, #13
  4094b4:	781b      	ldrb	r3, [r3, #0]
  4094b6:	041b      	lsls	r3, r3, #16
  4094b8:	431a      	orrs	r2, r3
  4094ba:	68bb      	ldr	r3, [r7, #8]
  4094bc:	619a      	str	r2, [r3, #24]
        fifo_ptr += QUAT9_DATA_SZ;
  4094be:	687b      	ldr	r3, [r7, #4]
  4094c0:	330e      	adds	r3, #14
  4094c2:	607b      	str	r3, [r7, #4]
    }

    if (fd->header & PED_STEPDET_SET) {
  4094c4:	68bb      	ldr	r3, [r7, #8]
  4094c6:	f8b3 309a 	ldrh.w	r3, [r3, #154]	; 0x9a
  4094ca:	f003 0310 	and.w	r3, r3, #16
  4094ce:	2b00      	cmp	r3, #0
  4094d0:	d015      	beq.n	4094fe <inv_icm20948_inv_decode_one_ivory_fifo_packet+0x166>
        fd->ped_step_det_ts = ((0xff & fifo_ptr[0]) << 24) | ((0xff & fifo_ptr[1]) << 16) | ((0xff & fifo_ptr[2]) << 8) | (0xff & fifo_ptr[3]);
  4094d2:	687b      	ldr	r3, [r7, #4]
  4094d4:	781b      	ldrb	r3, [r3, #0]
  4094d6:	061a      	lsls	r2, r3, #24
  4094d8:	687b      	ldr	r3, [r7, #4]
  4094da:	3301      	adds	r3, #1
  4094dc:	781b      	ldrb	r3, [r3, #0]
  4094de:	041b      	lsls	r3, r3, #16
  4094e0:	431a      	orrs	r2, r3
  4094e2:	687b      	ldr	r3, [r7, #4]
  4094e4:	3302      	adds	r3, #2
  4094e6:	781b      	ldrb	r3, [r3, #0]
  4094e8:	021b      	lsls	r3, r3, #8
  4094ea:	4313      	orrs	r3, r2
  4094ec:	687a      	ldr	r2, [r7, #4]
  4094ee:	3203      	adds	r2, #3
  4094f0:	7812      	ldrb	r2, [r2, #0]
  4094f2:	431a      	orrs	r2, r3
  4094f4:	68bb      	ldr	r3, [r7, #8]
  4094f6:	671a      	str	r2, [r3, #112]	; 0x70
        fifo_ptr += PED_STEPDET_TIMESTAMP_SZ;
  4094f8:	687b      	ldr	r3, [r7, #4]
  4094fa:	3304      	adds	r3, #4
  4094fc:	607b      	str	r3, [r7, #4]
    }

    if (fd->header & GEOMAG_SET) {
  4094fe:	68bb      	ldr	r3, [r7, #8]
  409500:	f8b3 309a 	ldrh.w	r3, [r3, #154]	; 0x9a
  409504:	f403 7380 	and.w	r3, r3, #256	; 0x100
  409508:	2b00      	cmp	r3, #0
  40950a:	d013      	beq.n	409534 <inv_icm20948_inv_decode_one_ivory_fifo_packet+0x19c>
        inv_decode_3_32bit_elements(fd->dmp_3e_geomagquat, fifo_ptr);
  40950c:	68bb      	ldr	r3, [r7, #8]
  40950e:	331c      	adds	r3, #28
  409510:	6879      	ldr	r1, [r7, #4]
  409512:	4618      	mov	r0, r3
  409514:	4b49      	ldr	r3, [pc, #292]	; (40963c <inv_icm20948_inv_decode_one_ivory_fifo_packet+0x2a4>)
  409516:	4798      	blx	r3
        fd->dmp_geomag_accuracyQ29 = ((0xff & fifo_ptr[12]) << 24) | ((0xff & fifo_ptr[13]) << 16);
  409518:	687b      	ldr	r3, [r7, #4]
  40951a:	330c      	adds	r3, #12
  40951c:	781b      	ldrb	r3, [r3, #0]
  40951e:	061a      	lsls	r2, r3, #24
  409520:	687b      	ldr	r3, [r7, #4]
  409522:	330d      	adds	r3, #13
  409524:	781b      	ldrb	r3, [r3, #0]
  409526:	041b      	lsls	r3, r3, #16
  409528:	431a      	orrs	r2, r3
  40952a:	68bb      	ldr	r3, [r7, #8]
  40952c:	629a      	str	r2, [r3, #40]	; 0x28
        fifo_ptr += GEOMAG_DATA_SZ;
  40952e:	687b      	ldr	r3, [r7, #4]
  409530:	330e      	adds	r3, #14
  409532:	607b      	str	r3, [r7, #4]
    }

    if(fd->header & PRESSURE_SET) {
  409534:	68bb      	ldr	r3, [r7, #8]
  409536:	f8b3 309a 	ldrh.w	r3, [r3, #154]	; 0x9a
  40953a:	f003 0380 	and.w	r3, r3, #128	; 0x80
  40953e:	2b00      	cmp	r3, #0
  409540:	d002      	beq.n	409548 <inv_icm20948_inv_decode_one_ivory_fifo_packet+0x1b0>
        fifo_ptr += PRESSURE_DATA_SZ;
  409542:	687b      	ldr	r3, [r7, #4]
  409544:	3306      	adds	r3, #6
  409546:	607b      	str	r3, [r7, #4]
    }
    if (fd->header & CPASS_CALIBR_SET) {
  409548:	68bb      	ldr	r3, [r7, #8]
  40954a:	f8b3 309a 	ldrh.w	r3, [r3, #154]	; 0x9a
  40954e:	f003 0320 	and.w	r3, r3, #32
  409552:	2b00      	cmp	r3, #0
  409554:	d00f      	beq.n	409576 <inv_icm20948_inv_decode_one_ivory_fifo_packet+0x1de>
        inv_decode_3_32bit_elements(fd->cpass_calibr, fifo_ptr);
  409556:	68bb      	ldr	r3, [r7, #8]
  409558:	3364      	adds	r3, #100	; 0x64
  40955a:	6879      	ldr	r1, [r7, #4]
  40955c:	4618      	mov	r0, r3
  40955e:	4b37      	ldr	r3, [pc, #220]	; (40963c <inv_icm20948_inv_decode_one_ivory_fifo_packet+0x2a4>)
  409560:	4798      	blx	r3
        memcpy( fd->cpass_calibr_12chars, fifo_ptr, 12*sizeof(unsigned char));
  409562:	68bb      	ldr	r3, [r7, #8]
  409564:	3388      	adds	r3, #136	; 0x88
  409566:	220c      	movs	r2, #12
  409568:	6879      	ldr	r1, [r7, #4]
  40956a:	4618      	mov	r0, r3
  40956c:	4b32      	ldr	r3, [pc, #200]	; (409638 <inv_icm20948_inv_decode_one_ivory_fifo_packet+0x2a0>)
  40956e:	4798      	blx	r3
        fifo_ptr += CPASS_CALIBR_DATA_SZ;
  409570:	687b      	ldr	r3, [r7, #4]
  409572:	330c      	adds	r3, #12
  409574:	607b      	str	r3, [r7, #4]
    }

    if (fd->header2 & ACCEL_ACCURACY_SET) {
  409576:	68bb      	ldr	r3, [r7, #8]
  409578:	f8b3 309c 	ldrh.w	r3, [r3, #156]	; 0x9c
  40957c:	f403 4380 	and.w	r3, r3, #16384	; 0x4000
  409580:	2b00      	cmp	r3, #0
  409582:	d00f      	beq.n	4095a4 <inv_icm20948_inv_decode_one_ivory_fifo_packet+0x20c>
        fd->accel_accuracy = ((0xff & fifo_ptr[0]) << 8) | (0xff & fifo_ptr[1]);
  409584:	687b      	ldr	r3, [r7, #4]
  409586:	781b      	ldrb	r3, [r3, #0]
  409588:	021b      	lsls	r3, r3, #8
  40958a:	b21a      	sxth	r2, r3
  40958c:	687b      	ldr	r3, [r7, #4]
  40958e:	3301      	adds	r3, #1
  409590:	781b      	ldrb	r3, [r3, #0]
  409592:	b21b      	sxth	r3, r3
  409594:	4313      	orrs	r3, r2
  409596:	b21a      	sxth	r2, r3
  409598:	68bb      	ldr	r3, [r7, #8]
  40959a:	f8a3 207a 	strh.w	r2, [r3, #122]	; 0x7a
        fifo_ptr += ACCEL_ACCURACY_SZ;
  40959e:	687b      	ldr	r3, [r7, #4]
  4095a0:	3302      	adds	r3, #2
  4095a2:	607b      	str	r3, [r7, #4]
    }
        
    if (fd->header2 & GYRO_ACCURACY_SET) {
  4095a4:	68bb      	ldr	r3, [r7, #8]
  4095a6:	f8b3 309c 	ldrh.w	r3, [r3, #156]	; 0x9c
  4095aa:	f403 5300 	and.w	r3, r3, #8192	; 0x2000
  4095ae:	2b00      	cmp	r3, #0
  4095b0:	d00f      	beq.n	4095d2 <inv_icm20948_inv_decode_one_ivory_fifo_packet+0x23a>
        fd->gyro_accuracy = ((0xff & fifo_ptr[0]) << 8) | (0xff & fifo_ptr[1]);
  4095b2:	687b      	ldr	r3, [r7, #4]
  4095b4:	781b      	ldrb	r3, [r3, #0]
  4095b6:	021b      	lsls	r3, r3, #8
  4095b8:	b21a      	sxth	r2, r3
  4095ba:	687b      	ldr	r3, [r7, #4]
  4095bc:	3301      	adds	r3, #1
  4095be:	781b      	ldrb	r3, [r3, #0]
  4095c0:	b21b      	sxth	r3, r3
  4095c2:	4313      	orrs	r3, r2
  4095c4:	b21a      	sxth	r2, r3
  4095c6:	68bb      	ldr	r3, [r7, #8]
  4095c8:	f8a3 207c 	strh.w	r2, [r3, #124]	; 0x7c
        fifo_ptr += GYRO_ACCURACY_SZ;
  4095cc:	687b      	ldr	r3, [r7, #4]
  4095ce:	3302      	adds	r3, #2
  4095d0:	607b      	str	r3, [r7, #4]
    }
 
    if (fd->header2 & CPASS_ACCURACY_SET) {
  4095d2:	68bb      	ldr	r3, [r7, #8]
  4095d4:	f8b3 309c 	ldrh.w	r3, [r3, #156]	; 0x9c
  4095d8:	f403 5380 	and.w	r3, r3, #4096	; 0x1000
  4095dc:	2b00      	cmp	r3, #0
  4095de:	d00f      	beq.n	409600 <inv_icm20948_inv_decode_one_ivory_fifo_packet+0x268>
        fd->cpass_accuracy = ((0xff & fifo_ptr[0]) << 8) | (0xff & fifo_ptr[1]);
  4095e0:	687b      	ldr	r3, [r7, #4]
  4095e2:	781b      	ldrb	r3, [r3, #0]
  4095e4:	021b      	lsls	r3, r3, #8
  4095e6:	b21a      	sxth	r2, r3
  4095e8:	687b      	ldr	r3, [r7, #4]
  4095ea:	3301      	adds	r3, #1
  4095ec:	781b      	ldrb	r3, [r3, #0]
  4095ee:	b21b      	sxth	r3, r3
  4095f0:	4313      	orrs	r3, r2
  4095f2:	b21a      	sxth	r2, r3
  4095f4:	68bb      	ldr	r3, [r7, #8]
  4095f6:	f8a3 207e 	strh.w	r2, [r3, #126]	; 0x7e
        fifo_ptr += CPASS_ACCURACY_SZ;
  4095fa:	687b      	ldr	r3, [r7, #4]
  4095fc:	3302      	adds	r3, #2
  4095fe:	607b      	str	r3, [r7, #4]
    }

	if (fd->header2 & FLIP_PICKUP_SET) {
  409600:	68bb      	ldr	r3, [r7, #8]
  409602:	f8b3 309c 	ldrh.w	r3, [r3, #156]	; 0x9c
  409606:	f403 6380 	and.w	r3, r3, #1024	; 0x400
  40960a:	2b00      	cmp	r3, #0
  40960c:	d018      	beq.n	409640 <inv_icm20948_inv_decode_one_ivory_fifo_packet+0x2a8>
		fd->flip_pickup = ((0xff & fifo_ptr[0]) << 8) | (0xff & fifo_ptr[1]);
  40960e:	687b      	ldr	r3, [r7, #4]
  409610:	781b      	ldrb	r3, [r3, #0]
  409612:	021b      	lsls	r3, r3, #8
  409614:	b21a      	sxth	r2, r3
  409616:	687b      	ldr	r3, [r7, #4]
  409618:	3301      	adds	r3, #1
  40961a:	781b      	ldrb	r3, [r3, #0]
  40961c:	b21b      	sxth	r3, r3
  40961e:	4313      	orrs	r3, r2
  409620:	b21a      	sxth	r2, r3
  409622:	68bb      	ldr	r3, [r7, #8]
  409624:	f8a3 2086 	strh.w	r2, [r3, #134]	; 0x86
		fifo_ptr += FLIP_PICKUP_SZ;
  409628:	687b      	ldr	r3, [r7, #4]
  40962a:	3302      	adds	r3, #2
  40962c:	607b      	str	r3, [r7, #4]
  40962e:	e007      	b.n	409640 <inv_icm20948_inv_decode_one_ivory_fifo_packet+0x2a8>
  409630:	00409331 	.word	0x00409331
  409634:	00405265 	.word	0x00405265
  409638:	00414045 	.word	0x00414045
  40963c:	004092a1 	.word	0x004092a1
	}
	
	if (fd->header2 & ACT_RECOG_SET) {
  409640:	68bb      	ldr	r3, [r7, #8]
  409642:	f8b3 309c 	ldrh.w	r3, [r3, #156]	; 0x9c
  409646:	f003 0380 	and.w	r3, r3, #128	; 0x80
  40964a:	2b00      	cmp	r3, #0
  40964c:	d025      	beq.n	40969a <inv_icm20948_inv_decode_one_ivory_fifo_packet+0x302>
		fd->bac_state = ((0xff & fifo_ptr[0]) << 8) | (0xff & fifo_ptr[1]);
  40964e:	687b      	ldr	r3, [r7, #4]
  409650:	781b      	ldrb	r3, [r3, #0]
  409652:	021b      	lsls	r3, r3, #8
  409654:	b21a      	sxth	r2, r3
  409656:	687b      	ldr	r3, [r7, #4]
  409658:	3301      	adds	r3, #1
  40965a:	781b      	ldrb	r3, [r3, #0]
  40965c:	b21b      	sxth	r3, r3
  40965e:	4313      	orrs	r3, r2
  409660:	b21b      	sxth	r3, r3
  409662:	b29a      	uxth	r2, r3
  409664:	68bb      	ldr	r3, [r7, #8]
  409666:	f8a3 2084 	strh.w	r2, [r3, #132]	; 0x84
		fd->bac_ts     = ((0xff & fifo_ptr[2]) << 24) | ((0xff & fifo_ptr[3]) << 16) | ((0xff & fifo_ptr[4]) << 8) | (0xff & fifo_ptr[5]);
  40966a:	687b      	ldr	r3, [r7, #4]
  40966c:	3302      	adds	r3, #2
  40966e:	781b      	ldrb	r3, [r3, #0]
  409670:	061a      	lsls	r2, r3, #24
  409672:	687b      	ldr	r3, [r7, #4]
  409674:	3303      	adds	r3, #3
  409676:	781b      	ldrb	r3, [r3, #0]
  409678:	041b      	lsls	r3, r3, #16
  40967a:	431a      	orrs	r2, r3
  40967c:	687b      	ldr	r3, [r7, #4]
  40967e:	3304      	adds	r3, #4
  409680:	781b      	ldrb	r3, [r3, #0]
  409682:	021b      	lsls	r3, r3, #8
  409684:	4313      	orrs	r3, r2
  409686:	687a      	ldr	r2, [r7, #4]
  409688:	3205      	adds	r2, #5
  40968a:	7812      	ldrb	r2, [r2, #0]
  40968c:	431a      	orrs	r2, r3
  40968e:	68bb      	ldr	r3, [r7, #8]
  409690:	f8c3 2080 	str.w	r2, [r3, #128]	; 0x80
		fifo_ptr += ACT_RECOG_SZ;
  409694:	687b      	ldr	r3, [r7, #4]
  409696:	3306      	adds	r3, #6
  409698:	607b      	str	r3, [r7, #4]
	}

	odr_cntr = ((0xff & fifo_ptr[0]) << 8) | (0xff & fifo_ptr[1]);
  40969a:	687b      	ldr	r3, [r7, #4]
  40969c:	781b      	ldrb	r3, [r3, #0]
  40969e:	021b      	lsls	r3, r3, #8
  4096a0:	b21a      	sxth	r2, r3
  4096a2:	687b      	ldr	r3, [r7, #4]
  4096a4:	3301      	adds	r3, #1
  4096a6:	781b      	ldrb	r3, [r3, #0]
  4096a8:	b21b      	sxth	r3, r3
  4096aa:	4313      	orrs	r3, r2
  4096ac:	827b      	strh	r3, [r7, #18]
	// odr_cntr_gyro is odr_cntr & 0xfff
	// 9KHz cnt is odr_cntr >> 12
	// not used for now, needed only for FSYNC purpose
	(void)odr_cntr;
	fifo_ptr += FOOTER_SZ;
  4096ae:	687b      	ldr	r3, [r7, #4]
  4096b0:	3302      	adds	r3, #2
  4096b2:	607b      	str	r3, [r7, #4]

    fd->new_data = 1; // Record a new data set
  4096b4:	68bb      	ldr	r3, [r7, #8]
  4096b6:	2201      	movs	r2, #1
  4096b8:	f8c3 20a0 	str.w	r2, [r3, #160]	; 0xa0

    return fifo_ptr-fifo_ptr_start;
  4096bc:	687a      	ldr	r2, [r7, #4]
  4096be:	697b      	ldr	r3, [r7, #20]
  4096c0:	1ad3      	subs	r3, r2, r3
}
  4096c2:	4618      	mov	r0, r3
  4096c4:	3718      	adds	r7, #24
  4096c6:	46bd      	mov	sp, r7
  4096c8:	bd80      	pop	{r7, pc}
  4096ca:	bf00      	nop

004096cc <inv_icm20948_dmp_get_accel>:

int inv_icm20948_dmp_get_accel(long acl[3])
{
  4096cc:	b580      	push	{r7, lr}
  4096ce:	b082      	sub	sp, #8
  4096d0:	af00      	add	r7, sp, #0
  4096d2:	6078      	str	r0, [r7, #4]
    if(!acl) return -1;
  4096d4:	687b      	ldr	r3, [r7, #4]
  4096d6:	2b00      	cmp	r3, #0
  4096d8:	d102      	bne.n	4096e0 <inv_icm20948_dmp_get_accel+0x14>
  4096da:	f04f 33ff 	mov.w	r3, #4294967295
  4096de:	e005      	b.n	4096ec <inv_icm20948_dmp_get_accel+0x20>
    memcpy( acl, fd.accel, 3*sizeof(long));
  4096e0:	220c      	movs	r2, #12
  4096e2:	4904      	ldr	r1, [pc, #16]	; (4096f4 <inv_icm20948_dmp_get_accel+0x28>)
  4096e4:	6878      	ldr	r0, [r7, #4]
  4096e6:	4b04      	ldr	r3, [pc, #16]	; (4096f8 <inv_icm20948_dmp_get_accel+0x2c>)
  4096e8:	4798      	blx	r3
    return MPU_SUCCESS;
  4096ea:	2300      	movs	r3, #0
} 
  4096ec:	4618      	mov	r0, r3
  4096ee:	3708      	adds	r7, #8
  4096f0:	46bd      	mov	sp, r7
  4096f2:	bd80      	pop	{r7, pc}
  4096f4:	200020a8 	.word	0x200020a8
  4096f8:	00414045 	.word	0x00414045

004096fc <inv_icm20948_dmp_get_raw_gyro>:

int inv_icm20948_dmp_get_raw_gyro(short raw_gyro[3])
{
  4096fc:	b480      	push	{r7}
  4096fe:	b083      	sub	sp, #12
  409700:	af00      	add	r7, sp, #0
  409702:	6078      	str	r0, [r7, #4]
    if(!raw_gyro) return -1;
  409704:	687b      	ldr	r3, [r7, #4]
  409706:	2b00      	cmp	r3, #0
  409708:	d102      	bne.n	409710 <inv_icm20948_dmp_get_raw_gyro+0x14>
  40970a:	f04f 33ff 	mov.w	r3, #4294967295
  40970e:	e011      	b.n	409734 <inv_icm20948_dmp_get_raw_gyro+0x38>
    raw_gyro[0] = fd.gyro[0];
  409710:	4b0b      	ldr	r3, [pc, #44]	; (409740 <inv_icm20948_dmp_get_raw_gyro+0x44>)
  409712:	f9b3 2040 	ldrsh.w	r2, [r3, #64]	; 0x40
  409716:	687b      	ldr	r3, [r7, #4]
  409718:	801a      	strh	r2, [r3, #0]
    raw_gyro[1] = fd.gyro[1];
  40971a:	687b      	ldr	r3, [r7, #4]
  40971c:	3302      	adds	r3, #2
  40971e:	4a08      	ldr	r2, [pc, #32]	; (409740 <inv_icm20948_dmp_get_raw_gyro+0x44>)
  409720:	f9b2 2042 	ldrsh.w	r2, [r2, #66]	; 0x42
  409724:	801a      	strh	r2, [r3, #0]
    raw_gyro[2] = fd.gyro[2];
  409726:	687b      	ldr	r3, [r7, #4]
  409728:	3304      	adds	r3, #4
  40972a:	4a05      	ldr	r2, [pc, #20]	; (409740 <inv_icm20948_dmp_get_raw_gyro+0x44>)
  40972c:	f9b2 2044 	ldrsh.w	r2, [r2, #68]	; 0x44
  409730:	801a      	strh	r2, [r3, #0]
    return MPU_SUCCESS;
  409732:	2300      	movs	r3, #0
}
  409734:	4618      	mov	r0, r3
  409736:	370c      	adds	r7, #12
  409738:	46bd      	mov	sp, r7
  40973a:	f85d 7b04 	ldr.w	r7, [sp], #4
  40973e:	4770      	bx	lr
  409740:	20002074 	.word	0x20002074

00409744 <inv_icm20948_dmp_get_gyro_bias>:


int inv_icm20948_dmp_get_gyro_bias(short gyro_bias[3])
{
  409744:	b580      	push	{r7, lr}
  409746:	b082      	sub	sp, #8
  409748:	af00      	add	r7, sp, #0
  40974a:	6078      	str	r0, [r7, #4]
    if(!gyro_bias) return -1;  
  40974c:	687b      	ldr	r3, [r7, #4]
  40974e:	2b00      	cmp	r3, #0
  409750:	d102      	bne.n	409758 <inv_icm20948_dmp_get_gyro_bias+0x14>
  409752:	f04f 33ff 	mov.w	r3, #4294967295
  409756:	e005      	b.n	409764 <inv_icm20948_dmp_get_gyro_bias+0x20>
    memcpy(gyro_bias, fd.gyro_bias, 3*sizeof(short)); 
  409758:	2206      	movs	r2, #6
  40975a:	4904      	ldr	r1, [pc, #16]	; (40976c <inv_icm20948_dmp_get_gyro_bias+0x28>)
  40975c:	6878      	ldr	r0, [r7, #4]
  40975e:	4b04      	ldr	r3, [pc, #16]	; (409770 <inv_icm20948_dmp_get_gyro_bias+0x2c>)
  409760:	4798      	blx	r3
    return MPU_SUCCESS;
  409762:	2300      	movs	r3, #0
}
  409764:	4618      	mov	r0, r3
  409766:	3708      	adds	r7, #8
  409768:	46bd      	mov	sp, r7
  40976a:	bd80      	pop	{r7, pc}
  40976c:	200020ba 	.word	0x200020ba
  409770:	00414045 	.word	0x00414045

00409774 <inv_icm20948_dmp_get_calibrated_gyro>:


int inv_icm20948_dmp_get_calibrated_gyro(signed long calibratedData[3], signed long raw[3], signed long bias[3])
{
  409774:	b480      	push	{r7}
  409776:	b085      	sub	sp, #20
  409778:	af00      	add	r7, sp, #0
  40977a:	60f8      	str	r0, [r7, #12]
  40977c:	60b9      	str	r1, [r7, #8]
  40977e:	607a      	str	r2, [r7, #4]
    if(!calibratedData) return -1;  
  409780:	68fb      	ldr	r3, [r7, #12]
  409782:	2b00      	cmp	r3, #0
  409784:	d102      	bne.n	40978c <inv_icm20948_dmp_get_calibrated_gyro+0x18>
  409786:	f04f 33ff 	mov.w	r3, #4294967295
  40978a:	e027      	b.n	4097dc <inv_icm20948_dmp_get_calibrated_gyro+0x68>
    if(!raw) return -1;  
  40978c:	68bb      	ldr	r3, [r7, #8]
  40978e:	2b00      	cmp	r3, #0
  409790:	d102      	bne.n	409798 <inv_icm20948_dmp_get_calibrated_gyro+0x24>
  409792:	f04f 33ff 	mov.w	r3, #4294967295
  409796:	e021      	b.n	4097dc <inv_icm20948_dmp_get_calibrated_gyro+0x68>
    if(!bias) return -1;  
  409798:	687b      	ldr	r3, [r7, #4]
  40979a:	2b00      	cmp	r3, #0
  40979c:	d102      	bne.n	4097a4 <inv_icm20948_dmp_get_calibrated_gyro+0x30>
  40979e:	f04f 33ff 	mov.w	r3, #4294967295
  4097a2:	e01b      	b.n	4097dc <inv_icm20948_dmp_get_calibrated_gyro+0x68>
    
    calibratedData[0] = raw[0] - bias[0];
  4097a4:	68bb      	ldr	r3, [r7, #8]
  4097a6:	681a      	ldr	r2, [r3, #0]
  4097a8:	687b      	ldr	r3, [r7, #4]
  4097aa:	681b      	ldr	r3, [r3, #0]
  4097ac:	1ad2      	subs	r2, r2, r3
  4097ae:	68fb      	ldr	r3, [r7, #12]
  4097b0:	601a      	str	r2, [r3, #0]
    calibratedData[1] = raw[1] - bias[1];
  4097b2:	68fb      	ldr	r3, [r7, #12]
  4097b4:	3304      	adds	r3, #4
  4097b6:	68ba      	ldr	r2, [r7, #8]
  4097b8:	3204      	adds	r2, #4
  4097ba:	6811      	ldr	r1, [r2, #0]
  4097bc:	687a      	ldr	r2, [r7, #4]
  4097be:	3204      	adds	r2, #4
  4097c0:	6812      	ldr	r2, [r2, #0]
  4097c2:	1a8a      	subs	r2, r1, r2
  4097c4:	601a      	str	r2, [r3, #0]
    calibratedData[2] = raw[2] - bias[2];
  4097c6:	68fb      	ldr	r3, [r7, #12]
  4097c8:	3308      	adds	r3, #8
  4097ca:	68ba      	ldr	r2, [r7, #8]
  4097cc:	3208      	adds	r2, #8
  4097ce:	6811      	ldr	r1, [r2, #0]
  4097d0:	687a      	ldr	r2, [r7, #4]
  4097d2:	3208      	adds	r2, #8
  4097d4:	6812      	ldr	r2, [r2, #0]
  4097d6:	1a8a      	subs	r2, r1, r2
  4097d8:	601a      	str	r2, [r3, #0]
    
    return MPU_SUCCESS;
  4097da:	2300      	movs	r3, #0
}
  4097dc:	4618      	mov	r0, r3
  4097de:	3714      	adds	r7, #20
  4097e0:	46bd      	mov	sp, r7
  4097e2:	f85d 7b04 	ldr.w	r7, [sp], #4
  4097e6:	4770      	bx	lr

004097e8 <inv_icm20948_dmp_get_6quaternion>:

int inv_icm20948_dmp_get_6quaternion(long quat[3])
{
  4097e8:	b580      	push	{r7, lr}
  4097ea:	b082      	sub	sp, #8
  4097ec:	af00      	add	r7, sp, #0
  4097ee:	6078      	str	r0, [r7, #4]
    if(!quat) return -1;
  4097f0:	687b      	ldr	r3, [r7, #4]
  4097f2:	2b00      	cmp	r3, #0
  4097f4:	d102      	bne.n	4097fc <inv_icm20948_dmp_get_6quaternion+0x14>
  4097f6:	f04f 33ff 	mov.w	r3, #4294967295
  4097fa:	e005      	b.n	409808 <inv_icm20948_dmp_get_6quaternion+0x20>
    memcpy( quat, fd.dmp_3e_6quat, sizeof(fd.dmp_3e_6quat));            
  4097fc:	220c      	movs	r2, #12
  4097fe:	4904      	ldr	r1, [pc, #16]	; (409810 <inv_icm20948_dmp_get_6quaternion+0x28>)
  409800:	6878      	ldr	r0, [r7, #4]
  409802:	4b04      	ldr	r3, [pc, #16]	; (409814 <inv_icm20948_dmp_get_6quaternion+0x2c>)
  409804:	4798      	blx	r3
    return MPU_SUCCESS;
  409806:	2300      	movs	r3, #0
}
  409808:	4618      	mov	r0, r3
  40980a:	3708      	adds	r7, #8
  40980c:	46bd      	mov	sp, r7
  40980e:	bd80      	pop	{r7, pc}
  409810:	20002074 	.word	0x20002074
  409814:	00414045 	.word	0x00414045

00409818 <inv_icm20948_dmp_get_9quaternion>:

int inv_icm20948_dmp_get_9quaternion(long quat[3])
{
  409818:	b580      	push	{r7, lr}
  40981a:	b082      	sub	sp, #8
  40981c:	af00      	add	r7, sp, #0
  40981e:	6078      	str	r0, [r7, #4]
    if(!quat) return -1;
  409820:	687b      	ldr	r3, [r7, #4]
  409822:	2b00      	cmp	r3, #0
  409824:	d102      	bne.n	40982c <inv_icm20948_dmp_get_9quaternion+0x14>
  409826:	f04f 33ff 	mov.w	r3, #4294967295
  40982a:	e005      	b.n	409838 <inv_icm20948_dmp_get_9quaternion+0x20>
    memcpy( quat, fd.dmp_3e_9quat, sizeof(fd.dmp_3e_9quat));            
  40982c:	220c      	movs	r2, #12
  40982e:	4904      	ldr	r1, [pc, #16]	; (409840 <inv_icm20948_dmp_get_9quaternion+0x28>)
  409830:	6878      	ldr	r0, [r7, #4]
  409832:	4b04      	ldr	r3, [pc, #16]	; (409844 <inv_icm20948_dmp_get_9quaternion+0x2c>)
  409834:	4798      	blx	r3
    return MPU_SUCCESS;
  409836:	2300      	movs	r3, #0
}
  409838:	4618      	mov	r0, r3
  40983a:	3708      	adds	r7, #8
  40983c:	46bd      	mov	sp, r7
  40983e:	bd80      	pop	{r7, pc}
  409840:	20002080 	.word	0x20002080
  409844:	00414045 	.word	0x00414045

00409848 <inv_icm20948_dmp_get_gmrvquaternion>:

int inv_icm20948_dmp_get_gmrvquaternion(long quat[3])
{
  409848:	b580      	push	{r7, lr}
  40984a:	b082      	sub	sp, #8
  40984c:	af00      	add	r7, sp, #0
  40984e:	6078      	str	r0, [r7, #4]
    if(!quat) return -1;
  409850:	687b      	ldr	r3, [r7, #4]
  409852:	2b00      	cmp	r3, #0
  409854:	d102      	bne.n	40985c <inv_icm20948_dmp_get_gmrvquaternion+0x14>
  409856:	f04f 33ff 	mov.w	r3, #4294967295
  40985a:	e005      	b.n	409868 <inv_icm20948_dmp_get_gmrvquaternion+0x20>
    memcpy( quat, fd.dmp_3e_geomagquat, sizeof(fd.dmp_3e_geomagquat));            
  40985c:	220c      	movs	r2, #12
  40985e:	4904      	ldr	r1, [pc, #16]	; (409870 <inv_icm20948_dmp_get_gmrvquaternion+0x28>)
  409860:	6878      	ldr	r0, [r7, #4]
  409862:	4b04      	ldr	r3, [pc, #16]	; (409874 <inv_icm20948_dmp_get_gmrvquaternion+0x2c>)
  409864:	4798      	blx	r3
    return MPU_SUCCESS;
  409866:	2300      	movs	r3, #0
}
  409868:	4618      	mov	r0, r3
  40986a:	3708      	adds	r7, #8
  40986c:	46bd      	mov	sp, r7
  40986e:	bd80      	pop	{r7, pc}
  409870:	20002090 	.word	0x20002090
  409874:	00414045 	.word	0x00414045

00409878 <inv_icm20948_dmp_get_raw_compass>:

int inv_icm20948_dmp_get_raw_compass(long raw_compass[3])
{
  409878:	b580      	push	{r7, lr}
  40987a:	b082      	sub	sp, #8
  40987c:	af00      	add	r7, sp, #0
  40987e:	6078      	str	r0, [r7, #4]
    if(!raw_compass) return -1;
  409880:	687b      	ldr	r3, [r7, #4]
  409882:	2b00      	cmp	r3, #0
  409884:	d102      	bne.n	40988c <inv_icm20948_dmp_get_raw_compass+0x14>
  409886:	f04f 33ff 	mov.w	r3, #4294967295
  40988a:	e005      	b.n	409898 <inv_icm20948_dmp_get_raw_compass+0x20>
    memcpy( raw_compass, fd.compass, 3*sizeof(long)); 
  40988c:	220c      	movs	r2, #12
  40988e:	4904      	ldr	r1, [pc, #16]	; (4098a0 <inv_icm20948_dmp_get_raw_compass+0x28>)
  409890:	6878      	ldr	r0, [r7, #4]
  409892:	4b04      	ldr	r3, [pc, #16]	; (4098a4 <inv_icm20948_dmp_get_raw_compass+0x2c>)
  409894:	4798      	blx	r3
    return MPU_SUCCESS;
  409896:	2300      	movs	r3, #0
}
  409898:	4618      	mov	r0, r3
  40989a:	3708      	adds	r7, #8
  40989c:	46bd      	mov	sp, r7
  40989e:	bd80      	pop	{r7, pc}
  4098a0:	200020cc 	.word	0x200020cc
  4098a4:	00414045 	.word	0x00414045

004098a8 <inv_icm20948_dmp_get_calibrated_compass>:

int inv_icm20948_dmp_get_calibrated_compass(long cal_compass[3])
{
  4098a8:	b580      	push	{r7, lr}
  4098aa:	b082      	sub	sp, #8
  4098ac:	af00      	add	r7, sp, #0
  4098ae:	6078      	str	r0, [r7, #4]
    if(!cal_compass) return -1;
  4098b0:	687b      	ldr	r3, [r7, #4]
  4098b2:	2b00      	cmp	r3, #0
  4098b4:	d102      	bne.n	4098bc <inv_icm20948_dmp_get_calibrated_compass+0x14>
  4098b6:	f04f 33ff 	mov.w	r3, #4294967295
  4098ba:	e005      	b.n	4098c8 <inv_icm20948_dmp_get_calibrated_compass+0x20>
    memcpy( cal_compass, fd.cpass_calibr, 3*sizeof(long));  
  4098bc:	220c      	movs	r2, #12
  4098be:	4904      	ldr	r1, [pc, #16]	; (4098d0 <inv_icm20948_dmp_get_calibrated_compass+0x28>)
  4098c0:	6878      	ldr	r0, [r7, #4]
  4098c2:	4b04      	ldr	r3, [pc, #16]	; (4098d4 <inv_icm20948_dmp_get_calibrated_compass+0x2c>)
  4098c4:	4798      	blx	r3
    return MPU_SUCCESS;
  4098c6:	2300      	movs	r3, #0
}
  4098c8:	4618      	mov	r0, r3
  4098ca:	3708      	adds	r7, #8
  4098cc:	46bd      	mov	sp, r7
  4098ce:	bd80      	pop	{r7, pc}
  4098d0:	200020d8 	.word	0x200020d8
  4098d4:	00414045 	.word	0x00414045

004098d8 <inv_icm20948_dmp_get_bac_state>:

int inv_icm20948_dmp_get_bac_state(uint16_t *bac_state)
{
  4098d8:	b480      	push	{r7}
  4098da:	b083      	sub	sp, #12
  4098dc:	af00      	add	r7, sp, #0
  4098de:	6078      	str	r0, [r7, #4]
	if(!bac_state) return -1;
  4098e0:	687b      	ldr	r3, [r7, #4]
  4098e2:	2b00      	cmp	r3, #0
  4098e4:	d102      	bne.n	4098ec <inv_icm20948_dmp_get_bac_state+0x14>
  4098e6:	f04f 33ff 	mov.w	r3, #4294967295
  4098ea:	e005      	b.n	4098f8 <inv_icm20948_dmp_get_bac_state+0x20>
	*bac_state = fd.bac_state;
  4098ec:	4b05      	ldr	r3, [pc, #20]	; (409904 <inv_icm20948_dmp_get_bac_state+0x2c>)
  4098ee:	f8b3 2084 	ldrh.w	r2, [r3, #132]	; 0x84
  4098f2:	687b      	ldr	r3, [r7, #4]
  4098f4:	801a      	strh	r2, [r3, #0]
	return 0;
  4098f6:	2300      	movs	r3, #0
}
  4098f8:	4618      	mov	r0, r3
  4098fa:	370c      	adds	r7, #12
  4098fc:	46bd      	mov	sp, r7
  4098fe:	f85d 7b04 	ldr.w	r7, [sp], #4
  409902:	4770      	bx	lr
  409904:	20002074 	.word	0x20002074

00409908 <inv_icm20948_dmp_get_bac_ts>:

int inv_icm20948_dmp_get_bac_ts(long *bac_ts)
{
  409908:	b480      	push	{r7}
  40990a:	b083      	sub	sp, #12
  40990c:	af00      	add	r7, sp, #0
  40990e:	6078      	str	r0, [r7, #4]
	if(!bac_ts) return -1;
  409910:	687b      	ldr	r3, [r7, #4]
  409912:	2b00      	cmp	r3, #0
  409914:	d102      	bne.n	40991c <inv_icm20948_dmp_get_bac_ts+0x14>
  409916:	f04f 33ff 	mov.w	r3, #4294967295
  40991a:	e005      	b.n	409928 <inv_icm20948_dmp_get_bac_ts+0x20>
	*bac_ts = fd.bac_ts;
  40991c:	4b05      	ldr	r3, [pc, #20]	; (409934 <inv_icm20948_dmp_get_bac_ts+0x2c>)
  40991e:	f8d3 2080 	ldr.w	r2, [r3, #128]	; 0x80
  409922:	687b      	ldr	r3, [r7, #4]
  409924:	601a      	str	r2, [r3, #0]
	return 0;
  409926:	2300      	movs	r3, #0
}
  409928:	4618      	mov	r0, r3
  40992a:	370c      	adds	r7, #12
  40992c:	46bd      	mov	sp, r7
  40992e:	f85d 7b04 	ldr.w	r7, [sp], #4
  409932:	4770      	bx	lr
  409934:	20002074 	.word	0x20002074

00409938 <inv_icm20948_dmp_get_flip_pickup_state>:

int inv_icm20948_dmp_get_flip_pickup_state(uint16_t *flip_pickup)
{
  409938:	b480      	push	{r7}
  40993a:	b083      	sub	sp, #12
  40993c:	af00      	add	r7, sp, #0
  40993e:	6078      	str	r0, [r7, #4]
	if(!flip_pickup) return -1;
  409940:	687b      	ldr	r3, [r7, #4]
  409942:	2b00      	cmp	r3, #0
  409944:	d102      	bne.n	40994c <inv_icm20948_dmp_get_flip_pickup_state+0x14>
  409946:	f04f 33ff 	mov.w	r3, #4294967295
  40994a:	e006      	b.n	40995a <inv_icm20948_dmp_get_flip_pickup_state+0x22>
	*flip_pickup = fd.flip_pickup;
  40994c:	4b06      	ldr	r3, [pc, #24]	; (409968 <inv_icm20948_dmp_get_flip_pickup_state+0x30>)
  40994e:	f9b3 3086 	ldrsh.w	r3, [r3, #134]	; 0x86
  409952:	b29a      	uxth	r2, r3
  409954:	687b      	ldr	r3, [r7, #4]
  409956:	801a      	strh	r2, [r3, #0]
	return 0;
  409958:	2300      	movs	r3, #0
}
  40995a:	4618      	mov	r0, r3
  40995c:	370c      	adds	r7, #12
  40995e:	46bd      	mov	sp, r7
  409960:	f85d 7b04 	ldr.w	r7, [sp], #4
  409964:	4770      	bx	lr
  409966:	bf00      	nop
  409968:	20002074 	.word	0x20002074

0040996c <inv_icm20948_get_accel_accuracy>:

/** Returns accuracy of accel.
 * @return Accuracy of accel with 0 being not accurate, and 3 being most accurate.
*/
int inv_icm20948_get_accel_accuracy(void)
{
  40996c:	b480      	push	{r7}
  40996e:	af00      	add	r7, sp, #0
	return fd.accel_accuracy;
  409970:	4b03      	ldr	r3, [pc, #12]	; (409980 <inv_icm20948_get_accel_accuracy+0x14>)
  409972:	f9b3 307a 	ldrsh.w	r3, [r3, #122]	; 0x7a
}
  409976:	4618      	mov	r0, r3
  409978:	46bd      	mov	sp, r7
  40997a:	f85d 7b04 	ldr.w	r7, [sp], #4
  40997e:	4770      	bx	lr
  409980:	20002074 	.word	0x20002074

00409984 <inv_icm20948_get_gyro_accuracy>:

/** Returns accuracy of gyro.
 * @return Accuracy of gyro with 0 being not accurate, and 3 being most accurate.
*/
int inv_icm20948_get_gyro_accuracy(void)
{
  409984:	b480      	push	{r7}
  409986:	af00      	add	r7, sp, #0
	return fd.gyro_accuracy;
  409988:	4b03      	ldr	r3, [pc, #12]	; (409998 <inv_icm20948_get_gyro_accuracy+0x14>)
  40998a:	f9b3 307c 	ldrsh.w	r3, [r3, #124]	; 0x7c
}
  40998e:	4618      	mov	r0, r3
  409990:	46bd      	mov	sp, r7
  409992:	f85d 7b04 	ldr.w	r7, [sp], #4
  409996:	4770      	bx	lr
  409998:	20002074 	.word	0x20002074

0040999c <inv_icm20948_get_mag_accuracy>:

/** Returns accuracy of compass.
 * @return Accuracy of compass with 0 being not accurate, and 3 being most accurate.
*/
int inv_icm20948_get_mag_accuracy(void)
{
  40999c:	b480      	push	{r7}
  40999e:	af00      	add	r7, sp, #0
	return fd.cpass_accuracy;
  4099a0:	4b03      	ldr	r3, [pc, #12]	; (4099b0 <inv_icm20948_get_mag_accuracy+0x14>)
  4099a2:	f9b3 307e 	ldrsh.w	r3, [r3, #126]	; 0x7e
}
  4099a6:	4618      	mov	r0, r3
  4099a8:	46bd      	mov	sp, r7
  4099aa:	f85d 7b04 	ldr.w	r7, [sp], #4
  4099ae:	4770      	bx	lr
  4099b0:	20002074 	.word	0x20002074

004099b4 <inv_icm20948_get_gmrv_accuracy>:

/** Returns accuracy of geomagnetic rotation vector.
 * @return Accuracy of GMRV in Q29.
*/
int inv_icm20948_get_gmrv_accuracy(void)
{
  4099b4:	b480      	push	{r7}
  4099b6:	af00      	add	r7, sp, #0
	return fd.dmp_geomag_accuracyQ29;
  4099b8:	4b03      	ldr	r3, [pc, #12]	; (4099c8 <inv_icm20948_get_gmrv_accuracy+0x14>)
  4099ba:	6a9b      	ldr	r3, [r3, #40]	; 0x28
}
  4099bc:	4618      	mov	r0, r3
  4099be:	46bd      	mov	sp, r7
  4099c0:	f85d 7b04 	ldr.w	r7, [sp], #4
  4099c4:	4770      	bx	lr
  4099c6:	bf00      	nop
  4099c8:	20002074 	.word	0x20002074

004099cc <inv_icm20948_get_rv_accuracy>:

/** Returns accuracy of rotation vector.
 * @return Accuracy of RV in Q29.
*/
int inv_icm20948_get_rv_accuracy(void)
{
  4099cc:	b480      	push	{r7}
  4099ce:	af00      	add	r7, sp, #0
	return fd.dmp_rv_accuracyQ29;
  4099d0:	4b03      	ldr	r3, [pc, #12]	; (4099e0 <inv_icm20948_get_rv_accuracy+0x14>)
  4099d2:	699b      	ldr	r3, [r3, #24]
}
  4099d4:	4618      	mov	r0, r3
  4099d6:	46bd      	mov	sp, r7
  4099d8:	f85d 7b04 	ldr.w	r7, [sp], #4
  4099dc:	4770      	bx	lr
  4099de:	bf00      	nop
  4099e0:	20002074 	.word	0x20002074

004099e4 <inv_save_setting>:
	28538, 28823, 29112, 29403, 29697, 29994, 30294, 30597,
	30903, 31212, 31524, 31839, 32157, 32479, 32804
};

static int inv_save_setting(struct inv_icm20948 * s, struct recover_regs * saved_regs)
{
  4099e4:	b590      	push	{r4, r7, lr}
  4099e6:	b085      	sub	sp, #20
  4099e8:	af00      	add	r7, sp, #0
  4099ea:	6078      	str	r0, [r7, #4]
  4099ec:	6039      	str	r1, [r7, #0]
	int result = 0;
  4099ee:	2300      	movs	r3, #0
  4099f0:	60fb      	str	r3, [r7, #12]

	result |= inv_icm20948_read_mems_reg(s, REG_FIFO_CFG, 1, &saved_regs->fifo_cfg);
  4099f2:	683b      	ldr	r3, [r7, #0]
  4099f4:	2201      	movs	r2, #1
  4099f6:	2176      	movs	r1, #118	; 0x76
  4099f8:	6878      	ldr	r0, [r7, #4]
  4099fa:	4c5a      	ldr	r4, [pc, #360]	; (409b64 <inv_save_setting+0x180>)
  4099fc:	47a0      	blx	r4
  4099fe:	4602      	mov	r2, r0
  409a00:	68fb      	ldr	r3, [r7, #12]
  409a02:	4313      	orrs	r3, r2
  409a04:	60fb      	str	r3, [r7, #12]

	result |= inv_icm20948_read_mems_reg(s, REG_USER_CTRL, 1, &saved_regs->user_ctrl);
  409a06:	683b      	ldr	r3, [r7, #0]
  409a08:	3301      	adds	r3, #1
  409a0a:	2201      	movs	r2, #1
  409a0c:	2103      	movs	r1, #3
  409a0e:	6878      	ldr	r0, [r7, #4]
  409a10:	4c54      	ldr	r4, [pc, #336]	; (409b64 <inv_save_setting+0x180>)
  409a12:	47a0      	blx	r4
  409a14:	4602      	mov	r2, r0
  409a16:	68fb      	ldr	r3, [r7, #12]
  409a18:	4313      	orrs	r3, r2
  409a1a:	60fb      	str	r3, [r7, #12]

	result = inv_icm20948_read_mems_reg(s, REG_LP_CONFIG, 1, &saved_regs->lp_config);
  409a1c:	683b      	ldr	r3, [r7, #0]
  409a1e:	3302      	adds	r3, #2
  409a20:	2201      	movs	r2, #1
  409a22:	2105      	movs	r1, #5
  409a24:	6878      	ldr	r0, [r7, #4]
  409a26:	4c4f      	ldr	r4, [pc, #316]	; (409b64 <inv_save_setting+0x180>)
  409a28:	47a0      	blx	r4
  409a2a:	60f8      	str	r0, [r7, #12]

	result |= inv_icm20948_read_mems_reg(s, REG_INT_ENABLE, 1, &saved_regs->int_enable);
  409a2c:	683b      	ldr	r3, [r7, #0]
  409a2e:	3303      	adds	r3, #3
  409a30:	2201      	movs	r2, #1
  409a32:	2110      	movs	r1, #16
  409a34:	6878      	ldr	r0, [r7, #4]
  409a36:	4c4b      	ldr	r4, [pc, #300]	; (409b64 <inv_save_setting+0x180>)
  409a38:	47a0      	blx	r4
  409a3a:	4602      	mov	r2, r0
  409a3c:	68fb      	ldr	r3, [r7, #12]
  409a3e:	4313      	orrs	r3, r2
  409a40:	60fb      	str	r3, [r7, #12]

	result |= inv_icm20948_read_mems_reg(s, REG_INT_ENABLE_1, 1, &saved_regs->int_enable_1);
  409a42:	683b      	ldr	r3, [r7, #0]
  409a44:	3304      	adds	r3, #4
  409a46:	2201      	movs	r2, #1
  409a48:	2111      	movs	r1, #17
  409a4a:	6878      	ldr	r0, [r7, #4]
  409a4c:	4c45      	ldr	r4, [pc, #276]	; (409b64 <inv_save_setting+0x180>)
  409a4e:	47a0      	blx	r4
  409a50:	4602      	mov	r2, r0
  409a52:	68fb      	ldr	r3, [r7, #12]
  409a54:	4313      	orrs	r3, r2
  409a56:	60fb      	str	r3, [r7, #12]

	result |= inv_icm20948_read_mems_reg(s, REG_INT_ENABLE_2, 1, &saved_regs->int_enable_2);
  409a58:	683b      	ldr	r3, [r7, #0]
  409a5a:	3305      	adds	r3, #5
  409a5c:	2201      	movs	r2, #1
  409a5e:	2112      	movs	r1, #18
  409a60:	6878      	ldr	r0, [r7, #4]
  409a62:	4c40      	ldr	r4, [pc, #256]	; (409b64 <inv_save_setting+0x180>)
  409a64:	47a0      	blx	r4
  409a66:	4602      	mov	r2, r0
  409a68:	68fb      	ldr	r3, [r7, #12]
  409a6a:	4313      	orrs	r3, r2
  409a6c:	60fb      	str	r3, [r7, #12]

	result |= inv_icm20948_read_mems_reg(s, REG_FIFO_EN, 1, &saved_regs->fifo_en);
  409a6e:	683b      	ldr	r3, [r7, #0]
  409a70:	3306      	adds	r3, #6
  409a72:	2201      	movs	r2, #1
  409a74:	2166      	movs	r1, #102	; 0x66
  409a76:	6878      	ldr	r0, [r7, #4]
  409a78:	4c3a      	ldr	r4, [pc, #232]	; (409b64 <inv_save_setting+0x180>)
  409a7a:	47a0      	blx	r4
  409a7c:	4602      	mov	r2, r0
  409a7e:	68fb      	ldr	r3, [r7, #12]
  409a80:	4313      	orrs	r3, r2
  409a82:	60fb      	str	r3, [r7, #12]

	result |= inv_icm20948_read_mems_reg(s, REG_FIFO_EN_2, 1, &saved_regs->fifo_en_2);
  409a84:	683b      	ldr	r3, [r7, #0]
  409a86:	3307      	adds	r3, #7
  409a88:	2201      	movs	r2, #1
  409a8a:	2167      	movs	r1, #103	; 0x67
  409a8c:	6878      	ldr	r0, [r7, #4]
  409a8e:	4c35      	ldr	r4, [pc, #212]	; (409b64 <inv_save_setting+0x180>)
  409a90:	47a0      	blx	r4
  409a92:	4602      	mov	r2, r0
  409a94:	68fb      	ldr	r3, [r7, #12]
  409a96:	4313      	orrs	r3, r2
  409a98:	60fb      	str	r3, [r7, #12]

	result |= inv_icm20948_read_mems_reg(s, REG_FIFO_RST, 1, &saved_regs->fifo_rst);
  409a9a:	683b      	ldr	r3, [r7, #0]
  409a9c:	3308      	adds	r3, #8
  409a9e:	2201      	movs	r2, #1
  409aa0:	2168      	movs	r1, #104	; 0x68
  409aa2:	6878      	ldr	r0, [r7, #4]
  409aa4:	4c2f      	ldr	r4, [pc, #188]	; (409b64 <inv_save_setting+0x180>)
  409aa6:	47a0      	blx	r4
  409aa8:	4602      	mov	r2, r0
  409aaa:	68fb      	ldr	r3, [r7, #12]
  409aac:	4313      	orrs	r3, r2
  409aae:	60fb      	str	r3, [r7, #12]

	result |= inv_icm20948_read_mems_reg(s, REG_GYRO_SMPLRT_DIV, 1, &saved_regs->gyro_smplrt_div);
  409ab0:	683b      	ldr	r3, [r7, #0]
  409ab2:	3309      	adds	r3, #9
  409ab4:	2201      	movs	r2, #1
  409ab6:	f44f 7180 	mov.w	r1, #256	; 0x100
  409aba:	6878      	ldr	r0, [r7, #4]
  409abc:	4c29      	ldr	r4, [pc, #164]	; (409b64 <inv_save_setting+0x180>)
  409abe:	47a0      	blx	r4
  409ac0:	4602      	mov	r2, r0
  409ac2:	68fb      	ldr	r3, [r7, #12]
  409ac4:	4313      	orrs	r3, r2
  409ac6:	60fb      	str	r3, [r7, #12]

	result |= inv_icm20948_read_mems_reg(s, REG_GYRO_CONFIG_1, 1, &saved_regs->gyro_config_1);
  409ac8:	683b      	ldr	r3, [r7, #0]
  409aca:	330a      	adds	r3, #10
  409acc:	2201      	movs	r2, #1
  409ace:	f240 1101 	movw	r1, #257	; 0x101
  409ad2:	6878      	ldr	r0, [r7, #4]
  409ad4:	4c23      	ldr	r4, [pc, #140]	; (409b64 <inv_save_setting+0x180>)
  409ad6:	47a0      	blx	r4
  409ad8:	4602      	mov	r2, r0
  409ada:	68fb      	ldr	r3, [r7, #12]
  409adc:	4313      	orrs	r3, r2
  409ade:	60fb      	str	r3, [r7, #12]

	result |= inv_icm20948_read_mems_reg(s, REG_GYRO_CONFIG_2, 1, &saved_regs->gyro_config_2);
  409ae0:	683b      	ldr	r3, [r7, #0]
  409ae2:	330b      	adds	r3, #11
  409ae4:	2201      	movs	r2, #1
  409ae6:	f44f 7181 	mov.w	r1, #258	; 0x102
  409aea:	6878      	ldr	r0, [r7, #4]
  409aec:	4c1d      	ldr	r4, [pc, #116]	; (409b64 <inv_save_setting+0x180>)
  409aee:	47a0      	blx	r4
  409af0:	4602      	mov	r2, r0
  409af2:	68fb      	ldr	r3, [r7, #12]
  409af4:	4313      	orrs	r3, r2
  409af6:	60fb      	str	r3, [r7, #12]

	result |= inv_icm20948_read_mems_reg(s, REG_ACCEL_SMPLRT_DIV_1, 1, &saved_regs->accel_smplrt_div_1);
  409af8:	683b      	ldr	r3, [r7, #0]
  409afa:	330c      	adds	r3, #12
  409afc:	2201      	movs	r2, #1
  409afe:	f44f 7188 	mov.w	r1, #272	; 0x110
  409b02:	6878      	ldr	r0, [r7, #4]
  409b04:	4c17      	ldr	r4, [pc, #92]	; (409b64 <inv_save_setting+0x180>)
  409b06:	47a0      	blx	r4
  409b08:	4602      	mov	r2, r0
  409b0a:	68fb      	ldr	r3, [r7, #12]
  409b0c:	4313      	orrs	r3, r2
  409b0e:	60fb      	str	r3, [r7, #12]

	result |= inv_icm20948_read_mems_reg(s, REG_ACCEL_SMPLRT_DIV_2, 1, &saved_regs->accel_smplrt_div_2);
  409b10:	683b      	ldr	r3, [r7, #0]
  409b12:	330d      	adds	r3, #13
  409b14:	2201      	movs	r2, #1
  409b16:	f240 1111 	movw	r1, #273	; 0x111
  409b1a:	6878      	ldr	r0, [r7, #4]
  409b1c:	4c11      	ldr	r4, [pc, #68]	; (409b64 <inv_save_setting+0x180>)
  409b1e:	47a0      	blx	r4
  409b20:	4602      	mov	r2, r0
  409b22:	68fb      	ldr	r3, [r7, #12]
  409b24:	4313      	orrs	r3, r2
  409b26:	60fb      	str	r3, [r7, #12]

	result |= inv_icm20948_read_mems_reg(s, REG_ACCEL_CONFIG, 1, &saved_regs->accel_config);
  409b28:	683b      	ldr	r3, [r7, #0]
  409b2a:	330e      	adds	r3, #14
  409b2c:	2201      	movs	r2, #1
  409b2e:	f44f 718a 	mov.w	r1, #276	; 0x114
  409b32:	6878      	ldr	r0, [r7, #4]
  409b34:	4c0b      	ldr	r4, [pc, #44]	; (409b64 <inv_save_setting+0x180>)
  409b36:	47a0      	blx	r4
  409b38:	4602      	mov	r2, r0
  409b3a:	68fb      	ldr	r3, [r7, #12]
  409b3c:	4313      	orrs	r3, r2
  409b3e:	60fb      	str	r3, [r7, #12]

	result |= inv_icm20948_read_mems_reg(s, REG_ACCEL_CONFIG_2, 1, &saved_regs->accel_config_2);
  409b40:	683b      	ldr	r3, [r7, #0]
  409b42:	330f      	adds	r3, #15
  409b44:	2201      	movs	r2, #1
  409b46:	f240 1115 	movw	r1, #277	; 0x115
  409b4a:	6878      	ldr	r0, [r7, #4]
  409b4c:	4c05      	ldr	r4, [pc, #20]	; (409b64 <inv_save_setting+0x180>)
  409b4e:	47a0      	blx	r4
  409b50:	4602      	mov	r2, r0
  409b52:	68fb      	ldr	r3, [r7, #12]
  409b54:	4313      	orrs	r3, r2
  409b56:	60fb      	str	r3, [r7, #12]

	return result;
  409b58:	68fb      	ldr	r3, [r7, #12]
}
  409b5a:	4618      	mov	r0, r3
  409b5c:	3714      	adds	r7, #20
  409b5e:	46bd      	mov	sp, r7
  409b60:	bd90      	pop	{r4, r7, pc}
  409b62:	bf00      	nop
  409b64:	0040c755 	.word	0x0040c755

00409b68 <inv_recover_setting>:

static int inv_recover_setting(struct inv_icm20948 * s, const struct recover_regs * saved_regs)
{
  409b68:	b580      	push	{r7, lr}
  409b6a:	b084      	sub	sp, #16
  409b6c:	af00      	add	r7, sp, #0
  409b6e:	6078      	str	r0, [r7, #4]
  409b70:	6039      	str	r1, [r7, #0]
	int result = 0;
  409b72:	2300      	movs	r3, #0
  409b74:	60fb      	str	r3, [r7, #12]

	// Stop sensors
	result |= inv_icm20948_write_single_mems_reg(s, REG_PWR_MGMT_2, 
  409b76:	227f      	movs	r2, #127	; 0x7f
  409b78:	2107      	movs	r1, #7
  409b7a:	6878      	ldr	r0, [r7, #4]
  409b7c:	4b73      	ldr	r3, [pc, #460]	; (409d4c <inv_recover_setting+0x1e4>)
  409b7e:	4798      	blx	r3
  409b80:	4602      	mov	r2, r0
  409b82:	68fb      	ldr	r3, [r7, #12]
  409b84:	4313      	orrs	r3, r2
  409b86:	60fb      	str	r3, [r7, #12]
		BIT_PWR_PRESSURE_STBY | BIT_PWR_ACCEL_STBY | BIT_PWR_GYRO_STBY);

	// Restore sensor configurations
	result |= inv_icm20948_write_single_mems_reg(s, REG_GYRO_SMPLRT_DIV, saved_regs->gyro_smplrt_div);
  409b88:	683b      	ldr	r3, [r7, #0]
  409b8a:	7a5b      	ldrb	r3, [r3, #9]
  409b8c:	461a      	mov	r2, r3
  409b8e:	f44f 7180 	mov.w	r1, #256	; 0x100
  409b92:	6878      	ldr	r0, [r7, #4]
  409b94:	4b6d      	ldr	r3, [pc, #436]	; (409d4c <inv_recover_setting+0x1e4>)
  409b96:	4798      	blx	r3
  409b98:	4602      	mov	r2, r0
  409b9a:	68fb      	ldr	r3, [r7, #12]
  409b9c:	4313      	orrs	r3, r2
  409b9e:	60fb      	str	r3, [r7, #12]

	result |= inv_icm20948_write_single_mems_reg(s, REG_GYRO_CONFIG_1, saved_regs->gyro_config_1);
  409ba0:	683b      	ldr	r3, [r7, #0]
  409ba2:	7a9b      	ldrb	r3, [r3, #10]
  409ba4:	461a      	mov	r2, r3
  409ba6:	f240 1101 	movw	r1, #257	; 0x101
  409baa:	6878      	ldr	r0, [r7, #4]
  409bac:	4b67      	ldr	r3, [pc, #412]	; (409d4c <inv_recover_setting+0x1e4>)
  409bae:	4798      	blx	r3
  409bb0:	4602      	mov	r2, r0
  409bb2:	68fb      	ldr	r3, [r7, #12]
  409bb4:	4313      	orrs	r3, r2
  409bb6:	60fb      	str	r3, [r7, #12]

	result |= inv_icm20948_write_single_mems_reg(s, REG_GYRO_CONFIG_2, saved_regs->gyro_config_2);
  409bb8:	683b      	ldr	r3, [r7, #0]
  409bba:	7adb      	ldrb	r3, [r3, #11]
  409bbc:	461a      	mov	r2, r3
  409bbe:	f44f 7181 	mov.w	r1, #258	; 0x102
  409bc2:	6878      	ldr	r0, [r7, #4]
  409bc4:	4b61      	ldr	r3, [pc, #388]	; (409d4c <inv_recover_setting+0x1e4>)
  409bc6:	4798      	blx	r3
  409bc8:	4602      	mov	r2, r0
  409bca:	68fb      	ldr	r3, [r7, #12]
  409bcc:	4313      	orrs	r3, r2
  409bce:	60fb      	str	r3, [r7, #12]

	result |= inv_icm20948_write_single_mems_reg(s, REG_ACCEL_SMPLRT_DIV_1, saved_regs->accel_smplrt_div_1);
  409bd0:	683b      	ldr	r3, [r7, #0]
  409bd2:	7b1b      	ldrb	r3, [r3, #12]
  409bd4:	461a      	mov	r2, r3
  409bd6:	f44f 7188 	mov.w	r1, #272	; 0x110
  409bda:	6878      	ldr	r0, [r7, #4]
  409bdc:	4b5b      	ldr	r3, [pc, #364]	; (409d4c <inv_recover_setting+0x1e4>)
  409bde:	4798      	blx	r3
  409be0:	4602      	mov	r2, r0
  409be2:	68fb      	ldr	r3, [r7, #12]
  409be4:	4313      	orrs	r3, r2
  409be6:	60fb      	str	r3, [r7, #12]

	result |= inv_icm20948_write_single_mems_reg(s, REG_ACCEL_SMPLRT_DIV_2, saved_regs->accel_smplrt_div_2);
  409be8:	683b      	ldr	r3, [r7, #0]
  409bea:	7b5b      	ldrb	r3, [r3, #13]
  409bec:	461a      	mov	r2, r3
  409bee:	f240 1111 	movw	r1, #273	; 0x111
  409bf2:	6878      	ldr	r0, [r7, #4]
  409bf4:	4b55      	ldr	r3, [pc, #340]	; (409d4c <inv_recover_setting+0x1e4>)
  409bf6:	4798      	blx	r3
  409bf8:	4602      	mov	r2, r0
  409bfa:	68fb      	ldr	r3, [r7, #12]
  409bfc:	4313      	orrs	r3, r2
  409bfe:	60fb      	str	r3, [r7, #12]

	result |= inv_icm20948_write_single_mems_reg(s, REG_ACCEL_CONFIG, saved_regs->accel_config);
  409c00:	683b      	ldr	r3, [r7, #0]
  409c02:	7b9b      	ldrb	r3, [r3, #14]
  409c04:	461a      	mov	r2, r3
  409c06:	f44f 718a 	mov.w	r1, #276	; 0x114
  409c0a:	6878      	ldr	r0, [r7, #4]
  409c0c:	4b4f      	ldr	r3, [pc, #316]	; (409d4c <inv_recover_setting+0x1e4>)
  409c0e:	4798      	blx	r3
  409c10:	4602      	mov	r2, r0
  409c12:	68fb      	ldr	r3, [r7, #12]
  409c14:	4313      	orrs	r3, r2
  409c16:	60fb      	str	r3, [r7, #12]

	result |= inv_icm20948_write_single_mems_reg(s, REG_ACCEL_CONFIG_2, saved_regs->accel_config_2);
  409c18:	683b      	ldr	r3, [r7, #0]
  409c1a:	7bdb      	ldrb	r3, [r3, #15]
  409c1c:	461a      	mov	r2, r3
  409c1e:	f240 1115 	movw	r1, #277	; 0x115
  409c22:	6878      	ldr	r0, [r7, #4]
  409c24:	4b49      	ldr	r3, [pc, #292]	; (409d4c <inv_recover_setting+0x1e4>)
  409c26:	4798      	blx	r3
  409c28:	4602      	mov	r2, r0
  409c2a:	68fb      	ldr	r3, [r7, #12]
  409c2c:	4313      	orrs	r3, r2
  409c2e:	60fb      	str	r3, [r7, #12]

	// Restore FIFO configurations
	result |= inv_icm20948_write_single_mems_reg(s, REG_FIFO_CFG, saved_regs->fifo_cfg);
  409c30:	683b      	ldr	r3, [r7, #0]
  409c32:	781b      	ldrb	r3, [r3, #0]
  409c34:	461a      	mov	r2, r3
  409c36:	2176      	movs	r1, #118	; 0x76
  409c38:	6878      	ldr	r0, [r7, #4]
  409c3a:	4b44      	ldr	r3, [pc, #272]	; (409d4c <inv_recover_setting+0x1e4>)
  409c3c:	4798      	blx	r3
  409c3e:	4602      	mov	r2, r0
  409c40:	68fb      	ldr	r3, [r7, #12]
  409c42:	4313      	orrs	r3, r2
  409c44:	60fb      	str	r3, [r7, #12]

	result |= inv_icm20948_write_single_mems_reg(s, REG_LP_CONFIG, saved_regs->lp_config);
  409c46:	683b      	ldr	r3, [r7, #0]
  409c48:	789b      	ldrb	r3, [r3, #2]
  409c4a:	461a      	mov	r2, r3
  409c4c:	2105      	movs	r1, #5
  409c4e:	6878      	ldr	r0, [r7, #4]
  409c50:	4b3e      	ldr	r3, [pc, #248]	; (409d4c <inv_recover_setting+0x1e4>)
  409c52:	4798      	blx	r3
  409c54:	4602      	mov	r2, r0
  409c56:	68fb      	ldr	r3, [r7, #12]
  409c58:	4313      	orrs	r3, r2
  409c5a:	60fb      	str	r3, [r7, #12]

	result |= inv_icm20948_write_single_mems_reg(s, REG_INT_ENABLE, saved_regs->int_enable);
  409c5c:	683b      	ldr	r3, [r7, #0]
  409c5e:	78db      	ldrb	r3, [r3, #3]
  409c60:	461a      	mov	r2, r3
  409c62:	2110      	movs	r1, #16
  409c64:	6878      	ldr	r0, [r7, #4]
  409c66:	4b39      	ldr	r3, [pc, #228]	; (409d4c <inv_recover_setting+0x1e4>)
  409c68:	4798      	blx	r3
  409c6a:	4602      	mov	r2, r0
  409c6c:	68fb      	ldr	r3, [r7, #12]
  409c6e:	4313      	orrs	r3, r2
  409c70:	60fb      	str	r3, [r7, #12]

	result |= inv_icm20948_write_single_mems_reg(s, REG_INT_ENABLE_1, saved_regs->int_enable_1);
  409c72:	683b      	ldr	r3, [r7, #0]
  409c74:	791b      	ldrb	r3, [r3, #4]
  409c76:	461a      	mov	r2, r3
  409c78:	2111      	movs	r1, #17
  409c7a:	6878      	ldr	r0, [r7, #4]
  409c7c:	4b33      	ldr	r3, [pc, #204]	; (409d4c <inv_recover_setting+0x1e4>)
  409c7e:	4798      	blx	r3
  409c80:	4602      	mov	r2, r0
  409c82:	68fb      	ldr	r3, [r7, #12]
  409c84:	4313      	orrs	r3, r2
  409c86:	60fb      	str	r3, [r7, #12]

	result |= inv_icm20948_write_single_mems_reg(s, REG_FIFO_EN, saved_regs->fifo_en);
  409c88:	683b      	ldr	r3, [r7, #0]
  409c8a:	799b      	ldrb	r3, [r3, #6]
  409c8c:	461a      	mov	r2, r3
  409c8e:	2166      	movs	r1, #102	; 0x66
  409c90:	6878      	ldr	r0, [r7, #4]
  409c92:	4b2e      	ldr	r3, [pc, #184]	; (409d4c <inv_recover_setting+0x1e4>)
  409c94:	4798      	blx	r3
  409c96:	4602      	mov	r2, r0
  409c98:	68fb      	ldr	r3, [r7, #12]
  409c9a:	4313      	orrs	r3, r2
  409c9c:	60fb      	str	r3, [r7, #12]

	result |= inv_icm20948_write_single_mems_reg(s, REG_FIFO_EN_2, saved_regs->fifo_en_2);
  409c9e:	683b      	ldr	r3, [r7, #0]
  409ca0:	79db      	ldrb	r3, [r3, #7]
  409ca2:	461a      	mov	r2, r3
  409ca4:	2167      	movs	r1, #103	; 0x67
  409ca6:	6878      	ldr	r0, [r7, #4]
  409ca8:	4b28      	ldr	r3, [pc, #160]	; (409d4c <inv_recover_setting+0x1e4>)
  409caa:	4798      	blx	r3
  409cac:	4602      	mov	r2, r0
  409cae:	68fb      	ldr	r3, [r7, #12]
  409cb0:	4313      	orrs	r3, r2
  409cb2:	60fb      	str	r3, [r7, #12]

	result |= inv_icm20948_write_single_mems_reg(s, REG_FIFO_RST, MAX_5_BIT_VALUE);
  409cb4:	221f      	movs	r2, #31
  409cb6:	2168      	movs	r1, #104	; 0x68
  409cb8:	6878      	ldr	r0, [r7, #4]
  409cba:	4b24      	ldr	r3, [pc, #144]	; (409d4c <inv_recover_setting+0x1e4>)
  409cbc:	4798      	blx	r3
  409cbe:	4602      	mov	r2, r0
  409cc0:	68fb      	ldr	r3, [r7, #12]
  409cc2:	4313      	orrs	r3, r2
  409cc4:	60fb      	str	r3, [r7, #12]

	result |= inv_icm20948_write_single_mems_reg(s, REG_FIFO_RST, saved_regs->fifo_rst);
  409cc6:	683b      	ldr	r3, [r7, #0]
  409cc8:	7a1b      	ldrb	r3, [r3, #8]
  409cca:	461a      	mov	r2, r3
  409ccc:	2168      	movs	r1, #104	; 0x68
  409cce:	6878      	ldr	r0, [r7, #4]
  409cd0:	4b1e      	ldr	r3, [pc, #120]	; (409d4c <inv_recover_setting+0x1e4>)
  409cd2:	4798      	blx	r3
  409cd4:	4602      	mov	r2, r0
  409cd6:	68fb      	ldr	r3, [r7, #12]
  409cd8:	4313      	orrs	r3, r2
  409cda:	60fb      	str	r3, [r7, #12]

	// Reset DMP
	result |= inv_icm20948_write_single_mems_reg(s, REG_USER_CTRL, 
		(saved_regs->user_ctrl & (~BIT_FIFO_EN)) | BIT_DMP_RST);
  409cdc:	683b      	ldr	r3, [r7, #0]
  409cde:	785b      	ldrb	r3, [r3, #1]
  409ce0:	b25b      	sxtb	r3, r3
  409ce2:	f023 0348 	bic.w	r3, r3, #72	; 0x48
  409ce6:	b25b      	sxtb	r3, r3
  409ce8:	f043 0308 	orr.w	r3, r3, #8
  409cec:	b25b      	sxtb	r3, r3
	result |= inv_icm20948_write_single_mems_reg(s, REG_USER_CTRL, 
  409cee:	b2db      	uxtb	r3, r3
  409cf0:	461a      	mov	r2, r3
  409cf2:	2103      	movs	r1, #3
  409cf4:	6878      	ldr	r0, [r7, #4]
  409cf6:	4b15      	ldr	r3, [pc, #84]	; (409d4c <inv_recover_setting+0x1e4>)
  409cf8:	4798      	blx	r3
  409cfa:	4602      	mov	r2, r0
  409cfc:	68fb      	ldr	r3, [r7, #12]
  409cfe:	4313      	orrs	r3, r2
  409d00:	60fb      	str	r3, [r7, #12]
	inv_icm20948_sleep_us(DMP_RESET_TIME*1000);
  409d02:	f644 6020 	movw	r0, #20000	; 0x4e20
  409d06:	4b12      	ldr	r3, [pc, #72]	; (409d50 <inv_recover_setting+0x1e8>)
  409d08:	4798      	blx	r3

	result |=inv_icm20948_set_dmp_address(s);
  409d0a:	6878      	ldr	r0, [r7, #4]
  409d0c:	4b11      	ldr	r3, [pc, #68]	; (409d54 <inv_recover_setting+0x1ec>)
  409d0e:	4798      	blx	r3
  409d10:	4602      	mov	r2, r0
  409d12:	68fb      	ldr	r3, [r7, #12]
  409d14:	4313      	orrs	r3, r2
  409d16:	60fb      	str	r3, [r7, #12]
	result |=inv_icm20948_set_secondary(s);
  409d18:	6878      	ldr	r0, [r7, #4]
  409d1a:	4b0f      	ldr	r3, [pc, #60]	; (409d58 <inv_recover_setting+0x1f0>)
  409d1c:	4798      	blx	r3
  409d1e:	4602      	mov	r2, r0
  409d20:	68fb      	ldr	r3, [r7, #12]
  409d22:	4313      	orrs	r3, r2
  409d24:	60fb      	str	r3, [r7, #12]
	result |=inv_icm20948_setup_compass_akm(s);
  409d26:	6878      	ldr	r0, [r7, #4]
  409d28:	4b0c      	ldr	r3, [pc, #48]	; (409d5c <inv_recover_setting+0x1f4>)
  409d2a:	4798      	blx	r3
  409d2c:	4602      	mov	r2, r0
  409d2e:	68fb      	ldr	r3, [r7, #12]
  409d30:	4313      	orrs	r3, r2
  409d32:	60fb      	str	r3, [r7, #12]
	result |= inv_icm20948_sleep_mems(s);
  409d34:	6878      	ldr	r0, [r7, #4]
  409d36:	4b0a      	ldr	r3, [pc, #40]	; (409d60 <inv_recover_setting+0x1f8>)
  409d38:	4798      	blx	r3
  409d3a:	4602      	mov	r2, r0
  409d3c:	68fb      	ldr	r3, [r7, #12]
  409d3e:	4313      	orrs	r3, r2
  409d40:	60fb      	str	r3, [r7, #12]
	return result;
  409d42:	68fb      	ldr	r3, [r7, #12]
}
  409d44:	4618      	mov	r0, r3
  409d46:	3710      	adds	r7, #16
  409d48:	46bd      	mov	sp, r7
  409d4a:	bd80      	pop	{r7, pc}
  409d4c:	0040c689 	.word	0x0040c689
  409d50:	004015f9 	.word	0x004015f9
  409d54:	00405a11 	.word	0x00405a11
  409d58:	00405a5d 	.word	0x00405a5d
  409d5c:	004049f5 	.word	0x004049f5
  409d60:	004059d1 	.word	0x004059d1

00409d64 <inv_check_accelgyro_self_test>:
*  @param[in] meanNormalTestValues average value of normal test.
*  @param[in] meanSelfTestValues   average value of self test
*  @return zero as success. A non-zero return value indicates failure in self test.
*/
static int inv_check_accelgyro_self_test(enum INV_SENSORS sensorType, uint8_t * selfTestValuesReadFromReg, int *meanNormalTestValues, int *meanSelfTestValues) 
{
  409d64:	b480      	push	{r7}
  409d66:	b08f      	sub	sp, #60	; 0x3c
  409d68:	af00      	add	r7, sp, #0
  409d6a:	60b9      	str	r1, [r7, #8]
  409d6c:	607a      	str	r2, [r7, #4]
  409d6e:	603b      	str	r3, [r7, #0]
  409d70:	4603      	mov	r3, r0
  409d72:	73fb      	strb	r3, [r7, #15]
	int ret_val;
	int lIsStOtpReadZero = 0;
  409d74:	2300      	movs	r3, #0
  409d76:	633b      	str	r3, [r7, #48]	; 0x30
	int l_st_otp_read[3], lDiffNormalStValues[3], i;

	ret_val = 0;
  409d78:	2300      	movs	r3, #0
  409d7a:	637b      	str	r3, [r7, #52]	; 0x34
	// Calculate factory Self-Test value (ST_OTP) based on the following equation:
	// The factory Self-Test value (ST_OTP) is calculated from the ST_Code (the SELF_TEST values read)
	// using the following equation, where FS is the full scale value code:
	// st_otp = 2620/2^FS * 1.01^(st_value - 1)
	// the result of the equation is in sSelfTestEquation array
	for (i = 0; i < 3; i++) {
  409d7c:	2300      	movs	r3, #0
  409d7e:	62fb      	str	r3, [r7, #44]	; 0x2c
  409d80:	e023      	b.n	409dca <inv_check_accelgyro_self_test+0x66>
		if (selfTestValuesReadFromReg[i] != 0) {
  409d82:	6afb      	ldr	r3, [r7, #44]	; 0x2c
  409d84:	68ba      	ldr	r2, [r7, #8]
  409d86:	4413      	add	r3, r2
  409d88:	781b      	ldrb	r3, [r3, #0]
  409d8a:	2b00      	cmp	r3, #0
  409d8c:	d010      	beq.n	409db0 <inv_check_accelgyro_self_test+0x4c>
			l_st_otp_read[i] = sSelfTestEquation[selfTestValuesReadFromReg[i] - 1];
  409d8e:	6afb      	ldr	r3, [r7, #44]	; 0x2c
  409d90:	68ba      	ldr	r2, [r7, #8]
  409d92:	4413      	add	r3, r2
  409d94:	781b      	ldrb	r3, [r3, #0]
  409d96:	3b01      	subs	r3, #1
  409d98:	4a3a      	ldr	r2, [pc, #232]	; (409e84 <inv_check_accelgyro_self_test+0x120>)
  409d9a:	f832 3013 	ldrh.w	r3, [r2, r3, lsl #1]
  409d9e:	461a      	mov	r2, r3
  409da0:	6afb      	ldr	r3, [r7, #44]	; 0x2c
  409da2:	009b      	lsls	r3, r3, #2
  409da4:	f107 0138 	add.w	r1, r7, #56	; 0x38
  409da8:	440b      	add	r3, r1
  409daa:	f843 2c18 	str.w	r2, [r3, #-24]
  409dae:	e009      	b.n	409dc4 <inv_check_accelgyro_self_test+0x60>
		} else {
			l_st_otp_read[i] = 0;
  409db0:	6afb      	ldr	r3, [r7, #44]	; 0x2c
  409db2:	009b      	lsls	r3, r3, #2
  409db4:	f107 0238 	add.w	r2, r7, #56	; 0x38
  409db8:	4413      	add	r3, r2
  409dba:	2200      	movs	r2, #0
  409dbc:	f843 2c18 	str.w	r2, [r3, #-24]
			lIsStOtpReadZero = 1;
  409dc0:	2301      	movs	r3, #1
  409dc2:	633b      	str	r3, [r7, #48]	; 0x30
	for (i = 0; i < 3; i++) {
  409dc4:	6afb      	ldr	r3, [r7, #44]	; 0x2c
  409dc6:	3301      	adds	r3, #1
  409dc8:	62fb      	str	r3, [r7, #44]	; 0x2c
  409dca:	6afb      	ldr	r3, [r7, #44]	; 0x2c
  409dcc:	2b02      	cmp	r3, #2
  409dce:	ddd8      	ble.n	409d82 <inv_check_accelgyro_self_test+0x1e>
	// - GYST = GY_ST_OS - GY_OS
	// - GZST = GZ_ST_OS - GZ_OS
	// - AXST = AX_ST_OS - AX_OS
	// - AYST = AY_ST_OS - AY_OS
	// - AZST = AZ_ST_OS - AZ_OS
	for (i = 0; i < 3; i++) {
  409dd0:	2300      	movs	r3, #0
  409dd2:	62fb      	str	r3, [r7, #44]	; 0x2c
  409dd4:	e04b      	b.n	409e6e <inv_check_accelgyro_self_test+0x10a>
		lDiffNormalStValues[i] = meanSelfTestValues[i] - meanNormalTestValues[i];
  409dd6:	6afb      	ldr	r3, [r7, #44]	; 0x2c
  409dd8:	009b      	lsls	r3, r3, #2
  409dda:	683a      	ldr	r2, [r7, #0]
  409ddc:	4413      	add	r3, r2
  409dde:	681a      	ldr	r2, [r3, #0]
  409de0:	6afb      	ldr	r3, [r7, #44]	; 0x2c
  409de2:	009b      	lsls	r3, r3, #2
  409de4:	6879      	ldr	r1, [r7, #4]
  409de6:	440b      	add	r3, r1
  409de8:	681b      	ldr	r3, [r3, #0]
  409dea:	1ad2      	subs	r2, r2, r3
  409dec:	6afb      	ldr	r3, [r7, #44]	; 0x2c
  409dee:	009b      	lsls	r3, r3, #2
  409df0:	f107 0138 	add.w	r1, r7, #56	; 0x38
  409df4:	440b      	add	r3, r1
  409df6:	f843 2c24 	str.w	r2, [r3, #-36]

		// Ensure the factory Self-Test values ST_OTP are not 0
		if (!lIsStOtpReadZero) {
  409dfa:	6b3b      	ldr	r3, [r7, #48]	; 0x30
  409dfc:	2b00      	cmp	r3, #0
  409dfe:	d131      	bne.n	409e64 <inv_check_accelgyro_self_test+0x100>
			// Compare the current Self-Test response (GXST, GYST, GZST, AXST, AYST and AZST) to the factory Self-Test values (ST_OTP)
			// and report Self-Test is passing if all the following criteria are fulfilled:
			// (GXST / GXST_OTP)  > 0.5
			if (lDiffNormalStValues[i] < LOWER_BOUND_CHECK(l_st_otp_read[i]) )
  409e00:	6afb      	ldr	r3, [r7, #44]	; 0x2c
  409e02:	009b      	lsls	r3, r3, #2
  409e04:	f107 0238 	add.w	r2, r7, #56	; 0x38
  409e08:	4413      	add	r3, r2
  409e0a:	f853 2c24 	ldr.w	r2, [r3, #-36]
  409e0e:	6afb      	ldr	r3, [r7, #44]	; 0x2c
  409e10:	009b      	lsls	r3, r3, #2
  409e12:	f107 0138 	add.w	r1, r7, #56	; 0x38
  409e16:	440b      	add	r3, r1
  409e18:	f853 3c18 	ldr.w	r3, [r3, #-24]
  409e1c:	105b      	asrs	r3, r3, #1
  409e1e:	429a      	cmp	r2, r3
  409e20:	da01      	bge.n	409e26 <inv_check_accelgyro_self_test+0xc2>
				ret_val = 1;
  409e22:	2301      	movs	r3, #1
  409e24:	637b      	str	r3, [r7, #52]	; 0x34
			if (sensorType != INV_SENSOR_GYRO)
  409e26:	7bfb      	ldrb	r3, [r7, #15]
  409e28:	2b01      	cmp	r3, #1
  409e2a:	d01d      	beq.n	409e68 <inv_check_accelgyro_self_test+0x104>
				// (AXST / AXST_OTP)  < 1.5
				if (lDiffNormalStValues[i] > UPPER_BOUND_CHECK(l_st_otp_read[i]) )
  409e2c:	6afb      	ldr	r3, [r7, #44]	; 0x2c
  409e2e:	009b      	lsls	r3, r3, #2
  409e30:	f107 0238 	add.w	r2, r7, #56	; 0x38
  409e34:	4413      	add	r3, r2
  409e36:	f853 2c24 	ldr.w	r2, [r3, #-36]
  409e3a:	6afb      	ldr	r3, [r7, #44]	; 0x2c
  409e3c:	009b      	lsls	r3, r3, #2
  409e3e:	f107 0138 	add.w	r1, r7, #56	; 0x38
  409e42:	440b      	add	r3, r1
  409e44:	f853 1c18 	ldr.w	r1, [r3, #-24]
  409e48:	6afb      	ldr	r3, [r7, #44]	; 0x2c
  409e4a:	009b      	lsls	r3, r3, #2
  409e4c:	f107 0038 	add.w	r0, r7, #56	; 0x38
  409e50:	4403      	add	r3, r0
  409e52:	f853 3c18 	ldr.w	r3, [r3, #-24]
  409e56:	105b      	asrs	r3, r3, #1
  409e58:	440b      	add	r3, r1
  409e5a:	429a      	cmp	r2, r3
  409e5c:	dd04      	ble.n	409e68 <inv_check_accelgyro_self_test+0x104>
					ret_val = 1;
  409e5e:	2301      	movs	r3, #1
  409e60:	637b      	str	r3, [r7, #52]	; 0x34
  409e62:	e001      	b.n	409e68 <inv_check_accelgyro_self_test+0x104>
		} else
			ret_val = 1;
  409e64:	2301      	movs	r3, #1
  409e66:	637b      	str	r3, [r7, #52]	; 0x34
	for (i = 0; i < 3; i++) {
  409e68:	6afb      	ldr	r3, [r7, #44]	; 0x2c
  409e6a:	3301      	adds	r3, #1
  409e6c:	62fb      	str	r3, [r7, #44]	; 0x2c
  409e6e:	6afb      	ldr	r3, [r7, #44]	; 0x2c
  409e70:	2b02      	cmp	r3, #2
  409e72:	ddb0      	ble.n	409dd6 <inv_check_accelgyro_self_test+0x72>
	}

	return ret_val;
  409e74:	6b7b      	ldr	r3, [r7, #52]	; 0x34
}
  409e76:	4618      	mov	r0, r3
  409e78:	373c      	adds	r7, #60	; 0x3c
  409e7a:	46bd      	mov	sp, r7
  409e7c:	f85d 7b04 	ldr.w	r7, [sp], #4
  409e80:	4770      	bx	lr
  409e82:	bf00      	nop
  409e84:	0041bd10 	.word	0x0041bd10

00409e88 <inv_setup_selftest>:

static int inv_setup_selftest(struct inv_icm20948 * s, struct recover_regs * recover_regs)
{
  409e88:	b590      	push	{r4, r7, lr}
  409e8a:	b085      	sub	sp, #20
  409e8c:	af00      	add	r7, sp, #0
  409e8e:	6078      	str	r0, [r7, #4]
  409e90:	6039      	str	r1, [r7, #0]
	int result = 0;
  409e92:	2300      	movs	r3, #0
  409e94:	60fb      	str	r3, [r7, #12]

	// reset static value
	memset(s->gyro_st_data, 0, sizeof(s->gyro_st_data));
  409e96:	687b      	ldr	r3, [r7, #4]
  409e98:	3392      	adds	r3, #146	; 0x92
  409e9a:	2203      	movs	r2, #3
  409e9c:	2100      	movs	r1, #0
  409e9e:	4618      	mov	r0, r3
  409ea0:	4b6b      	ldr	r3, [pc, #428]	; (40a050 <inv_setup_selftest+0x1c8>)
  409ea2:	4798      	blx	r3
	memset(s->accel_st_data, 0, sizeof(s->accel_st_data));
  409ea4:	687b      	ldr	r3, [r7, #4]
  409ea6:	3395      	adds	r3, #149	; 0x95
  409ea8:	2203      	movs	r2, #3
  409eaa:	2100      	movs	r1, #0
  409eac:	4618      	mov	r0, r3
  409eae:	4b68      	ldr	r3, [pc, #416]	; (40a050 <inv_setup_selftest+0x1c8>)
  409eb0:	4798      	blx	r3

	// Save the current settings
	result |= inv_save_setting(s, recover_regs);
  409eb2:	6839      	ldr	r1, [r7, #0]
  409eb4:	6878      	ldr	r0, [r7, #4]
  409eb6:	4b67      	ldr	r3, [pc, #412]	; (40a054 <inv_setup_selftest+0x1cc>)
  409eb8:	4798      	blx	r3
  409eba:	4602      	mov	r2, r0
  409ebc:	68fb      	ldr	r3, [r7, #12]
  409ebe:	4313      	orrs	r3, r2
  409ec0:	60fb      	str	r3, [r7, #12]

	// Wake up
	result |= inv_icm20948_write_single_mems_reg(s, REG_PWR_MGMT_1, BIT_CLK_PLL);
  409ec2:	2201      	movs	r2, #1
  409ec4:	2106      	movs	r1, #6
  409ec6:	6878      	ldr	r0, [r7, #4]
  409ec8:	4b63      	ldr	r3, [pc, #396]	; (40a058 <inv_setup_selftest+0x1d0>)
  409eca:	4798      	blx	r3
  409ecc:	4602      	mov	r2, r0
  409ece:	68fb      	ldr	r3, [r7, #12]
  409ed0:	4313      	orrs	r3, r2
  409ed2:	60fb      	str	r3, [r7, #12]

	// Stop sensors
	result |= inv_icm20948_write_single_mems_reg(s, REG_PWR_MGMT_2, BIT_PWR_ACCEL_STBY | BIT_PWR_GYRO_STBY);
  409ed4:	223f      	movs	r2, #63	; 0x3f
  409ed6:	2107      	movs	r1, #7
  409ed8:	6878      	ldr	r0, [r7, #4]
  409eda:	4b5f      	ldr	r3, [pc, #380]	; (40a058 <inv_setup_selftest+0x1d0>)
  409edc:	4798      	blx	r3
  409ede:	4602      	mov	r2, r0
  409ee0:	68fb      	ldr	r3, [r7, #12]
  409ee2:	4313      	orrs	r3, r2
  409ee4:	60fb      	str	r3, [r7, #12]

	/*   Perform a soft-reset of the chip by setting the MSB of PWR_MGMT_1 register
	* This will clear any prior states in the chip
	*/
	result |= inv_icm20948_write_single_mems_reg(s, REG_PWR_MGMT_1, BIT_H_RESET);               
  409ee6:	2280      	movs	r2, #128	; 0x80
  409ee8:	2106      	movs	r1, #6
  409eea:	6878      	ldr	r0, [r7, #4]
  409eec:	4b5a      	ldr	r3, [pc, #360]	; (40a058 <inv_setup_selftest+0x1d0>)
  409eee:	4798      	blx	r3
  409ef0:	4602      	mov	r2, r0
  409ef2:	68fb      	ldr	r3, [r7, #12]
  409ef4:	4313      	orrs	r3, r2
  409ef6:	60fb      	str	r3, [r7, #12]
	inv_icm20948_sleep_us(100000); //100ms delay after soft reset--yd
  409ef8:	4858      	ldr	r0, [pc, #352]	; (40a05c <inv_setup_selftest+0x1d4>)
  409efa:	4b59      	ldr	r3, [pc, #356]	; (40a060 <inv_setup_selftest+0x1d8>)
  409efc:	4798      	blx	r3

	// Wake up
	result |= inv_icm20948_write_single_mems_reg(s, REG_PWR_MGMT_1, BIT_CLK_PLL);
  409efe:	2201      	movs	r2, #1
  409f00:	2106      	movs	r1, #6
  409f02:	6878      	ldr	r0, [r7, #4]
  409f04:	4b54      	ldr	r3, [pc, #336]	; (40a058 <inv_setup_selftest+0x1d0>)
  409f06:	4798      	blx	r3
  409f08:	4602      	mov	r2, r0
  409f0a:	68fb      	ldr	r3, [r7, #12]
  409f0c:	4313      	orrs	r3, r2
  409f0e:	60fb      	str	r3, [r7, #12]
	if (result)
  409f10:	68fb      	ldr	r3, [r7, #12]
  409f12:	2b00      	cmp	r3, #0
  409f14:	d001      	beq.n	409f1a <inv_setup_selftest+0x92>
		return result;
  409f16:	68fb      	ldr	r3, [r7, #12]
  409f18:	e095      	b.n	40a046 <inv_setup_selftest+0x1be>

	// Set cycle mode
	result |= inv_icm20948_write_single_mems_reg(s, REG_LP_CONFIG, 
  409f1a:	2270      	movs	r2, #112	; 0x70
  409f1c:	2105      	movs	r1, #5
  409f1e:	6878      	ldr	r0, [r7, #4]
  409f20:	4b4d      	ldr	r3, [pc, #308]	; (40a058 <inv_setup_selftest+0x1d0>)
  409f22:	4798      	blx	r3
  409f24:	4602      	mov	r2, r0
  409f26:	68fb      	ldr	r3, [r7, #12]
  409f28:	4313      	orrs	r3, r2
  409f2a:	60fb      	str	r3, [r7, #12]
		BIT_I2C_MST_CYCLE | BIT_ACCEL_CYCLE | BIT_GYRO_CYCLE);

	// Configure FSR and DLPF for gyro
	result |= inv_icm20948_write_single_mems_reg(s, REG_GYRO_SMPLRT_DIV, SELFTEST_GYRO_SMPLRT_DIV);
  409f2c:	220a      	movs	r2, #10
  409f2e:	f44f 7180 	mov.w	r1, #256	; 0x100
  409f32:	6878      	ldr	r0, [r7, #4]
  409f34:	4b48      	ldr	r3, [pc, #288]	; (40a058 <inv_setup_selftest+0x1d0>)
  409f36:	4798      	blx	r3
  409f38:	4602      	mov	r2, r0
  409f3a:	68fb      	ldr	r3, [r7, #12]
  409f3c:	4313      	orrs	r3, r2
  409f3e:	60fb      	str	r3, [r7, #12]

	result |= inv_icm20948_write_single_mems_reg(s, REG_GYRO_CONFIG_1, SELFTEST_GYRO_FS);
  409f40:	2201      	movs	r2, #1
  409f42:	f240 1101 	movw	r1, #257	; 0x101
  409f46:	6878      	ldr	r0, [r7, #4]
  409f48:	4b43      	ldr	r3, [pc, #268]	; (40a058 <inv_setup_selftest+0x1d0>)
  409f4a:	4798      	blx	r3
  409f4c:	4602      	mov	r2, r0
  409f4e:	68fb      	ldr	r3, [r7, #12]
  409f50:	4313      	orrs	r3, r2
  409f52:	60fb      	str	r3, [r7, #12]

	result |= inv_icm20948_write_single_mems_reg(s, REG_GYRO_CONFIG_2, SELFTEST_GYRO_AVGCFG);
  409f54:	2203      	movs	r2, #3
  409f56:	f44f 7181 	mov.w	r1, #258	; 0x102
  409f5a:	6878      	ldr	r0, [r7, #4]
  409f5c:	4b3e      	ldr	r3, [pc, #248]	; (40a058 <inv_setup_selftest+0x1d0>)
  409f5e:	4798      	blx	r3
  409f60:	4602      	mov	r2, r0
  409f62:	68fb      	ldr	r3, [r7, #12]
  409f64:	4313      	orrs	r3, r2
  409f66:	60fb      	str	r3, [r7, #12]

	// Configure FSR and DLPF for accel
	result |= inv_icm20948_write_single_mems_reg(s, REG_ACCEL_SMPLRT_DIV_1, 0);
  409f68:	2200      	movs	r2, #0
  409f6a:	f44f 7188 	mov.w	r1, #272	; 0x110
  409f6e:	6878      	ldr	r0, [r7, #4]
  409f70:	4b39      	ldr	r3, [pc, #228]	; (40a058 <inv_setup_selftest+0x1d0>)
  409f72:	4798      	blx	r3
  409f74:	4602      	mov	r2, r0
  409f76:	68fb      	ldr	r3, [r7, #12]
  409f78:	4313      	orrs	r3, r2
  409f7a:	60fb      	str	r3, [r7, #12]

	result |= inv_icm20948_write_single_mems_reg(s, REG_ACCEL_SMPLRT_DIV_2, SELFTEST_ACCEL_SMPLRT_DIV);
  409f7c:	220a      	movs	r2, #10
  409f7e:	f240 1111 	movw	r1, #273	; 0x111
  409f82:	6878      	ldr	r0, [r7, #4]
  409f84:	4b34      	ldr	r3, [pc, #208]	; (40a058 <inv_setup_selftest+0x1d0>)
  409f86:	4798      	blx	r3
  409f88:	4602      	mov	r2, r0
  409f8a:	68fb      	ldr	r3, [r7, #12]
  409f8c:	4313      	orrs	r3, r2
  409f8e:	60fb      	str	r3, [r7, #12]

	result |= inv_icm20948_write_single_mems_reg(s, REG_ACCEL_CONFIG, SELFTEST_ACCEL_FS);
  409f90:	2239      	movs	r2, #57	; 0x39
  409f92:	f44f 718a 	mov.w	r1, #276	; 0x114
  409f96:	6878      	ldr	r0, [r7, #4]
  409f98:	4b2f      	ldr	r3, [pc, #188]	; (40a058 <inv_setup_selftest+0x1d0>)
  409f9a:	4798      	blx	r3
  409f9c:	4602      	mov	r2, r0
  409f9e:	68fb      	ldr	r3, [r7, #12]
  409fa0:	4313      	orrs	r3, r2
  409fa2:	60fb      	str	r3, [r7, #12]

	result |= inv_icm20948_write_single_mems_reg(s, REG_ACCEL_CONFIG_2, SELFTEST_ACCEL_DEC3_CFG);
  409fa4:	2202      	movs	r2, #2
  409fa6:	f240 1115 	movw	r1, #277	; 0x115
  409faa:	6878      	ldr	r0, [r7, #4]
  409fac:	4b2a      	ldr	r3, [pc, #168]	; (40a058 <inv_setup_selftest+0x1d0>)
  409fae:	4798      	blx	r3
  409fb0:	4602      	mov	r2, r0
  409fb2:	68fb      	ldr	r3, [r7, #12]
  409fb4:	4313      	orrs	r3, r2
  409fb6:	60fb      	str	r3, [r7, #12]

	// Read selftest values
	// Retrieve factory Self-Test code (ST_Code) from SELF_TEST registers  (User Bank 1): 
	result |= inv_icm20948_read_mems_reg(s, REG_SELF_TEST1, 1, &s->gyro_st_data[0]);
  409fb8:	687b      	ldr	r3, [r7, #4]
  409fba:	3392      	adds	r3, #146	; 0x92
  409fbc:	2201      	movs	r2, #1
  409fbe:	2182      	movs	r1, #130	; 0x82
  409fc0:	6878      	ldr	r0, [r7, #4]
  409fc2:	4c28      	ldr	r4, [pc, #160]	; (40a064 <inv_setup_selftest+0x1dc>)
  409fc4:	47a0      	blx	r4
  409fc6:	4602      	mov	r2, r0
  409fc8:	68fb      	ldr	r3, [r7, #12]
  409fca:	4313      	orrs	r3, r2
  409fcc:	60fb      	str	r3, [r7, #12]

	result |= inv_icm20948_read_mems_reg(s, REG_SELF_TEST2, 1, &s->gyro_st_data[1]);
  409fce:	687b      	ldr	r3, [r7, #4]
  409fd0:	3393      	adds	r3, #147	; 0x93
  409fd2:	2201      	movs	r2, #1
  409fd4:	2183      	movs	r1, #131	; 0x83
  409fd6:	6878      	ldr	r0, [r7, #4]
  409fd8:	4c22      	ldr	r4, [pc, #136]	; (40a064 <inv_setup_selftest+0x1dc>)
  409fda:	47a0      	blx	r4
  409fdc:	4602      	mov	r2, r0
  409fde:	68fb      	ldr	r3, [r7, #12]
  409fe0:	4313      	orrs	r3, r2
  409fe2:	60fb      	str	r3, [r7, #12]

	result |= inv_icm20948_read_mems_reg(s, REG_SELF_TEST3, 1, &s->gyro_st_data[2]);
  409fe4:	687b      	ldr	r3, [r7, #4]
  409fe6:	3394      	adds	r3, #148	; 0x94
  409fe8:	2201      	movs	r2, #1
  409fea:	2184      	movs	r1, #132	; 0x84
  409fec:	6878      	ldr	r0, [r7, #4]
  409fee:	4c1d      	ldr	r4, [pc, #116]	; (40a064 <inv_setup_selftest+0x1dc>)
  409ff0:	47a0      	blx	r4
  409ff2:	4602      	mov	r2, r0
  409ff4:	68fb      	ldr	r3, [r7, #12]
  409ff6:	4313      	orrs	r3, r2
  409ff8:	60fb      	str	r3, [r7, #12]

	result |= inv_icm20948_read_mems_reg(s, REG_SELF_TEST4, 1, &s->accel_st_data[0]);
  409ffa:	687b      	ldr	r3, [r7, #4]
  409ffc:	3395      	adds	r3, #149	; 0x95
  409ffe:	2201      	movs	r2, #1
  40a000:	218e      	movs	r1, #142	; 0x8e
  40a002:	6878      	ldr	r0, [r7, #4]
  40a004:	4c17      	ldr	r4, [pc, #92]	; (40a064 <inv_setup_selftest+0x1dc>)
  40a006:	47a0      	blx	r4
  40a008:	4602      	mov	r2, r0
  40a00a:	68fb      	ldr	r3, [r7, #12]
  40a00c:	4313      	orrs	r3, r2
  40a00e:	60fb      	str	r3, [r7, #12]

	result |= inv_icm20948_read_mems_reg(s, REG_SELF_TEST5, 1, &s->accel_st_data[1]);
  40a010:	687b      	ldr	r3, [r7, #4]
  40a012:	3396      	adds	r3, #150	; 0x96
  40a014:	2201      	movs	r2, #1
  40a016:	218f      	movs	r1, #143	; 0x8f
  40a018:	6878      	ldr	r0, [r7, #4]
  40a01a:	4c12      	ldr	r4, [pc, #72]	; (40a064 <inv_setup_selftest+0x1dc>)
  40a01c:	47a0      	blx	r4
  40a01e:	4602      	mov	r2, r0
  40a020:	68fb      	ldr	r3, [r7, #12]
  40a022:	4313      	orrs	r3, r2
  40a024:	60fb      	str	r3, [r7, #12]

	result |= inv_icm20948_read_mems_reg(s, REG_SELF_TEST6, 1, &s->accel_st_data[2]);
  40a026:	687b      	ldr	r3, [r7, #4]
  40a028:	3397      	adds	r3, #151	; 0x97
  40a02a:	2201      	movs	r2, #1
  40a02c:	2190      	movs	r1, #144	; 0x90
  40a02e:	6878      	ldr	r0, [r7, #4]
  40a030:	4c0c      	ldr	r4, [pc, #48]	; (40a064 <inv_setup_selftest+0x1dc>)
  40a032:	47a0      	blx	r4
  40a034:	4602      	mov	r2, r0
  40a036:	68fb      	ldr	r3, [r7, #12]
  40a038:	4313      	orrs	r3, r2
  40a03a:	60fb      	str	r3, [r7, #12]

	// Restart sensors
	inv_icm20948_sleep_us(GYRO_ENGINE_UP_TIME*1000);
  40a03c:	f24c 3050 	movw	r0, #50000	; 0xc350
  40a040:	4b07      	ldr	r3, [pc, #28]	; (40a060 <inv_setup_selftest+0x1d8>)
  40a042:	4798      	blx	r3

	return result;
  40a044:	68fb      	ldr	r3, [r7, #12]
}
  40a046:	4618      	mov	r0, r3
  40a048:	3714      	adds	r7, #20
  40a04a:	46bd      	mov	sp, r7
  40a04c:	bd90      	pop	{r4, r7, pc}
  40a04e:	bf00      	nop
  40a050:	00414241 	.word	0x00414241
  40a054:	004099e5 	.word	0x004099e5
  40a058:	0040c689 	.word	0x0040c689
  40a05c:	000186a0 	.word	0x000186a0
  40a060:	004015f9 	.word	0x004015f9
  40a064:	0040c755 	.word	0x0040c755

0040a068 <inv_selftest_read_samples>:

static int inv_selftest_read_samples(struct inv_icm20948 * self, enum INV_SENSORS type, int *sum_result, int *s)
{
  40a068:	b590      	push	{r4, r7, lr}
  40a06a:	b08b      	sub	sp, #44	; 0x2c
  40a06c:	af00      	add	r7, sp, #0
  40a06e:	60f8      	str	r0, [r7, #12]
  40a070:	607a      	str	r2, [r7, #4]
  40a072:	603b      	str	r3, [r7, #0]
  40a074:	460b      	mov	r3, r1
  40a076:	72fb      	strb	r3, [r7, #11]
	// - GZ_OS = Average (GYRO_ZOUT_H | GYRO_ZOUT_L)
	// - AX_OS = Average (ACCEL_XOUT_H | ACCEL_XOUT_L)
	// - AY_OS = Average (ACCEL_YOUT_H | ACCEL_YOUT_L)
	// - AZ_OS = Average (ACCEL_ZOUT_H | ACCEL_ZOUT_L)

	if (INV_SENSOR_GYRO == type)
  40a078:	7afb      	ldrb	r3, [r7, #11]
  40a07a:	2b01      	cmp	r3, #1
  40a07c:	d103      	bne.n	40a086 <inv_selftest_read_samples+0x1e>
		w = REG_GYRO_XOUT_H_SH;
  40a07e:	2333      	movs	r3, #51	; 0x33
  40a080:	f887 3027 	strb.w	r3, [r7, #39]	; 0x27
  40a084:	e051      	b.n	40a12a <inv_selftest_read_samples+0xc2>
	else
		w = REG_ACCEL_XOUT_H_SH;
  40a086:	232d      	movs	r3, #45	; 0x2d
  40a088:	f887 3027 	strb.w	r3, [r7, #39]	; 0x27

	while (*s < DEF_ST_SAMPLES) {
  40a08c:	e04d      	b.n	40a12a <inv_selftest_read_samples+0xc2>

		if(inv_icm20948_read_mems_reg(self, w, BYTES_PER_SENSOR, d))
  40a08e:	f897 3027 	ldrb.w	r3, [r7, #39]	; 0x27
  40a092:	b299      	uxth	r1, r3
  40a094:	f107 0310 	add.w	r3, r7, #16
  40a098:	2206      	movs	r2, #6
  40a09a:	68f8      	ldr	r0, [r7, #12]
  40a09c:	4c27      	ldr	r4, [pc, #156]	; (40a13c <inv_selftest_read_samples+0xd4>)
  40a09e:	47a0      	blx	r4
  40a0a0:	4603      	mov	r3, r0
  40a0a2:	2b00      	cmp	r3, #0
  40a0a4:	d002      	beq.n	40a0ac <inv_selftest_read_samples+0x44>
			return -1;
  40a0a6:	f04f 33ff 	mov.w	r3, #4294967295
  40a0aa:	e043      	b.n	40a134 <inv_selftest_read_samples+0xcc>

		for (j = 0; j < THREE_AXES; j++) {
  40a0ac:	2300      	movs	r3, #0
  40a0ae:	623b      	str	r3, [r7, #32]
  40a0b0:	e02f      	b.n	40a112 <inv_selftest_read_samples+0xaa>
			vals[j] = (d[(2*j)]<<8) | (d[(2*j)+ 1] & 0xff);
  40a0b2:	6a3b      	ldr	r3, [r7, #32]
  40a0b4:	005b      	lsls	r3, r3, #1
  40a0b6:	f107 0228 	add.w	r2, r7, #40	; 0x28
  40a0ba:	4413      	add	r3, r2
  40a0bc:	f813 3c18 	ldrb.w	r3, [r3, #-24]
  40a0c0:	021b      	lsls	r3, r3, #8
  40a0c2:	b21a      	sxth	r2, r3
  40a0c4:	6a3b      	ldr	r3, [r7, #32]
  40a0c6:	005b      	lsls	r3, r3, #1
  40a0c8:	3301      	adds	r3, #1
  40a0ca:	f107 0128 	add.w	r1, r7, #40	; 0x28
  40a0ce:	440b      	add	r3, r1
  40a0d0:	f813 3c18 	ldrb.w	r3, [r3, #-24]
  40a0d4:	b21b      	sxth	r3, r3
  40a0d6:	4313      	orrs	r3, r2
  40a0d8:	b21a      	sxth	r2, r3
  40a0da:	6a3b      	ldr	r3, [r7, #32]
  40a0dc:	005b      	lsls	r3, r3, #1
  40a0de:	f107 0128 	add.w	r1, r7, #40	; 0x28
  40a0e2:	440b      	add	r3, r1
  40a0e4:	f823 2c10 	strh.w	r2, [r3, #-16]
			sum_result[j] += vals[j];
  40a0e8:	6a3b      	ldr	r3, [r7, #32]
  40a0ea:	009b      	lsls	r3, r3, #2
  40a0ec:	687a      	ldr	r2, [r7, #4]
  40a0ee:	441a      	add	r2, r3
  40a0f0:	6a3b      	ldr	r3, [r7, #32]
  40a0f2:	009b      	lsls	r3, r3, #2
  40a0f4:	6879      	ldr	r1, [r7, #4]
  40a0f6:	440b      	add	r3, r1
  40a0f8:	6819      	ldr	r1, [r3, #0]
  40a0fa:	6a3b      	ldr	r3, [r7, #32]
  40a0fc:	005b      	lsls	r3, r3, #1
  40a0fe:	f107 0028 	add.w	r0, r7, #40	; 0x28
  40a102:	4403      	add	r3, r0
  40a104:	f933 3c10 	ldrsh.w	r3, [r3, #-16]
  40a108:	440b      	add	r3, r1
  40a10a:	6013      	str	r3, [r2, #0]
		for (j = 0; j < THREE_AXES; j++) {
  40a10c:	6a3b      	ldr	r3, [r7, #32]
  40a10e:	3301      	adds	r3, #1
  40a110:	623b      	str	r3, [r7, #32]
  40a112:	6a3b      	ldr	r3, [r7, #32]
  40a114:	2b02      	cmp	r3, #2
  40a116:	ddcc      	ble.n	40a0b2 <inv_selftest_read_samples+0x4a>
		}

		(*s)++;
  40a118:	683b      	ldr	r3, [r7, #0]
  40a11a:	681b      	ldr	r3, [r3, #0]
  40a11c:	1c5a      	adds	r2, r3, #1
  40a11e:	683b      	ldr	r3, [r7, #0]
  40a120:	601a      	str	r2, [r3, #0]

		inv_icm20948_sleep_us(WAIT_TIME_BTW_2_SAMPLESREAD*1000);
  40a122:	f242 7010 	movw	r0, #10000	; 0x2710
  40a126:	4b06      	ldr	r3, [pc, #24]	; (40a140 <inv_selftest_read_samples+0xd8>)
  40a128:	4798      	blx	r3
	while (*s < DEF_ST_SAMPLES) {
  40a12a:	683b      	ldr	r3, [r7, #0]
  40a12c:	681b      	ldr	r3, [r3, #0]
  40a12e:	2bc7      	cmp	r3, #199	; 0xc7
  40a130:	ddad      	ble.n	40a08e <inv_selftest_read_samples+0x26>
	}
	return 0;
  40a132:	2300      	movs	r3, #0
}
  40a134:	4618      	mov	r0, r3
  40a136:	372c      	adds	r7, #44	; 0x2c
  40a138:	46bd      	mov	sp, r7
  40a13a:	bd90      	pop	{r4, r7, pc}
  40a13c:	0040c755 	.word	0x0040c755
  40a140:	004015f9 	.word	0x004015f9

0040a144 <inv_do_test_accelgyro>:

/*
*  inv_do_test_accelgyro() - do the actual test of self testing
*/
static int inv_do_test_accelgyro(struct inv_icm20948 * s, enum INV_SENSORS sensorType, int *meanValue, int *stMeanValue)
{
  40a144:	b590      	push	{r4, r7, lr}
  40a146:	b089      	sub	sp, #36	; 0x24
  40a148:	af00      	add	r7, sp, #0
  40a14a:	60f8      	str	r0, [r7, #12]
  40a14c:	607a      	str	r2, [r7, #4]
  40a14e:	603b      	str	r3, [r7, #0]
  40a150:	460b      	mov	r3, r1
  40a152:	72fb      	strb	r3, [r7, #11]
	int result, i, j;
	int lNbSamples = 0;
  40a154:	2300      	movs	r3, #0
  40a156:	613b      	str	r3, [r7, #16]

	// initialize output to be 0
	for (i = 0; i < THREE_AXES; i++) {
  40a158:	2300      	movs	r3, #0
  40a15a:	61bb      	str	r3, [r7, #24]
  40a15c:	e00e      	b.n	40a17c <inv_do_test_accelgyro+0x38>
		meanValue[i] = 0;
  40a15e:	69bb      	ldr	r3, [r7, #24]
  40a160:	009b      	lsls	r3, r3, #2
  40a162:	687a      	ldr	r2, [r7, #4]
  40a164:	4413      	add	r3, r2
  40a166:	2200      	movs	r2, #0
  40a168:	601a      	str	r2, [r3, #0]
		stMeanValue[i] = 0;
  40a16a:	69bb      	ldr	r3, [r7, #24]
  40a16c:	009b      	lsls	r3, r3, #2
  40a16e:	683a      	ldr	r2, [r7, #0]
  40a170:	4413      	add	r3, r2
  40a172:	2200      	movs	r2, #0
  40a174:	601a      	str	r2, [r3, #0]
	for (i = 0; i < THREE_AXES; i++) {
  40a176:	69bb      	ldr	r3, [r7, #24]
  40a178:	3301      	adds	r3, #1
  40a17a:	61bb      	str	r3, [r7, #24]
  40a17c:	69bb      	ldr	r3, [r7, #24]
  40a17e:	2b02      	cmp	r3, #2
  40a180:	dded      	ble.n	40a15e <inv_do_test_accelgyro+0x1a>
	}

	// read the accel/gyro output
	// the output values are 16 bits wide and in 2s complement
	// Average 200 readings and save the averaged values
	result = inv_selftest_read_samples(s, sensorType, meanValue, &lNbSamples);
  40a182:	f107 0310 	add.w	r3, r7, #16
  40a186:	7af9      	ldrb	r1, [r7, #11]
  40a188:	687a      	ldr	r2, [r7, #4]
  40a18a:	68f8      	ldr	r0, [r7, #12]
  40a18c:	4c31      	ldr	r4, [pc, #196]	; (40a254 <inv_do_test_accelgyro+0x110>)
  40a18e:	47a0      	blx	r4
  40a190:	61f8      	str	r0, [r7, #28]
	if (result)
  40a192:	69fb      	ldr	r3, [r7, #28]
  40a194:	2b00      	cmp	r3, #0
  40a196:	d001      	beq.n	40a19c <inv_do_test_accelgyro+0x58>
		return result;
  40a198:	69fb      	ldr	r3, [r7, #28]
  40a19a:	e056      	b.n	40a24a <inv_do_test_accelgyro+0x106>
	for (j = 0; j < THREE_AXES; j++) {
  40a19c:	2300      	movs	r3, #0
  40a19e:	617b      	str	r3, [r7, #20]
  40a1a0:	e00f      	b.n	40a1c2 <inv_do_test_accelgyro+0x7e>
		meanValue[j] /= lNbSamples;
  40a1a2:	697b      	ldr	r3, [r7, #20]
  40a1a4:	009b      	lsls	r3, r3, #2
  40a1a6:	687a      	ldr	r2, [r7, #4]
  40a1a8:	4413      	add	r3, r2
  40a1aa:	697a      	ldr	r2, [r7, #20]
  40a1ac:	0092      	lsls	r2, r2, #2
  40a1ae:	6879      	ldr	r1, [r7, #4]
  40a1b0:	440a      	add	r2, r1
  40a1b2:	6811      	ldr	r1, [r2, #0]
  40a1b4:	693a      	ldr	r2, [r7, #16]
  40a1b6:	fb91 f2f2 	sdiv	r2, r1, r2
  40a1ba:	601a      	str	r2, [r3, #0]
	for (j = 0; j < THREE_AXES; j++) {
  40a1bc:	697b      	ldr	r3, [r7, #20]
  40a1be:	3301      	adds	r3, #1
  40a1c0:	617b      	str	r3, [r7, #20]
  40a1c2:	697b      	ldr	r3, [r7, #20]
  40a1c4:	2b02      	cmp	r3, #2
  40a1c6:	ddec      	ble.n	40a1a2 <inv_do_test_accelgyro+0x5e>
	}

	// Set Self-Test Bit
	if (sensorType == INV_SENSOR_GYRO)
  40a1c8:	7afb      	ldrb	r3, [r7, #11]
  40a1ca:	2b01      	cmp	r3, #1
  40a1cc:	d107      	bne.n	40a1de <inv_do_test_accelgyro+0x9a>
	{
		// Enable gyroscope Self-Test by setting register User Bank 2, Register Address 02 (02h) Bit [5:3] to b111
		result = inv_icm20948_write_single_mems_reg(s, REG_GYRO_CONFIG_2, BIT_GYRO_CTEN | SELFTEST_GYRO_AVGCFG);
  40a1ce:	223b      	movs	r2, #59	; 0x3b
  40a1d0:	f44f 7181 	mov.w	r1, #258	; 0x102
  40a1d4:	68f8      	ldr	r0, [r7, #12]
  40a1d6:	4b20      	ldr	r3, [pc, #128]	; (40a258 <inv_do_test_accelgyro+0x114>)
  40a1d8:	4798      	blx	r3
  40a1da:	61f8      	str	r0, [r7, #28]
  40a1dc:	e006      	b.n	40a1ec <inv_do_test_accelgyro+0xa8>
	} else
	{
		result = inv_icm20948_write_single_mems_reg(s, REG_ACCEL_CONFIG_2, BIT_ACCEL_CTEN | SELFTEST_ACCEL_DEC3_CFG);
  40a1de:	221e      	movs	r2, #30
  40a1e0:	f240 1115 	movw	r1, #277	; 0x115
  40a1e4:	68f8      	ldr	r0, [r7, #12]
  40a1e6:	4b1c      	ldr	r3, [pc, #112]	; (40a258 <inv_do_test_accelgyro+0x114>)
  40a1e8:	4798      	blx	r3
  40a1ea:	61f8      	str	r0, [r7, #28]
	}
	if (result)
  40a1ec:	69fb      	ldr	r3, [r7, #28]
  40a1ee:	2b00      	cmp	r3, #0
  40a1f0:	d001      	beq.n	40a1f6 <inv_do_test_accelgyro+0xb2>
		return result;
  40a1f2:	69fb      	ldr	r3, [r7, #28]
  40a1f4:	e029      	b.n	40a24a <inv_do_test_accelgyro+0x106>

	// Wait 20ms for oscillations to stabilize. 
	inv_icm20948_sleep_us(DEF_ST_STABLE_TIME*1000);
  40a1f6:	f644 6020 	movw	r0, #20000	; 0x4e20
  40a1fa:	4b18      	ldr	r3, [pc, #96]	; (40a25c <inv_do_test_accelgyro+0x118>)
  40a1fc:	4798      	blx	r3

	// Read the accel/gyro output and average 200 readings
	// These readings are in units of LSBs
	lNbSamples = 0; 
  40a1fe:	2300      	movs	r3, #0
  40a200:	613b      	str	r3, [r7, #16]
	result = inv_selftest_read_samples(s, sensorType, stMeanValue, &lNbSamples);
  40a202:	f107 0310 	add.w	r3, r7, #16
  40a206:	7af9      	ldrb	r1, [r7, #11]
  40a208:	683a      	ldr	r2, [r7, #0]
  40a20a:	68f8      	ldr	r0, [r7, #12]
  40a20c:	4c11      	ldr	r4, [pc, #68]	; (40a254 <inv_do_test_accelgyro+0x110>)
  40a20e:	47a0      	blx	r4
  40a210:	61f8      	str	r0, [r7, #28]
	if (result)
  40a212:	69fb      	ldr	r3, [r7, #28]
  40a214:	2b00      	cmp	r3, #0
  40a216:	d001      	beq.n	40a21c <inv_do_test_accelgyro+0xd8>
		return result;
  40a218:	69fb      	ldr	r3, [r7, #28]
  40a21a:	e016      	b.n	40a24a <inv_do_test_accelgyro+0x106>
	for (j = 0; j < THREE_AXES; j++) {
  40a21c:	2300      	movs	r3, #0
  40a21e:	617b      	str	r3, [r7, #20]
  40a220:	e00f      	b.n	40a242 <inv_do_test_accelgyro+0xfe>
		stMeanValue[j] /= lNbSamples;
  40a222:	697b      	ldr	r3, [r7, #20]
  40a224:	009b      	lsls	r3, r3, #2
  40a226:	683a      	ldr	r2, [r7, #0]
  40a228:	4413      	add	r3, r2
  40a22a:	697a      	ldr	r2, [r7, #20]
  40a22c:	0092      	lsls	r2, r2, #2
  40a22e:	6839      	ldr	r1, [r7, #0]
  40a230:	440a      	add	r2, r1
  40a232:	6811      	ldr	r1, [r2, #0]
  40a234:	693a      	ldr	r2, [r7, #16]
  40a236:	fb91 f2f2 	sdiv	r2, r1, r2
  40a23a:	601a      	str	r2, [r3, #0]
	for (j = 0; j < THREE_AXES; j++) {
  40a23c:	697b      	ldr	r3, [r7, #20]
  40a23e:	3301      	adds	r3, #1
  40a240:	617b      	str	r3, [r7, #20]
  40a242:	697b      	ldr	r3, [r7, #20]
  40a244:	2b02      	cmp	r3, #2
  40a246:	ddec      	ble.n	40a222 <inv_do_test_accelgyro+0xde>
	}

	return 0;
  40a248:	2300      	movs	r3, #0
}
  40a24a:	4618      	mov	r0, r3
  40a24c:	3724      	adds	r7, #36	; 0x24
  40a24e:	46bd      	mov	sp, r7
  40a250:	bd90      	pop	{r4, r7, pc}
  40a252:	bf00      	nop
  40a254:	0040a069 	.word	0x0040a069
  40a258:	0040c689 	.word	0x0040c689
  40a25c:	004015f9 	.word	0x004015f9

0040a260 <inv_icm20948_run_selftest>:

int inv_icm20948_run_selftest(struct inv_icm20948 * s, int gyro_bias_regular[], int accel_bias_regular[])
{
  40a260:	b590      	push	{r4, r7, lr}
  40a262:	b093      	sub	sp, #76	; 0x4c
  40a264:	af00      	add	r7, sp, #0
  40a266:	60f8      	str	r0, [r7, #12]
  40a268:	60b9      	str	r1, [r7, #8]
  40a26a:	607a      	str	r2, [r7, #4]
	int accel_bias_st[THREE_AXES];
	int test_times;
	char accel_result, gyro_result, compass_result;
	struct recover_regs recover_regs;

	accel_result = 0;
  40a26c:	2300      	movs	r3, #0
  40a26e:	f887 303f 	strb.w	r3, [r7, #63]	; 0x3f
	gyro_result = 0;
  40a272:	2300      	movs	r3, #0
  40a274:	f887 303e 	strb.w	r3, [r7, #62]	; 0x3e
	compass_result = 0;
  40a278:	2300      	movs	r3, #0
  40a27a:	f887 303d 	strb.w	r3, [r7, #61]	; 0x3d

	// save original state of the chip, initialize registers, configure sensors and read ST values
	result = inv_setup_selftest(s, &recover_regs);
  40a27e:	f107 0314 	add.w	r3, r7, #20
  40a282:	4619      	mov	r1, r3
  40a284:	68f8      	ldr	r0, [r7, #12]
  40a286:	4b3f      	ldr	r3, [pc, #252]	; (40a384 <inv_icm20948_run_selftest+0x124>)
  40a288:	4798      	blx	r3
  40a28a:	6478      	str	r0, [r7, #68]	; 0x44
	if (result)
  40a28c:	6c7b      	ldr	r3, [r7, #68]	; 0x44
  40a28e:	2b00      	cmp	r3, #0
  40a290:	d15f      	bne.n	40a352 <inv_icm20948_run_selftest+0xf2>
		goto test_fail;    
	// perform self test for gyro
	test_times = DEF_ST_TRY_TIMES;	
  40a292:	2302      	movs	r3, #2
  40a294:	643b      	str	r3, [r7, #64]	; 0x40
	while (test_times > 0) {
  40a296:	e00d      	b.n	40a2b4 <inv_icm20948_run_selftest+0x54>
		result = inv_do_test_accelgyro(s, INV_SENSOR_GYRO, gyro_bias_regular, gyro_bias_st);
  40a298:	f107 0330 	add.w	r3, r7, #48	; 0x30
  40a29c:	68ba      	ldr	r2, [r7, #8]
  40a29e:	2101      	movs	r1, #1
  40a2a0:	68f8      	ldr	r0, [r7, #12]
  40a2a2:	4c39      	ldr	r4, [pc, #228]	; (40a388 <inv_icm20948_run_selftest+0x128>)
  40a2a4:	47a0      	blx	r4
  40a2a6:	6478      	str	r0, [r7, #68]	; 0x44
		if (result)
  40a2a8:	6c7b      	ldr	r3, [r7, #68]	; 0x44
  40a2aa:	2b00      	cmp	r3, #0
  40a2ac:	d006      	beq.n	40a2bc <inv_icm20948_run_selftest+0x5c>
			test_times--;
  40a2ae:	6c3b      	ldr	r3, [r7, #64]	; 0x40
  40a2b0:	3b01      	subs	r3, #1
  40a2b2:	643b      	str	r3, [r7, #64]	; 0x40
	while (test_times > 0) {
  40a2b4:	6c3b      	ldr	r3, [r7, #64]	; 0x40
  40a2b6:	2b00      	cmp	r3, #0
  40a2b8:	dcee      	bgt.n	40a298 <inv_icm20948_run_selftest+0x38>
  40a2ba:	e000      	b.n	40a2be <inv_icm20948_run_selftest+0x5e>
		else
			break;
  40a2bc:	bf00      	nop
	}
	if (result)
  40a2be:	6c7b      	ldr	r3, [r7, #68]	; 0x44
  40a2c0:	2b00      	cmp	r3, #0
  40a2c2:	d148      	bne.n	40a356 <inv_icm20948_run_selftest+0xf6>
		goto test_fail;    

	// perform self test for accel
	test_times = DEF_ST_TRY_TIMES;
  40a2c4:	2302      	movs	r3, #2
  40a2c6:	643b      	str	r3, [r7, #64]	; 0x40
	while (test_times > 0) {
  40a2c8:	e00d      	b.n	40a2e6 <inv_icm20948_run_selftest+0x86>
		result = inv_do_test_accelgyro(s, INV_SENSOR_ACCEL, accel_bias_regular, accel_bias_st);
  40a2ca:	f107 0324 	add.w	r3, r7, #36	; 0x24
  40a2ce:	687a      	ldr	r2, [r7, #4]
  40a2d0:	2100      	movs	r1, #0
  40a2d2:	68f8      	ldr	r0, [r7, #12]
  40a2d4:	4c2c      	ldr	r4, [pc, #176]	; (40a388 <inv_icm20948_run_selftest+0x128>)
  40a2d6:	47a0      	blx	r4
  40a2d8:	6478      	str	r0, [r7, #68]	; 0x44
		if (result)
  40a2da:	6c7b      	ldr	r3, [r7, #68]	; 0x44
  40a2dc:	2b00      	cmp	r3, #0
  40a2de:	d006      	beq.n	40a2ee <inv_icm20948_run_selftest+0x8e>
			test_times--;
  40a2e0:	6c3b      	ldr	r3, [r7, #64]	; 0x40
  40a2e2:	3b01      	subs	r3, #1
  40a2e4:	643b      	str	r3, [r7, #64]	; 0x40
	while (test_times > 0) {
  40a2e6:	6c3b      	ldr	r3, [r7, #64]	; 0x40
  40a2e8:	2b00      	cmp	r3, #0
  40a2ea:	dcee      	bgt.n	40a2ca <inv_icm20948_run_selftest+0x6a>
  40a2ec:	e000      	b.n	40a2f0 <inv_icm20948_run_selftest+0x90>
		else
			break;
  40a2ee:	bf00      	nop
	}
	if (result)
  40a2f0:	6c7b      	ldr	r3, [r7, #68]	; 0x44
  40a2f2:	2b00      	cmp	r3, #0
  40a2f4:	d131      	bne.n	40a35a <inv_icm20948_run_selftest+0xfa>
		goto test_fail;

	// check values read at various steps
	accel_result = !inv_check_accelgyro_self_test(INV_SENSOR_ACCEL, s->accel_st_data, accel_bias_regular, accel_bias_st);
  40a2f6:	68fb      	ldr	r3, [r7, #12]
  40a2f8:	f103 0195 	add.w	r1, r3, #149	; 0x95
  40a2fc:	f107 0324 	add.w	r3, r7, #36	; 0x24
  40a300:	687a      	ldr	r2, [r7, #4]
  40a302:	2000      	movs	r0, #0
  40a304:	4c21      	ldr	r4, [pc, #132]	; (40a38c <inv_icm20948_run_selftest+0x12c>)
  40a306:	47a0      	blx	r4
  40a308:	4603      	mov	r3, r0
  40a30a:	2b00      	cmp	r3, #0
  40a30c:	bf0c      	ite	eq
  40a30e:	2301      	moveq	r3, #1
  40a310:	2300      	movne	r3, #0
  40a312:	b2db      	uxtb	r3, r3
  40a314:	f887 303f 	strb.w	r3, [r7, #63]	; 0x3f
	gyro_result = !inv_check_accelgyro_self_test(INV_SENSOR_GYRO, s->gyro_st_data, gyro_bias_regular, gyro_bias_st);
  40a318:	68fb      	ldr	r3, [r7, #12]
  40a31a:	f103 0192 	add.w	r1, r3, #146	; 0x92
  40a31e:	f107 0330 	add.w	r3, r7, #48	; 0x30
  40a322:	68ba      	ldr	r2, [r7, #8]
  40a324:	2001      	movs	r0, #1
  40a326:	4c19      	ldr	r4, [pc, #100]	; (40a38c <inv_icm20948_run_selftest+0x12c>)
  40a328:	47a0      	blx	r4
  40a32a:	4603      	mov	r3, r0
  40a32c:	2b00      	cmp	r3, #0
  40a32e:	bf0c      	ite	eq
  40a330:	2301      	moveq	r3, #1
  40a332:	2300      	movne	r3, #0
  40a334:	b2db      	uxtb	r3, r3
  40a336:	f887 303e 	strb.w	r3, [r7, #62]	; 0x3e
	compass_result = !inv_icm20948_check_akm_self_test(s);
  40a33a:	68f8      	ldr	r0, [r7, #12]
  40a33c:	4b14      	ldr	r3, [pc, #80]	; (40a390 <inv_icm20948_run_selftest+0x130>)
  40a33e:	4798      	blx	r3
  40a340:	4603      	mov	r3, r0
  40a342:	2b00      	cmp	r3, #0
  40a344:	bf0c      	ite	eq
  40a346:	2301      	moveq	r3, #1
  40a348:	2300      	movne	r3, #0
  40a34a:	b2db      	uxtb	r3, r3
  40a34c:	f887 303d 	strb.w	r3, [r7, #61]	; 0x3d
  40a350:	e004      	b.n	40a35c <inv_icm20948_run_selftest+0xfc>
		goto test_fail;    
  40a352:	bf00      	nop
  40a354:	e002      	b.n	40a35c <inv_icm20948_run_selftest+0xfc>
		goto test_fail;    
  40a356:	bf00      	nop
  40a358:	e000      	b.n	40a35c <inv_icm20948_run_selftest+0xfc>
		goto test_fail;
  40a35a:	bf00      	nop

test_fail:
	// restore original state of the chips
	inv_recover_setting(s, &recover_regs);
  40a35c:	f107 0314 	add.w	r3, r7, #20
  40a360:	4619      	mov	r1, r3
  40a362:	68f8      	ldr	r0, [r7, #12]
  40a364:	4b0b      	ldr	r3, [pc, #44]	; (40a394 <inv_icm20948_run_selftest+0x134>)
  40a366:	4798      	blx	r3

	return (compass_result << 2) |
  40a368:	f997 303d 	ldrsb.w	r3, [r7, #61]	; 0x3d
  40a36c:	009a      	lsls	r2, r3, #2
		(accel_result   << 1) |
  40a36e:	f997 303f 	ldrsb.w	r3, [r7, #63]	; 0x3f
  40a372:	005b      	lsls	r3, r3, #1
	return (compass_result << 2) |
  40a374:	431a      	orrs	r2, r3
		(accel_result   << 1) |
  40a376:	f997 303e 	ldrsb.w	r3, [r7, #62]	; 0x3e
  40a37a:	4313      	orrs	r3, r2
		gyro_result;
}
  40a37c:	4618      	mov	r0, r3
  40a37e:	374c      	adds	r7, #76	; 0x4c
  40a380:	46bd      	mov	sp, r7
  40a382:	bd90      	pop	{r4, r7, pc}
  40a384:	00409e89 	.word	0x00409e89
  40a388:	0040a145 	.word	0x0040a145
  40a38c:	00409d65 	.word	0x00409d65
  40a390:	00404af1 	.word	0x00404af1
  40a394:	00409b69 	.word	0x00409b69

0040a398 <inv_icm20948_set_offset>:

void inv_icm20948_set_offset(struct inv_icm20948 * s, int raw_bias[])
{
  40a398:	b590      	push	{r4, r7, lr}
  40a39a:	b089      	sub	sp, #36	; 0x24
  40a39c:	af00      	add	r7, sp, #0
  40a39e:	6078      	str	r0, [r7, #4]
  40a3a0:	6039      	str	r1, [r7, #0]
#define ACCEL_OFFSET	3
	int16_t		offset[3];
	int16_t		delta_offset, old_offset, new_offset;
	uint8_t		data;
	int			ii;
	uint16_t	reg_addr = REG_XG_OFFS_USRH;
  40a3a2:	f240 1303 	movw	r3, #259	; 0x103
  40a3a6:	837b      	strh	r3, [r7, #26]
	
	// Set Gyro offset
	for (ii = 0; ii < 3; ii++) {
  40a3a8:	2300      	movs	r3, #0
  40a3aa:	61fb      	str	r3, [r7, #28]
  40a3ac:	e038      	b.n	40a420 <inv_icm20948_set_offset+0x88>
		offset[ii] = -1 * (raw_bias[ii] >> 2);	// Change to 2's complement and convert from 250dps to 1000dps (>>2)
  40a3ae:	69fb      	ldr	r3, [r7, #28]
  40a3b0:	009b      	lsls	r3, r3, #2
  40a3b2:	683a      	ldr	r2, [r7, #0]
  40a3b4:	4413      	add	r3, r2
  40a3b6:	681b      	ldr	r3, [r3, #0]
  40a3b8:	109b      	asrs	r3, r3, #2
  40a3ba:	b29b      	uxth	r3, r3
  40a3bc:	425b      	negs	r3, r3
  40a3be:	b29b      	uxth	r3, r3
  40a3c0:	b21a      	sxth	r2, r3
  40a3c2:	69fb      	ldr	r3, [r7, #28]
  40a3c4:	005b      	lsls	r3, r3, #1
  40a3c6:	f107 0120 	add.w	r1, r7, #32
  40a3ca:	440b      	add	r3, r1
  40a3cc:	f823 2c14 	strh.w	r2, [r3, #-20]
		data = (offset[ii] & 0xFF00) >> 8;		// Get the high order byte
  40a3d0:	69fb      	ldr	r3, [r7, #28]
  40a3d2:	005b      	lsls	r3, r3, #1
  40a3d4:	f107 0220 	add.w	r2, r7, #32
  40a3d8:	4413      	add	r3, r2
  40a3da:	f933 3c14 	ldrsh.w	r3, [r3, #-20]
  40a3de:	121b      	asrs	r3, r3, #8
  40a3e0:	b2db      	uxtb	r3, r3
  40a3e2:	72fb      	strb	r3, [r7, #11]
		inv_icm20948_write_mems_reg(s, reg_addr++, 1, &data);
  40a3e4:	8b79      	ldrh	r1, [r7, #26]
  40a3e6:	1c4b      	adds	r3, r1, #1
  40a3e8:	837b      	strh	r3, [r7, #26]
  40a3ea:	f107 030b 	add.w	r3, r7, #11
  40a3ee:	2201      	movs	r2, #1
  40a3f0:	6878      	ldr	r0, [r7, #4]
  40a3f2:	4c37      	ldr	r4, [pc, #220]	; (40a4d0 <inv_icm20948_set_offset+0x138>)
  40a3f4:	47a0      	blx	r4
		data = offset[ii] & 0x00FF;				// get the low order byte
  40a3f6:	69fb      	ldr	r3, [r7, #28]
  40a3f8:	005b      	lsls	r3, r3, #1
  40a3fa:	f107 0220 	add.w	r2, r7, #32
  40a3fe:	4413      	add	r3, r2
  40a400:	f933 3c14 	ldrsh.w	r3, [r3, #-20]
  40a404:	b2db      	uxtb	r3, r3
  40a406:	72fb      	strb	r3, [r7, #11]
		inv_icm20948_write_mems_reg(s, reg_addr++, 1, &data);
  40a408:	8b79      	ldrh	r1, [r7, #26]
  40a40a:	1c4b      	adds	r3, r1, #1
  40a40c:	837b      	strh	r3, [r7, #26]
  40a40e:	f107 030b 	add.w	r3, r7, #11
  40a412:	2201      	movs	r2, #1
  40a414:	6878      	ldr	r0, [r7, #4]
  40a416:	4c2e      	ldr	r4, [pc, #184]	; (40a4d0 <inv_icm20948_set_offset+0x138>)
  40a418:	47a0      	blx	r4
	for (ii = 0; ii < 3; ii++) {
  40a41a:	69fb      	ldr	r3, [r7, #28]
  40a41c:	3301      	adds	r3, #1
  40a41e:	61fb      	str	r3, [r7, #28]
  40a420:	69fb      	ldr	r3, [r7, #28]
  40a422:	2b02      	cmp	r3, #2
  40a424:	ddc3      	ble.n	40a3ae <inv_icm20948_set_offset+0x16>
	}

	// Set Accel offset
	reg_addr = REG_XA_OFFS_H;
  40a426:	2394      	movs	r3, #148	; 0x94
  40a428:	837b      	strh	r3, [r7, #26]
	for (ii = 0; ii < 3; ii++) {
  40a42a:	2300      	movs	r3, #0
  40a42c:	61fb      	str	r3, [r7, #28]
  40a42e:	e048      	b.n	40a4c2 <inv_icm20948_set_offset+0x12a>
		inv_icm20948_read_mems_reg(s, reg_addr, 1, &data);			// Get current offset value (16 bits in two registers)
  40a430:	f107 030b 	add.w	r3, r7, #11
  40a434:	8b79      	ldrh	r1, [r7, #26]
  40a436:	2201      	movs	r2, #1
  40a438:	6878      	ldr	r0, [r7, #4]
  40a43a:	4c26      	ldr	r4, [pc, #152]	; (40a4d4 <inv_icm20948_set_offset+0x13c>)
  40a43c:	47a0      	blx	r4
		old_offset = data << 8;
  40a43e:	7afb      	ldrb	r3, [r7, #11]
  40a440:	021b      	lsls	r3, r3, #8
  40a442:	833b      	strh	r3, [r7, #24]
		inv_icm20948_read_mems_reg(s, reg_addr + 1, 1, &data);
  40a444:	8b7b      	ldrh	r3, [r7, #26]
  40a446:	3301      	adds	r3, #1
  40a448:	b299      	uxth	r1, r3
  40a44a:	f107 030b 	add.w	r3, r7, #11
  40a44e:	2201      	movs	r2, #1
  40a450:	6878      	ldr	r0, [r7, #4]
  40a452:	4c20      	ldr	r4, [pc, #128]	; (40a4d4 <inv_icm20948_set_offset+0x13c>)
  40a454:	47a0      	blx	r4
		old_offset += data;
  40a456:	7afb      	ldrb	r3, [r7, #11]
  40a458:	b29a      	uxth	r2, r3
  40a45a:	8b3b      	ldrh	r3, [r7, #24]
  40a45c:	4413      	add	r3, r2
  40a45e:	b29b      	uxth	r3, r3
  40a460:	833b      	strh	r3, [r7, #24]
		delta_offset = raw_bias[ACCEL_OFFSET + ii] >> 3;			// Convert from 2gto 16g (>>3)
  40a462:	69fb      	ldr	r3, [r7, #28]
  40a464:	3303      	adds	r3, #3
  40a466:	009b      	lsls	r3, r3, #2
  40a468:	683a      	ldr	r2, [r7, #0]
  40a46a:	4413      	add	r3, r2
  40a46c:	681b      	ldr	r3, [r3, #0]
  40a46e:	10db      	asrs	r3, r3, #3
  40a470:	82fb      	strh	r3, [r7, #22]
		new_offset = old_offset - delta_offset;						// Store the delta of old value and self-test result
  40a472:	8b3a      	ldrh	r2, [r7, #24]
  40a474:	8afb      	ldrh	r3, [r7, #22]
  40a476:	1ad3      	subs	r3, r2, r3
  40a478:	b29b      	uxth	r3, r3
  40a47a:	82bb      	strh	r3, [r7, #20]
		data = (new_offset & 0xFF00) >> 8;							// Take high order byte
  40a47c:	f9b7 3014 	ldrsh.w	r3, [r7, #20]
  40a480:	121b      	asrs	r3, r3, #8
  40a482:	b2db      	uxtb	r3, r3
  40a484:	72fb      	strb	r3, [r7, #11]
		inv_icm20948_write_mems_reg(s, reg_addr++, 1, &data);
  40a486:	8b79      	ldrh	r1, [r7, #26]
  40a488:	1c4b      	adds	r3, r1, #1
  40a48a:	837b      	strh	r3, [r7, #26]
  40a48c:	f107 030b 	add.w	r3, r7, #11
  40a490:	2201      	movs	r2, #1
  40a492:	6878      	ldr	r0, [r7, #4]
  40a494:	4c0e      	ldr	r4, [pc, #56]	; (40a4d0 <inv_icm20948_set_offset+0x138>)
  40a496:	47a0      	blx	r4
		data = new_offset & 0x00FE;									// Only take the high order 7 bits
  40a498:	8abb      	ldrh	r3, [r7, #20]
  40a49a:	b2db      	uxtb	r3, r3
  40a49c:	f023 0301 	bic.w	r3, r3, #1
  40a4a0:	b2db      	uxtb	r3, r3
  40a4a2:	72fb      	strb	r3, [r7, #11]
		inv_icm20948_write_mems_reg(s, reg_addr++, 1, &data);
  40a4a4:	8b79      	ldrh	r1, [r7, #26]
  40a4a6:	1c4b      	adds	r3, r1, #1
  40a4a8:	837b      	strh	r3, [r7, #26]
  40a4aa:	f107 030b 	add.w	r3, r7, #11
  40a4ae:	2201      	movs	r2, #1
  40a4b0:	6878      	ldr	r0, [r7, #4]
  40a4b2:	4c07      	ldr	r4, [pc, #28]	; (40a4d0 <inv_icm20948_set_offset+0x138>)
  40a4b4:	47a0      	blx	r4
		reg_addr++;													// Skip over unused register
  40a4b6:	8b7b      	ldrh	r3, [r7, #26]
  40a4b8:	3301      	adds	r3, #1
  40a4ba:	837b      	strh	r3, [r7, #26]
	for (ii = 0; ii < 3; ii++) {
  40a4bc:	69fb      	ldr	r3, [r7, #28]
  40a4be:	3301      	adds	r3, #1
  40a4c0:	61fb      	str	r3, [r7, #28]
  40a4c2:	69fb      	ldr	r3, [r7, #28]
  40a4c4:	2b02      	cmp	r3, #2
  40a4c6:	ddb3      	ble.n	40a430 <inv_icm20948_set_offset+0x98>
	}
}
  40a4c8:	bf00      	nop
  40a4ca:	3724      	adds	r7, #36	; 0x24
  40a4cc:	46bd      	mov	sp, r7
  40a4ce:	bd90      	pop	{r4, r7, pc}
  40a4d0:	0040c581 	.word	0x0040c581
  40a4d4:	0040c755 	.word	0x0040c755

0040a4d8 <inv_icm20948_read_reg_one>:
{
	return inv_icm20948_write_reg(s, reg, &reg_value, 1);
}

static inline int inv_icm20948_read_reg_one(struct inv_icm20948 * s, uint8_t reg, uint8_t * reg_value)
{
  40a4d8:	b590      	push	{r4, r7, lr}
  40a4da:	b085      	sub	sp, #20
  40a4dc:	af00      	add	r7, sp, #0
  40a4de:	60f8      	str	r0, [r7, #12]
  40a4e0:	460b      	mov	r3, r1
  40a4e2:	607a      	str	r2, [r7, #4]
  40a4e4:	72fb      	strb	r3, [r7, #11]
	return inv_icm20948_read_reg(s, reg, reg_value, 1);
  40a4e6:	7af9      	ldrb	r1, [r7, #11]
  40a4e8:	2301      	movs	r3, #1
  40a4ea:	687a      	ldr	r2, [r7, #4]
  40a4ec:	68f8      	ldr	r0, [r7, #12]
  40a4ee:	4c03      	ldr	r4, [pc, #12]	; (40a4fc <inv_icm20948_read_reg_one+0x24>)
  40a4f0:	47a0      	blx	r4
  40a4f2:	4603      	mov	r3, r0
}
  40a4f4:	4618      	mov	r0, r3
  40a4f6:	3714      	adds	r7, #20
  40a4f8:	46bd      	mov	sp, r7
  40a4fa:	bd90      	pop	{r4, r7, pc}
  40a4fc:	0040c3f5 	.word	0x0040c3f5

0040a500 <sensor_type_2_android_sensor>:
/** @brief Conversion from DMP units to float format for compass scale */
#define DMP_UNIT_TO_FLOAT_COMPASS_CONVERSION      (1/(float)(1UL<<16))
//! Convert the \a value from QN value to float. \ingroup invn_macro
#define INVN_FXP_TO_FLT(value, shift)	( (float)  (int32_t)(value) / (float)(1ULL << (shift)) )
static uint8_t sensor_type_2_android_sensor(enum inv_icm20948_sensor sensor)
{
  40a500:	b480      	push	{r7}
  40a502:	b083      	sub	sp, #12
  40a504:	af00      	add	r7, sp, #0
  40a506:	4603      	mov	r3, r0
  40a508:	71fb      	strb	r3, [r7, #7]
	switch(sensor) {
  40a50a:	79fb      	ldrb	r3, [r7, #7]
  40a50c:	2b13      	cmp	r3, #19
  40a50e:	d853      	bhi.n	40a5b8 <sensor_type_2_android_sensor+0xb8>
  40a510:	a201      	add	r2, pc, #4	; (adr r2, 40a518 <sensor_type_2_android_sensor+0x18>)
  40a512:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
  40a516:	bf00      	nop
  40a518:	0040a569 	.word	0x0040a569
  40a51c:	0040a56d 	.word	0x0040a56d
  40a520:	0040a571 	.word	0x0040a571
  40a524:	0040a575 	.word	0x0040a575
  40a528:	0040a579 	.word	0x0040a579
  40a52c:	0040a57d 	.word	0x0040a57d
  40a530:	0040a581 	.word	0x0040a581
  40a534:	0040a585 	.word	0x0040a585
  40a538:	0040a589 	.word	0x0040a589
  40a53c:	0040a58d 	.word	0x0040a58d
  40a540:	0040a591 	.word	0x0040a591
  40a544:	0040a595 	.word	0x0040a595
  40a548:	0040a599 	.word	0x0040a599
  40a54c:	0040a59d 	.word	0x0040a59d
  40a550:	0040a5a1 	.word	0x0040a5a1
  40a554:	0040a5a5 	.word	0x0040a5a5
  40a558:	0040a5a9 	.word	0x0040a5a9
  40a55c:	0040a5ad 	.word	0x0040a5ad
  40a560:	0040a5b1 	.word	0x0040a5b1
  40a564:	0040a5b5 	.word	0x0040a5b5
	case INV_ICM20948_SENSOR_ACCELEROMETER:                 return ANDROID_SENSOR_ACCELEROMETER;
  40a568:	2301      	movs	r3, #1
  40a56a:	e026      	b.n	40a5ba <sensor_type_2_android_sensor+0xba>
	case INV_ICM20948_SENSOR_GYROSCOPE:                     return ANDROID_SENSOR_GYROSCOPE;
  40a56c:	2304      	movs	r3, #4
  40a56e:	e024      	b.n	40a5ba <sensor_type_2_android_sensor+0xba>
	case INV_ICM20948_SENSOR_RAW_ACCELEROMETER:             return ANDROID_SENSOR_RAW_ACCELEROMETER;
  40a570:	232a      	movs	r3, #42	; 0x2a
  40a572:	e022      	b.n	40a5ba <sensor_type_2_android_sensor+0xba>
	case INV_ICM20948_SENSOR_RAW_GYROSCOPE:                 return ANDROID_SENSOR_RAW_GYROSCOPE;
  40a574:	232b      	movs	r3, #43	; 0x2b
  40a576:	e020      	b.n	40a5ba <sensor_type_2_android_sensor+0xba>
	case INV_ICM20948_SENSOR_MAGNETIC_FIELD_UNCALIBRATED:   return ANDROID_SENSOR_MAGNETIC_FIELD_UNCALIBRATED;
  40a578:	230e      	movs	r3, #14
  40a57a:	e01e      	b.n	40a5ba <sensor_type_2_android_sensor+0xba>
	case INV_ICM20948_SENSOR_GYROSCOPE_UNCALIBRATED:        return ANDROID_SENSOR_GYROSCOPE_UNCALIBRATED;
  40a57c:	2310      	movs	r3, #16
  40a57e:	e01c      	b.n	40a5ba <sensor_type_2_android_sensor+0xba>
	case INV_ICM20948_SENSOR_ACTIVITY_CLASSIFICATON:        return ANDROID_SENSOR_ACTIVITY_CLASSIFICATON;
  40a580:	232f      	movs	r3, #47	; 0x2f
  40a582:	e01a      	b.n	40a5ba <sensor_type_2_android_sensor+0xba>
	case INV_ICM20948_SENSOR_STEP_DETECTOR:                 return ANDROID_SENSOR_STEP_DETECTOR;
  40a584:	2312      	movs	r3, #18
  40a586:	e018      	b.n	40a5ba <sensor_type_2_android_sensor+0xba>
	case INV_ICM20948_SENSOR_STEP_COUNTER:                  return ANDROID_SENSOR_STEP_COUNTER;
  40a588:	2313      	movs	r3, #19
  40a58a:	e016      	b.n	40a5ba <sensor_type_2_android_sensor+0xba>
	case INV_ICM20948_SENSOR_GAME_ROTATION_VECTOR:          return ANDROID_SENSOR_GAME_ROTATION_VECTOR;
  40a58c:	230f      	movs	r3, #15
  40a58e:	e014      	b.n	40a5ba <sensor_type_2_android_sensor+0xba>
	case INV_ICM20948_SENSOR_ROTATION_VECTOR:               return ANDROID_SENSOR_ROTATION_VECTOR;
  40a590:	230b      	movs	r3, #11
  40a592:	e012      	b.n	40a5ba <sensor_type_2_android_sensor+0xba>
	case INV_ICM20948_SENSOR_GEOMAGNETIC_ROTATION_VECTOR:   return ANDROID_SENSOR_GEOMAGNETIC_ROTATION_VECTOR;
  40a594:	2314      	movs	r3, #20
  40a596:	e010      	b.n	40a5ba <sensor_type_2_android_sensor+0xba>
	case INV_ICM20948_SENSOR_GEOMAGNETIC_FIELD:             return ANDROID_SENSOR_GEOMAGNETIC_FIELD;
  40a598:	2302      	movs	r3, #2
  40a59a:	e00e      	b.n	40a5ba <sensor_type_2_android_sensor+0xba>
	case INV_ICM20948_SENSOR_WAKEUP_SIGNIFICANT_MOTION:     return ANDROID_SENSOR_WAKEUP_SIGNIFICANT_MOTION;
  40a59c:	2311      	movs	r3, #17
  40a59e:	e00c      	b.n	40a5ba <sensor_type_2_android_sensor+0xba>
	case INV_ICM20948_SENSOR_FLIP_PICKUP:                   return ANDROID_SENSOR_FLIP_PICKUP;
  40a5a0:	232e      	movs	r3, #46	; 0x2e
  40a5a2:	e00a      	b.n	40a5ba <sensor_type_2_android_sensor+0xba>
	case INV_ICM20948_SENSOR_WAKEUP_TILT_DETECTOR:          return ANDROID_SENSOR_WAKEUP_TILT_DETECTOR;
  40a5a4:	2329      	movs	r3, #41	; 0x29
  40a5a6:	e008      	b.n	40a5ba <sensor_type_2_android_sensor+0xba>
	case INV_ICM20948_SENSOR_GRAVITY:                       return ANDROID_SENSOR_GRAVITY;
  40a5a8:	2309      	movs	r3, #9
  40a5aa:	e006      	b.n	40a5ba <sensor_type_2_android_sensor+0xba>
	case INV_ICM20948_SENSOR_LINEAR_ACCELERATION:           return ANDROID_SENSOR_LINEAR_ACCELERATION;
  40a5ac:	230a      	movs	r3, #10
  40a5ae:	e004      	b.n	40a5ba <sensor_type_2_android_sensor+0xba>
	case INV_ICM20948_SENSOR_ORIENTATION:                   return ANDROID_SENSOR_ORIENTATION;
  40a5b0:	2303      	movs	r3, #3
  40a5b2:	e002      	b.n	40a5ba <sensor_type_2_android_sensor+0xba>
	case INV_ICM20948_SENSOR_B2S:                           return ANDROID_SENSOR_B2S;
  40a5b4:	232d      	movs	r3, #45	; 0x2d
  40a5b6:	e000      	b.n	40a5ba <sensor_type_2_android_sensor+0xba>
	default:                                                return ANDROID_SENSOR_NUM_MAX;
  40a5b8:	232c      	movs	r3, #44	; 0x2c
	}
}
  40a5ba:	4618      	mov	r0, r3
  40a5bc:	370c      	adds	r7, #12
  40a5be:	46bd      	mov	sp, r7
  40a5c0:	f85d 7b04 	ldr.w	r7, [sp], #4
  40a5c4:	4770      	bx	lr
  40a5c6:	bf00      	nop

0040a5c8 <inv_icm20948_sensor_android_2_sensor_type>:

enum inv_icm20948_sensor inv_icm20948_sensor_android_2_sensor_type(int sensor)
{
  40a5c8:	b480      	push	{r7}
  40a5ca:	b083      	sub	sp, #12
  40a5cc:	af00      	add	r7, sp, #0
  40a5ce:	6078      	str	r0, [r7, #4]
	switch(sensor) {
  40a5d0:	687b      	ldr	r3, [r7, #4]
  40a5d2:	3b01      	subs	r3, #1
  40a5d4:	2b2e      	cmp	r3, #46	; 0x2e
  40a5d6:	f200 8089 	bhi.w	40a6ec <inv_icm20948_sensor_android_2_sensor_type+0x124>
  40a5da:	a201      	add	r2, pc, #4	; (adr r2, 40a5e0 <inv_icm20948_sensor_android_2_sensor_type+0x18>)
  40a5dc:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
  40a5e0:	0040a69d 	.word	0x0040a69d
  40a5e4:	0040a6cd 	.word	0x0040a6cd
  40a5e8:	0040a6e5 	.word	0x0040a6e5
  40a5ec:	0040a6a1 	.word	0x0040a6a1
  40a5f0:	0040a6ed 	.word	0x0040a6ed
  40a5f4:	0040a6ed 	.word	0x0040a6ed
  40a5f8:	0040a6ed 	.word	0x0040a6ed
  40a5fc:	0040a6ed 	.word	0x0040a6ed
  40a600:	0040a6dd 	.word	0x0040a6dd
  40a604:	0040a6e1 	.word	0x0040a6e1
  40a608:	0040a6c5 	.word	0x0040a6c5
  40a60c:	0040a6ed 	.word	0x0040a6ed
  40a610:	0040a6ed 	.word	0x0040a6ed
  40a614:	0040a6ad 	.word	0x0040a6ad
  40a618:	0040a6c1 	.word	0x0040a6c1
  40a61c:	0040a6b1 	.word	0x0040a6b1
  40a620:	0040a6d1 	.word	0x0040a6d1
  40a624:	0040a6b9 	.word	0x0040a6b9
  40a628:	0040a6bd 	.word	0x0040a6bd
  40a62c:	0040a6c9 	.word	0x0040a6c9
  40a630:	0040a6ed 	.word	0x0040a6ed
  40a634:	0040a6ed 	.word	0x0040a6ed
  40a638:	0040a6ed 	.word	0x0040a6ed
  40a63c:	0040a6ed 	.word	0x0040a6ed
  40a640:	0040a6ed 	.word	0x0040a6ed
  40a644:	0040a6ed 	.word	0x0040a6ed
  40a648:	0040a6ed 	.word	0x0040a6ed
  40a64c:	0040a6ed 	.word	0x0040a6ed
  40a650:	0040a6ed 	.word	0x0040a6ed
  40a654:	0040a6ed 	.word	0x0040a6ed
  40a658:	0040a6ed 	.word	0x0040a6ed
  40a65c:	0040a6ed 	.word	0x0040a6ed
  40a660:	0040a6ed 	.word	0x0040a6ed
  40a664:	0040a6ed 	.word	0x0040a6ed
  40a668:	0040a6ed 	.word	0x0040a6ed
  40a66c:	0040a6ed 	.word	0x0040a6ed
  40a670:	0040a6ed 	.word	0x0040a6ed
  40a674:	0040a6ed 	.word	0x0040a6ed
  40a678:	0040a6ed 	.word	0x0040a6ed
  40a67c:	0040a6ed 	.word	0x0040a6ed
  40a680:	0040a6d9 	.word	0x0040a6d9
  40a684:	0040a6a5 	.word	0x0040a6a5
  40a688:	0040a6a9 	.word	0x0040a6a9
  40a68c:	0040a6ed 	.word	0x0040a6ed
  40a690:	0040a6e9 	.word	0x0040a6e9
  40a694:	0040a6d5 	.word	0x0040a6d5
  40a698:	0040a6b5 	.word	0x0040a6b5
	case ANDROID_SENSOR_ACCELEROMETER:                    return INV_ICM20948_SENSOR_ACCELEROMETER;
  40a69c:	2300      	movs	r3, #0
  40a69e:	e026      	b.n	40a6ee <inv_icm20948_sensor_android_2_sensor_type+0x126>
	case ANDROID_SENSOR_GYROSCOPE:                        return INV_ICM20948_SENSOR_GYROSCOPE;
  40a6a0:	2301      	movs	r3, #1
  40a6a2:	e024      	b.n	40a6ee <inv_icm20948_sensor_android_2_sensor_type+0x126>
	case ANDROID_SENSOR_RAW_ACCELEROMETER:                return INV_ICM20948_SENSOR_RAW_ACCELEROMETER;
  40a6a4:	2302      	movs	r3, #2
  40a6a6:	e022      	b.n	40a6ee <inv_icm20948_sensor_android_2_sensor_type+0x126>
	case ANDROID_SENSOR_RAW_GYROSCOPE:                    return INV_ICM20948_SENSOR_RAW_GYROSCOPE;
  40a6a8:	2303      	movs	r3, #3
  40a6aa:	e020      	b.n	40a6ee <inv_icm20948_sensor_android_2_sensor_type+0x126>
	case ANDROID_SENSOR_MAGNETIC_FIELD_UNCALIBRATED:      return INV_ICM20948_SENSOR_MAGNETIC_FIELD_UNCALIBRATED;
  40a6ac:	2304      	movs	r3, #4
  40a6ae:	e01e      	b.n	40a6ee <inv_icm20948_sensor_android_2_sensor_type+0x126>
	case ANDROID_SENSOR_GYROSCOPE_UNCALIBRATED:           return INV_ICM20948_SENSOR_GYROSCOPE_UNCALIBRATED;
  40a6b0:	2305      	movs	r3, #5
  40a6b2:	e01c      	b.n	40a6ee <inv_icm20948_sensor_android_2_sensor_type+0x126>
	case ANDROID_SENSOR_ACTIVITY_CLASSIFICATON:           return INV_ICM20948_SENSOR_ACTIVITY_CLASSIFICATON;
  40a6b4:	2306      	movs	r3, #6
  40a6b6:	e01a      	b.n	40a6ee <inv_icm20948_sensor_android_2_sensor_type+0x126>
	case ANDROID_SENSOR_STEP_DETECTOR:                    return INV_ICM20948_SENSOR_STEP_DETECTOR;
  40a6b8:	2307      	movs	r3, #7
  40a6ba:	e018      	b.n	40a6ee <inv_icm20948_sensor_android_2_sensor_type+0x126>
	case ANDROID_SENSOR_STEP_COUNTER:                     return INV_ICM20948_SENSOR_STEP_COUNTER;
  40a6bc:	2308      	movs	r3, #8
  40a6be:	e016      	b.n	40a6ee <inv_icm20948_sensor_android_2_sensor_type+0x126>
	case ANDROID_SENSOR_GAME_ROTATION_VECTOR:             return INV_ICM20948_SENSOR_GAME_ROTATION_VECTOR;
  40a6c0:	2309      	movs	r3, #9
  40a6c2:	e014      	b.n	40a6ee <inv_icm20948_sensor_android_2_sensor_type+0x126>
	case ANDROID_SENSOR_ROTATION_VECTOR:                  return INV_ICM20948_SENSOR_ROTATION_VECTOR;
  40a6c4:	230a      	movs	r3, #10
  40a6c6:	e012      	b.n	40a6ee <inv_icm20948_sensor_android_2_sensor_type+0x126>
	case ANDROID_SENSOR_GEOMAGNETIC_ROTATION_VECTOR:      return INV_ICM20948_SENSOR_GEOMAGNETIC_ROTATION_VECTOR;
  40a6c8:	230b      	movs	r3, #11
  40a6ca:	e010      	b.n	40a6ee <inv_icm20948_sensor_android_2_sensor_type+0x126>
	case ANDROID_SENSOR_GEOMAGNETIC_FIELD:                return INV_ICM20948_SENSOR_GEOMAGNETIC_FIELD;
  40a6cc:	230c      	movs	r3, #12
  40a6ce:	e00e      	b.n	40a6ee <inv_icm20948_sensor_android_2_sensor_type+0x126>
	case ANDROID_SENSOR_WAKEUP_SIGNIFICANT_MOTION:        return INV_ICM20948_SENSOR_WAKEUP_SIGNIFICANT_MOTION;
  40a6d0:	230d      	movs	r3, #13
  40a6d2:	e00c      	b.n	40a6ee <inv_icm20948_sensor_android_2_sensor_type+0x126>
	case ANDROID_SENSOR_FLIP_PICKUP:                      return INV_ICM20948_SENSOR_FLIP_PICKUP;
  40a6d4:	230e      	movs	r3, #14
  40a6d6:	e00a      	b.n	40a6ee <inv_icm20948_sensor_android_2_sensor_type+0x126>
	case ANDROID_SENSOR_WAKEUP_TILT_DETECTOR:             return INV_ICM20948_SENSOR_WAKEUP_TILT_DETECTOR;
  40a6d8:	230f      	movs	r3, #15
  40a6da:	e008      	b.n	40a6ee <inv_icm20948_sensor_android_2_sensor_type+0x126>
	case ANDROID_SENSOR_GRAVITY:                          return INV_ICM20948_SENSOR_GRAVITY;
  40a6dc:	2310      	movs	r3, #16
  40a6de:	e006      	b.n	40a6ee <inv_icm20948_sensor_android_2_sensor_type+0x126>
	case ANDROID_SENSOR_LINEAR_ACCELERATION:              return INV_ICM20948_SENSOR_LINEAR_ACCELERATION;
  40a6e0:	2311      	movs	r3, #17
  40a6e2:	e004      	b.n	40a6ee <inv_icm20948_sensor_android_2_sensor_type+0x126>
	case ANDROID_SENSOR_ORIENTATION:                      return INV_ICM20948_SENSOR_ORIENTATION;
  40a6e4:	2312      	movs	r3, #18
  40a6e6:	e002      	b.n	40a6ee <inv_icm20948_sensor_android_2_sensor_type+0x126>
	case ANDROID_SENSOR_B2S:                              return INV_ICM20948_SENSOR_B2S;
  40a6e8:	2313      	movs	r3, #19
  40a6ea:	e000      	b.n	40a6ee <inv_icm20948_sensor_android_2_sensor_type+0x126>
	default:                                              return INV_ICM20948_SENSOR_MAX;
  40a6ec:	2314      	movs	r3, #20
	}
}
  40a6ee:	4618      	mov	r0, r3
  40a6f0:	370c      	adds	r7, #12
  40a6f2:	46bd      	mov	sp, r7
  40a6f4:	f85d 7b04 	ldr.w	r7, [sp], #4
  40a6f8:	4770      	bx	lr
  40a6fa:	bf00      	nop

0040a6fc <skip_sensor>:

static int skip_sensor(struct inv_icm20948 * s, unsigned char androidSensor)
{
  40a6fc:	b580      	push	{r7, lr}
  40a6fe:	b084      	sub	sp, #16
  40a700:	af00      	add	r7, sp, #0
  40a702:	6078      	str	r0, [r7, #4]
  40a704:	460b      	mov	r3, r1
  40a706:	70fb      	strb	r3, [r7, #3]
	enum inv_icm20948_sensor icm20948_sensor_id = inv_icm20948_sensor_android_2_sensor_type(androidSensor);
  40a708:	78fb      	ldrb	r3, [r7, #3]
  40a70a:	4618      	mov	r0, r3
  40a70c:	4b10      	ldr	r3, [pc, #64]	; (40a750 <skip_sensor+0x54>)
  40a70e:	4798      	blx	r3
  40a710:	4603      	mov	r3, r0
  40a712:	73fb      	strb	r3, [r7, #15]
	uint8_t skip_sample = s->skip_sample[icm20948_sensor_id];
  40a714:	7bfb      	ldrb	r3, [r7, #15]
  40a716:	687a      	ldr	r2, [r7, #4]
  40a718:	4413      	add	r3, r2
  40a71a:	f893 32ac 	ldrb.w	r3, [r3, #684]	; 0x2ac
  40a71e:	73bb      	strb	r3, [r7, #14]

	if (s->skip_sample[icm20948_sensor_id])
  40a720:	7bfb      	ldrb	r3, [r7, #15]
  40a722:	687a      	ldr	r2, [r7, #4]
  40a724:	4413      	add	r3, r2
  40a726:	f893 32ac 	ldrb.w	r3, [r3, #684]	; 0x2ac
  40a72a:	2b00      	cmp	r3, #0
  40a72c:	d00b      	beq.n	40a746 <skip_sensor+0x4a>
		s->skip_sample[icm20948_sensor_id]--;
  40a72e:	7bfb      	ldrb	r3, [r7, #15]
  40a730:	687a      	ldr	r2, [r7, #4]
  40a732:	441a      	add	r2, r3
  40a734:	f892 22ac 	ldrb.w	r2, [r2, #684]	; 0x2ac
  40a738:	3a01      	subs	r2, #1
  40a73a:	b2d1      	uxtb	r1, r2
  40a73c:	687a      	ldr	r2, [r7, #4]
  40a73e:	4413      	add	r3, r2
  40a740:	460a      	mov	r2, r1
  40a742:	f883 22ac 	strb.w	r2, [r3, #684]	; 0x2ac

	return skip_sample;
  40a746:	7bbb      	ldrb	r3, [r7, #14]
}
  40a748:	4618      	mov	r0, r3
  40a74a:	3710      	adds	r7, #16
  40a74c:	46bd      	mov	sp, r7
  40a74e:	bd80      	pop	{r7, pc}
  40a750:	0040a5c9 	.word	0x0040a5c9

0040a754 <inv_icm20948_get_whoami>:

/* Identification related functions */
int inv_icm20948_get_whoami(struct inv_icm20948 * s, uint8_t * whoami)
{
  40a754:	b580      	push	{r7, lr}
  40a756:	b082      	sub	sp, #8
  40a758:	af00      	add	r7, sp, #0
  40a75a:	6078      	str	r0, [r7, #4]
  40a75c:	6039      	str	r1, [r7, #0]
	return inv_icm20948_read_reg_one(s, REG_WHO_AM_I, whoami);
  40a75e:	683a      	ldr	r2, [r7, #0]
  40a760:	2100      	movs	r1, #0
  40a762:	6878      	ldr	r0, [r7, #4]
  40a764:	4b03      	ldr	r3, [pc, #12]	; (40a774 <inv_icm20948_get_whoami+0x20>)
  40a766:	4798      	blx	r3
  40a768:	4603      	mov	r3, r0
}
  40a76a:	4618      	mov	r0, r3
  40a76c:	3708      	adds	r7, #8
  40a76e:	46bd      	mov	sp, r7
  40a770:	bd80      	pop	{r7, pc}
  40a772:	bf00      	nop
  40a774:	0040a4d9 	.word	0x0040a4d9

0040a778 <inv_icm20948_init_matrix>:

void inv_icm20948_init_matrix(struct inv_icm20948 * s)
{
  40a778:	b580      	push	{r7, lr}
  40a77a:	b082      	sub	sp, #8
  40a77c:	af00      	add	r7, sp, #0
  40a77e:	6078      	str	r0, [r7, #4]
	// initialize chip to body
	s->s_quat_chip_to_body[0] = (1L<<30);
  40a780:	687b      	ldr	r3, [r7, #4]
  40a782:	f04f 4280 	mov.w	r2, #1073741824	; 0x40000000
  40a786:	f8c3 20a8 	str.w	r2, [r3, #168]	; 0xa8
	s->s_quat_chip_to_body[1] = 0;
  40a78a:	687b      	ldr	r3, [r7, #4]
  40a78c:	2200      	movs	r2, #0
  40a78e:	f8c3 20ac 	str.w	r2, [r3, #172]	; 0xac
	s->s_quat_chip_to_body[2] = 0;
  40a792:	687b      	ldr	r3, [r7, #4]
  40a794:	2200      	movs	r2, #0
  40a796:	f8c3 20b0 	str.w	r2, [r3, #176]	; 0xb0
	s->s_quat_chip_to_body[3] = 0;
  40a79a:	687b      	ldr	r3, [r7, #4]
  40a79c:	2200      	movs	r2, #0
  40a79e:	f8c3 20b4 	str.w	r2, [r3, #180]	; 0xb4
	//initialize mounting matrix
	memset(s->mounting_matrix, 0, sizeof(s->mounting_matrix));
  40a7a2:	687b      	ldr	r3, [r7, #4]
  40a7a4:	f503 731d 	add.w	r3, r3, #628	; 0x274
  40a7a8:	2209      	movs	r2, #9
  40a7aa:	2100      	movs	r1, #0
  40a7ac:	4618      	mov	r0, r3
  40a7ae:	4b15      	ldr	r3, [pc, #84]	; (40a804 <inv_icm20948_init_matrix+0x8c>)
  40a7b0:	4798      	blx	r3
	s->mounting_matrix[0] = 1;
  40a7b2:	687b      	ldr	r3, [r7, #4]
  40a7b4:	2201      	movs	r2, #1
  40a7b6:	f883 2274 	strb.w	r2, [r3, #628]	; 0x274
	s->mounting_matrix[4] = 1;
  40a7ba:	687b      	ldr	r3, [r7, #4]
  40a7bc:	2201      	movs	r2, #1
  40a7be:	f883 2278 	strb.w	r2, [r3, #632]	; 0x278
	s->mounting_matrix[8] = 1;
  40a7c2:	687b      	ldr	r3, [r7, #4]
  40a7c4:	2201      	movs	r2, #1
  40a7c6:	f883 227c 	strb.w	r2, [r3, #636]	; 0x27c
	//initialize soft iron matrix
	s->soft_iron_matrix[0] = (1L<<30);
  40a7ca:	687b      	ldr	r3, [r7, #4]
  40a7cc:	f04f 4280 	mov.w	r2, #1073741824	; 0x40000000
  40a7d0:	f8c3 2288 	str.w	r2, [r3, #648]	; 0x288
	s->soft_iron_matrix[4] = (1L<<30);
  40a7d4:	687b      	ldr	r3, [r7, #4]
  40a7d6:	f04f 4280 	mov.w	r2, #1073741824	; 0x40000000
  40a7da:	f8c3 2298 	str.w	r2, [r3, #664]	; 0x298
	s->soft_iron_matrix[8] = (1L<<30);
  40a7de:	687b      	ldr	r3, [r7, #4]
  40a7e0:	f04f 4280 	mov.w	r2, #1073741824	; 0x40000000
  40a7e4:	f8c3 22a8 	str.w	r2, [r3, #680]	; 0x2a8

	inv_icm20948_set_chip_to_body_axis_quaternion(s, s->mounting_matrix, 0.0);
  40a7e8:	687b      	ldr	r3, [r7, #4]
  40a7ea:	f503 731d 	add.w	r3, r3, #628	; 0x274
  40a7ee:	ed9f 0a06 	vldr	s0, [pc, #24]	; 40a808 <inv_icm20948_init_matrix+0x90>
  40a7f2:	4619      	mov	r1, r3
  40a7f4:	6878      	ldr	r0, [r7, #4]
  40a7f6:	4b05      	ldr	r3, [pc, #20]	; (40a80c <inv_icm20948_init_matrix+0x94>)
  40a7f8:	4798      	blx	r3
}
  40a7fa:	bf00      	nop
  40a7fc:	3708      	adds	r7, #8
  40a7fe:	46bd      	mov	sp, r7
  40a800:	bd80      	pop	{r7, pc}
  40a802:	bf00      	nop
  40a804:	00414241 	.word	0x00414241
  40a808:	00000000 	.word	0x00000000
  40a80c:	00406b41 	.word	0x00406b41

0040a810 <inv_icm20948_init_structure>:

int inv_icm20948_init_structure(struct inv_icm20948 * s)
{
  40a810:	b590      	push	{r4, r7, lr}
  40a812:	b085      	sub	sp, #20
  40a814:	af00      	add	r7, sp, #0
  40a816:	6078      	str	r0, [r7, #4]
	int i;
	inv_icm20948_base_control_init(s);
  40a818:	6878      	ldr	r0, [r7, #4]
  40a81a:	4b16      	ldr	r3, [pc, #88]	; (40a874 <inv_icm20948_init_structure+0x64>)
  40a81c:	4798      	blx	r3
	inv_icm20948_transport_init(s);
  40a81e:	6878      	ldr	r0, [r7, #4]
  40a820:	4b15      	ldr	r3, [pc, #84]	; (40a878 <inv_icm20948_init_structure+0x68>)
  40a822:	4798      	blx	r3
	inv_icm20948_augmented_init(s);
  40a824:	6878      	ldr	r0, [r7, #4]
  40a826:	4b15      	ldr	r3, [pc, #84]	; (40a87c <inv_icm20948_init_structure+0x6c>)
  40a828:	4798      	blx	r3
	//Init state
	s->set_accuracy = 0;
  40a82a:	687b      	ldr	r3, [r7, #4]
  40a82c:	2200      	movs	r2, #0
  40a82e:	f8a3 24f2 	strh.w	r2, [r3, #1266]	; 0x4f2
	s->new_accuracy = 0;
  40a832:	687b      	ldr	r3, [r7, #4]
  40a834:	2200      	movs	r2, #0
  40a836:	f8c3 24f4 	str.w	r2, [r3, #1268]	; 0x4f4
	for(i = 0; i < GENERAL_SENSORS_MAX; i ++)
  40a83a:	2300      	movs	r3, #0
  40a83c:	60fb      	str	r3, [r7, #12]
  40a83e:	e010      	b.n	40a862 <inv_icm20948_init_structure+0x52>
		s->timestamp[inv_icm20948_sensor_android_2_sensor_type(i)] = 0;
  40a840:	68f8      	ldr	r0, [r7, #12]
  40a842:	4b0f      	ldr	r3, [pc, #60]	; (40a880 <inv_icm20948_init_structure+0x70>)
  40a844:	4798      	blx	r3
  40a846:	4603      	mov	r3, r0
  40a848:	687a      	ldr	r2, [r7, #4]
  40a84a:	3359      	adds	r3, #89	; 0x59
  40a84c:	00db      	lsls	r3, r3, #3
  40a84e:	441a      	add	r2, r3
  40a850:	f04f 0300 	mov.w	r3, #0
  40a854:	f04f 0400 	mov.w	r4, #0
  40a858:	e9c2 3400 	strd	r3, r4, [r2]
	for(i = 0; i < GENERAL_SENSORS_MAX; i ++)
  40a85c:	68fb      	ldr	r3, [r7, #12]
  40a85e:	3301      	adds	r3, #1
  40a860:	60fb      	str	r3, [r7, #12]
  40a862:	68fb      	ldr	r3, [r7, #12]
  40a864:	2b32      	cmp	r3, #50	; 0x32
  40a866:	ddeb      	ble.n	40a840 <inv_icm20948_init_structure+0x30>

	return 0;
  40a868:	2300      	movs	r3, #0
}
  40a86a:	4618      	mov	r0, r3
  40a86c:	3714      	adds	r7, #20
  40a86e:	46bd      	mov	sp, r7
  40a870:	bd90      	pop	{r4, r7, pc}
  40a872:	bf00      	nop
  40a874:	00410bf5 	.word	0x00410bf5
  40a878:	0040c471 	.word	0x0040c471
  40a87c:	0040fe5f 	.word	0x0040fe5f
  40a880:	0040a5c9 	.word	0x0040a5c9

0040a884 <inv_icm20948_initialize>:

int inv_icm20948_initialize(struct inv_icm20948 * s, const uint8_t *dmp3_image, uint32_t dmp3_image_size)
{
  40a884:	b590      	push	{r4, r7, lr}
  40a886:	b085      	sub	sp, #20
  40a888:	af00      	add	r7, sp, #0
  40a88a:	60f8      	str	r0, [r7, #12]
  40a88c:	60b9      	str	r1, [r7, #8]
  40a88e:	607a      	str	r2, [r7, #4]
	if(s->serif.is_spi) {
  40a890:	68fb      	ldr	r3, [r7, #12]
  40a892:	695b      	ldr	r3, [r3, #20]
  40a894:	2b00      	cmp	r3, #0
  40a896:	d00b      	beq.n	40a8b0 <inv_icm20948_initialize+0x2c>
		/* Hardware initialization */
		// No image to be loaded from flash, no pointer to pass.
		if (inv_icm20948_initialize_lower_driver(s, SERIAL_INTERFACE_SPI, dmp3_image, dmp3_image_size)) {
  40a898:	687b      	ldr	r3, [r7, #4]
  40a89a:	68ba      	ldr	r2, [r7, #8]
  40a89c:	2102      	movs	r1, #2
  40a89e:	68f8      	ldr	r0, [r7, #12]
  40a8a0:	4c0c      	ldr	r4, [pc, #48]	; (40a8d4 <inv_icm20948_initialize+0x50>)
  40a8a2:	47a0      	blx	r4
  40a8a4:	4603      	mov	r3, r0
  40a8a6:	2b00      	cmp	r3, #0
  40a8a8:	d00e      	beq.n	40a8c8 <inv_icm20948_initialize+0x44>
			return -1;
  40a8aa:	f04f 33ff 	mov.w	r3, #4294967295
  40a8ae:	e00c      	b.n	40a8ca <inv_icm20948_initialize+0x46>
		}
	}
	else {
		/* Hardware initialization */
		// No image to be loaded from flash, no pointer to pass.
		if (inv_icm20948_initialize_lower_driver(s, SERIAL_INTERFACE_I2C, dmp3_image, dmp3_image_size)) {
  40a8b0:	687b      	ldr	r3, [r7, #4]
  40a8b2:	68ba      	ldr	r2, [r7, #8]
  40a8b4:	2101      	movs	r1, #1
  40a8b6:	68f8      	ldr	r0, [r7, #12]
  40a8b8:	4c06      	ldr	r4, [pc, #24]	; (40a8d4 <inv_icm20948_initialize+0x50>)
  40a8ba:	47a0      	blx	r4
  40a8bc:	4603      	mov	r3, r0
  40a8be:	2b00      	cmp	r3, #0
  40a8c0:	d002      	beq.n	40a8c8 <inv_icm20948_initialize+0x44>
			return -1;
  40a8c2:	f04f 33ff 	mov.w	r3, #4294967295
  40a8c6:	e000      	b.n	40a8ca <inv_icm20948_initialize+0x46>
		}
	}
	return 0;
  40a8c8:	2300      	movs	r3, #0
}
  40a8ca:	4618      	mov	r0, r3
  40a8cc:	3714      	adds	r7, #20
  40a8ce:	46bd      	mov	sp, r7
  40a8d0:	bd90      	pop	{r4, r7, pc}
  40a8d2:	bf00      	nop
  40a8d4:	00405b0d 	.word	0x00405b0d

0040a8d8 <inv_icm20948_set_fsr>:

	return 0;
}

int inv_icm20948_set_fsr(struct inv_icm20948 * s, enum inv_icm20948_sensor sensor, const void * fsr)
{
  40a8d8:	b580      	push	{r7, lr}
  40a8da:	b088      	sub	sp, #32
  40a8dc:	af00      	add	r7, sp, #0
  40a8de:	60f8      	str	r0, [r7, #12]
  40a8e0:	460b      	mov	r3, r1
  40a8e2:	607a      	str	r2, [r7, #4]
  40a8e4:	72fb      	strb	r3, [r7, #11]
	int result = 0;
  40a8e6:	2300      	movs	r3, #0
  40a8e8:	61fb      	str	r3, [r7, #28]
	int * castedvalue = (int*) fsr;
  40a8ea:	687b      	ldr	r3, [r7, #4]
  40a8ec:	617b      	str	r3, [r7, #20]
	if((sensor == INV_ICM20948_SENSOR_RAW_ACCELEROMETER) ||
  40a8ee:	7afb      	ldrb	r3, [r7, #11]
  40a8f0:	2b02      	cmp	r3, #2
  40a8f2:	d002      	beq.n	40a8fa <inv_icm20948_set_fsr+0x22>
  40a8f4:	7afb      	ldrb	r3, [r7, #11]
  40a8f6:	2b00      	cmp	r3, #0
  40a8f8:	d128      	bne.n	40a94c <inv_icm20948_set_fsr+0x74>
		(sensor == INV_ICM20948_SENSOR_ACCELEROMETER)){
			enum mpu_accel_fs afsr;
			if(*castedvalue == 2)
  40a8fa:	697b      	ldr	r3, [r7, #20]
  40a8fc:	681b      	ldr	r3, [r3, #0]
  40a8fe:	2b02      	cmp	r3, #2
  40a900:	d102      	bne.n	40a908 <inv_icm20948_set_fsr+0x30>
				afsr = MPU_FS_2G;
  40a902:	2300      	movs	r3, #0
  40a904:	76fb      	strb	r3, [r7, #27]
  40a906:	e017      	b.n	40a938 <inv_icm20948_set_fsr+0x60>
			else if(*castedvalue == 4)
  40a908:	697b      	ldr	r3, [r7, #20]
  40a90a:	681b      	ldr	r3, [r3, #0]
  40a90c:	2b04      	cmp	r3, #4
  40a90e:	d102      	bne.n	40a916 <inv_icm20948_set_fsr+0x3e>
				afsr = MPU_FS_4G;
  40a910:	2301      	movs	r3, #1
  40a912:	76fb      	strb	r3, [r7, #27]
  40a914:	e010      	b.n	40a938 <inv_icm20948_set_fsr+0x60>
			else if(*castedvalue == 8)
  40a916:	697b      	ldr	r3, [r7, #20]
  40a918:	681b      	ldr	r3, [r3, #0]
  40a91a:	2b08      	cmp	r3, #8
  40a91c:	d102      	bne.n	40a924 <inv_icm20948_set_fsr+0x4c>
				afsr = MPU_FS_8G;
  40a91e:	2302      	movs	r3, #2
  40a920:	76fb      	strb	r3, [r7, #27]
  40a922:	e009      	b.n	40a938 <inv_icm20948_set_fsr+0x60>
			else if(*castedvalue == 16)
  40a924:	697b      	ldr	r3, [r7, #20]
  40a926:	681b      	ldr	r3, [r3, #0]
  40a928:	2b10      	cmp	r3, #16
  40a92a:	d102      	bne.n	40a932 <inv_icm20948_set_fsr+0x5a>
				afsr = MPU_FS_16G;
  40a92c:	2303      	movs	r3, #3
  40a92e:	76fb      	strb	r3, [r7, #27]
  40a930:	e002      	b.n	40a938 <inv_icm20948_set_fsr+0x60>
			else
				return -1;
  40a932:	f04f 33ff 	mov.w	r3, #4294967295
  40a936:	e03e      	b.n	40a9b6 <inv_icm20948_set_fsr+0xde>
			result |= inv_icm20948_set_accel_fullscale(s, afsr);
  40a938:	7efb      	ldrb	r3, [r7, #27]
  40a93a:	4619      	mov	r1, r3
  40a93c:	68f8      	ldr	r0, [r7, #12]
  40a93e:	4b20      	ldr	r3, [pc, #128]	; (40a9c0 <inv_icm20948_set_fsr+0xe8>)
  40a940:	4798      	blx	r3
  40a942:	4602      	mov	r2, r0
  40a944:	69fb      	ldr	r3, [r7, #28]
  40a946:	4313      	orrs	r3, r2
  40a948:	61fb      	str	r3, [r7, #28]
		(sensor == INV_ICM20948_SENSOR_ACCELEROMETER)){
  40a94a:	e033      	b.n	40a9b4 <inv_icm20948_set_fsr+0xdc>
	}
	else if((sensor == INV_ICM20948_SENSOR_GYROSCOPE) ||
  40a94c:	7afb      	ldrb	r3, [r7, #11]
  40a94e:	2b01      	cmp	r3, #1
  40a950:	d005      	beq.n	40a95e <inv_icm20948_set_fsr+0x86>
  40a952:	7afb      	ldrb	r3, [r7, #11]
  40a954:	2b03      	cmp	r3, #3
  40a956:	d002      	beq.n	40a95e <inv_icm20948_set_fsr+0x86>
		(sensor == INV_ICM20948_SENSOR_RAW_GYROSCOPE) ||
  40a958:	7afb      	ldrb	r3, [r7, #11]
  40a95a:	2b05      	cmp	r3, #5
  40a95c:	d12a      	bne.n	40a9b4 <inv_icm20948_set_fsr+0xdc>
		(sensor == INV_ICM20948_SENSOR_GYROSCOPE_UNCALIBRATED)) {
			enum mpu_gyro_fs gfsr;
			if(*castedvalue == 250)
  40a95e:	697b      	ldr	r3, [r7, #20]
  40a960:	681b      	ldr	r3, [r3, #0]
  40a962:	2bfa      	cmp	r3, #250	; 0xfa
  40a964:	d102      	bne.n	40a96c <inv_icm20948_set_fsr+0x94>
				gfsr = MPU_FS_250dps;
  40a966:	2300      	movs	r3, #0
  40a968:	76bb      	strb	r3, [r7, #26]
  40a96a:	e01a      	b.n	40a9a2 <inv_icm20948_set_fsr+0xca>
			else if(*castedvalue == 500)
  40a96c:	697b      	ldr	r3, [r7, #20]
  40a96e:	681b      	ldr	r3, [r3, #0]
  40a970:	f5b3 7ffa 	cmp.w	r3, #500	; 0x1f4
  40a974:	d102      	bne.n	40a97c <inv_icm20948_set_fsr+0xa4>
				gfsr = MPU_FS_500dps;
  40a976:	2301      	movs	r3, #1
  40a978:	76bb      	strb	r3, [r7, #26]
  40a97a:	e012      	b.n	40a9a2 <inv_icm20948_set_fsr+0xca>
			else if(*castedvalue == 1000)
  40a97c:	697b      	ldr	r3, [r7, #20]
  40a97e:	681b      	ldr	r3, [r3, #0]
  40a980:	f5b3 7f7a 	cmp.w	r3, #1000	; 0x3e8
  40a984:	d102      	bne.n	40a98c <inv_icm20948_set_fsr+0xb4>
				gfsr = MPU_FS_1000dps;
  40a986:	2302      	movs	r3, #2
  40a988:	76bb      	strb	r3, [r7, #26]
  40a98a:	e00a      	b.n	40a9a2 <inv_icm20948_set_fsr+0xca>
			else if(*castedvalue == 2000)
  40a98c:	697b      	ldr	r3, [r7, #20]
  40a98e:	681b      	ldr	r3, [r3, #0]
  40a990:	f5b3 6ffa 	cmp.w	r3, #2000	; 0x7d0
  40a994:	d102      	bne.n	40a99c <inv_icm20948_set_fsr+0xc4>
				gfsr = MPU_FS_2000dps;
  40a996:	2303      	movs	r3, #3
  40a998:	76bb      	strb	r3, [r7, #26]
  40a99a:	e002      	b.n	40a9a2 <inv_icm20948_set_fsr+0xca>
			else
				return -1;
  40a99c:	f04f 33ff 	mov.w	r3, #4294967295
  40a9a0:	e009      	b.n	40a9b6 <inv_icm20948_set_fsr+0xde>
			result |= inv_icm20948_set_gyro_fullscale(s, gfsr);
  40a9a2:	7ebb      	ldrb	r3, [r7, #26]
  40a9a4:	4619      	mov	r1, r3
  40a9a6:	68f8      	ldr	r0, [r7, #12]
  40a9a8:	4b06      	ldr	r3, [pc, #24]	; (40a9c4 <inv_icm20948_set_fsr+0xec>)
  40a9aa:	4798      	blx	r3
  40a9ac:	4602      	mov	r2, r0
  40a9ae:	69fb      	ldr	r3, [r7, #28]
  40a9b0:	4313      	orrs	r3, r2
  40a9b2:	61fb      	str	r3, [r7, #28]
	}
	return result;
  40a9b4:	69fb      	ldr	r3, [r7, #28]
}
  40a9b6:	4618      	mov	r0, r3
  40a9b8:	3720      	adds	r7, #32
  40a9ba:	46bd      	mov	sp, r7
  40a9bc:	bd80      	pop	{r7, pc}
  40a9be:	bf00      	nop
  40a9c0:	004062a9 	.word	0x004062a9
  40a9c4:	004060fd 	.word	0x004060fd

0040a9c8 <inv_icm20948_set_lowpower_or_highperformance>:
	}
	return (rc == 0) ? 3*(int)sizeof(float) : rc;
}

int inv_icm20948_set_lowpower_or_highperformance(struct inv_icm20948 * s, uint8_t lowpower_or_highperformance)
{
  40a9c8:	b580      	push	{r7, lr}
  40a9ca:	b082      	sub	sp, #8
  40a9cc:	af00      	add	r7, sp, #0
  40a9ce:	6078      	str	r0, [r7, #4]
  40a9d0:	460b      	mov	r3, r1
  40a9d2:	70fb      	strb	r3, [r7, #3]
	s->go_back_lp_when_odr_low = 0;
  40a9d4:	687b      	ldr	r3, [r7, #4]
  40a9d6:	2200      	movs	r2, #0
  40a9d8:	f883 2244 	strb.w	r2, [r3, #580]	; 0x244
	if(lowpower_or_highperformance)
  40a9dc:	78fb      	ldrb	r3, [r7, #3]
  40a9de:	2b00      	cmp	r3, #0
  40a9e0:	d004      	beq.n	40a9ec <inv_icm20948_set_lowpower_or_highperformance+0x24>
		return inv_icm20948_enter_low_noise_mode(s);
  40a9e2:	6878      	ldr	r0, [r7, #4]
  40a9e4:	4b05      	ldr	r3, [pc, #20]	; (40a9fc <inv_icm20948_set_lowpower_or_highperformance+0x34>)
  40a9e6:	4798      	blx	r3
  40a9e8:	4603      	mov	r3, r0
  40a9ea:	e003      	b.n	40a9f4 <inv_icm20948_set_lowpower_or_highperformance+0x2c>
	else
		return inv_icm20948_enter_duty_cycle_mode(s);
  40a9ec:	6878      	ldr	r0, [r7, #4]
  40a9ee:	4b04      	ldr	r3, [pc, #16]	; (40aa00 <inv_icm20948_set_lowpower_or_highperformance+0x38>)
  40a9f0:	4798      	blx	r3
  40a9f2:	4603      	mov	r3, r0
}
  40a9f4:	4618      	mov	r0, r3
  40a9f6:	3708      	adds	r7, #8
  40a9f8:	46bd      	mov	sp, r7
  40a9fa:	bd80      	pop	{r7, pc}
  40a9fc:	00405add 	.word	0x00405add
  40aa00:	00405aad 	.word	0x00405aad

0040aa04 <DmpDriver_convertion>:
	return 1;
}

static void DmpDriver_convertion(signed char transformedtochar[9],
	const int32_t MatrixInQ30[9])
{
  40aa04:	b480      	push	{r7}
  40aa06:	b085      	sub	sp, #20
  40aa08:	af00      	add	r7, sp, #0
  40aa0a:	6078      	str	r0, [r7, #4]
  40aa0c:	6039      	str	r1, [r7, #0]
	// To convert Q30 to signed char value
	uint8_t iter;
	for (iter = 0; iter < 9; ++iter)
  40aa0e:	2300      	movs	r3, #0
  40aa10:	73fb      	strb	r3, [r7, #15]
  40aa12:	e00d      	b.n	40aa30 <DmpDriver_convertion+0x2c>
		transformedtochar[iter] = MatrixInQ30[iter] >> 30;
  40aa14:	7bfb      	ldrb	r3, [r7, #15]
  40aa16:	687a      	ldr	r2, [r7, #4]
  40aa18:	4413      	add	r3, r2
  40aa1a:	7bfa      	ldrb	r2, [r7, #15]
  40aa1c:	0092      	lsls	r2, r2, #2
  40aa1e:	6839      	ldr	r1, [r7, #0]
  40aa20:	440a      	add	r2, r1
  40aa22:	6812      	ldr	r2, [r2, #0]
  40aa24:	1792      	asrs	r2, r2, #30
  40aa26:	b252      	sxtb	r2, r2
  40aa28:	701a      	strb	r2, [r3, #0]
	for (iter = 0; iter < 9; ++iter)
  40aa2a:	7bfb      	ldrb	r3, [r7, #15]
  40aa2c:	3301      	adds	r3, #1
  40aa2e:	73fb      	strb	r3, [r7, #15]
  40aa30:	7bfb      	ldrb	r3, [r7, #15]
  40aa32:	2b08      	cmp	r3, #8
  40aa34:	d9ee      	bls.n	40aa14 <DmpDriver_convertion+0x10>
}
  40aa36:	bf00      	nop
  40aa38:	3714      	adds	r7, #20
  40aa3a:	46bd      	mov	sp, r7
  40aa3c:	f85d 7b04 	ldr.w	r7, [sp], #4
  40aa40:	4770      	bx	lr
	...

0040aa44 <inv_icm20948_set_matrix>:

int inv_icm20948_set_matrix(struct inv_icm20948 * s, const float matrix[9], enum inv_icm20948_sensor sensor)
{
  40aa44:	b580      	push	{r7, lr}
  40aa46:	b090      	sub	sp, #64	; 0x40
  40aa48:	af00      	add	r7, sp, #0
  40aa4a:	60f8      	str	r0, [r7, #12]
  40aa4c:	60b9      	str	r1, [r7, #8]
  40aa4e:	4613      	mov	r3, r2
  40aa50:	71fb      	strb	r3, [r7, #7]
	int32_t mounting_mq30[9];
	int result = 0;
  40aa52:	2300      	movs	r3, #0
  40aa54:	63fb      	str	r3, [r7, #60]	; 0x3c
	int i;

	for(i = 0; i < 9; ++i)
  40aa56:	2300      	movs	r3, #0
  40aa58:	63bb      	str	r3, [r7, #56]	; 0x38
  40aa5a:	e017      	b.n	40aa8c <inv_icm20948_set_matrix+0x48>
		mounting_mq30[i] = (int32_t)(matrix[i] * (1 << 30));
  40aa5c:	6bbb      	ldr	r3, [r7, #56]	; 0x38
  40aa5e:	009b      	lsls	r3, r3, #2
  40aa60:	68ba      	ldr	r2, [r7, #8]
  40aa62:	4413      	add	r3, r2
  40aa64:	edd3 7a00 	vldr	s15, [r3]
  40aa68:	ed9f 7a22 	vldr	s14, [pc, #136]	; 40aaf4 <inv_icm20948_set_matrix+0xb0>
  40aa6c:	ee67 7a87 	vmul.f32	s15, s15, s14
  40aa70:	eefd 7ae7 	vcvt.s32.f32	s15, s15
  40aa74:	ee17 2a90 	vmov	r2, s15
  40aa78:	6bbb      	ldr	r3, [r7, #56]	; 0x38
  40aa7a:	009b      	lsls	r3, r3, #2
  40aa7c:	f107 0140 	add.w	r1, r7, #64	; 0x40
  40aa80:	440b      	add	r3, r1
  40aa82:	f843 2c2c 	str.w	r2, [r3, #-44]
	for(i = 0; i < 9; ++i)
  40aa86:	6bbb      	ldr	r3, [r7, #56]	; 0x38
  40aa88:	3301      	adds	r3, #1
  40aa8a:	63bb      	str	r3, [r7, #56]	; 0x38
  40aa8c:	6bbb      	ldr	r3, [r7, #56]	; 0x38
  40aa8e:	2b08      	cmp	r3, #8
  40aa90:	dde4      	ble.n	40aa5c <inv_icm20948_set_matrix+0x18>
	// Convert mounting matrix in char
	DmpDriver_convertion(s->mounting_matrix, mounting_mq30);
  40aa92:	68fb      	ldr	r3, [r7, #12]
  40aa94:	f503 731d 	add.w	r3, r3, #628	; 0x274
  40aa98:	f107 0214 	add.w	r2, r7, #20
  40aa9c:	4611      	mov	r1, r2
  40aa9e:	4618      	mov	r0, r3
  40aaa0:	4b15      	ldr	r3, [pc, #84]	; (40aaf8 <inv_icm20948_set_matrix+0xb4>)
  40aaa2:	4798      	blx	r3
	//Apply new matrix
	inv_icm20948_set_chip_to_body_axis_quaternion(s, s->mounting_matrix, 0.0);
  40aaa4:	68fb      	ldr	r3, [r7, #12]
  40aaa6:	f503 731d 	add.w	r3, r3, #628	; 0x274
  40aaaa:	ed9f 0a14 	vldr	s0, [pc, #80]	; 40aafc <inv_icm20948_set_matrix+0xb8>
  40aaae:	4619      	mov	r1, r3
  40aab0:	68f8      	ldr	r0, [r7, #12]
  40aab2:	4b13      	ldr	r3, [pc, #76]	; (40ab00 <inv_icm20948_set_matrix+0xbc>)
  40aab4:	4798      	blx	r3

	if ((sensor == INV_ICM20948_SENSOR_RAW_ACCELEROMETER) ||
  40aab6:	79fb      	ldrb	r3, [r7, #7]
  40aab8:	2b02      	cmp	r3, #2
  40aaba:	d00b      	beq.n	40aad4 <inv_icm20948_set_matrix+0x90>
  40aabc:	79fb      	ldrb	r3, [r7, #7]
  40aabe:	2b00      	cmp	r3, #0
  40aac0:	d008      	beq.n	40aad4 <inv_icm20948_set_matrix+0x90>
		(sensor == INV_ICM20948_SENSOR_ACCELEROMETER) ||
  40aac2:	79fb      	ldrb	r3, [r7, #7]
  40aac4:	2b03      	cmp	r3, #3
  40aac6:	d005      	beq.n	40aad4 <inv_icm20948_set_matrix+0x90>
		(sensor == INV_ICM20948_SENSOR_RAW_GYROSCOPE) ||
  40aac8:	79fb      	ldrb	r3, [r7, #7]
  40aaca:	2b01      	cmp	r3, #1
  40aacc:	d002      	beq.n	40aad4 <inv_icm20948_set_matrix+0x90>
		(sensor == INV_ICM20948_SENSOR_GYROSCOPE) ||
  40aace:	79fb      	ldrb	r3, [r7, #7]
  40aad0:	2b05      	cmp	r3, #5
  40aad2:	d109      	bne.n	40aae8 <inv_icm20948_set_matrix+0xa4>
		(sensor == INV_ICM20948_SENSOR_GYROSCOPE_UNCALIBRATED)) {
			//Update Dmp B2S according to new mmatrix in q30
			result |= dmp_icm20948_set_B2S_matrix(s, (int*)mounting_mq30);
  40aad4:	f107 0314 	add.w	r3, r7, #20
  40aad8:	4619      	mov	r1, r3
  40aada:	68f8      	ldr	r0, [r7, #12]
  40aadc:	4b09      	ldr	r3, [pc, #36]	; (40ab04 <inv_icm20948_set_matrix+0xc0>)
  40aade:	4798      	blx	r3
  40aae0:	4602      	mov	r2, r0
  40aae2:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
  40aae4:	4313      	orrs	r3, r2
  40aae6:	63fb      	str	r3, [r7, #60]	; 0x3c
	}

	return result;
  40aae8:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
}
  40aaea:	4618      	mov	r0, r3
  40aaec:	3740      	adds	r7, #64	; 0x40
  40aaee:	46bd      	mov	sp, r7
  40aaf0:	bd80      	pop	{r7, pc}
  40aaf2:	bf00      	nop
  40aaf4:	4e800000 	.word	0x4e800000
  40aaf8:	0040aa05 	.word	0x0040aa05
  40aafc:	00000000 	.word	0x00000000
  40ab00:	00406b41 	.word	0x00406b41
  40ab04:	00408695 	.word	0x00408695

0040ab08 <inv_icm20948_initialize_auxiliary>:

int inv_icm20948_initialize_auxiliary(struct inv_icm20948 * s)
{
  40ab08:	b580      	push	{r7, lr}
  40ab0a:	b082      	sub	sp, #8
  40ab0c:	af00      	add	r7, sp, #0
  40ab0e:	6078      	str	r0, [r7, #4]
	if (inv_icm20948_set_slave_compass_id(s, s->secondary_state.compass_slave_id) )
  40ab10:	687b      	ldr	r3, [r7, #4]
  40ab12:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
  40ab16:	4619      	mov	r1, r3
  40ab18:	6878      	ldr	r0, [r7, #4]
  40ab1a:	4b06      	ldr	r3, [pc, #24]	; (40ab34 <inv_icm20948_initialize_auxiliary+0x2c>)
  40ab1c:	4798      	blx	r3
  40ab1e:	4603      	mov	r3, r0
  40ab20:	2b00      	cmp	r3, #0
  40ab22:	d002      	beq.n	40ab2a <inv_icm20948_initialize_auxiliary+0x22>
		return -1;
  40ab24:	f04f 33ff 	mov.w	r3, #4294967295
  40ab28:	e000      	b.n	40ab2c <inv_icm20948_initialize_auxiliary+0x24>
	return 0;
  40ab2a:	2300      	movs	r3, #0
}
  40ab2c:	4618      	mov	r0, r3
  40ab2e:	3708      	adds	r7, #8
  40ab30:	46bd      	mov	sp, r7
  40ab32:	bd80      	pop	{r7, pc}
  40ab34:	00405e05 	.word	0x00405e05

0040ab38 <inv_icm20948_soft_reset>:

int inv_icm20948_soft_reset(struct inv_icm20948 * s)
{
  40ab38:	b580      	push	{r7, lr}
  40ab3a:	b084      	sub	sp, #16
  40ab3c:	af00      	add	r7, sp, #0
  40ab3e:	6078      	str	r0, [r7, #4]
	//soft reset like
	int rc = inv_icm20948_write_single_mems_reg(s, REG_PWR_MGMT_1, BIT_H_RESET);
  40ab40:	2280      	movs	r2, #128	; 0x80
  40ab42:	2106      	movs	r1, #6
  40ab44:	6878      	ldr	r0, [r7, #4]
  40ab46:	4b05      	ldr	r3, [pc, #20]	; (40ab5c <inv_icm20948_soft_reset+0x24>)
  40ab48:	4798      	blx	r3
  40ab4a:	60f8      	str	r0, [r7, #12]
	// max start-up time is 100 msec
	inv_icm20948_sleep_us(100000);
  40ab4c:	4804      	ldr	r0, [pc, #16]	; (40ab60 <inv_icm20948_soft_reset+0x28>)
  40ab4e:	4b05      	ldr	r3, [pc, #20]	; (40ab64 <inv_icm20948_soft_reset+0x2c>)
  40ab50:	4798      	blx	r3
	return rc;
  40ab52:	68fb      	ldr	r3, [r7, #12]
}
  40ab54:	4618      	mov	r0, r3
  40ab56:	3710      	adds	r7, #16
  40ab58:	46bd      	mov	sp, r7
  40ab5a:	bd80      	pop	{r7, pc}
  40ab5c:	0040c689 	.word	0x0040c689
  40ab60:	000186a0 	.word	0x000186a0
  40ab64:	004015f9 	.word	0x004015f9

0040ab68 <inv_icm20948_enable_sensor>:

int inv_icm20948_enable_sensor(struct inv_icm20948 * s, enum inv_icm20948_sensor sensor, inv_bool_t state)
{
  40ab68:	b590      	push	{r4, r7, lr}
  40ab6a:	b087      	sub	sp, #28
  40ab6c:	af00      	add	r7, sp, #0
  40ab6e:	60f8      	str	r0, [r7, #12]
  40ab70:	460b      	mov	r3, r1
  40ab72:	607a      	str	r2, [r7, #4]
  40ab74:	72fb      	strb	r3, [r7, #11]
	uint8_t androidSensor = sensor_type_2_android_sensor(sensor);
  40ab76:	7afb      	ldrb	r3, [r7, #11]
  40ab78:	4618      	mov	r0, r3
  40ab7a:	4b12      	ldr	r3, [pc, #72]	; (40abc4 <inv_icm20948_enable_sensor+0x5c>)
  40ab7c:	4798      	blx	r3
  40ab7e:	4603      	mov	r3, r0
  40ab80:	75fb      	strb	r3, [r7, #23]

	if(0!=inv_icm20948_ctrl_enable_sensor(s, androidSensor, state))
  40ab82:	687b      	ldr	r3, [r7, #4]
  40ab84:	b2da      	uxtb	r2, r3
  40ab86:	7dfb      	ldrb	r3, [r7, #23]
  40ab88:	4619      	mov	r1, r3
  40ab8a:	68f8      	ldr	r0, [r7, #12]
  40ab8c:	4b0e      	ldr	r3, [pc, #56]	; (40abc8 <inv_icm20948_enable_sensor+0x60>)
  40ab8e:	4798      	blx	r3
  40ab90:	4603      	mov	r3, r0
  40ab92:	2b00      	cmp	r3, #0
  40ab94:	d002      	beq.n	40ab9c <inv_icm20948_enable_sensor+0x34>
		return -1;
  40ab96:	f04f 33ff 	mov.w	r3, #4294967295
  40ab9a:	e00e      	b.n	40abba <inv_icm20948_enable_sensor+0x52>

	//In case we disable a sensor, we reset his timestamp
	if(state == 0)
  40ab9c:	687b      	ldr	r3, [r7, #4]
  40ab9e:	2b00      	cmp	r3, #0
  40aba0:	d10a      	bne.n	40abb8 <inv_icm20948_enable_sensor+0x50>
		s->timestamp[sensor] = 0;
  40aba2:	7afb      	ldrb	r3, [r7, #11]
  40aba4:	68fa      	ldr	r2, [r7, #12]
  40aba6:	3359      	adds	r3, #89	; 0x59
  40aba8:	00db      	lsls	r3, r3, #3
  40abaa:	441a      	add	r2, r3
  40abac:	f04f 0300 	mov.w	r3, #0
  40abb0:	f04f 0400 	mov.w	r4, #0
  40abb4:	e9c2 3400 	strd	r3, r4, [r2]

	return 0;
  40abb8:	2300      	movs	r3, #0
}
  40abba:	4618      	mov	r0, r3
  40abbc:	371c      	adds	r7, #28
  40abbe:	46bd      	mov	sp, r7
  40abc0:	bd90      	pop	{r4, r7, pc}
  40abc2:	bf00      	nop
  40abc4:	0040a501 	.word	0x0040a501
  40abc8:	004119d5 	.word	0x004119d5

0040abcc <inv_icm20948_set_sensor_period>:

int inv_icm20948_set_sensor_period(struct inv_icm20948 * s, enum inv_icm20948_sensor sensor, uint32_t period)
{
  40abcc:	b590      	push	{r4, r7, lr}
  40abce:	b087      	sub	sp, #28
  40abd0:	af00      	add	r7, sp, #0
  40abd2:	60f8      	str	r0, [r7, #12]
  40abd4:	460b      	mov	r3, r1
  40abd6:	607a      	str	r2, [r7, #4]
  40abd8:	72fb      	strb	r3, [r7, #11]
	uint8_t androidSensor = sensor_type_2_android_sensor(sensor);
  40abda:	7afb      	ldrb	r3, [r7, #11]
  40abdc:	4618      	mov	r0, r3
  40abde:	4b17      	ldr	r3, [pc, #92]	; (40ac3c <inv_icm20948_set_sensor_period+0x70>)
  40abe0:	4798      	blx	r3
  40abe2:	4603      	mov	r3, r0
  40abe4:	75fb      	strb	r3, [r7, #23]

	if(0!=inv_icm20948_set_odr(s, androidSensor, period))
  40abe6:	687b      	ldr	r3, [r7, #4]
  40abe8:	b29a      	uxth	r2, r3
  40abea:	7dfb      	ldrb	r3, [r7, #23]
  40abec:	4619      	mov	r1, r3
  40abee:	68f8      	ldr	r0, [r7, #12]
  40abf0:	4b13      	ldr	r3, [pc, #76]	; (40ac40 <inv_icm20948_set_sensor_period+0x74>)
  40abf2:	4798      	blx	r3
  40abf4:	4603      	mov	r3, r0
  40abf6:	2b00      	cmp	r3, #0
  40abf8:	d002      	beq.n	40ac00 <inv_icm20948_set_sensor_period+0x34>
		return -1;
  40abfa:	f04f 33ff 	mov.w	r3, #4294967295
  40abfe:	e019      	b.n	40ac34 <inv_icm20948_set_sensor_period+0x68>

	// reset timestamp value and save current odr
	s->timestamp[sensor] = 0;
  40ac00:	7afb      	ldrb	r3, [r7, #11]
  40ac02:	68fa      	ldr	r2, [r7, #12]
  40ac04:	3359      	adds	r3, #89	; 0x59
  40ac06:	00db      	lsls	r3, r3, #3
  40ac08:	441a      	add	r2, r3
  40ac0a:	f04f 0300 	mov.w	r3, #0
  40ac0e:	f04f 0400 	mov.w	r4, #0
  40ac12:	e9c2 3400 	strd	r3, r4, [r2]
	s->sensorlist[sensor].odr_us = period * 1000;
  40ac16:	7afa      	ldrb	r2, [r7, #11]
  40ac18:	687b      	ldr	r3, [r7, #4]
  40ac1a:	f44f 717a 	mov.w	r1, #1000	; 0x3e8
  40ac1e:	fb01 f303 	mul.w	r3, r1, r3
  40ac22:	f04f 0400 	mov.w	r4, #0
  40ac26:	68f9      	ldr	r1, [r7, #12]
  40ac28:	3239      	adds	r2, #57	; 0x39
  40ac2a:	0112      	lsls	r2, r2, #4
  40ac2c:	440a      	add	r2, r1
  40ac2e:	e9c2 3400 	strd	r3, r4, [r2]
	return 0;
  40ac32:	2300      	movs	r3, #0
}
  40ac34:	4618      	mov	r0, r3
  40ac36:	371c      	adds	r7, #28
  40ac38:	46bd      	mov	sp, r7
  40ac3a:	bd90      	pop	{r4, r7, pc}
  40ac3c:	0040a501 	.word	0x0040a501
  40ac40:	004113f1 	.word	0x004113f1

0040ac44 <inv_icm20948_load>:
	}
	return 0;
}

int inv_icm20948_load(struct inv_icm20948 * s, const uint8_t * image, unsigned short size)
{
  40ac44:	b590      	push	{r4, r7, lr}
  40ac46:	b085      	sub	sp, #20
  40ac48:	af00      	add	r7, sp, #0
  40ac4a:	60f8      	str	r0, [r7, #12]
  40ac4c:	60b9      	str	r1, [r7, #8]
  40ac4e:	4613      	mov	r3, r2
  40ac50:	80fb      	strh	r3, [r7, #6]
	return inv_icm20948_firmware_load(s, image, size, DMP_LOAD_START);
  40ac52:	88fa      	ldrh	r2, [r7, #6]
  40ac54:	2390      	movs	r3, #144	; 0x90
  40ac56:	68b9      	ldr	r1, [r7, #8]
  40ac58:	68f8      	ldr	r0, [r7, #12]
  40ac5a:	4c03      	ldr	r4, [pc, #12]	; (40ac68 <inv_icm20948_load+0x24>)
  40ac5c:	47a0      	blx	r4
  40ac5e:	4603      	mov	r3, r0
}
  40ac60:	4618      	mov	r0, r3
  40ac62:	3714      	adds	r7, #20
  40ac64:	46bd      	mov	sp, r7
  40ac66:	bd90      	pop	{r4, r7, pc}
  40ac68:	0040885d 	.word	0x0040885d

0040ac6c <inv_icm20948_is_streamed_sensor>:

/** @brief Returns 1 if the sensor id is a streamed sensor and not an event-based sensor */
static int inv_icm20948_is_streamed_sensor(uint8_t id)
{
  40ac6c:	b480      	push	{r7}
  40ac6e:	b083      	sub	sp, #12
  40ac70:	af00      	add	r7, sp, #0
  40ac72:	4603      	mov	r3, r0
  40ac74:	71fb      	strb	r3, [r7, #7]
	switch(id)
  40ac76:	79fb      	ldrb	r3, [r7, #7]
  40ac78:	3b11      	subs	r3, #17
  40ac7a:	2b1e      	cmp	r3, #30
  40ac7c:	d842      	bhi.n	40ad04 <inv_icm20948_is_streamed_sensor+0x98>
  40ac7e:	a201      	add	r2, pc, #4	; (adr r2, 40ac84 <inv_icm20948_is_streamed_sensor+0x18>)
  40ac80:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
  40ac84:	0040ad01 	.word	0x0040ad01
  40ac88:	0040ad01 	.word	0x0040ad01
  40ac8c:	0040ad01 	.word	0x0040ad01
  40ac90:	0040ad05 	.word	0x0040ad05
  40ac94:	0040ad05 	.word	0x0040ad05
  40ac98:	0040ad05 	.word	0x0040ad05
  40ac9c:	0040ad05 	.word	0x0040ad05
  40aca0:	0040ad05 	.word	0x0040ad05
  40aca4:	0040ad05 	.word	0x0040ad05
  40aca8:	0040ad05 	.word	0x0040ad05
  40acac:	0040ad05 	.word	0x0040ad05
  40acb0:	0040ad05 	.word	0x0040ad05
  40acb4:	0040ad05 	.word	0x0040ad05
  40acb8:	0040ad05 	.word	0x0040ad05
  40acbc:	0040ad05 	.word	0x0040ad05
  40acc0:	0040ad05 	.word	0x0040ad05
  40acc4:	0040ad05 	.word	0x0040ad05
  40acc8:	0040ad05 	.word	0x0040ad05
  40accc:	0040ad05 	.word	0x0040ad05
  40acd0:	0040ad05 	.word	0x0040ad05
  40acd4:	0040ad05 	.word	0x0040ad05
  40acd8:	0040ad05 	.word	0x0040ad05
  40acdc:	0040ad05 	.word	0x0040ad05
  40ace0:	0040ad05 	.word	0x0040ad05
  40ace4:	0040ad01 	.word	0x0040ad01
  40ace8:	0040ad05 	.word	0x0040ad05
  40acec:	0040ad05 	.word	0x0040ad05
  40acf0:	0040ad05 	.word	0x0040ad05
  40acf4:	0040ad01 	.word	0x0040ad01
  40acf8:	0040ad01 	.word	0x0040ad01
  40acfc:	0040ad01 	.word	0x0040ad01
	case ANDROID_SENSOR_FLIP_PICKUP :
	case ANDROID_SENSOR_B2S :
	case ANDROID_SENSOR_STEP_COUNTER:
	case ANDROID_SENSOR_WAKEUP_SIGNIFICANT_MOTION :
	case ANDROID_SENSOR_STEP_DETECTOR :
		return 0;
  40ad00:	2300      	movs	r3, #0
  40ad02:	e000      	b.n	40ad06 <inv_icm20948_is_streamed_sensor+0x9a>
	default :
		return 1;
  40ad04:	2301      	movs	r3, #1
	}
}
  40ad06:	4618      	mov	r0, r3
  40ad08:	370c      	adds	r7, #12
  40ad0a:	46bd      	mov	sp, r7
  40ad0c:	f85d 7b04 	ldr.w	r7, [sp], #4
  40ad10:	4770      	bx	lr
  40ad12:	bf00      	nop

0040ad14 <inv_icm20948_updateTs>:

/** @brief Preprocess all timestamps so that they either contain very last time at which MEMS IRQ was fired
* or last time sent for the sensor + ODR */
static uint8_t inv_icm20948_updateTs(struct inv_icm20948 * s, int * data_left_in_fifo,
	unsigned short * total_sample_cnt, uint64_t * lastIrqTimeUs)
{
  40ad14:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
  40ad18:	b0a1      	sub	sp, #132	; 0x84
  40ad1a:	af00      	add	r7, sp, #0
  40ad1c:	60f8      	str	r0, [r7, #12]
  40ad1e:	60b9      	str	r1, [r7, #8]
  40ad20:	607a      	str	r2, [r7, #4]
  40ad22:	603b      	str	r3, [r7, #0]
	/** @brief Very last time in us at which IRQ was fired since flushing FIFO process was started */
	unsigned short sample_cnt_array[GENERAL_SENSORS_MAX] = {0};
  40ad24:	f107 0314 	add.w	r3, r7, #20
  40ad28:	2266      	movs	r2, #102	; 0x66
  40ad2a:	2100      	movs	r1, #0
  40ad2c:	4618      	mov	r0, r3
  40ad2e:	4bbd      	ldr	r3, [pc, #756]	; (40b024 <inv_icm20948_updateTs+0x310>)
  40ad30:	4798      	blx	r3
	uint8_t i;

	memset(sample_cnt_array, 0, sizeof(sample_cnt_array));
  40ad32:	f107 0314 	add.w	r3, r7, #20
  40ad36:	2266      	movs	r2, #102	; 0x66
  40ad38:	2100      	movs	r1, #0
  40ad3a:	4618      	mov	r0, r3
  40ad3c:	4bb9      	ldr	r3, [pc, #740]	; (40b024 <inv_icm20948_updateTs+0x310>)
  40ad3e:	4798      	blx	r3
	if (inv_icm20948_fifo_swmirror(s, data_left_in_fifo, total_sample_cnt, sample_cnt_array)) {
  40ad40:	f107 0314 	add.w	r3, r7, #20
  40ad44:	687a      	ldr	r2, [r7, #4]
  40ad46:	68b9      	ldr	r1, [r7, #8]
  40ad48:	68f8      	ldr	r0, [r7, #12]
  40ad4a:	4cb7      	ldr	r4, [pc, #732]	; (40b028 <inv_icm20948_updateTs+0x314>)
  40ad4c:	47a0      	blx	r4
  40ad4e:	4603      	mov	r3, r0
  40ad50:	2b00      	cmp	r3, #0
  40ad52:	d026      	beq.n	40ada2 <inv_icm20948_updateTs+0x8e>
		for(i = 0; i< GENERAL_SENSORS_MAX; i++) {
  40ad54:	2300      	movs	r3, #0
  40ad56:	f887 307f 	strb.w	r3, [r7, #127]	; 0x7f
  40ad5a:	e01c      	b.n	40ad96 <inv_icm20948_updateTs+0x82>
			if (inv_icm20948_is_streamed_sensor(i)) {
  40ad5c:	f897 307f 	ldrb.w	r3, [r7, #127]	; 0x7f
  40ad60:	4618      	mov	r0, r3
  40ad62:	4bb2      	ldr	r3, [pc, #712]	; (40b02c <inv_icm20948_updateTs+0x318>)
  40ad64:	4798      	blx	r3
  40ad66:	4603      	mov	r3, r0
  40ad68:	2b00      	cmp	r3, #0
  40ad6a:	d00f      	beq.n	40ad8c <inv_icm20948_updateTs+0x78>
				s->timestamp[inv_icm20948_sensor_android_2_sensor_type(i)] = *lastIrqTimeUs;
  40ad6c:	f897 307f 	ldrb.w	r3, [r7, #127]	; 0x7f
  40ad70:	4618      	mov	r0, r3
  40ad72:	4baf      	ldr	r3, [pc, #700]	; (40b030 <inv_icm20948_updateTs+0x31c>)
  40ad74:	4798      	blx	r3
  40ad76:	4603      	mov	r3, r0
  40ad78:	461a      	mov	r2, r3
  40ad7a:	683b      	ldr	r3, [r7, #0]
  40ad7c:	e9d3 3400 	ldrd	r3, r4, [r3]
  40ad80:	68f9      	ldr	r1, [r7, #12]
  40ad82:	3259      	adds	r2, #89	; 0x59
  40ad84:	00d2      	lsls	r2, r2, #3
  40ad86:	440a      	add	r2, r1
  40ad88:	e9c2 3400 	strd	r3, r4, [r2]
		for(i = 0; i< GENERAL_SENSORS_MAX; i++) {
  40ad8c:	f897 307f 	ldrb.w	r3, [r7, #127]	; 0x7f
  40ad90:	3301      	adds	r3, #1
  40ad92:	f887 307f 	strb.w	r3, [r7, #127]	; 0x7f
  40ad96:	f897 307f 	ldrb.w	r3, [r7, #127]	; 0x7f
  40ad9a:	2b32      	cmp	r3, #50	; 0x32
  40ad9c:	d9de      	bls.n	40ad5c <inv_icm20948_updateTs+0x48>
			}
		}
		return -1;
  40ad9e:	23ff      	movs	r3, #255	; 0xff
  40ada0:	e13b      	b.n	40b01a <inv_icm20948_updateTs+0x306>
	}
	// we parse all senosr according to android type
	for (i = 0; i < GENERAL_SENSORS_MAX; i++) {
  40ada2:	2300      	movs	r3, #0
  40ada4:	f887 307f 	strb.w	r3, [r7, #127]	; 0x7f
  40ada8:	e131      	b.n	40b00e <inv_icm20948_updateTs+0x2fa>
		if (inv_icm20948_is_streamed_sensor(i)) {
  40adaa:	f897 307f 	ldrb.w	r3, [r7, #127]	; 0x7f
  40adae:	4618      	mov	r0, r3
  40adb0:	4b9e      	ldr	r3, [pc, #632]	; (40b02c <inv_icm20948_updateTs+0x318>)
  40adb2:	4798      	blx	r3
  40adb4:	4603      	mov	r3, r0
  40adb6:	2b00      	cmp	r3, #0
  40adb8:	f000 8114 	beq.w	40afe4 <inv_icm20948_updateTs+0x2d0>
			if (sample_cnt_array[i]) {
  40adbc:	f897 307f 	ldrb.w	r3, [r7, #127]	; 0x7f
  40adc0:	005b      	lsls	r3, r3, #1
  40adc2:	f107 0280 	add.w	r2, r7, #128	; 0x80
  40adc6:	4413      	add	r3, r2
  40adc8:	f833 3c6c 	ldrh.w	r3, [r3, #-108]
  40adcc:	2b00      	cmp	r3, #0
  40adce:	f000 8119 	beq.w	40b004 <inv_icm20948_updateTs+0x2f0>
				/** Number of samples present in MEMS FIFO last time we mirrored it */
				unsigned short fifo_sample_cnt = sample_cnt_array[i];
  40add2:	f897 307f 	ldrb.w	r3, [r7, #127]	; 0x7f
  40add6:	005b      	lsls	r3, r3, #1
  40add8:	f107 0280 	add.w	r2, r7, #128	; 0x80
  40addc:	4413      	add	r3, r2
  40adde:	f833 3c6c 	ldrh.w	r3, [r3, #-108]
  40ade2:	f8a7 307c 	strh.w	r3, [r7, #124]	; 0x7c

				/** In case of first batch we have less than the expected number of samples in the batch */
				/** To avoid a bad timestamping we recompute the startup time based on the theorical ODR and the number of samples */
				if (s->sFirstBatch[inv_icm20948_sensor_android_2_sensor_type(i)]) {
  40ade6:	f897 307f 	ldrb.w	r3, [r7, #127]	; 0x7f
  40adea:	4618      	mov	r0, r3
  40adec:	4b90      	ldr	r3, [pc, #576]	; (40b030 <inv_icm20948_updateTs+0x31c>)
  40adee:	4798      	blx	r3
  40adf0:	4603      	mov	r3, r0
  40adf2:	461a      	mov	r2, r3
  40adf4:	68fb      	ldr	r3, [r7, #12]
  40adf6:	4413      	add	r3, r2
  40adf8:	f893 3370 	ldrb.w	r3, [r3, #880]	; 0x370
  40adfc:	2b00      	cmp	r3, #0
  40adfe:	d058      	beq.n	40aeb2 <inv_icm20948_updateTs+0x19e>
					s->timestamp[inv_icm20948_sensor_android_2_sensor_type(i)] += *lastIrqTimeUs-s->timestamp[inv_icm20948_sensor_android_2_sensor_type(i)]
  40ae00:	683b      	ldr	r3, [r7, #0]
  40ae02:	e9d3 5600 	ldrd	r5, r6, [r3]
  40ae06:	f897 307f 	ldrb.w	r3, [r7, #127]	; 0x7f
  40ae0a:	4618      	mov	r0, r3
  40ae0c:	4b88      	ldr	r3, [pc, #544]	; (40b030 <inv_icm20948_updateTs+0x31c>)
  40ae0e:	4798      	blx	r3
  40ae10:	4603      	mov	r3, r0
  40ae12:	68fa      	ldr	r2, [r7, #12]
  40ae14:	3359      	adds	r3, #89	; 0x59
  40ae16:	00db      	lsls	r3, r3, #3
  40ae18:	4413      	add	r3, r2
  40ae1a:	e9d3 3400 	ldrd	r3, r4, [r3]
  40ae1e:	1aed      	subs	r5, r5, r3
  40ae20:	eb66 0604 	sbc.w	r6, r6, r4
  40ae24:	46a8      	mov	r8, r5
  40ae26:	46b1      	mov	r9, r6
					- fifo_sample_cnt*s->sensorlist[inv_icm20948_sensor_android_2_sensor_type(i)].odr_us;
  40ae28:	f8b7 507c 	ldrh.w	r5, [r7, #124]	; 0x7c
  40ae2c:	f04f 0600 	mov.w	r6, #0
  40ae30:	f897 307f 	ldrb.w	r3, [r7, #127]	; 0x7f
  40ae34:	4618      	mov	r0, r3
  40ae36:	4b7e      	ldr	r3, [pc, #504]	; (40b030 <inv_icm20948_updateTs+0x31c>)
  40ae38:	4798      	blx	r3
  40ae3a:	4603      	mov	r3, r0
  40ae3c:	68fa      	ldr	r2, [r7, #12]
  40ae3e:	3339      	adds	r3, #57	; 0x39
  40ae40:	011b      	lsls	r3, r3, #4
  40ae42:	4413      	add	r3, r2
  40ae44:	e9d3 3400 	ldrd	r3, r4, [r3]
  40ae48:	fb03 f106 	mul.w	r1, r3, r6
  40ae4c:	fb05 f204 	mul.w	r2, r5, r4
  40ae50:	440a      	add	r2, r1
  40ae52:	fba5 3403 	umull	r3, r4, r5, r3
  40ae56:	4422      	add	r2, r4
  40ae58:	4614      	mov	r4, r2
  40ae5a:	ebb8 0803 	subs.w	r8, r8, r3
  40ae5e:	eb69 0904 	sbc.w	r9, r9, r4
  40ae62:	4644      	mov	r4, r8
  40ae64:	464d      	mov	r5, r9
					s->timestamp[inv_icm20948_sensor_android_2_sensor_type(i)] += *lastIrqTimeUs-s->timestamp[inv_icm20948_sensor_android_2_sensor_type(i)]
  40ae66:	f897 307f 	ldrb.w	r3, [r7, #127]	; 0x7f
  40ae6a:	4618      	mov	r0, r3
  40ae6c:	4b70      	ldr	r3, [pc, #448]	; (40b030 <inv_icm20948_updateTs+0x31c>)
  40ae6e:	4798      	blx	r3
  40ae70:	4603      	mov	r3, r0
  40ae72:	4618      	mov	r0, r3
  40ae74:	68fa      	ldr	r2, [r7, #12]
  40ae76:	3359      	adds	r3, #89	; 0x59
  40ae78:	00db      	lsls	r3, r3, #3
  40ae7a:	4413      	add	r3, r2
  40ae7c:	e9d3 2300 	ldrd	r2, r3, [r3]
  40ae80:	eb12 0804 	adds.w	r8, r2, r4
  40ae84:	eb43 0905 	adc.w	r9, r3, r5
  40ae88:	4643      	mov	r3, r8
  40ae8a:	464c      	mov	r4, r9
  40ae8c:	68f9      	ldr	r1, [r7, #12]
  40ae8e:	f100 0259 	add.w	r2, r0, #89	; 0x59
  40ae92:	00d2      	lsls	r2, r2, #3
  40ae94:	440a      	add	r2, r1
  40ae96:	e9c2 3400 	strd	r3, r4, [r2]
					s->sFirstBatch[inv_icm20948_sensor_android_2_sensor_type(i)] = 0;
  40ae9a:	f897 307f 	ldrb.w	r3, [r7, #127]	; 0x7f
  40ae9e:	4618      	mov	r0, r3
  40aea0:	4b63      	ldr	r3, [pc, #396]	; (40b030 <inv_icm20948_updateTs+0x31c>)
  40aea2:	4798      	blx	r3
  40aea4:	4603      	mov	r3, r0
  40aea6:	461a      	mov	r2, r3
  40aea8:	68fb      	ldr	r3, [r7, #12]
  40aeaa:	4413      	add	r3, r2
  40aeac:	2200      	movs	r2, #0
  40aeae:	f883 2370 	strb.w	r2, [r3, #880]	; 0x370
				first time to be printed is t1+(t2-t1)/N
				- t1 is last time we sent data
				- t2 is when IRQ was fired so that we pop the FIFO
				- N is number of samples */

				if(s->timestamp[inv_icm20948_sensor_android_2_sensor_type(i)] == 0) {
  40aeb2:	f897 307f 	ldrb.w	r3, [r7, #127]	; 0x7f
  40aeb6:	4618      	mov	r0, r3
  40aeb8:	4b5d      	ldr	r3, [pc, #372]	; (40b030 <inv_icm20948_updateTs+0x31c>)
  40aeba:	4798      	blx	r3
  40aebc:	4603      	mov	r3, r0
  40aebe:	68fa      	ldr	r2, [r7, #12]
  40aec0:	3359      	adds	r3, #89	; 0x59
  40aec2:	00db      	lsls	r3, r3, #3
  40aec4:	4413      	add	r3, r2
  40aec6:	e9d3 3400 	ldrd	r3, r4, [r3]
  40aeca:	4323      	orrs	r3, r4
  40aecc:	d15c      	bne.n	40af88 <inv_icm20948_updateTs+0x274>
					s->timestamp[inv_icm20948_sensor_android_2_sensor_type(i)] = *lastIrqTimeUs;
  40aece:	f897 307f 	ldrb.w	r3, [r7, #127]	; 0x7f
  40aed2:	4618      	mov	r0, r3
  40aed4:	4b56      	ldr	r3, [pc, #344]	; (40b030 <inv_icm20948_updateTs+0x31c>)
  40aed6:	4798      	blx	r3
  40aed8:	4603      	mov	r3, r0
  40aeda:	461a      	mov	r2, r3
  40aedc:	683b      	ldr	r3, [r7, #0]
  40aede:	e9d3 3400 	ldrd	r3, r4, [r3]
  40aee2:	68f9      	ldr	r1, [r7, #12]
  40aee4:	3259      	adds	r2, #89	; 0x59
  40aee6:	00d2      	lsls	r2, r2, #3
  40aee8:	440a      	add	r2, r1
  40aeea:	e9c2 3400 	strd	r3, r4, [r2]
					s->timestamp[inv_icm20948_sensor_android_2_sensor_type(i)] -= s->sensorlist[inv_icm20948_sensor_android_2_sensor_type(i)].odr_us*(fifo_sample_cnt);
  40aeee:	f897 307f 	ldrb.w	r3, [r7, #127]	; 0x7f
  40aef2:	4618      	mov	r0, r3
  40aef4:	4b4e      	ldr	r3, [pc, #312]	; (40b030 <inv_icm20948_updateTs+0x31c>)
  40aef6:	4798      	blx	r3
  40aef8:	4603      	mov	r3, r0
  40aefa:	68fa      	ldr	r2, [r7, #12]
  40aefc:	3339      	adds	r3, #57	; 0x39
  40aefe:	011b      	lsls	r3, r3, #4
  40af00:	4413      	add	r3, r2
  40af02:	e9d3 1200 	ldrd	r1, r2, [r3]
  40af06:	f8b7 307c 	ldrh.w	r3, [r7, #124]	; 0x7c
  40af0a:	f04f 0400 	mov.w	r4, #0
  40af0e:	fb03 f502 	mul.w	r5, r3, r2
  40af12:	fb01 f004 	mul.w	r0, r1, r4
  40af16:	4428      	add	r0, r5
  40af18:	fba1 4503 	umull	r4, r5, r1, r3
  40af1c:	1943      	adds	r3, r0, r5
  40af1e:	461d      	mov	r5, r3
  40af20:	f897 307f 	ldrb.w	r3, [r7, #127]	; 0x7f
  40af24:	4618      	mov	r0, r3
  40af26:	4b42      	ldr	r3, [pc, #264]	; (40b030 <inv_icm20948_updateTs+0x31c>)
  40af28:	4798      	blx	r3
  40af2a:	4603      	mov	r3, r0
  40af2c:	4618      	mov	r0, r3
  40af2e:	68fa      	ldr	r2, [r7, #12]
  40af30:	3359      	adds	r3, #89	; 0x59
  40af32:	00db      	lsls	r3, r3, #3
  40af34:	4413      	add	r3, r2
  40af36:	e9d3 2300 	ldrd	r2, r3, [r3]
  40af3a:	1b12      	subs	r2, r2, r4
  40af3c:	eb63 0305 	sbc.w	r3, r3, r5
  40af40:	461c      	mov	r4, r3
  40af42:	4613      	mov	r3, r2
  40af44:	68f9      	ldr	r1, [r7, #12]
  40af46:	f100 0259 	add.w	r2, r0, #89	; 0x59
  40af4a:	00d2      	lsls	r2, r2, #3
  40af4c:	440a      	add	r2, r1
  40af4e:	e9c2 3400 	strd	r3, r4, [r2]
					s->sensorlist[inv_icm20948_sensor_android_2_sensor_type(i)].odr_applied_us = s->sensorlist[inv_icm20948_sensor_android_2_sensor_type(i)].odr_us;
  40af52:	f897 307f 	ldrb.w	r3, [r7, #127]	; 0x7f
  40af56:	4618      	mov	r0, r3
  40af58:	4b35      	ldr	r3, [pc, #212]	; (40b030 <inv_icm20948_updateTs+0x31c>)
  40af5a:	4798      	blx	r3
  40af5c:	4603      	mov	r3, r0
  40af5e:	461d      	mov	r5, r3
  40af60:	f897 307f 	ldrb.w	r3, [r7, #127]	; 0x7f
  40af64:	4618      	mov	r0, r3
  40af66:	4b32      	ldr	r3, [pc, #200]	; (40b030 <inv_icm20948_updateTs+0x31c>)
  40af68:	4798      	blx	r3
  40af6a:	4603      	mov	r3, r0
  40af6c:	68fa      	ldr	r2, [r7, #12]
  40af6e:	3339      	adds	r3, #57	; 0x39
  40af70:	011b      	lsls	r3, r3, #4
  40af72:	4413      	add	r3, r2
  40af74:	e9d3 3400 	ldrd	r3, r4, [r3]
  40af78:	68f9      	ldr	r1, [r7, #12]
  40af7a:	012a      	lsls	r2, r5, #4
  40af7c:	440a      	add	r2, r1
  40af7e:	f502 7262 	add.w	r2, r2, #904	; 0x388
  40af82:	e9c2 3400 	strd	r3, r4, [r2]
  40af86:	e03d      	b.n	40b004 <inv_icm20948_updateTs+0x2f0>
				}
				else {
					s->sensorlist[inv_icm20948_sensor_android_2_sensor_type(i)].odr_applied_us = (*lastIrqTimeUs-s->timestamp[inv_icm20948_sensor_android_2_sensor_type(i)])/fifo_sample_cnt;
  40af88:	f897 307f 	ldrb.w	r3, [r7, #127]	; 0x7f
  40af8c:	4618      	mov	r0, r3
  40af8e:	4b28      	ldr	r3, [pc, #160]	; (40b030 <inv_icm20948_updateTs+0x31c>)
  40af90:	4798      	blx	r3
  40af92:	4603      	mov	r3, r0
  40af94:	4698      	mov	r8, r3
  40af96:	683b      	ldr	r3, [r7, #0]
  40af98:	e9d3 5600 	ldrd	r5, r6, [r3]
  40af9c:	f897 307f 	ldrb.w	r3, [r7, #127]	; 0x7f
  40afa0:	4618      	mov	r0, r3
  40afa2:	4b23      	ldr	r3, [pc, #140]	; (40b030 <inv_icm20948_updateTs+0x31c>)
  40afa4:	4798      	blx	r3
  40afa6:	4603      	mov	r3, r0
  40afa8:	68fa      	ldr	r2, [r7, #12]
  40afaa:	3359      	adds	r3, #89	; 0x59
  40afac:	00db      	lsls	r3, r3, #3
  40afae:	4413      	add	r3, r2
  40afb0:	e9d3 3400 	ldrd	r3, r4, [r3]
  40afb4:	4628      	mov	r0, r5
  40afb6:	4631      	mov	r1, r6
  40afb8:	1ac0      	subs	r0, r0, r3
  40afba:	eb61 0104 	sbc.w	r1, r1, r4
  40afbe:	f8b7 307c 	ldrh.w	r3, [r7, #124]	; 0x7c
  40afc2:	f04f 0400 	mov.w	r4, #0
  40afc6:	4d1b      	ldr	r5, [pc, #108]	; (40b034 <inv_icm20948_updateTs+0x320>)
  40afc8:	461a      	mov	r2, r3
  40afca:	4623      	mov	r3, r4
  40afcc:	47a8      	blx	r5
  40afce:	4603      	mov	r3, r0
  40afd0:	460c      	mov	r4, r1
  40afd2:	68f9      	ldr	r1, [r7, #12]
  40afd4:	ea4f 1208 	mov.w	r2, r8, lsl #4
  40afd8:	440a      	add	r2, r1
  40afda:	f502 7262 	add.w	r2, r2, #904	; 0x388
  40afde:	e9c2 3400 	strd	r3, r4, [r2]
  40afe2:	e00f      	b.n	40b004 <inv_icm20948_updateTs+0x2f0>
				}
			}
		} else {
			/** update timestamp for all event sensors with time at which MEMS IRQ was fired */
			s->timestamp[inv_icm20948_sensor_android_2_sensor_type(i)] = *lastIrqTimeUs;
  40afe4:	f897 307f 	ldrb.w	r3, [r7, #127]	; 0x7f
  40afe8:	4618      	mov	r0, r3
  40afea:	4b11      	ldr	r3, [pc, #68]	; (40b030 <inv_icm20948_updateTs+0x31c>)
  40afec:	4798      	blx	r3
  40afee:	4603      	mov	r3, r0
  40aff0:	461a      	mov	r2, r3
  40aff2:	683b      	ldr	r3, [r7, #0]
  40aff4:	e9d3 3400 	ldrd	r3, r4, [r3]
  40aff8:	68f9      	ldr	r1, [r7, #12]
  40affa:	3259      	adds	r2, #89	; 0x59
  40affc:	00d2      	lsls	r2, r2, #3
  40affe:	440a      	add	r2, r1
  40b000:	e9c2 3400 	strd	r3, r4, [r2]
	for (i = 0; i < GENERAL_SENSORS_MAX; i++) {
  40b004:	f897 307f 	ldrb.w	r3, [r7, #127]	; 0x7f
  40b008:	3301      	adds	r3, #1
  40b00a:	f887 307f 	strb.w	r3, [r7, #127]	; 0x7f
  40b00e:	f897 307f 	ldrb.w	r3, [r7, #127]	; 0x7f
  40b012:	2b32      	cmp	r3, #50	; 0x32
  40b014:	f67f aec9 	bls.w	40adaa <inv_icm20948_updateTs+0x96>
		}
	}

	return 0;
  40b018:	2300      	movs	r3, #0
}
  40b01a:	4618      	mov	r0, r3
  40b01c:	3784      	adds	r7, #132	; 0x84
  40b01e:	46bd      	mov	sp, r7
  40b020:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
  40b024:	00414241 	.word	0x00414241
  40b028:	00409141 	.word	0x00409141
  40b02c:	0040ac6d 	.word	0x0040ac6d
  40b030:	0040a5c9 	.word	0x0040a5c9
  40b034:	00413c79 	.word	0x00413c79

0040b038 <inv_icm20948_poll_sensor>:

int inv_icm20948_poll_sensor(struct inv_icm20948 * s, void * context,
	void (*handler)(void * context, enum inv_icm20948_sensor sensor, uint64_t timestamp, const void * data, const void *arg))
{
  40b038:	b5b0      	push	{r4, r5, r7, lr}
  40b03a:	f5ad 7d08 	sub.w	sp, sp, #544	; 0x220
  40b03e:	af02      	add	r7, sp, #8
  40b040:	f107 030c 	add.w	r3, r7, #12
  40b044:	6018      	str	r0, [r3, #0]
  40b046:	f107 0308 	add.w	r3, r7, #8
  40b04a:	6019      	str	r1, [r3, #0]
  40b04c:	1d3b      	adds	r3, r7, #4
  40b04e:	601a      	str	r2, [r3, #0]
	short int_read_back=0;
  40b050:	2300      	movs	r3, #0
  40b052:	f8a7 31f2 	strh.w	r3, [r7, #498]	; 0x1f2
	unsigned short header=0, header2 = 0;
  40b056:	2300      	movs	r3, #0
  40b058:	f8a7 31f0 	strh.w	r3, [r7, #496]	; 0x1f0
  40b05c:	2300      	movs	r3, #0
  40b05e:	f8a7 31ee 	strh.w	r3, [r7, #494]	; 0x1ee
	int data_left_in_fifo=0;
  40b062:	2300      	movs	r3, #0
  40b064:	f8c7 31e8 	str.w	r3, [r7, #488]	; 0x1e8
	short short_data[3] = {0};
  40b068:	f507 73f0 	add.w	r3, r7, #480	; 0x1e0
  40b06c:	2200      	movs	r2, #0
  40b06e:	601a      	str	r2, [r3, #0]
  40b070:	809a      	strh	r2, [r3, #4]
	signed long  long_data[3] = {0};
  40b072:	f507 73ea 	add.w	r3, r7, #468	; 0x1d4
  40b076:	2200      	movs	r2, #0
  40b078:	601a      	str	r2, [r3, #0]
  40b07a:	605a      	str	r2, [r3, #4]
  40b07c:	609a      	str	r2, [r3, #8]
	signed long  long_quat[3] = {0};
  40b07e:	f507 73e4 	add.w	r3, r7, #456	; 0x1c8
  40b082:	2200      	movs	r2, #0
  40b084:	601a      	str	r2, [r3, #0]
  40b086:	605a      	str	r2, [r3, #4]
  40b088:	609a      	str	r2, [r3, #8]
	float gyro_raw_float[3];
	float gyro_bias_float[3];
	int gyro_accuracy = 0;
  40b08a:	2300      	movs	r3, #0
  40b08c:	f8c7 3210 	str.w	r3, [r7, #528]	; 0x210
	int dummy_accuracy = 0;
  40b090:	2300      	movs	r3, #0
  40b092:	f8c7 31ac 	str.w	r3, [r7, #428]	; 0x1ac
	int accel_accuracy = 0;
  40b096:	2300      	movs	r3, #0
  40b098:	f8c7 31a8 	str.w	r3, [r7, #424]	; 0x1a8
	int compass_accuracy = 0;
  40b09c:	2300      	movs	r3, #0
  40b09e:	f8c7 31a4 	str.w	r3, [r7, #420]	; 0x1a4
	float rv_accuracy = 0;
  40b0a2:	f04f 0300 	mov.w	r3, #0
  40b0a6:	f8c7 31a0 	str.w	r3, [r7, #416]	; 0x1a0
	float gmrv_accuracy = 0;
  40b0aa:	f04f 0300 	mov.w	r3, #0
  40b0ae:	f8c7 319c 	str.w	r3, [r7, #412]	; 0x19c
	float accel_float[3];
	float grv_float[4];
	float gyro_float[3];
	float compass_float[3] = {0};
  40b0b2:	f507 73b4 	add.w	r3, r7, #360	; 0x168
  40b0b6:	2200      	movs	r2, #0
  40b0b8:	601a      	str	r2, [r3, #0]
  40b0ba:	605a      	str	r2, [r3, #4]
  40b0bc:	609a      	str	r2, [r3, #8]
	float compass_raw_float[3];
	float rv_float[4];
	float gmrv_float[4];
	uint16_t pickup_state = 0;
  40b0be:	2300      	movs	r3, #0
  40b0c0:	f8a7 313a 	strh.w	r3, [r7, #314]	; 0x13a
	uint64_t lastIrqTimeUs;

	inv_icm20948_identify_interrupt(s, &int_read_back);
  40b0c4:	f507 72f9 	add.w	r2, r7, #498	; 0x1f2
  40b0c8:	f107 030c 	add.w	r3, r7, #12
  40b0cc:	4611      	mov	r1, r2
  40b0ce:	6818      	ldr	r0, [r3, #0]
  40b0d0:	4b12      	ldr	r3, [pc, #72]	; (40b11c <inv_icm20948_poll_sensor+0xe4>)
  40b0d2:	4798      	blx	r3

	if (int_read_back & (BIT_MSG_DMP_INT | BIT_MSG_DMP_INT_0)) {
  40b0d4:	f9b7 31f2 	ldrsh.w	r3, [r7, #498]	; 0x1f2
  40b0d8:	b29b      	uxth	r3, r3
  40b0da:	f403 7381 	and.w	r3, r3, #258	; 0x102
  40b0de:	2b00      	cmp	r3, #0
  40b0e0:	f001 812d 	beq.w	40c33e <inv_icm20948_poll_sensor+0x1306>
		lastIrqTimeUs = inv_icm20948_get_time_us();
  40b0e4:	4b0e      	ldr	r3, [pc, #56]	; (40b120 <inv_icm20948_poll_sensor+0xe8>)
  40b0e6:	4798      	blx	r3
  40b0e8:	4603      	mov	r3, r0
  40b0ea:	460c      	mov	r4, r1
  40b0ec:	f507 7298 	add.w	r2, r7, #304	; 0x130
  40b0f0:	e9c2 3400 	strd	r3, r4, [r2]
		do {
			unsigned short total_sample_cnt = 0;
  40b0f4:	2300      	movs	r3, #0
  40b0f6:	f8a7 312e 	strh.w	r3, [r7, #302]	; 0x12e

			/* Mirror FIFO contents and stop processing FIFO if an error was detected*/
			if(inv_icm20948_updateTs(s, &data_left_in_fifo, &total_sample_cnt, &lastIrqTimeUs))
  40b0fa:	f507 7398 	add.w	r3, r7, #304	; 0x130
  40b0fe:	f507 7297 	add.w	r2, r7, #302	; 0x12e
  40b102:	f507 71f4 	add.w	r1, r7, #488	; 0x1e8
  40b106:	f107 000c 	add.w	r0, r7, #12
  40b10a:	6800      	ldr	r0, [r0, #0]
  40b10c:	4c05      	ldr	r4, [pc, #20]	; (40b124 <inv_icm20948_poll_sensor+0xec>)
  40b10e:	47a0      	blx	r4
  40b110:	4603      	mov	r3, r0
  40b112:	2b00      	cmp	r3, #0
  40b114:	f041 80b2 	bne.w	40c27c <inv_icm20948_poll_sensor+0x1244>
				break;
			while(total_sample_cnt--) {
  40b118:	f001 b890 	b.w	40c23c <inv_icm20948_poll_sensor+0x1204>
  40b11c:	00408a09 	.word	0x00408a09
  40b120:	00401105 	.word	0x00401105
  40b124:	0040ad15 	.word	0x0040ad15
				/* Read FIFO contents and parse it, and stop processing FIFO if an error was detected*/
				if (inv_icm20948_fifo_pop(s, &header, &header2, &data_left_in_fifo))
  40b128:	f507 73f4 	add.w	r3, r7, #488	; 0x1e8
  40b12c:	f507 72f7 	add.w	r2, r7, #494	; 0x1ee
  40b130:	f507 71f8 	add.w	r1, r7, #496	; 0x1f0
  40b134:	f107 000c 	add.w	r0, r7, #12
  40b138:	6800      	ldr	r0, [r0, #0]
  40b13a:	4cc1      	ldr	r4, [pc, #772]	; (40b440 <inv_icm20948_poll_sensor+0x408>)
  40b13c:	47a0      	blx	r4
  40b13e:	4603      	mov	r3, r0
  40b140:	2b00      	cmp	r3, #0
  40b142:	f041 8085 	bne.w	40c250 <inv_icm20948_poll_sensor+0x1218>
					break;

				/* Gyro sample available from DMP FIFO */
				if (header & GYRO_SET) {
  40b146:	f8b7 31f0 	ldrh.w	r3, [r7, #496]	; 0x1f0
  40b14a:	f403 4380 	and.w	r3, r3, #16384	; 0x4000
  40b14e:	2b00      	cmp	r3, #0
  40b150:	f000 81e1 	beq.w	40b516 <inv_icm20948_poll_sensor+0x4de>
					float lScaleDeg = (1 << inv_icm20948_get_gyro_fullscale(s)) * 250.f; // From raw to dps to degree per seconds
  40b154:	f107 030c 	add.w	r3, r7, #12
  40b158:	6818      	ldr	r0, [r3, #0]
  40b15a:	4bba      	ldr	r3, [pc, #744]	; (40b444 <inv_icm20948_poll_sensor+0x40c>)
  40b15c:	4798      	blx	r3
  40b15e:	4603      	mov	r3, r0
  40b160:	461a      	mov	r2, r3
  40b162:	2301      	movs	r3, #1
  40b164:	4093      	lsls	r3, r2
  40b166:	ee07 3a90 	vmov	s15, r3
  40b16a:	eef8 7ae7 	vcvt.f32.s32	s15, s15
  40b16e:	ed9f 7ab6 	vldr	s14, [pc, #728]	; 40b448 <inv_icm20948_poll_sensor+0x410>
  40b172:	ee67 7a87 	vmul.f32	s15, s15, s14
  40b176:	edc7 7a83 	vstr	s15, [r7, #524]	; 0x20c
					float lScaleDeg_bias = 2000.f; // Gyro bias from FIFO is always in 2^20 = 2000 dps regardless of fullscale
  40b17a:	4bb4      	ldr	r3, [pc, #720]	; (40b44c <inv_icm20948_poll_sensor+0x414>)
  40b17c:	f8c7 3208 	str.w	r3, [r7, #520]	; 0x208
					signed long  lRawGyroQ15[3] = {0};
  40b180:	f507 7390 	add.w	r3, r7, #288	; 0x120
  40b184:	2200      	movs	r2, #0
  40b186:	601a      	str	r2, [r3, #0]
  40b188:	605a      	str	r2, [r3, #4]
  40b18a:	609a      	str	r2, [r3, #8]
					signed long  lBiasGyroQ20[3] = {0};
  40b18c:	f507 738a 	add.w	r3, r7, #276	; 0x114
  40b190:	461a      	mov	r2, r3
  40b192:	2300      	movs	r3, #0
  40b194:	6013      	str	r3, [r2, #0]
  40b196:	6053      	str	r3, [r2, #4]
  40b198:	6093      	str	r3, [r2, #8]

					/* Read raw gyro out of DMP FIFO and convert it from Q15 raw data format to radian per seconds in Android format */
					inv_icm20948_dmp_get_raw_gyro(short_data);
  40b19a:	f507 73f0 	add.w	r3, r7, #480	; 0x1e0
  40b19e:	4618      	mov	r0, r3
  40b1a0:	4bab      	ldr	r3, [pc, #684]	; (40b450 <inv_icm20948_poll_sensor+0x418>)
  40b1a2:	4798      	blx	r3
					lRawGyroQ15[0] = (long) short_data[0];
  40b1a4:	f9b7 31e0 	ldrsh.w	r3, [r7, #480]	; 0x1e0
  40b1a8:	f8c7 3120 	str.w	r3, [r7, #288]	; 0x120
					lRawGyroQ15[1] = (long) short_data[1];
  40b1ac:	f9b7 31e2 	ldrsh.w	r3, [r7, #482]	; 0x1e2
  40b1b0:	f8c7 3124 	str.w	r3, [r7, #292]	; 0x124
					lRawGyroQ15[2] = (long) short_data[2];
  40b1b4:	f9b7 31e4 	ldrsh.w	r3, [r7, #484]	; 0x1e4
  40b1b8:	f8c7 3128 	str.w	r3, [r7, #296]	; 0x128
					inv_icm20948_convert_dmp3_to_body(s, lRawGyroQ15, lScaleDeg/(1L<<15), gyro_raw_float);
  40b1bc:	edd7 7a83 	vldr	s15, [r7, #524]	; 0x20c
  40b1c0:	ed9f 7aa4 	vldr	s14, [pc, #656]	; 40b454 <inv_icm20948_poll_sensor+0x41c>
  40b1c4:	eec7 6a87 	vdiv.f32	s13, s15, s14
  40b1c8:	f507 72de 	add.w	r2, r7, #444	; 0x1bc
  40b1cc:	f507 7190 	add.w	r1, r7, #288	; 0x120
  40b1d0:	f107 030c 	add.w	r3, r7, #12
  40b1d4:	eeb0 0a66 	vmov.f32	s0, s13
  40b1d8:	6818      	ldr	r0, [r3, #0]
  40b1da:	4b9f      	ldr	r3, [pc, #636]	; (40b458 <inv_icm20948_poll_sensor+0x420>)
  40b1dc:	4798      	blx	r3

					if(inv_icm20948_ctrl_androidSensor_enabled(s, ANDROID_SENSOR_RAW_GYROSCOPE) && !skip_sensor(s, ANDROID_SENSOR_RAW_GYROSCOPE)) {
  40b1de:	f107 030c 	add.w	r3, r7, #12
  40b1e2:	212b      	movs	r1, #43	; 0x2b
  40b1e4:	6818      	ldr	r0, [r3, #0]
  40b1e6:	4b9d      	ldr	r3, [pc, #628]	; (40b45c <inv_icm20948_poll_sensor+0x424>)
  40b1e8:	4798      	blx	r3
  40b1ea:	4603      	mov	r3, r0
  40b1ec:	2b00      	cmp	r3, #0
  40b1ee:	d041      	beq.n	40b274 <inv_icm20948_poll_sensor+0x23c>
  40b1f0:	f107 030c 	add.w	r3, r7, #12
  40b1f4:	212b      	movs	r1, #43	; 0x2b
  40b1f6:	6818      	ldr	r0, [r3, #0]
  40b1f8:	4b99      	ldr	r3, [pc, #612]	; (40b460 <inv_icm20948_poll_sensor+0x428>)
  40b1fa:	4798      	blx	r3
  40b1fc:	4603      	mov	r3, r0
  40b1fe:	2b00      	cmp	r3, #0
  40b200:	d138      	bne.n	40b274 <inv_icm20948_poll_sensor+0x23c>
						long out[3];
						inv_icm20948_convert_quat_rotate_fxp(s->s_quat_chip_to_body, lRawGyroQ15, out);
  40b202:	f107 030c 	add.w	r3, r7, #12
  40b206:	681b      	ldr	r3, [r3, #0]
  40b208:	33a8      	adds	r3, #168	; 0xa8
  40b20a:	f507 7284 	add.w	r2, r7, #264	; 0x108
  40b20e:	f507 7190 	add.w	r1, r7, #288	; 0x120
  40b212:	4618      	mov	r0, r3
  40b214:	4b93      	ldr	r3, [pc, #588]	; (40b464 <inv_icm20948_poll_sensor+0x42c>)
  40b216:	4798      	blx	r3
						s->timestamp[INV_ICM20948_SENSOR_RAW_GYROSCOPE] += s->sensorlist[INV_ICM20948_SENSOR_RAW_GYROSCOPE].odr_applied_us;
  40b218:	f107 030c 	add.w	r3, r7, #12
  40b21c:	681b      	ldr	r3, [r3, #0]
  40b21e:	f503 7338 	add.w	r3, r3, #736	; 0x2e0
  40b222:	e9d3 1200 	ldrd	r1, r2, [r3]
  40b226:	f107 030c 	add.w	r3, r7, #12
  40b22a:	681b      	ldr	r3, [r3, #0]
  40b22c:	f503 736e 	add.w	r3, r3, #952	; 0x3b8
  40b230:	e9d3 3400 	ldrd	r3, r4, [r3]
  40b234:	185b      	adds	r3, r3, r1
  40b236:	eb44 0402 	adc.w	r4, r4, r2
  40b23a:	f107 020c 	add.w	r2, r7, #12
  40b23e:	6812      	ldr	r2, [r2, #0]
  40b240:	f502 7238 	add.w	r2, r2, #736	; 0x2e0
  40b244:	e9c2 3400 	strd	r3, r4, [r2]
						handler(context, INV_ICM20948_SENSOR_RAW_GYROSCOPE, s->timestamp[INV_ICM20948_SENSOR_RAW_GYROSCOPE], out, &dummy_accuracy);
  40b248:	f107 030c 	add.w	r3, r7, #12
  40b24c:	681b      	ldr	r3, [r3, #0]
  40b24e:	f503 7338 	add.w	r3, r3, #736	; 0x2e0
  40b252:	e9d3 3400 	ldrd	r3, r4, [r3]
  40b256:	f107 0008 	add.w	r0, r7, #8
  40b25a:	1d3a      	adds	r2, r7, #4
  40b25c:	f507 71d6 	add.w	r1, r7, #428	; 0x1ac
  40b260:	9101      	str	r1, [sp, #4]
  40b262:	f507 7184 	add.w	r1, r7, #264	; 0x108
  40b266:	9100      	str	r1, [sp, #0]
  40b268:	6815      	ldr	r5, [r2, #0]
  40b26a:	461a      	mov	r2, r3
  40b26c:	4623      	mov	r3, r4
  40b26e:	2103      	movs	r1, #3
  40b270:	6800      	ldr	r0, [r0, #0]
  40b272:	47a8      	blx	r5
					}

					/* Read bias gyro out of DMP FIFO and convert it from Q20 raw data format to radian per seconds in Android format */
					inv_icm20948_dmp_get_gyro_bias(short_data);
  40b274:	f507 73f0 	add.w	r3, r7, #480	; 0x1e0
  40b278:	4618      	mov	r0, r3
  40b27a:	4b7b      	ldr	r3, [pc, #492]	; (40b468 <inv_icm20948_poll_sensor+0x430>)
  40b27c:	4798      	blx	r3
					lBiasGyroQ20[0] = (long) short_data[0];
  40b27e:	f9b7 31e0 	ldrsh.w	r3, [r7, #480]	; 0x1e0
  40b282:	461a      	mov	r2, r3
  40b284:	f507 738a 	add.w	r3, r7, #276	; 0x114
  40b288:	601a      	str	r2, [r3, #0]
					lBiasGyroQ20[1] = (long) short_data[1];
  40b28a:	f9b7 31e2 	ldrsh.w	r3, [r7, #482]	; 0x1e2
  40b28e:	461a      	mov	r2, r3
  40b290:	f507 738a 	add.w	r3, r7, #276	; 0x114
  40b294:	605a      	str	r2, [r3, #4]
					lBiasGyroQ20[2] = (long) short_data[2];
  40b296:	f9b7 31e4 	ldrsh.w	r3, [r7, #484]	; 0x1e4
  40b29a:	461a      	mov	r2, r3
  40b29c:	f507 738a 	add.w	r3, r7, #276	; 0x114
  40b2a0:	609a      	str	r2, [r3, #8]
					inv_icm20948_convert_dmp3_to_body(s, lBiasGyroQ20, lScaleDeg_bias/(1L<<20), gyro_bias_float);
  40b2a2:	edd7 7a82 	vldr	s15, [r7, #520]	; 0x208
  40b2a6:	ed9f 7a71 	vldr	s14, [pc, #452]	; 40b46c <inv_icm20948_poll_sensor+0x434>
  40b2aa:	eec7 6a87 	vdiv.f32	s13, s15, s14
  40b2ae:	f507 72d8 	add.w	r2, r7, #432	; 0x1b0
  40b2b2:	f507 718a 	add.w	r1, r7, #276	; 0x114
  40b2b6:	f107 030c 	add.w	r3, r7, #12
  40b2ba:	eeb0 0a66 	vmov.f32	s0, s13
  40b2be:	6818      	ldr	r0, [r3, #0]
  40b2c0:	4b65      	ldr	r3, [pc, #404]	; (40b458 <inv_icm20948_poll_sensor+0x420>)
  40b2c2:	4798      	blx	r3

					/* Extract accuracy and calibrated gyro data based on raw/bias data if calibrated gyro sensor is enabled */
					gyro_accuracy = inv_icm20948_get_gyro_accuracy();
  40b2c4:	4b6a      	ldr	r3, [pc, #424]	; (40b470 <inv_icm20948_poll_sensor+0x438>)
  40b2c6:	4798      	blx	r3
  40b2c8:	f8c7 0210 	str.w	r0, [r7, #528]	; 0x210
					/* If accuracy has changed previously we update the new accuracy the same time as bias*/
					if(s->set_accuracy){
  40b2cc:	f107 030c 	add.w	r3, r7, #12
  40b2d0:	681b      	ldr	r3, [r3, #0]
  40b2d2:	f9b3 34f2 	ldrsh.w	r3, [r3, #1266]	; 0x4f2
  40b2d6:	2b00      	cmp	r3, #0
  40b2d8:	d00c      	beq.n	40b2f4 <inv_icm20948_poll_sensor+0x2bc>
						s->set_accuracy = 0;
  40b2da:	f107 030c 	add.w	r3, r7, #12
  40b2de:	681b      	ldr	r3, [r3, #0]
  40b2e0:	2200      	movs	r2, #0
  40b2e2:	f8a3 24f2 	strh.w	r2, [r3, #1266]	; 0x4f2
						s->new_accuracy = gyro_accuracy;
  40b2e6:	f107 030c 	add.w	r3, r7, #12
  40b2ea:	681b      	ldr	r3, [r3, #0]
  40b2ec:	f8d7 2210 	ldr.w	r2, [r7, #528]	; 0x210
  40b2f0:	f8c3 24f4 	str.w	r2, [r3, #1268]	; 0x4f4
					}
					/* gyro accuracy has changed, we will notify it the next time*/
					if(gyro_accuracy != s->new_accuracy){
  40b2f4:	f107 030c 	add.w	r3, r7, #12
  40b2f8:	681b      	ldr	r3, [r3, #0]
  40b2fa:	f8d3 24f4 	ldr.w	r2, [r3, #1268]	; 0x4f4
  40b2fe:	f8d7 3210 	ldr.w	r3, [r7, #528]	; 0x210
  40b302:	429a      	cmp	r2, r3
  40b304:	d005      	beq.n	40b312 <inv_icm20948_poll_sensor+0x2da>
						s->set_accuracy = 1;
  40b306:	f107 030c 	add.w	r3, r7, #12
  40b30a:	681b      	ldr	r3, [r3, #0]
  40b30c:	2201      	movs	r2, #1
  40b30e:	f8a3 24f2 	strh.w	r2, [r3, #1266]	; 0x4f2
					}
					if(inv_icm20948_ctrl_androidSensor_enabled(s, ANDROID_SENSOR_GYROSCOPE) && !skip_sensor(s, ANDROID_SENSOR_GYROSCOPE)) {
  40b312:	f107 030c 	add.w	r3, r7, #12
  40b316:	2104      	movs	r1, #4
  40b318:	6818      	ldr	r0, [r3, #0]
  40b31a:	4b50      	ldr	r3, [pc, #320]	; (40b45c <inv_icm20948_poll_sensor+0x424>)
  40b31c:	4798      	blx	r3
  40b31e:	4603      	mov	r3, r0
  40b320:	2b00      	cmp	r3, #0
  40b322:	d07a      	beq.n	40b41a <inv_icm20948_poll_sensor+0x3e2>
  40b324:	f107 030c 	add.w	r3, r7, #12
  40b328:	2104      	movs	r1, #4
  40b32a:	6818      	ldr	r0, [r3, #0]
  40b32c:	4b4c      	ldr	r3, [pc, #304]	; (40b460 <inv_icm20948_poll_sensor+0x428>)
  40b32e:	4798      	blx	r3
  40b330:	4603      	mov	r3, r0
  40b332:	2b00      	cmp	r3, #0
  40b334:	d171      	bne.n	40b41a <inv_icm20948_poll_sensor+0x3e2>
						// shift to Q20 to do all calibrated gyrometer operations in Q20
						// Gyro bias from FIFO is always in 2^20 = 2000 dps regardless of fullscale
						// Raw gyro from FIFO is in 2^15 = gyro fsr (250/500/1000/2000).
						lRawGyroQ15[0] <<= 5 - (MPU_FS_2000dps - inv_icm20948_get_gyro_fullscale(s));
  40b336:	f107 030c 	add.w	r3, r7, #12
  40b33a:	6818      	ldr	r0, [r3, #0]
  40b33c:	4b41      	ldr	r3, [pc, #260]	; (40b444 <inv_icm20948_poll_sensor+0x40c>)
  40b33e:	4798      	blx	r3
  40b340:	4603      	mov	r3, r0
  40b342:	3302      	adds	r3, #2
  40b344:	f8d7 2120 	ldr.w	r2, [r7, #288]	; 0x120
  40b348:	fa02 f303 	lsl.w	r3, r2, r3
  40b34c:	f8c7 3120 	str.w	r3, [r7, #288]	; 0x120
						lRawGyroQ15[1] <<= 5 - (MPU_FS_2000dps - inv_icm20948_get_gyro_fullscale(s));
  40b350:	f107 030c 	add.w	r3, r7, #12
  40b354:	6818      	ldr	r0, [r3, #0]
  40b356:	4b3b      	ldr	r3, [pc, #236]	; (40b444 <inv_icm20948_poll_sensor+0x40c>)
  40b358:	4798      	blx	r3
  40b35a:	4603      	mov	r3, r0
  40b35c:	3302      	adds	r3, #2
  40b35e:	f8d7 2124 	ldr.w	r2, [r7, #292]	; 0x124
  40b362:	fa02 f303 	lsl.w	r3, r2, r3
  40b366:	f8c7 3124 	str.w	r3, [r7, #292]	; 0x124
						lRawGyroQ15[2] <<= 5 - (MPU_FS_2000dps - inv_icm20948_get_gyro_fullscale(s));
  40b36a:	f107 030c 	add.w	r3, r7, #12
  40b36e:	6818      	ldr	r0, [r3, #0]
  40b370:	4b34      	ldr	r3, [pc, #208]	; (40b444 <inv_icm20948_poll_sensor+0x40c>)
  40b372:	4798      	blx	r3
  40b374:	4603      	mov	r3, r0
  40b376:	3302      	adds	r3, #2
  40b378:	f8d7 2128 	ldr.w	r2, [r7, #296]	; 0x128
  40b37c:	fa02 f303 	lsl.w	r3, r2, r3
  40b380:	f8c7 3128 	str.w	r3, [r7, #296]	; 0x128
						/* Compute calibrated gyro data based on raw and bias gyro data and convert it from Q20 raw data format to radian per seconds in Android format */
						inv_icm20948_dmp_get_calibrated_gyro(long_data, lRawGyroQ15, lBiasGyroQ20);
  40b384:	f507 728a 	add.w	r2, r7, #276	; 0x114
  40b388:	f507 7190 	add.w	r1, r7, #288	; 0x120
  40b38c:	f507 73ea 	add.w	r3, r7, #468	; 0x1d4
  40b390:	4618      	mov	r0, r3
  40b392:	4b38      	ldr	r3, [pc, #224]	; (40b474 <inv_icm20948_poll_sensor+0x43c>)
  40b394:	4798      	blx	r3
						inv_icm20948_convert_dmp3_to_body(s, long_data, lScaleDeg_bias/(1L<<20), gyro_float);
  40b396:	edd7 7a82 	vldr	s15, [r7, #520]	; 0x208
  40b39a:	ed9f 7a34 	vldr	s14, [pc, #208]	; 40b46c <inv_icm20948_poll_sensor+0x434>
  40b39e:	eec7 6a87 	vdiv.f32	s13, s15, s14
  40b3a2:	f507 72ba 	add.w	r2, r7, #372	; 0x174
  40b3a6:	f507 71ea 	add.w	r1, r7, #468	; 0x1d4
  40b3aa:	f107 030c 	add.w	r3, r7, #12
  40b3ae:	eeb0 0a66 	vmov.f32	s0, s13
  40b3b2:	6818      	ldr	r0, [r3, #0]
  40b3b4:	4b28      	ldr	r3, [pc, #160]	; (40b458 <inv_icm20948_poll_sensor+0x420>)
  40b3b6:	4798      	blx	r3
						s->timestamp[INV_ICM20948_SENSOR_GYROSCOPE] += s->sensorlist[INV_ICM20948_SENSOR_GYROSCOPE].odr_applied_us;
  40b3b8:	f107 030c 	add.w	r3, r7, #12
  40b3bc:	681b      	ldr	r3, [r3, #0]
  40b3be:	f503 7334 	add.w	r3, r3, #720	; 0x2d0
  40b3c2:	e9d3 1200 	ldrd	r1, r2, [r3]
  40b3c6:	f107 030c 	add.w	r3, r7, #12
  40b3ca:	681b      	ldr	r3, [r3, #0]
  40b3cc:	f503 7366 	add.w	r3, r3, #920	; 0x398
  40b3d0:	e9d3 3400 	ldrd	r3, r4, [r3]
  40b3d4:	185b      	adds	r3, r3, r1
  40b3d6:	eb44 0402 	adc.w	r4, r4, r2
  40b3da:	f107 020c 	add.w	r2, r7, #12
  40b3de:	6812      	ldr	r2, [r2, #0]
  40b3e0:	f502 7234 	add.w	r2, r2, #720	; 0x2d0
  40b3e4:	e9c2 3400 	strd	r3, r4, [r2]
						handler(context, INV_ICM20948_SENSOR_GYROSCOPE, s->timestamp[INV_ICM20948_SENSOR_GYROSCOPE], gyro_float, &s->new_accuracy);
  40b3e8:	f107 030c 	add.w	r3, r7, #12
  40b3ec:	681b      	ldr	r3, [r3, #0]
  40b3ee:	f503 7334 	add.w	r3, r3, #720	; 0x2d0
  40b3f2:	e9d3 3400 	ldrd	r3, r4, [r3]
  40b3f6:	f107 020c 	add.w	r2, r7, #12
  40b3fa:	6812      	ldr	r2, [r2, #0]
  40b3fc:	f202 41f4 	addw	r1, r2, #1268	; 0x4f4
  40b400:	f107 0008 	add.w	r0, r7, #8
  40b404:	1d3a      	adds	r2, r7, #4
  40b406:	9101      	str	r1, [sp, #4]
  40b408:	f507 71ba 	add.w	r1, r7, #372	; 0x174
  40b40c:	9100      	str	r1, [sp, #0]
  40b40e:	6815      	ldr	r5, [r2, #0]
  40b410:	461a      	mov	r2, r3
  40b412:	4623      	mov	r3, r4
  40b414:	2101      	movs	r1, #1
  40b416:	6800      	ldr	r0, [r0, #0]
  40b418:	47a8      	blx	r5
					}
					if(inv_icm20948_ctrl_androidSensor_enabled(s, ANDROID_SENSOR_GYROSCOPE_UNCALIBRATED)  && !skip_sensor(s, ANDROID_SENSOR_GYROSCOPE_UNCALIBRATED)) {
  40b41a:	f107 030c 	add.w	r3, r7, #12
  40b41e:	2110      	movs	r1, #16
  40b420:	6818      	ldr	r0, [r3, #0]
  40b422:	4b0e      	ldr	r3, [pc, #56]	; (40b45c <inv_icm20948_poll_sensor+0x424>)
  40b424:	4798      	blx	r3
  40b426:	4603      	mov	r3, r0
  40b428:	2b00      	cmp	r3, #0
  40b42a:	d074      	beq.n	40b516 <inv_icm20948_poll_sensor+0x4de>
  40b42c:	f107 030c 	add.w	r3, r7, #12
  40b430:	2110      	movs	r1, #16
  40b432:	6818      	ldr	r0, [r3, #0]
  40b434:	4b0a      	ldr	r3, [pc, #40]	; (40b460 <inv_icm20948_poll_sensor+0x428>)
  40b436:	4798      	blx	r3
  40b438:	4603      	mov	r3, r0
  40b43a:	2b00      	cmp	r3, #0
  40b43c:	d16b      	bne.n	40b516 <inv_icm20948_poll_sensor+0x4de>
  40b43e:	e01b      	b.n	40b478 <inv_icm20948_poll_sensor+0x440>
  40b440:	004091d1 	.word	0x004091d1
  40b444:	00406161 	.word	0x00406161
  40b448:	437a0000 	.word	0x437a0000
  40b44c:	44fa0000 	.word	0x44fa0000
  40b450:	004096fd 	.word	0x004096fd
  40b454:	47000000 	.word	0x47000000
  40b458:	00406c71 	.word	0x00406c71
  40b45c:	004107b9 	.word	0x004107b9
  40b460:	0040a6fd 	.word	0x0040a6fd
  40b464:	00406901 	.word	0x00406901
  40b468:	00409745 	.word	0x00409745
  40b46c:	49800000 	.word	0x49800000
  40b470:	00409985 	.word	0x00409985
  40b474:	00409775 	.word	0x00409775
						float raw_bias_gyr[6];
						raw_bias_gyr[0] = gyro_raw_float[0];
  40b478:	f8d7 21bc 	ldr.w	r2, [r7, #444]	; 0x1bc
  40b47c:	f107 03f0 	add.w	r3, r7, #240	; 0xf0
  40b480:	601a      	str	r2, [r3, #0]
						raw_bias_gyr[1] = gyro_raw_float[1];
  40b482:	f8d7 21c0 	ldr.w	r2, [r7, #448]	; 0x1c0
  40b486:	f107 03f0 	add.w	r3, r7, #240	; 0xf0
  40b48a:	605a      	str	r2, [r3, #4]
						raw_bias_gyr[2] = gyro_raw_float[2];
  40b48c:	f8d7 21c4 	ldr.w	r2, [r7, #452]	; 0x1c4
  40b490:	f107 03f0 	add.w	r3, r7, #240	; 0xf0
  40b494:	609a      	str	r2, [r3, #8]
						raw_bias_gyr[3] = gyro_bias_float[0];
  40b496:	f8d7 21b0 	ldr.w	r2, [r7, #432]	; 0x1b0
  40b49a:	f107 03f0 	add.w	r3, r7, #240	; 0xf0
  40b49e:	60da      	str	r2, [r3, #12]
						raw_bias_gyr[4] = gyro_bias_float[1];
  40b4a0:	f8d7 21b4 	ldr.w	r2, [r7, #436]	; 0x1b4
  40b4a4:	f107 03f0 	add.w	r3, r7, #240	; 0xf0
  40b4a8:	611a      	str	r2, [r3, #16]
						raw_bias_gyr[5] = gyro_bias_float[2];
  40b4aa:	f8d7 21b8 	ldr.w	r2, [r7, #440]	; 0x1b8
  40b4ae:	f107 03f0 	add.w	r3, r7, #240	; 0xf0
  40b4b2:	615a      	str	r2, [r3, #20]
						s->timestamp[INV_ICM20948_SENSOR_GYROSCOPE_UNCALIBRATED] += s->sensorlist[INV_ICM20948_SENSOR_GYROSCOPE_UNCALIBRATED].odr_applied_us;
  40b4b4:	f107 030c 	add.w	r3, r7, #12
  40b4b8:	681b      	ldr	r3, [r3, #0]
  40b4ba:	f503 733c 	add.w	r3, r3, #752	; 0x2f0
  40b4be:	e9d3 1200 	ldrd	r1, r2, [r3]
  40b4c2:	f107 030c 	add.w	r3, r7, #12
  40b4c6:	681b      	ldr	r3, [r3, #0]
  40b4c8:	f503 7376 	add.w	r3, r3, #984	; 0x3d8
  40b4cc:	e9d3 3400 	ldrd	r3, r4, [r3]
  40b4d0:	185b      	adds	r3, r3, r1
  40b4d2:	eb44 0402 	adc.w	r4, r4, r2
  40b4d6:	f107 020c 	add.w	r2, r7, #12
  40b4da:	6812      	ldr	r2, [r2, #0]
  40b4dc:	f502 723c 	add.w	r2, r2, #752	; 0x2f0
  40b4e0:	e9c2 3400 	strd	r3, r4, [r2]
						/* send raw float and bias for uncal gyr*/
						handler(context, INV_ICM20948_SENSOR_GYROSCOPE_UNCALIBRATED, s->timestamp[INV_ICM20948_SENSOR_GYROSCOPE_UNCALIBRATED], raw_bias_gyr, &s->new_accuracy);
  40b4e4:	f107 030c 	add.w	r3, r7, #12
  40b4e8:	681b      	ldr	r3, [r3, #0]
  40b4ea:	f503 733c 	add.w	r3, r3, #752	; 0x2f0
  40b4ee:	e9d3 3400 	ldrd	r3, r4, [r3]
  40b4f2:	f107 020c 	add.w	r2, r7, #12
  40b4f6:	6812      	ldr	r2, [r2, #0]
  40b4f8:	f202 41f4 	addw	r1, r2, #1268	; 0x4f4
  40b4fc:	f107 0008 	add.w	r0, r7, #8
  40b500:	1d3a      	adds	r2, r7, #4
  40b502:	9101      	str	r1, [sp, #4]
  40b504:	f107 01f0 	add.w	r1, r7, #240	; 0xf0
  40b508:	9100      	str	r1, [sp, #0]
  40b50a:	6815      	ldr	r5, [r2, #0]
  40b50c:	461a      	mov	r2, r3
  40b50e:	4623      	mov	r3, r4
  40b510:	2105      	movs	r1, #5
  40b512:	6800      	ldr	r0, [r0, #0]
  40b514:	47a8      	blx	r5
					}
				}
				/* Calibrated accel sample available from DMP FIFO */
				if (header & ACCEL_SET) {
  40b516:	f8b7 31f0 	ldrh.w	r3, [r7, #496]	; 0x1f0
  40b51a:	b21b      	sxth	r3, r3
  40b51c:	2b00      	cmp	r3, #0
  40b51e:	f280 80dc 	bge.w	40b6da <inv_icm20948_poll_sensor+0x6a2>
					float scale;
					/* Read calibrated accel out of DMP FIFO and convert it from Q25 raw data format to m/s in Android format */
					inv_icm20948_dmp_get_accel(long_data);
  40b522:	f507 73ea 	add.w	r3, r7, #468	; 0x1d4
  40b526:	4618      	mov	r0, r3
  40b528:	4bbe      	ldr	r3, [pc, #760]	; (40b824 <inv_icm20948_poll_sensor+0x7ec>)
  40b52a:	4798      	blx	r3

					if(inv_icm20948_ctrl_androidSensor_enabled(s, ANDROID_SENSOR_RAW_ACCELEROMETER) && !skip_sensor(s, ANDROID_SENSOR_RAW_ACCELEROMETER)) {
  40b52c:	f107 030c 	add.w	r3, r7, #12
  40b530:	212a      	movs	r1, #42	; 0x2a
  40b532:	6818      	ldr	r0, [r3, #0]
  40b534:	4bbc      	ldr	r3, [pc, #752]	; (40b828 <inv_icm20948_poll_sensor+0x7f0>)
  40b536:	4798      	blx	r3
  40b538:	4603      	mov	r3, r0
  40b53a:	2b00      	cmp	r3, #0
  40b53c:	d056      	beq.n	40b5ec <inv_icm20948_poll_sensor+0x5b4>
  40b53e:	f107 030c 	add.w	r3, r7, #12
  40b542:	212a      	movs	r1, #42	; 0x2a
  40b544:	6818      	ldr	r0, [r3, #0]
  40b546:	4bb9      	ldr	r3, [pc, #740]	; (40b82c <inv_icm20948_poll_sensor+0x7f4>)
  40b548:	4798      	blx	r3
  40b54a:	4603      	mov	r3, r0
  40b54c:	2b00      	cmp	r3, #0
  40b54e:	d14d      	bne.n	40b5ec <inv_icm20948_poll_sensor+0x5b4>
						long out[3];
						inv_icm20948_convert_quat_rotate_fxp(s->s_quat_chip_to_body, long_data, out);
  40b550:	f107 030c 	add.w	r3, r7, #12
  40b554:	681b      	ldr	r3, [r3, #0]
  40b556:	33a8      	adds	r3, #168	; 0xa8
  40b558:	f107 02e4 	add.w	r2, r7, #228	; 0xe4
  40b55c:	f507 71ea 	add.w	r1, r7, #468	; 0x1d4
  40b560:	4618      	mov	r0, r3
  40b562:	4bb3      	ldr	r3, [pc, #716]	; (40b830 <inv_icm20948_poll_sensor+0x7f8>)
  40b564:	4798      	blx	r3
						
						/* convert to raw data format to Q12/Q11/Q10/Q9 depending on full scale applied,
						so that it fits on 16bits so that it can go through any protocol, even the one which have raw data on 16b */
						out[0] = out[0] >> 15;
  40b566:	f107 03e4 	add.w	r3, r7, #228	; 0xe4
  40b56a:	681b      	ldr	r3, [r3, #0]
  40b56c:	13da      	asrs	r2, r3, #15
  40b56e:	f107 03e4 	add.w	r3, r7, #228	; 0xe4
  40b572:	601a      	str	r2, [r3, #0]
						out[1] = out[1] >> 15;
  40b574:	f107 03e4 	add.w	r3, r7, #228	; 0xe4
  40b578:	685b      	ldr	r3, [r3, #4]
  40b57a:	13da      	asrs	r2, r3, #15
  40b57c:	f107 03e4 	add.w	r3, r7, #228	; 0xe4
  40b580:	605a      	str	r2, [r3, #4]
						out[2] = out[2] >> 15;
  40b582:	f107 03e4 	add.w	r3, r7, #228	; 0xe4
  40b586:	689b      	ldr	r3, [r3, #8]
  40b588:	13da      	asrs	r2, r3, #15
  40b58a:	f107 03e4 	add.w	r3, r7, #228	; 0xe4
  40b58e:	609a      	str	r2, [r3, #8]
						s->timestamp[INV_ICM20948_SENSOR_RAW_ACCELEROMETER] += s->sensorlist[INV_ICM20948_SENSOR_RAW_ACCELEROMETER].odr_applied_us;
  40b590:	f107 030c 	add.w	r3, r7, #12
  40b594:	681b      	ldr	r3, [r3, #0]
  40b596:	f503 7336 	add.w	r3, r3, #728	; 0x2d8
  40b59a:	e9d3 1200 	ldrd	r1, r2, [r3]
  40b59e:	f107 030c 	add.w	r3, r7, #12
  40b5a2:	681b      	ldr	r3, [r3, #0]
  40b5a4:	f503 736a 	add.w	r3, r3, #936	; 0x3a8
  40b5a8:	e9d3 3400 	ldrd	r3, r4, [r3]
  40b5ac:	185b      	adds	r3, r3, r1
  40b5ae:	eb44 0402 	adc.w	r4, r4, r2
  40b5b2:	f107 020c 	add.w	r2, r7, #12
  40b5b6:	6812      	ldr	r2, [r2, #0]
  40b5b8:	f502 7236 	add.w	r2, r2, #728	; 0x2d8
  40b5bc:	e9c2 3400 	strd	r3, r4, [r2]
						handler(context, INV_ICM20948_SENSOR_RAW_ACCELEROMETER, s->timestamp[INV_ICM20948_SENSOR_RAW_ACCELEROMETER], out, &dummy_accuracy);
  40b5c0:	f107 030c 	add.w	r3, r7, #12
  40b5c4:	681b      	ldr	r3, [r3, #0]
  40b5c6:	f503 7336 	add.w	r3, r3, #728	; 0x2d8
  40b5ca:	e9d3 3400 	ldrd	r3, r4, [r3]
  40b5ce:	f107 0008 	add.w	r0, r7, #8
  40b5d2:	1d3a      	adds	r2, r7, #4
  40b5d4:	f507 71d6 	add.w	r1, r7, #428	; 0x1ac
  40b5d8:	9101      	str	r1, [sp, #4]
  40b5da:	f107 01e4 	add.w	r1, r7, #228	; 0xe4
  40b5de:	9100      	str	r1, [sp, #0]
  40b5e0:	6815      	ldr	r5, [r2, #0]
  40b5e2:	461a      	mov	r2, r3
  40b5e4:	4623      	mov	r3, r4
  40b5e6:	2102      	movs	r1, #2
  40b5e8:	6800      	ldr	r0, [r0, #0]
  40b5ea:	47a8      	blx	r5
					}
					if((inv_icm20948_ctrl_androidSensor_enabled(s, ANDROID_SENSOR_ACCELEROMETER) && !skip_sensor(s, ANDROID_SENSOR_ACCELEROMETER)) ||
  40b5ec:	f107 030c 	add.w	r3, r7, #12
  40b5f0:	2101      	movs	r1, #1
  40b5f2:	6818      	ldr	r0, [r3, #0]
  40b5f4:	4b8c      	ldr	r3, [pc, #560]	; (40b828 <inv_icm20948_poll_sensor+0x7f0>)
  40b5f6:	4798      	blx	r3
  40b5f8:	4603      	mov	r3, r0
  40b5fa:	2b00      	cmp	r3, #0
  40b5fc:	d008      	beq.n	40b610 <inv_icm20948_poll_sensor+0x5d8>
  40b5fe:	f107 030c 	add.w	r3, r7, #12
  40b602:	2101      	movs	r1, #1
  40b604:	6818      	ldr	r0, [r3, #0]
  40b606:	4b89      	ldr	r3, [pc, #548]	; (40b82c <inv_icm20948_poll_sensor+0x7f4>)
  40b608:	4798      	blx	r3
  40b60a:	4603      	mov	r3, r0
  40b60c:	2b00      	cmp	r3, #0
  40b60e:	d008      	beq.n	40b622 <inv_icm20948_poll_sensor+0x5ea>
						(inv_icm20948_ctrl_androidSensor_enabled(s, ANDROID_SENSOR_LINEAR_ACCELERATION))) {
  40b610:	f107 030c 	add.w	r3, r7, #12
  40b614:	210a      	movs	r1, #10
  40b616:	6818      	ldr	r0, [r3, #0]
  40b618:	4b83      	ldr	r3, [pc, #524]	; (40b828 <inv_icm20948_poll_sensor+0x7f0>)
  40b61a:	4798      	blx	r3
  40b61c:	4603      	mov	r3, r0
					if((inv_icm20948_ctrl_androidSensor_enabled(s, ANDROID_SENSOR_ACCELEROMETER) && !skip_sensor(s, ANDROID_SENSOR_ACCELEROMETER)) ||
  40b61e:	2b00      	cmp	r3, #0
  40b620:	d05b      	beq.n	40b6da <inv_icm20948_poll_sensor+0x6a2>
							accel_accuracy = inv_icm20948_get_accel_accuracy();
  40b622:	4b84      	ldr	r3, [pc, #528]	; (40b834 <inv_icm20948_poll_sensor+0x7fc>)
  40b624:	4798      	blx	r3
  40b626:	4603      	mov	r3, r0
  40b628:	f8c7 31a8 	str.w	r3, [r7, #424]	; 0x1a8
							scale = (1 << inv_icm20948_get_accel_fullscale(s)) * 2.f / (1L<<30); // Convert from raw units to g's
  40b62c:	f107 030c 	add.w	r3, r7, #12
  40b630:	6818      	ldr	r0, [r3, #0]
  40b632:	4b81      	ldr	r3, [pc, #516]	; (40b838 <inv_icm20948_poll_sensor+0x800>)
  40b634:	4798      	blx	r3
  40b636:	4603      	mov	r3, r0
  40b638:	461a      	mov	r2, r3
  40b63a:	2301      	movs	r3, #1
  40b63c:	4093      	lsls	r3, r2
  40b63e:	ee07 3a90 	vmov	s15, r3
  40b642:	eef8 7ae7 	vcvt.f32.s32	s15, s15
  40b646:	ee37 7aa7 	vadd.f32	s14, s15, s15
  40b64a:	eddf 6a7c 	vldr	s13, [pc, #496]	; 40b83c <inv_icm20948_poll_sensor+0x804>
  40b64e:	eec7 7a26 	vdiv.f32	s15, s14, s13
  40b652:	edc7 7a81 	vstr	s15, [r7, #516]	; 0x204

							inv_icm20948_convert_dmp3_to_body(s, long_data, scale, accel_float);
  40b656:	f507 72c8 	add.w	r2, r7, #400	; 0x190
  40b65a:	f507 71ea 	add.w	r1, r7, #468	; 0x1d4
  40b65e:	f107 030c 	add.w	r3, r7, #12
  40b662:	ed97 0a81 	vldr	s0, [r7, #516]	; 0x204
  40b666:	6818      	ldr	r0, [r3, #0]
  40b668:	4b75      	ldr	r3, [pc, #468]	; (40b840 <inv_icm20948_poll_sensor+0x808>)
  40b66a:	4798      	blx	r3

							if(inv_icm20948_ctrl_androidSensor_enabled(s, ANDROID_SENSOR_ACCELEROMETER)) {
  40b66c:	f107 030c 	add.w	r3, r7, #12
  40b670:	2101      	movs	r1, #1
  40b672:	6818      	ldr	r0, [r3, #0]
  40b674:	4b6c      	ldr	r3, [pc, #432]	; (40b828 <inv_icm20948_poll_sensor+0x7f0>)
  40b676:	4798      	blx	r3
  40b678:	4603      	mov	r3, r0
  40b67a:	2b00      	cmp	r3, #0
  40b67c:	d02d      	beq.n	40b6da <inv_icm20948_poll_sensor+0x6a2>
								s->timestamp[INV_ICM20948_SENSOR_ACCELEROMETER] += s->sensorlist[INV_ICM20948_SENSOR_ACCELEROMETER].odr_applied_us;
  40b67e:	f107 030c 	add.w	r3, r7, #12
  40b682:	681b      	ldr	r3, [r3, #0]
  40b684:	f503 7332 	add.w	r3, r3, #712	; 0x2c8
  40b688:	e9d3 1200 	ldrd	r1, r2, [r3]
  40b68c:	f107 030c 	add.w	r3, r7, #12
  40b690:	681b      	ldr	r3, [r3, #0]
  40b692:	f503 7362 	add.w	r3, r3, #904	; 0x388
  40b696:	e9d3 3400 	ldrd	r3, r4, [r3]
  40b69a:	185b      	adds	r3, r3, r1
  40b69c:	eb44 0402 	adc.w	r4, r4, r2
  40b6a0:	f107 020c 	add.w	r2, r7, #12
  40b6a4:	6812      	ldr	r2, [r2, #0]
  40b6a6:	f502 7232 	add.w	r2, r2, #712	; 0x2c8
  40b6aa:	e9c2 3400 	strd	r3, r4, [r2]
								handler(context, INV_ICM20948_SENSOR_ACCELEROMETER, s->timestamp[INV_ICM20948_SENSOR_ACCELEROMETER], accel_float, &accel_accuracy);
  40b6ae:	f107 030c 	add.w	r3, r7, #12
  40b6b2:	681b      	ldr	r3, [r3, #0]
  40b6b4:	f503 7332 	add.w	r3, r3, #712	; 0x2c8
  40b6b8:	e9d3 3400 	ldrd	r3, r4, [r3]
  40b6bc:	f107 0008 	add.w	r0, r7, #8
  40b6c0:	1d3a      	adds	r2, r7, #4
  40b6c2:	f507 71d4 	add.w	r1, r7, #424	; 0x1a8
  40b6c6:	9101      	str	r1, [sp, #4]
  40b6c8:	f507 71c8 	add.w	r1, r7, #400	; 0x190
  40b6cc:	9100      	str	r1, [sp, #0]
  40b6ce:	6815      	ldr	r5, [r2, #0]
  40b6d0:	461a      	mov	r2, r3
  40b6d2:	4623      	mov	r3, r4
  40b6d4:	2100      	movs	r1, #0
  40b6d6:	6800      	ldr	r0, [r0, #0]
  40b6d8:	47a8      	blx	r5
							}
					}
				}
				/* Calibrated compass sample available from DMP FIFO */
				if (header & CPASS_CALIBR_SET) {
  40b6da:	f8b7 31f0 	ldrh.w	r3, [r7, #496]	; 0x1f0
  40b6de:	f003 0320 	and.w	r3, r3, #32
  40b6e2:	2b00      	cmp	r3, #0
  40b6e4:	d058      	beq.n	40b798 <inv_icm20948_poll_sensor+0x760>
					float scale;

					/* Read calibrated compass out of DMP FIFO and convert it from Q16 raw data format to T in Android format */
					inv_icm20948_dmp_get_calibrated_compass(long_data);
  40b6e6:	f507 73ea 	add.w	r3, r7, #468	; 0x1d4
  40b6ea:	4618      	mov	r0, r3
  40b6ec:	4b55      	ldr	r3, [pc, #340]	; (40b844 <inv_icm20948_poll_sensor+0x80c>)
  40b6ee:	4798      	blx	r3

					compass_accuracy = inv_icm20948_get_mag_accuracy();
  40b6f0:	4b55      	ldr	r3, [pc, #340]	; (40b848 <inv_icm20948_poll_sensor+0x810>)
  40b6f2:	4798      	blx	r3
  40b6f4:	4603      	mov	r3, r0
  40b6f6:	f8c7 31a4 	str.w	r3, [r7, #420]	; 0x1a4
					scale = DMP_UNIT_TO_FLOAT_COMPASS_CONVERSION;
  40b6fa:	f04f 535e 	mov.w	r3, #931135488	; 0x37800000
  40b6fe:	f8c7 3200 	str.w	r3, [r7, #512]	; 0x200
					inv_icm20948_convert_dmp3_to_body(s, long_data, scale, compass_float);
  40b702:	f507 72b4 	add.w	r2, r7, #360	; 0x168
  40b706:	f507 71ea 	add.w	r1, r7, #468	; 0x1d4
  40b70a:	f107 030c 	add.w	r3, r7, #12
  40b70e:	ed97 0a80 	vldr	s0, [r7, #512]	; 0x200
  40b712:	6818      	ldr	r0, [r3, #0]
  40b714:	4b4a      	ldr	r3, [pc, #296]	; (40b840 <inv_icm20948_poll_sensor+0x808>)
  40b716:	4798      	blx	r3
					if(inv_icm20948_ctrl_androidSensor_enabled(s, ANDROID_SENSOR_GEOMAGNETIC_FIELD) && !skip_sensor(s, ANDROID_SENSOR_GEOMAGNETIC_FIELD)) {
  40b718:	f107 030c 	add.w	r3, r7, #12
  40b71c:	2102      	movs	r1, #2
  40b71e:	6818      	ldr	r0, [r3, #0]
  40b720:	4b41      	ldr	r3, [pc, #260]	; (40b828 <inv_icm20948_poll_sensor+0x7f0>)
  40b722:	4798      	blx	r3
  40b724:	4603      	mov	r3, r0
  40b726:	2b00      	cmp	r3, #0
  40b728:	d036      	beq.n	40b798 <inv_icm20948_poll_sensor+0x760>
  40b72a:	f107 030c 	add.w	r3, r7, #12
  40b72e:	2102      	movs	r1, #2
  40b730:	6818      	ldr	r0, [r3, #0]
  40b732:	4b3e      	ldr	r3, [pc, #248]	; (40b82c <inv_icm20948_poll_sensor+0x7f4>)
  40b734:	4798      	blx	r3
  40b736:	4603      	mov	r3, r0
  40b738:	2b00      	cmp	r3, #0
  40b73a:	d12d      	bne.n	40b798 <inv_icm20948_poll_sensor+0x760>
						s->timestamp[INV_ICM20948_SENSOR_GEOMAGNETIC_FIELD] += s->sensorlist[INV_ICM20948_SENSOR_GEOMAGNETIC_FIELD].odr_applied_us;
  40b73c:	f107 030c 	add.w	r3, r7, #12
  40b740:	681b      	ldr	r3, [r3, #0]
  40b742:	f503 734a 	add.w	r3, r3, #808	; 0x328
  40b746:	e9d3 1200 	ldrd	r1, r2, [r3]
  40b74a:	f107 030c 	add.w	r3, r7, #12
  40b74e:	681b      	ldr	r3, [r3, #0]
  40b750:	f503 6389 	add.w	r3, r3, #1096	; 0x448
  40b754:	e9d3 3400 	ldrd	r3, r4, [r3]
  40b758:	185b      	adds	r3, r3, r1
  40b75a:	eb44 0402 	adc.w	r4, r4, r2
  40b75e:	f107 020c 	add.w	r2, r7, #12
  40b762:	6812      	ldr	r2, [r2, #0]
  40b764:	f502 724a 	add.w	r2, r2, #808	; 0x328
  40b768:	e9c2 3400 	strd	r3, r4, [r2]
						handler(context, INV_ICM20948_SENSOR_GEOMAGNETIC_FIELD, s->timestamp[INV_ICM20948_SENSOR_GEOMAGNETIC_FIELD], compass_float, &compass_accuracy);
  40b76c:	f107 030c 	add.w	r3, r7, #12
  40b770:	681b      	ldr	r3, [r3, #0]
  40b772:	f503 734a 	add.w	r3, r3, #808	; 0x328
  40b776:	e9d3 3400 	ldrd	r3, r4, [r3]
  40b77a:	f107 0008 	add.w	r0, r7, #8
  40b77e:	1d3a      	adds	r2, r7, #4
  40b780:	f507 71d2 	add.w	r1, r7, #420	; 0x1a4
  40b784:	9101      	str	r1, [sp, #4]
  40b786:	f507 71b4 	add.w	r1, r7, #360	; 0x168
  40b78a:	9100      	str	r1, [sp, #0]
  40b78c:	6815      	ldr	r5, [r2, #0]
  40b78e:	461a      	mov	r2, r3
  40b790:	4623      	mov	r3, r4
  40b792:	210c      	movs	r1, #12
  40b794:	6800      	ldr	r0, [r0, #0]
  40b796:	47a8      	blx	r5
					}
				}

				/* Raw compass sample available from DMP FIFO */
				if (header & CPASS_SET) {
  40b798:	f8b7 31f0 	ldrh.w	r3, [r7, #496]	; 0x1f0
  40b79c:	f403 5300 	and.w	r3, r3, #8192	; 0x2000
  40b7a0:	2b00      	cmp	r3, #0
  40b7a2:	f000 80ce 	beq.w	40b942 <inv_icm20948_poll_sensor+0x90a>
					/* Read calibrated compass out of DMP FIFO and convert it from Q16 raw data format to T in Android format */
					inv_icm20948_dmp_get_raw_compass(long_data);
  40b7a6:	f507 73ea 	add.w	r3, r7, #468	; 0x1d4
  40b7aa:	4618      	mov	r0, r3
  40b7ac:	4b27      	ldr	r3, [pc, #156]	; (40b84c <inv_icm20948_poll_sensor+0x814>)
  40b7ae:	4798      	blx	r3
					compass_raw_float[0] = long_data[0] * DMP_UNIT_TO_FLOAT_COMPASS_CONVERSION;
  40b7b0:	f8d7 31d4 	ldr.w	r3, [r7, #468]	; 0x1d4
  40b7b4:	ee07 3a90 	vmov	s15, r3
  40b7b8:	eef8 7ae7 	vcvt.f32.s32	s15, s15
  40b7bc:	ed9f 7a24 	vldr	s14, [pc, #144]	; 40b850 <inv_icm20948_poll_sensor+0x818>
  40b7c0:	ee67 7a87 	vmul.f32	s15, s15, s14
  40b7c4:	edc7 7a57 	vstr	s15, [r7, #348]	; 0x15c
					compass_raw_float[1] = long_data[1] * DMP_UNIT_TO_FLOAT_COMPASS_CONVERSION;
  40b7c8:	f8d7 31d8 	ldr.w	r3, [r7, #472]	; 0x1d8
  40b7cc:	ee07 3a90 	vmov	s15, r3
  40b7d0:	eef8 7ae7 	vcvt.f32.s32	s15, s15
  40b7d4:	ed9f 7a1e 	vldr	s14, [pc, #120]	; 40b850 <inv_icm20948_poll_sensor+0x818>
  40b7d8:	ee67 7a87 	vmul.f32	s15, s15, s14
  40b7dc:	edc7 7a58 	vstr	s15, [r7, #352]	; 0x160
					compass_raw_float[2] = long_data[2] * DMP_UNIT_TO_FLOAT_COMPASS_CONVERSION;
  40b7e0:	f8d7 31dc 	ldr.w	r3, [r7, #476]	; 0x1dc
  40b7e4:	ee07 3a90 	vmov	s15, r3
  40b7e8:	eef8 7ae7 	vcvt.f32.s32	s15, s15
  40b7ec:	ed9f 7a18 	vldr	s14, [pc, #96]	; 40b850 <inv_icm20948_poll_sensor+0x818>
  40b7f0:	ee67 7a87 	vmul.f32	s15, s15, s14
  40b7f4:	edc7 7a59 	vstr	s15, [r7, #356]	; 0x164
					if(inv_icm20948_ctrl_androidSensor_enabled(s, ANDROID_SENSOR_MAGNETIC_FIELD_UNCALIBRATED) && !skip_sensor(s, ANDROID_SENSOR_MAGNETIC_FIELD_UNCALIBRATED)) {
  40b7f8:	f107 030c 	add.w	r3, r7, #12
  40b7fc:	210e      	movs	r1, #14
  40b7fe:	6818      	ldr	r0, [r3, #0]
  40b800:	4b09      	ldr	r3, [pc, #36]	; (40b828 <inv_icm20948_poll_sensor+0x7f0>)
  40b802:	4798      	blx	r3
  40b804:	4603      	mov	r3, r0
  40b806:	2b00      	cmp	r3, #0
  40b808:	f000 809b 	beq.w	40b942 <inv_icm20948_poll_sensor+0x90a>
  40b80c:	f107 030c 	add.w	r3, r7, #12
  40b810:	210e      	movs	r1, #14
  40b812:	6818      	ldr	r0, [r3, #0]
  40b814:	4b05      	ldr	r3, [pc, #20]	; (40b82c <inv_icm20948_poll_sensor+0x7f4>)
  40b816:	4798      	blx	r3
  40b818:	4603      	mov	r3, r0
  40b81a:	2b00      	cmp	r3, #0
  40b81c:	f040 8091 	bne.w	40b942 <inv_icm20948_poll_sensor+0x90a>
  40b820:	e018      	b.n	40b854 <inv_icm20948_poll_sensor+0x81c>
  40b822:	bf00      	nop
  40b824:	004096cd 	.word	0x004096cd
  40b828:	004107b9 	.word	0x004107b9
  40b82c:	0040a6fd 	.word	0x0040a6fd
  40b830:	00406901 	.word	0x00406901
  40b834:	0040996d 	.word	0x0040996d
  40b838:	00406311 	.word	0x00406311
  40b83c:	4e800000 	.word	0x4e800000
  40b840:	00406c71 	.word	0x00406c71
  40b844:	004098a9 	.word	0x004098a9
  40b848:	0040999d 	.word	0x0040999d
  40b84c:	00409879 	.word	0x00409879
  40b850:	37800000 	.word	0x37800000
						float raw_bias_mag[6];
						int mag_bias[3];

						raw_bias_mag[0] = compass_raw_float[0];
  40b854:	f8d7 215c 	ldr.w	r2, [r7, #348]	; 0x15c
  40b858:	f107 03cc 	add.w	r3, r7, #204	; 0xcc
  40b85c:	601a      	str	r2, [r3, #0]
						raw_bias_mag[1] = compass_raw_float[1];
  40b85e:	f8d7 2160 	ldr.w	r2, [r7, #352]	; 0x160
  40b862:	f107 03cc 	add.w	r3, r7, #204	; 0xcc
  40b866:	605a      	str	r2, [r3, #4]
						raw_bias_mag[2] = compass_raw_float[2];
  40b868:	f8d7 2164 	ldr.w	r2, [r7, #356]	; 0x164
  40b86c:	f107 03cc 	add.w	r3, r7, #204	; 0xcc
  40b870:	609a      	str	r2, [r3, #8]
						inv_icm20948_ctrl_get_mag_bias(s, mag_bias);
  40b872:	f107 02c0 	add.w	r2, r7, #192	; 0xc0
  40b876:	f107 030c 	add.w	r3, r7, #12
  40b87a:	4611      	mov	r1, r2
  40b87c:	6818      	ldr	r0, [r3, #0]
  40b87e:	4bbf      	ldr	r3, [pc, #764]	; (40bb7c <inv_icm20948_poll_sensor+0xb44>)
  40b880:	4798      	blx	r3
						//calculate bias
						raw_bias_mag[3] = mag_bias[0] * DMP_UNIT_TO_FLOAT_COMPASS_CONVERSION;
  40b882:	f107 03c0 	add.w	r3, r7, #192	; 0xc0
  40b886:	681b      	ldr	r3, [r3, #0]
  40b888:	ee07 3a90 	vmov	s15, r3
  40b88c:	eef8 7ae7 	vcvt.f32.s32	s15, s15
  40b890:	ed9f 7abb 	vldr	s14, [pc, #748]	; 40bb80 <inv_icm20948_poll_sensor+0xb48>
  40b894:	ee67 7a87 	vmul.f32	s15, s15, s14
  40b898:	f107 03cc 	add.w	r3, r7, #204	; 0xcc
  40b89c:	edc3 7a03 	vstr	s15, [r3, #12]
						raw_bias_mag[4] = mag_bias[1] * DMP_UNIT_TO_FLOAT_COMPASS_CONVERSION;
  40b8a0:	f107 03c0 	add.w	r3, r7, #192	; 0xc0
  40b8a4:	685b      	ldr	r3, [r3, #4]
  40b8a6:	ee07 3a90 	vmov	s15, r3
  40b8aa:	eef8 7ae7 	vcvt.f32.s32	s15, s15
  40b8ae:	ed9f 7ab4 	vldr	s14, [pc, #720]	; 40bb80 <inv_icm20948_poll_sensor+0xb48>
  40b8b2:	ee67 7a87 	vmul.f32	s15, s15, s14
  40b8b6:	f107 03cc 	add.w	r3, r7, #204	; 0xcc
  40b8ba:	edc3 7a04 	vstr	s15, [r3, #16]
						raw_bias_mag[5] = mag_bias[2] * DMP_UNIT_TO_FLOAT_COMPASS_CONVERSION;
  40b8be:	f107 03c0 	add.w	r3, r7, #192	; 0xc0
  40b8c2:	689b      	ldr	r3, [r3, #8]
  40b8c4:	ee07 3a90 	vmov	s15, r3
  40b8c8:	eef8 7ae7 	vcvt.f32.s32	s15, s15
  40b8cc:	ed9f 7aac 	vldr	s14, [pc, #688]	; 40bb80 <inv_icm20948_poll_sensor+0xb48>
  40b8d0:	ee67 7a87 	vmul.f32	s15, s15, s14
  40b8d4:	f107 03cc 	add.w	r3, r7, #204	; 0xcc
  40b8d8:	edc3 7a05 	vstr	s15, [r3, #20]

						compass_accuracy = inv_icm20948_get_mag_accuracy();
  40b8dc:	4ba9      	ldr	r3, [pc, #676]	; (40bb84 <inv_icm20948_poll_sensor+0xb4c>)
  40b8de:	4798      	blx	r3
  40b8e0:	4603      	mov	r3, r0
  40b8e2:	f8c7 31a4 	str.w	r3, [r7, #420]	; 0x1a4
						s->timestamp[INV_ICM20948_SENSOR_MAGNETIC_FIELD_UNCALIBRATED] += s->sensorlist[INV_ICM20948_SENSOR_MAGNETIC_FIELD_UNCALIBRATED].odr_applied_us;
  40b8e6:	f107 030c 	add.w	r3, r7, #12
  40b8ea:	681b      	ldr	r3, [r3, #0]
  40b8ec:	f503 733a 	add.w	r3, r3, #744	; 0x2e8
  40b8f0:	e9d3 1200 	ldrd	r1, r2, [r3]
  40b8f4:	f107 030c 	add.w	r3, r7, #12
  40b8f8:	681b      	ldr	r3, [r3, #0]
  40b8fa:	f503 7372 	add.w	r3, r3, #968	; 0x3c8
  40b8fe:	e9d3 3400 	ldrd	r3, r4, [r3]
  40b902:	185b      	adds	r3, r3, r1
  40b904:	eb44 0402 	adc.w	r4, r4, r2
  40b908:	f107 020c 	add.w	r2, r7, #12
  40b90c:	6812      	ldr	r2, [r2, #0]
  40b90e:	f502 723a 	add.w	r2, r2, #744	; 0x2e8
  40b912:	e9c2 3400 	strd	r3, r4, [r2]
						/* send raw float and bias for uncal mag*/
						handler(context, INV_ICM20948_SENSOR_MAGNETIC_FIELD_UNCALIBRATED, s->timestamp[INV_ICM20948_SENSOR_MAGNETIC_FIELD_UNCALIBRATED],
  40b916:	f107 030c 	add.w	r3, r7, #12
  40b91a:	681b      	ldr	r3, [r3, #0]
  40b91c:	f503 733a 	add.w	r3, r3, #744	; 0x2e8
  40b920:	e9d3 3400 	ldrd	r3, r4, [r3]
  40b924:	f107 0008 	add.w	r0, r7, #8
  40b928:	1d3a      	adds	r2, r7, #4
  40b92a:	f507 71d2 	add.w	r1, r7, #420	; 0x1a4
  40b92e:	9101      	str	r1, [sp, #4]
  40b930:	f107 01cc 	add.w	r1, r7, #204	; 0xcc
  40b934:	9100      	str	r1, [sp, #0]
  40b936:	6815      	ldr	r5, [r2, #0]
  40b938:	461a      	mov	r2, r3
  40b93a:	4623      	mov	r3, r4
  40b93c:	2104      	movs	r1, #4
  40b93e:	6800      	ldr	r0, [r0, #0]
  40b940:	47a8      	blx	r5
							raw_bias_mag, &compass_accuracy);
					}
				}
				/* 6axis AG orientation quaternion sample available from DMP FIFO */
				if (header & QUAT6_SET) {
  40b942:	f8b7 31f0 	ldrh.w	r3, [r7, #496]	; 0x1f0
  40b946:	f403 6300 	and.w	r3, r3, #2048	; 0x800
  40b94a:	2b00      	cmp	r3, #0
  40b94c:	f000 81b2 	beq.w	40bcb4 <inv_icm20948_poll_sensor+0xc7c>
					long gravityQ16[3];
					float ref_quat[4];
					/* Read 6 axis quaternion out of DMP FIFO in Q30 */
					inv_icm20948_dmp_get_6quaternion(long_quat);
  40b950:	f507 73e4 	add.w	r3, r7, #456	; 0x1c8
  40b954:	4618      	mov	r0, r3
  40b956:	4b8c      	ldr	r3, [pc, #560]	; (40bb88 <inv_icm20948_poll_sensor+0xb50>)
  40b958:	4798      	blx	r3
					if(inv_icm20948_ctrl_androidSensor_enabled(s, ANDROID_SENSOR_GAME_ROTATION_VECTOR) && !skip_sensor(s, ANDROID_SENSOR_GAME_ROTATION_VECTOR)) {
  40b95a:	f107 030c 	add.w	r3, r7, #12
  40b95e:	210f      	movs	r1, #15
  40b960:	6818      	ldr	r0, [r3, #0]
  40b962:	4b8a      	ldr	r3, [pc, #552]	; (40bb8c <inv_icm20948_poll_sensor+0xb54>)
  40b964:	4798      	blx	r3
  40b966:	4603      	mov	r3, r0
  40b968:	2b00      	cmp	r3, #0
  40b96a:	d052      	beq.n	40ba12 <inv_icm20948_poll_sensor+0x9da>
  40b96c:	f107 030c 	add.w	r3, r7, #12
  40b970:	210f      	movs	r1, #15
  40b972:	6818      	ldr	r0, [r3, #0]
  40b974:	4b86      	ldr	r3, [pc, #536]	; (40bb90 <inv_icm20948_poll_sensor+0xb58>)
  40b976:	4798      	blx	r3
  40b978:	4603      	mov	r3, r0
  40b97a:	2b00      	cmp	r3, #0
  40b97c:	d149      	bne.n	40ba12 <inv_icm20948_poll_sensor+0x9da>
						/* and convert it from Q30 DMP format to Android format only if GRV sensor is enabled */
						inv_icm20948_convert_rotation_vector(s, long_quat, grv_float);
  40b97e:	f507 72c0 	add.w	r2, r7, #384	; 0x180
  40b982:	f507 71e4 	add.w	r1, r7, #456	; 0x1c8
  40b986:	f107 030c 	add.w	r3, r7, #12
  40b98a:	6818      	ldr	r0, [r3, #0]
  40b98c:	4b81      	ldr	r3, [pc, #516]	; (40bb94 <inv_icm20948_poll_sensor+0xb5c>)
  40b98e:	4798      	blx	r3
						ref_quat[0] = grv_float[3];
  40b990:	f8d7 218c 	ldr.w	r2, [r7, #396]	; 0x18c
  40b994:	f107 03a4 	add.w	r3, r7, #164	; 0xa4
  40b998:	601a      	str	r2, [r3, #0]
						ref_quat[1] = grv_float[0];
  40b99a:	f8d7 2180 	ldr.w	r2, [r7, #384]	; 0x180
  40b99e:	f107 03a4 	add.w	r3, r7, #164	; 0xa4
  40b9a2:	605a      	str	r2, [r3, #4]
						ref_quat[2] = grv_float[1];
  40b9a4:	f8d7 2184 	ldr.w	r2, [r7, #388]	; 0x184
  40b9a8:	f107 03a4 	add.w	r3, r7, #164	; 0xa4
  40b9ac:	609a      	str	r2, [r3, #8]
						ref_quat[3] = grv_float[2];
  40b9ae:	f8d7 2188 	ldr.w	r2, [r7, #392]	; 0x188
  40b9b2:	f107 03a4 	add.w	r3, r7, #164	; 0xa4
  40b9b6:	60da      	str	r2, [r3, #12]
						s->timestamp[INV_ICM20948_SENSOR_GAME_ROTATION_VECTOR] += s->sensorlist[INV_ICM20948_SENSOR_GAME_ROTATION_VECTOR].odr_applied_us;
  40b9b8:	f107 030c 	add.w	r3, r7, #12
  40b9bc:	681b      	ldr	r3, [r3, #0]
  40b9be:	f503 7344 	add.w	r3, r3, #784	; 0x310
  40b9c2:	e9d3 1200 	ldrd	r1, r2, [r3]
  40b9c6:	f107 030c 	add.w	r3, r7, #12
  40b9ca:	681b      	ldr	r3, [r3, #0]
  40b9cc:	f503 6383 	add.w	r3, r3, #1048	; 0x418
  40b9d0:	e9d3 3400 	ldrd	r3, r4, [r3]
  40b9d4:	185b      	adds	r3, r3, r1
  40b9d6:	eb44 0402 	adc.w	r4, r4, r2
  40b9da:	f107 020c 	add.w	r2, r7, #12
  40b9de:	6812      	ldr	r2, [r2, #0]
  40b9e0:	f502 7244 	add.w	r2, r2, #784	; 0x310
  40b9e4:	e9c2 3400 	strd	r3, r4, [r2]
						handler(context, INV_ICM20948_SENSOR_GAME_ROTATION_VECTOR, s->timestamp[INV_ICM20948_SENSOR_GAME_ROTATION_VECTOR], ref_quat, 0);
  40b9e8:	f107 030c 	add.w	r3, r7, #12
  40b9ec:	681b      	ldr	r3, [r3, #0]
  40b9ee:	f503 7344 	add.w	r3, r3, #784	; 0x310
  40b9f2:	e9d3 3400 	ldrd	r3, r4, [r3]
  40b9f6:	f107 0008 	add.w	r0, r7, #8
  40b9fa:	1d3a      	adds	r2, r7, #4
  40b9fc:	2100      	movs	r1, #0
  40b9fe:	9101      	str	r1, [sp, #4]
  40ba00:	f107 01a4 	add.w	r1, r7, #164	; 0xa4
  40ba04:	9100      	str	r1, [sp, #0]
  40ba06:	6815      	ldr	r5, [r2, #0]
  40ba08:	461a      	mov	r2, r3
  40ba0a:	4623      	mov	r3, r4
  40ba0c:	2109      	movs	r1, #9
  40ba0e:	6800      	ldr	r0, [r0, #0]
  40ba10:	47a8      	blx	r5
					}

					/* Compute gravity sensor data in Q16 in g based on 6 axis quaternion in Q30 DMP format */
					inv_icm20948_augmented_sensors_get_gravity(s, gravityQ16, long_quat);
  40ba12:	f507 72e4 	add.w	r2, r7, #456	; 0x1c8
  40ba16:	f107 01b4 	add.w	r1, r7, #180	; 0xb4
  40ba1a:	f107 030c 	add.w	r3, r7, #12
  40ba1e:	6818      	ldr	r0, [r3, #0]
  40ba20:	4b5d      	ldr	r3, [pc, #372]	; (40bb98 <inv_icm20948_poll_sensor+0xb60>)
  40ba22:	4798      	blx	r3
					if(inv_icm20948_ctrl_androidSensor_enabled(s, ANDROID_SENSOR_GRAVITY) && !skip_sensor(s, ANDROID_SENSOR_GRAVITY)) {
  40ba24:	f107 030c 	add.w	r3, r7, #12
  40ba28:	2109      	movs	r1, #9
  40ba2a:	6818      	ldr	r0, [r3, #0]
  40ba2c:	4b57      	ldr	r3, [pc, #348]	; (40bb8c <inv_icm20948_poll_sensor+0xb54>)
  40ba2e:	4798      	blx	r3
  40ba30:	4603      	mov	r3, r0
  40ba32:	2b00      	cmp	r3, #0
  40ba34:	d063      	beq.n	40bafe <inv_icm20948_poll_sensor+0xac6>
  40ba36:	f107 030c 	add.w	r3, r7, #12
  40ba3a:	2109      	movs	r1, #9
  40ba3c:	6818      	ldr	r0, [r3, #0]
  40ba3e:	4b54      	ldr	r3, [pc, #336]	; (40bb90 <inv_icm20948_poll_sensor+0xb58>)
  40ba40:	4798      	blx	r3
  40ba42:	4603      	mov	r3, r0
  40ba44:	2b00      	cmp	r3, #0
  40ba46:	d15a      	bne.n	40bafe <inv_icm20948_poll_sensor+0xac6>
						float gravity_float[3];
						/* Convert gravity data from Q16 to float format in g */
						gravity_float[0] = INVN_FXP_TO_FLT(gravityQ16[0], 16);
  40ba48:	f107 03b4 	add.w	r3, r7, #180	; 0xb4
  40ba4c:	681b      	ldr	r3, [r3, #0]
  40ba4e:	ee07 3a90 	vmov	s15, r3
  40ba52:	eeb8 7ae7 	vcvt.f32.s32	s14, s15
  40ba56:	eddf 6a51 	vldr	s13, [pc, #324]	; 40bb9c <inv_icm20948_poll_sensor+0xb64>
  40ba5a:	eec7 7a26 	vdiv.f32	s15, s14, s13
  40ba5e:	f107 0398 	add.w	r3, r7, #152	; 0x98
  40ba62:	edc3 7a00 	vstr	s15, [r3]
						gravity_float[1] = INVN_FXP_TO_FLT(gravityQ16[1], 16);
  40ba66:	f107 03b4 	add.w	r3, r7, #180	; 0xb4
  40ba6a:	685b      	ldr	r3, [r3, #4]
  40ba6c:	ee07 3a90 	vmov	s15, r3
  40ba70:	eeb8 7ae7 	vcvt.f32.s32	s14, s15
  40ba74:	eddf 6a49 	vldr	s13, [pc, #292]	; 40bb9c <inv_icm20948_poll_sensor+0xb64>
  40ba78:	eec7 7a26 	vdiv.f32	s15, s14, s13
  40ba7c:	f107 0398 	add.w	r3, r7, #152	; 0x98
  40ba80:	edc3 7a01 	vstr	s15, [r3, #4]
						gravity_float[2] = INVN_FXP_TO_FLT(gravityQ16[2], 16);
  40ba84:	f107 03b4 	add.w	r3, r7, #180	; 0xb4
  40ba88:	689b      	ldr	r3, [r3, #8]
  40ba8a:	ee07 3a90 	vmov	s15, r3
  40ba8e:	eeb8 7ae7 	vcvt.f32.s32	s14, s15
  40ba92:	eddf 6a42 	vldr	s13, [pc, #264]	; 40bb9c <inv_icm20948_poll_sensor+0xb64>
  40ba96:	eec7 7a26 	vdiv.f32	s15, s14, s13
  40ba9a:	f107 0398 	add.w	r3, r7, #152	; 0x98
  40ba9e:	edc3 7a02 	vstr	s15, [r3, #8]
						s->timestamp[INV_ICM20948_SENSOR_GRAVITY] += s->sensorlist[INV_ICM20948_SENSOR_GRAVITY].odr_applied_us;
  40baa2:	f107 030c 	add.w	r3, r7, #12
  40baa6:	681b      	ldr	r3, [r3, #0]
  40baa8:	f503 7352 	add.w	r3, r3, #840	; 0x348
  40baac:	e9d3 1200 	ldrd	r1, r2, [r3]
  40bab0:	f107 030c 	add.w	r3, r7, #12
  40bab4:	681b      	ldr	r3, [r3, #0]
  40bab6:	f503 6391 	add.w	r3, r3, #1160	; 0x488
  40baba:	e9d3 3400 	ldrd	r3, r4, [r3]
  40babe:	185b      	adds	r3, r3, r1
  40bac0:	eb44 0402 	adc.w	r4, r4, r2
  40bac4:	f107 020c 	add.w	r2, r7, #12
  40bac8:	6812      	ldr	r2, [r2, #0]
  40baca:	f502 7252 	add.w	r2, r2, #840	; 0x348
  40bace:	e9c2 3400 	strd	r3, r4, [r2]
						handler(context, INV_ICM20948_SENSOR_GRAVITY, s->timestamp[INV_ICM20948_SENSOR_GRAVITY], gravity_float, &accel_accuracy);
  40bad2:	f107 030c 	add.w	r3, r7, #12
  40bad6:	681b      	ldr	r3, [r3, #0]
  40bad8:	f503 7352 	add.w	r3, r3, #840	; 0x348
  40badc:	e9d3 3400 	ldrd	r3, r4, [r3]
  40bae0:	f107 0008 	add.w	r0, r7, #8
  40bae4:	1d3a      	adds	r2, r7, #4
  40bae6:	f507 71d4 	add.w	r1, r7, #424	; 0x1a8
  40baea:	9101      	str	r1, [sp, #4]
  40baec:	f107 0198 	add.w	r1, r7, #152	; 0x98
  40baf0:	9100      	str	r1, [sp, #0]
  40baf2:	6815      	ldr	r5, [r2, #0]
  40baf4:	461a      	mov	r2, r3
  40baf6:	4623      	mov	r3, r4
  40baf8:	2110      	movs	r1, #16
  40bafa:	6800      	ldr	r0, [r0, #0]
  40bafc:	47a8      	blx	r5
					}

					if(inv_icm20948_ctrl_androidSensor_enabled(s, ANDROID_SENSOR_LINEAR_ACCELERATION) && !skip_sensor(s, ANDROID_SENSOR_LINEAR_ACCELERATION)) {
  40bafe:	f107 030c 	add.w	r3, r7, #12
  40bb02:	210a      	movs	r1, #10
  40bb04:	6818      	ldr	r0, [r3, #0]
  40bb06:	4b21      	ldr	r3, [pc, #132]	; (40bb8c <inv_icm20948_poll_sensor+0xb54>)
  40bb08:	4798      	blx	r3
  40bb0a:	4603      	mov	r3, r0
  40bb0c:	2b00      	cmp	r3, #0
  40bb0e:	f000 80d1 	beq.w	40bcb4 <inv_icm20948_poll_sensor+0xc7c>
  40bb12:	f107 030c 	add.w	r3, r7, #12
  40bb16:	210a      	movs	r1, #10
  40bb18:	6818      	ldr	r0, [r3, #0]
  40bb1a:	4b1d      	ldr	r3, [pc, #116]	; (40bb90 <inv_icm20948_poll_sensor+0xb58>)
  40bb1c:	4798      	blx	r3
  40bb1e:	4603      	mov	r3, r0
  40bb20:	2b00      	cmp	r3, #0
  40bb22:	f040 80c7 	bne.w	40bcb4 <inv_icm20948_poll_sensor+0xc7c>
						float linacc_float[3];
						long linAccQ16[3];
						long accelQ16[3];

						/* Compute linear acceleration data based on accelerometer data in Q16 g and on gravity data in Q16 g */
						accelQ16[0] = (int32_t)  ((float)(accel_float[0])*(1ULL << 16) + ( (accel_float[0]>=0)-0.5f ));
  40bb26:	edd7 7a64 	vldr	s15, [r7, #400]	; 0x190
  40bb2a:	ed9f 7a1c 	vldr	s14, [pc, #112]	; 40bb9c <inv_icm20948_poll_sensor+0xb64>
  40bb2e:	ee27 7a87 	vmul.f32	s14, s15, s14
  40bb32:	edd7 7a64 	vldr	s15, [r7, #400]	; 0x190
  40bb36:	eef5 7ac0 	vcmpe.f32	s15, #0.0
  40bb3a:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
  40bb3e:	db02      	blt.n	40bb46 <inv_icm20948_poll_sensor+0xb0e>
  40bb40:	eef6 7a00 	vmov.f32	s15, #96	; 0x3f000000  0.5
  40bb44:	e001      	b.n	40bb4a <inv_icm20948_poll_sensor+0xb12>
  40bb46:	eefe 7a00 	vmov.f32	s15, #224	; 0xbf000000 -0.5
  40bb4a:	ee77 7a27 	vadd.f32	s15, s14, s15
  40bb4e:	eefd 7ae7 	vcvt.s32.f32	s15, s15
  40bb52:	ee17 2a90 	vmov	r2, s15
  40bb56:	f107 0374 	add.w	r3, r7, #116	; 0x74
  40bb5a:	601a      	str	r2, [r3, #0]
						accelQ16[1] = (int32_t)  ((float)(accel_float[1])*(1ULL << 16) + ( (accel_float[1]>=0)-0.5f ));
  40bb5c:	edd7 7a65 	vldr	s15, [r7, #404]	; 0x194
  40bb60:	ed9f 7a0e 	vldr	s14, [pc, #56]	; 40bb9c <inv_icm20948_poll_sensor+0xb64>
  40bb64:	ee27 7a87 	vmul.f32	s14, s15, s14
  40bb68:	edd7 7a65 	vldr	s15, [r7, #404]	; 0x194
  40bb6c:	eef5 7ac0 	vcmpe.f32	s15, #0.0
  40bb70:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
  40bb74:	db14      	blt.n	40bba0 <inv_icm20948_poll_sensor+0xb68>
  40bb76:	eef6 7a00 	vmov.f32	s15, #96	; 0x3f000000  0.5
  40bb7a:	e013      	b.n	40bba4 <inv_icm20948_poll_sensor+0xb6c>
  40bb7c:	004124a1 	.word	0x004124a1
  40bb80:	37800000 	.word	0x37800000
  40bb84:	0040999d 	.word	0x0040999d
  40bb88:	004097e9 	.word	0x004097e9
  40bb8c:	004107b9 	.word	0x004107b9
  40bb90:	0040a6fd 	.word	0x0040a6fd
  40bb94:	00406999 	.word	0x00406999
  40bb98:	0040fed9 	.word	0x0040fed9
  40bb9c:	47800000 	.word	0x47800000
  40bba0:	eefe 7a00 	vmov.f32	s15, #224	; 0xbf000000 -0.5
  40bba4:	ee77 7a27 	vadd.f32	s15, s14, s15
  40bba8:	eefd 7ae7 	vcvt.s32.f32	s15, s15
  40bbac:	ee17 2a90 	vmov	r2, s15
  40bbb0:	f107 0374 	add.w	r3, r7, #116	; 0x74
  40bbb4:	605a      	str	r2, [r3, #4]
						accelQ16[2] = (int32_t)  ((float)(accel_float[2])*(1ULL << 16) + ( (accel_float[2]>=0)-0.5f ));
  40bbb6:	edd7 7a66 	vldr	s15, [r7, #408]	; 0x198
  40bbba:	ed1f 7a08 	vldr	s14, [pc, #-32]	; 40bb9c <inv_icm20948_poll_sensor+0xb64>
  40bbbe:	ee27 7a87 	vmul.f32	s14, s15, s14
  40bbc2:	edd7 7a66 	vldr	s15, [r7, #408]	; 0x198
  40bbc6:	eef5 7ac0 	vcmpe.f32	s15, #0.0
  40bbca:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
  40bbce:	db02      	blt.n	40bbd6 <inv_icm20948_poll_sensor+0xb9e>
  40bbd0:	eef6 7a00 	vmov.f32	s15, #96	; 0x3f000000  0.5
  40bbd4:	e001      	b.n	40bbda <inv_icm20948_poll_sensor+0xba2>
  40bbd6:	eefe 7a00 	vmov.f32	s15, #224	; 0xbf000000 -0.5
  40bbda:	ee77 7a27 	vadd.f32	s15, s14, s15
  40bbde:	eefd 7ae7 	vcvt.s32.f32	s15, s15
  40bbe2:	ee17 2a90 	vmov	r2, s15
  40bbe6:	f107 0374 	add.w	r3, r7, #116	; 0x74
  40bbea:	609a      	str	r2, [r3, #8]

						inv_icm20948_augmented_sensors_get_linearacceleration(linAccQ16, gravityQ16, accelQ16);
  40bbec:	f107 0274 	add.w	r2, r7, #116	; 0x74
  40bbf0:	f107 01b4 	add.w	r1, r7, #180	; 0xb4
  40bbf4:	f107 0380 	add.w	r3, r7, #128	; 0x80
  40bbf8:	4618      	mov	r0, r3
  40bbfa:	4bc8      	ldr	r3, [pc, #800]	; (40bf1c <inv_icm20948_poll_sensor+0xee4>)
  40bbfc:	4798      	blx	r3
						linacc_float[0] = INVN_FXP_TO_FLT(linAccQ16[0], 16);
  40bbfe:	f107 0380 	add.w	r3, r7, #128	; 0x80
  40bc02:	681b      	ldr	r3, [r3, #0]
  40bc04:	ee07 3a90 	vmov	s15, r3
  40bc08:	eeb8 7ae7 	vcvt.f32.s32	s14, s15
  40bc0c:	eddf 6ac4 	vldr	s13, [pc, #784]	; 40bf20 <inv_icm20948_poll_sensor+0xee8>
  40bc10:	eec7 7a26 	vdiv.f32	s15, s14, s13
  40bc14:	f107 038c 	add.w	r3, r7, #140	; 0x8c
  40bc18:	edc3 7a00 	vstr	s15, [r3]
						linacc_float[1] = INVN_FXP_TO_FLT(linAccQ16[1], 16);
  40bc1c:	f107 0380 	add.w	r3, r7, #128	; 0x80
  40bc20:	685b      	ldr	r3, [r3, #4]
  40bc22:	ee07 3a90 	vmov	s15, r3
  40bc26:	eeb8 7ae7 	vcvt.f32.s32	s14, s15
  40bc2a:	eddf 6abd 	vldr	s13, [pc, #756]	; 40bf20 <inv_icm20948_poll_sensor+0xee8>
  40bc2e:	eec7 7a26 	vdiv.f32	s15, s14, s13
  40bc32:	f107 038c 	add.w	r3, r7, #140	; 0x8c
  40bc36:	edc3 7a01 	vstr	s15, [r3, #4]
						linacc_float[2] = INVN_FXP_TO_FLT(linAccQ16[2], 16);
  40bc3a:	f107 0380 	add.w	r3, r7, #128	; 0x80
  40bc3e:	689b      	ldr	r3, [r3, #8]
  40bc40:	ee07 3a90 	vmov	s15, r3
  40bc44:	eeb8 7ae7 	vcvt.f32.s32	s14, s15
  40bc48:	eddf 6ab5 	vldr	s13, [pc, #724]	; 40bf20 <inv_icm20948_poll_sensor+0xee8>
  40bc4c:	eec7 7a26 	vdiv.f32	s15, s14, s13
  40bc50:	f107 038c 	add.w	r3, r7, #140	; 0x8c
  40bc54:	edc3 7a02 	vstr	s15, [r3, #8]
						s->timestamp[INV_ICM20948_SENSOR_LINEAR_ACCELERATION] += s->sensorlist[INV_ICM20948_SENSOR_LINEAR_ACCELERATION].odr_applied_us;
  40bc58:	f107 030c 	add.w	r3, r7, #12
  40bc5c:	681b      	ldr	r3, [r3, #0]
  40bc5e:	f503 7354 	add.w	r3, r3, #848	; 0x350
  40bc62:	e9d3 1200 	ldrd	r1, r2, [r3]
  40bc66:	f107 030c 	add.w	r3, r7, #12
  40bc6a:	681b      	ldr	r3, [r3, #0]
  40bc6c:	f503 6393 	add.w	r3, r3, #1176	; 0x498
  40bc70:	e9d3 3400 	ldrd	r3, r4, [r3]
  40bc74:	185b      	adds	r3, r3, r1
  40bc76:	eb44 0402 	adc.w	r4, r4, r2
  40bc7a:	f107 020c 	add.w	r2, r7, #12
  40bc7e:	6812      	ldr	r2, [r2, #0]
  40bc80:	f502 7254 	add.w	r2, r2, #848	; 0x350
  40bc84:	e9c2 3400 	strd	r3, r4, [r2]
						handler(context, INV_ICM20948_SENSOR_LINEAR_ACCELERATION, s->timestamp[INV_ICM20948_SENSOR_LINEAR_ACCELERATION], linacc_float, &accel_accuracy);
  40bc88:	f107 030c 	add.w	r3, r7, #12
  40bc8c:	681b      	ldr	r3, [r3, #0]
  40bc8e:	f503 7354 	add.w	r3, r3, #848	; 0x350
  40bc92:	e9d3 3400 	ldrd	r3, r4, [r3]
  40bc96:	f107 0008 	add.w	r0, r7, #8
  40bc9a:	1d3a      	adds	r2, r7, #4
  40bc9c:	f507 71d4 	add.w	r1, r7, #424	; 0x1a8
  40bca0:	9101      	str	r1, [sp, #4]
  40bca2:	f107 018c 	add.w	r1, r7, #140	; 0x8c
  40bca6:	9100      	str	r1, [sp, #0]
  40bca8:	6815      	ldr	r5, [r2, #0]
  40bcaa:	461a      	mov	r2, r3
  40bcac:	4623      	mov	r3, r4
  40bcae:	2111      	movs	r1, #17
  40bcb0:	6800      	ldr	r0, [r0, #0]
  40bcb2:	47a8      	blx	r5
					}
				}
				/* 9axis orientation quaternion sample available from DMP FIFO */
				if (header & QUAT9_SET) {
  40bcb4:	f8b7 31f0 	ldrh.w	r3, [r7, #496]	; 0x1f0
  40bcb8:	f403 6380 	and.w	r3, r3, #1024	; 0x400
  40bcbc:	2b00      	cmp	r3, #0
  40bcbe:	f000 80e6 	beq.w	40be8e <inv_icm20948_poll_sensor+0xe56>
					float ref_quat[4];
					/* Read 9 axis quaternion out of DMP FIFO in Q30 */
					inv_icm20948_dmp_get_9quaternion(long_quat);
  40bcc2:	f507 73e4 	add.w	r3, r7, #456	; 0x1c8
  40bcc6:	4618      	mov	r0, r3
  40bcc8:	4b96      	ldr	r3, [pc, #600]	; (40bf24 <inv_icm20948_poll_sensor+0xeec>)
  40bcca:	4798      	blx	r3
					if(inv_icm20948_ctrl_androidSensor_enabled(s, ANDROID_SENSOR_ROTATION_VECTOR) && !skip_sensor(s, ANDROID_SENSOR_ROTATION_VECTOR)) {
  40bccc:	f107 030c 	add.w	r3, r7, #12
  40bcd0:	210b      	movs	r1, #11
  40bcd2:	6818      	ldr	r0, [r3, #0]
  40bcd4:	4b94      	ldr	r3, [pc, #592]	; (40bf28 <inv_icm20948_poll_sensor+0xef0>)
  40bcd6:	4798      	blx	r3
  40bcd8:	4603      	mov	r3, r0
  40bcda:	2b00      	cmp	r3, #0
  40bcdc:	d063      	beq.n	40bda6 <inv_icm20948_poll_sensor+0xd6e>
  40bcde:	f107 030c 	add.w	r3, r7, #12
  40bce2:	210b      	movs	r1, #11
  40bce4:	6818      	ldr	r0, [r3, #0]
  40bce6:	4b91      	ldr	r3, [pc, #580]	; (40bf2c <inv_icm20948_poll_sensor+0xef4>)
  40bce8:	4798      	blx	r3
  40bcea:	4603      	mov	r3, r0
  40bcec:	2b00      	cmp	r3, #0
  40bcee:	d15a      	bne.n	40bda6 <inv_icm20948_poll_sensor+0xd6e>
						/* and convert it from Q30 DMP format to Android format only if RV sensor is enabled */
						inv_icm20948_convert_rotation_vector(s, long_quat, rv_float);
  40bcf0:	f507 72a6 	add.w	r2, r7, #332	; 0x14c
  40bcf4:	f507 71e4 	add.w	r1, r7, #456	; 0x1c8
  40bcf8:	f107 030c 	add.w	r3, r7, #12
  40bcfc:	6818      	ldr	r0, [r3, #0]
  40bcfe:	4b8c      	ldr	r3, [pc, #560]	; (40bf30 <inv_icm20948_poll_sensor+0xef8>)
  40bd00:	4798      	blx	r3
						/* Read rotation vector heading accuracy out of DMP FIFO in Q29*/
						{
							float rv_accur = inv_icm20948_get_rv_accuracy();
  40bd02:	4b8c      	ldr	r3, [pc, #560]	; (40bf34 <inv_icm20948_poll_sensor+0xefc>)
  40bd04:	4798      	blx	r3
  40bd06:	ee07 0a90 	vmov	s15, r0
  40bd0a:	eef8 7ae7 	vcvt.f32.s32	s15, s15
  40bd0e:	edc7 7a7f 	vstr	s15, [r7, #508]	; 0x1fc
							rv_accuracy = rv_accur/(float)(1ULL << (29));
  40bd12:	ed97 7a7f 	vldr	s14, [r7, #508]	; 0x1fc
  40bd16:	eddf 6a88 	vldr	s13, [pc, #544]	; 40bf38 <inv_icm20948_poll_sensor+0xf00>
  40bd1a:	eec7 7a26 	vdiv.f32	s15, s14, s13
  40bd1e:	edc7 7a68 	vstr	s15, [r7, #416]	; 0x1a0
						}
						ref_quat[0] = rv_float[3];
  40bd22:	f8d7 2158 	ldr.w	r2, [r7, #344]	; 0x158
  40bd26:	f107 0364 	add.w	r3, r7, #100	; 0x64
  40bd2a:	601a      	str	r2, [r3, #0]
						ref_quat[1] = rv_float[0];
  40bd2c:	f8d7 214c 	ldr.w	r2, [r7, #332]	; 0x14c
  40bd30:	f107 0364 	add.w	r3, r7, #100	; 0x64
  40bd34:	605a      	str	r2, [r3, #4]
						ref_quat[2] = rv_float[1];
  40bd36:	f8d7 2150 	ldr.w	r2, [r7, #336]	; 0x150
  40bd3a:	f107 0364 	add.w	r3, r7, #100	; 0x64
  40bd3e:	609a      	str	r2, [r3, #8]
						ref_quat[3] = rv_float[2];
  40bd40:	f8d7 2154 	ldr.w	r2, [r7, #340]	; 0x154
  40bd44:	f107 0364 	add.w	r3, r7, #100	; 0x64
  40bd48:	60da      	str	r2, [r3, #12]
						s->timestamp[INV_ICM20948_SENSOR_ROTATION_VECTOR] += s->sensorlist[INV_ICM20948_SENSOR_ROTATION_VECTOR].odr_applied_us;
  40bd4a:	f107 030c 	add.w	r3, r7, #12
  40bd4e:	681b      	ldr	r3, [r3, #0]
  40bd50:	f503 7346 	add.w	r3, r3, #792	; 0x318
  40bd54:	e9d3 1200 	ldrd	r1, r2, [r3]
  40bd58:	f107 030c 	add.w	r3, r7, #12
  40bd5c:	681b      	ldr	r3, [r3, #0]
  40bd5e:	f503 6385 	add.w	r3, r3, #1064	; 0x428
  40bd62:	e9d3 3400 	ldrd	r3, r4, [r3]
  40bd66:	185b      	adds	r3, r3, r1
  40bd68:	eb44 0402 	adc.w	r4, r4, r2
  40bd6c:	f107 020c 	add.w	r2, r7, #12
  40bd70:	6812      	ldr	r2, [r2, #0]
  40bd72:	f502 7246 	add.w	r2, r2, #792	; 0x318
  40bd76:	e9c2 3400 	strd	r3, r4, [r2]
						handler(context, INV_ICM20948_SENSOR_ROTATION_VECTOR, s->timestamp[INV_ICM20948_SENSOR_ROTATION_VECTOR], ref_quat, &rv_accuracy);
  40bd7a:	f107 030c 	add.w	r3, r7, #12
  40bd7e:	681b      	ldr	r3, [r3, #0]
  40bd80:	f503 7346 	add.w	r3, r3, #792	; 0x318
  40bd84:	e9d3 3400 	ldrd	r3, r4, [r3]
  40bd88:	f107 0008 	add.w	r0, r7, #8
  40bd8c:	1d3a      	adds	r2, r7, #4
  40bd8e:	f507 71d0 	add.w	r1, r7, #416	; 0x1a0
  40bd92:	9101      	str	r1, [sp, #4]
  40bd94:	f107 0164 	add.w	r1, r7, #100	; 0x64
  40bd98:	9100      	str	r1, [sp, #0]
  40bd9a:	6815      	ldr	r5, [r2, #0]
  40bd9c:	461a      	mov	r2, r3
  40bd9e:	4623      	mov	r3, r4
  40bda0:	210a      	movs	r1, #10
  40bda2:	6800      	ldr	r0, [r0, #0]
  40bda4:	47a8      	blx	r5
					}

					if(inv_icm20948_ctrl_androidSensor_enabled(s, ANDROID_SENSOR_ORIENTATION) && !skip_sensor(s, ANDROID_SENSOR_ORIENTATION)) {
  40bda6:	f107 030c 	add.w	r3, r7, #12
  40bdaa:	2103      	movs	r1, #3
  40bdac:	6818      	ldr	r0, [r3, #0]
  40bdae:	4b5e      	ldr	r3, [pc, #376]	; (40bf28 <inv_icm20948_poll_sensor+0xef0>)
  40bdb0:	4798      	blx	r3
  40bdb2:	4603      	mov	r3, r0
  40bdb4:	2b00      	cmp	r3, #0
  40bdb6:	d06a      	beq.n	40be8e <inv_icm20948_poll_sensor+0xe56>
  40bdb8:	f107 030c 	add.w	r3, r7, #12
  40bdbc:	2103      	movs	r1, #3
  40bdbe:	6818      	ldr	r0, [r3, #0]
  40bdc0:	4b5a      	ldr	r3, [pc, #360]	; (40bf2c <inv_icm20948_poll_sensor+0xef4>)
  40bdc2:	4798      	blx	r3
  40bdc4:	4603      	mov	r3, r0
  40bdc6:	2b00      	cmp	r3, #0
  40bdc8:	d161      	bne.n	40be8e <inv_icm20948_poll_sensor+0xe56>
						long orientationQ16[3];
						float orientation_float[3];
						/* Compute Android-orientation sensor data based on rotation vector data in Q30 */
						inv_icm20948_augmented_sensors_get_orientation(orientationQ16, long_quat);
  40bdca:	f507 72e4 	add.w	r2, r7, #456	; 0x1c8
  40bdce:	f107 0358 	add.w	r3, r7, #88	; 0x58
  40bdd2:	4611      	mov	r1, r2
  40bdd4:	4618      	mov	r0, r3
  40bdd6:	4b59      	ldr	r3, [pc, #356]	; (40bf3c <inv_icm20948_poll_sensor+0xf04>)
  40bdd8:	4798      	blx	r3
						orientation_float[0] = INVN_FXP_TO_FLT(orientationQ16[0], 16);
  40bdda:	f107 0358 	add.w	r3, r7, #88	; 0x58
  40bdde:	681b      	ldr	r3, [r3, #0]
  40bde0:	ee07 3a90 	vmov	s15, r3
  40bde4:	eeb8 7ae7 	vcvt.f32.s32	s14, s15
  40bde8:	eddf 6a4d 	vldr	s13, [pc, #308]	; 40bf20 <inv_icm20948_poll_sensor+0xee8>
  40bdec:	eec7 7a26 	vdiv.f32	s15, s14, s13
  40bdf0:	f107 034c 	add.w	r3, r7, #76	; 0x4c
  40bdf4:	edc3 7a00 	vstr	s15, [r3]
						orientation_float[1] = INVN_FXP_TO_FLT(orientationQ16[1], 16);
  40bdf8:	f107 0358 	add.w	r3, r7, #88	; 0x58
  40bdfc:	685b      	ldr	r3, [r3, #4]
  40bdfe:	ee07 3a90 	vmov	s15, r3
  40be02:	eeb8 7ae7 	vcvt.f32.s32	s14, s15
  40be06:	eddf 6a46 	vldr	s13, [pc, #280]	; 40bf20 <inv_icm20948_poll_sensor+0xee8>
  40be0a:	eec7 7a26 	vdiv.f32	s15, s14, s13
  40be0e:	f107 034c 	add.w	r3, r7, #76	; 0x4c
  40be12:	edc3 7a01 	vstr	s15, [r3, #4]
						orientation_float[2] = INVN_FXP_TO_FLT(orientationQ16[2], 16);
  40be16:	f107 0358 	add.w	r3, r7, #88	; 0x58
  40be1a:	689b      	ldr	r3, [r3, #8]
  40be1c:	ee07 3a90 	vmov	s15, r3
  40be20:	eeb8 7ae7 	vcvt.f32.s32	s14, s15
  40be24:	eddf 6a3e 	vldr	s13, [pc, #248]	; 40bf20 <inv_icm20948_poll_sensor+0xee8>
  40be28:	eec7 7a26 	vdiv.f32	s15, s14, s13
  40be2c:	f107 034c 	add.w	r3, r7, #76	; 0x4c
  40be30:	edc3 7a02 	vstr	s15, [r3, #8]
						s->timestamp[INV_ICM20948_SENSOR_ORIENTATION] += s->sensorlist[INV_ICM20948_SENSOR_ORIENTATION].odr_applied_us;
  40be34:	f107 030c 	add.w	r3, r7, #12
  40be38:	681b      	ldr	r3, [r3, #0]
  40be3a:	f503 7356 	add.w	r3, r3, #856	; 0x358
  40be3e:	e9d3 1200 	ldrd	r1, r2, [r3]
  40be42:	f107 030c 	add.w	r3, r7, #12
  40be46:	681b      	ldr	r3, [r3, #0]
  40be48:	f503 6395 	add.w	r3, r3, #1192	; 0x4a8
  40be4c:	e9d3 3400 	ldrd	r3, r4, [r3]
  40be50:	185b      	adds	r3, r3, r1
  40be52:	eb44 0402 	adc.w	r4, r4, r2
  40be56:	f107 020c 	add.w	r2, r7, #12
  40be5a:	6812      	ldr	r2, [r2, #0]
  40be5c:	f502 7256 	add.w	r2, r2, #856	; 0x358
  40be60:	e9c2 3400 	strd	r3, r4, [r2]
						handler(context, INV_ICM20948_SENSOR_ORIENTATION, s->timestamp[INV_ICM20948_SENSOR_ORIENTATION], orientation_float, 0);
  40be64:	f107 030c 	add.w	r3, r7, #12
  40be68:	681b      	ldr	r3, [r3, #0]
  40be6a:	f503 7356 	add.w	r3, r3, #856	; 0x358
  40be6e:	e9d3 3400 	ldrd	r3, r4, [r3]
  40be72:	f107 0008 	add.w	r0, r7, #8
  40be76:	1d3a      	adds	r2, r7, #4
  40be78:	2100      	movs	r1, #0
  40be7a:	9101      	str	r1, [sp, #4]
  40be7c:	f107 014c 	add.w	r1, r7, #76	; 0x4c
  40be80:	9100      	str	r1, [sp, #0]
  40be82:	6815      	ldr	r5, [r2, #0]
  40be84:	461a      	mov	r2, r3
  40be86:	4623      	mov	r3, r4
  40be88:	2112      	movs	r1, #18
  40be8a:	6800      	ldr	r0, [r0, #0]
  40be8c:	47a8      	blx	r5
					}
				}
				/* 6axis AM orientation quaternion sample available from DMP FIFO */
				if (header & GEOMAG_SET) {
  40be8e:	f8b7 31f0 	ldrh.w	r3, [r7, #496]	; 0x1f0
  40be92:	f403 7380 	and.w	r3, r3, #256	; 0x100
  40be96:	2b00      	cmp	r3, #0
  40be98:	f000 808a 	beq.w	40bfb0 <inv_icm20948_poll_sensor+0xf78>
					float ref_quat[4];
					/* Read 6 axis quaternion out of DMP FIFO in Q30 and convert it to Android format */
					inv_icm20948_dmp_get_gmrvquaternion(long_quat);
  40be9c:	f507 73e4 	add.w	r3, r7, #456	; 0x1c8
  40bea0:	4618      	mov	r0, r3
  40bea2:	4b27      	ldr	r3, [pc, #156]	; (40bf40 <inv_icm20948_poll_sensor+0xf08>)
  40bea4:	4798      	blx	r3
					if(inv_icm20948_ctrl_androidSensor_enabled(s, ANDROID_SENSOR_GEOMAGNETIC_ROTATION_VECTOR) && !skip_sensor(s, ANDROID_SENSOR_GEOMAGNETIC_ROTATION_VECTOR)) {
  40bea6:	f107 030c 	add.w	r3, r7, #12
  40beaa:	2114      	movs	r1, #20
  40beac:	6818      	ldr	r0, [r3, #0]
  40beae:	4b1e      	ldr	r3, [pc, #120]	; (40bf28 <inv_icm20948_poll_sensor+0xef0>)
  40beb0:	4798      	blx	r3
  40beb2:	4603      	mov	r3, r0
  40beb4:	2b00      	cmp	r3, #0
  40beb6:	d07b      	beq.n	40bfb0 <inv_icm20948_poll_sensor+0xf78>
  40beb8:	f107 030c 	add.w	r3, r7, #12
  40bebc:	2114      	movs	r1, #20
  40bebe:	6818      	ldr	r0, [r3, #0]
  40bec0:	4b1a      	ldr	r3, [pc, #104]	; (40bf2c <inv_icm20948_poll_sensor+0xef4>)
  40bec2:	4798      	blx	r3
  40bec4:	4603      	mov	r3, r0
  40bec6:	2b00      	cmp	r3, #0
  40bec8:	d172      	bne.n	40bfb0 <inv_icm20948_poll_sensor+0xf78>
						inv_icm20948_convert_rotation_vector(s, long_quat, gmrv_float);
  40beca:	f507 729e 	add.w	r2, r7, #316	; 0x13c
  40bece:	f507 71e4 	add.w	r1, r7, #456	; 0x1c8
  40bed2:	f107 030c 	add.w	r3, r7, #12
  40bed6:	6818      	ldr	r0, [r3, #0]
  40bed8:	4b15      	ldr	r3, [pc, #84]	; (40bf30 <inv_icm20948_poll_sensor+0xef8>)
  40beda:	4798      	blx	r3
						/* Read geomagnetic rotation vector heading accuracy out of DMP FIFO in Q29*/
						{
							float gmrv_acc = inv_icm20948_get_gmrv_accuracy();
  40bedc:	4b19      	ldr	r3, [pc, #100]	; (40bf44 <inv_icm20948_poll_sensor+0xf0c>)
  40bede:	4798      	blx	r3
  40bee0:	ee07 0a90 	vmov	s15, r0
  40bee4:	eef8 7ae7 	vcvt.f32.s32	s15, s15
  40bee8:	edc7 7a7e 	vstr	s15, [r7, #504]	; 0x1f8
							gmrv_accuracy = gmrv_acc/(float)(1ULL << (29));
  40beec:	ed97 7a7e 	vldr	s14, [r7, #504]	; 0x1f8
  40bef0:	eddf 6a11 	vldr	s13, [pc, #68]	; 40bf38 <inv_icm20948_poll_sensor+0xf00>
  40bef4:	eec7 7a26 	vdiv.f32	s15, s14, s13
  40bef8:	edc7 7a67 	vstr	s15, [r7, #412]	; 0x19c
						}
						ref_quat[0] = gmrv_float[3];
  40befc:	f8d7 2148 	ldr.w	r2, [r7, #328]	; 0x148
  40bf00:	f107 033c 	add.w	r3, r7, #60	; 0x3c
  40bf04:	601a      	str	r2, [r3, #0]
						ref_quat[1] = gmrv_float[0];
  40bf06:	f8d7 213c 	ldr.w	r2, [r7, #316]	; 0x13c
  40bf0a:	f107 033c 	add.w	r3, r7, #60	; 0x3c
  40bf0e:	605a      	str	r2, [r3, #4]
						ref_quat[2] = gmrv_float[1];
  40bf10:	f8d7 2140 	ldr.w	r2, [r7, #320]	; 0x140
  40bf14:	f107 033c 	add.w	r3, r7, #60	; 0x3c
  40bf18:	e016      	b.n	40bf48 <inv_icm20948_poll_sensor+0xf10>
  40bf1a:	bf00      	nop
  40bf1c:	0040ffb1 	.word	0x0040ffb1
  40bf20:	47800000 	.word	0x47800000
  40bf24:	00409819 	.word	0x00409819
  40bf28:	004107b9 	.word	0x004107b9
  40bf2c:	0040a6fd 	.word	0x0040a6fd
  40bf30:	00406999 	.word	0x00406999
  40bf34:	004099cd 	.word	0x004099cd
  40bf38:	4e000000 	.word	0x4e000000
  40bf3c:	00410025 	.word	0x00410025
  40bf40:	00409849 	.word	0x00409849
  40bf44:	004099b5 	.word	0x004099b5
  40bf48:	609a      	str	r2, [r3, #8]
						ref_quat[3] = gmrv_float[2];
  40bf4a:	f8d7 2144 	ldr.w	r2, [r7, #324]	; 0x144
  40bf4e:	f107 033c 	add.w	r3, r7, #60	; 0x3c
  40bf52:	60da      	str	r2, [r3, #12]
						s->timestamp[INV_ICM20948_SENSOR_GEOMAGNETIC_ROTATION_VECTOR] += s->sensorlist[INV_ICM20948_SENSOR_GEOMAGNETIC_ROTATION_VECTOR].odr_applied_us;
  40bf54:	f107 030c 	add.w	r3, r7, #12
  40bf58:	681b      	ldr	r3, [r3, #0]
  40bf5a:	f503 7348 	add.w	r3, r3, #800	; 0x320
  40bf5e:	e9d3 1200 	ldrd	r1, r2, [r3]
  40bf62:	f107 030c 	add.w	r3, r7, #12
  40bf66:	681b      	ldr	r3, [r3, #0]
  40bf68:	f503 6387 	add.w	r3, r3, #1080	; 0x438
  40bf6c:	e9d3 3400 	ldrd	r3, r4, [r3]
  40bf70:	185b      	adds	r3, r3, r1
  40bf72:	eb44 0402 	adc.w	r4, r4, r2
  40bf76:	f107 020c 	add.w	r2, r7, #12
  40bf7a:	6812      	ldr	r2, [r2, #0]
  40bf7c:	f502 7248 	add.w	r2, r2, #800	; 0x320
  40bf80:	e9c2 3400 	strd	r3, r4, [r2]
						handler(context, INV_ICM20948_SENSOR_GEOMAGNETIC_ROTATION_VECTOR, s->timestamp[INV_ICM20948_SENSOR_GEOMAGNETIC_ROTATION_VECTOR],
  40bf84:	f107 030c 	add.w	r3, r7, #12
  40bf88:	681b      	ldr	r3, [r3, #0]
  40bf8a:	f503 7348 	add.w	r3, r3, #800	; 0x320
  40bf8e:	e9d3 3400 	ldrd	r3, r4, [r3]
  40bf92:	f107 0008 	add.w	r0, r7, #8
  40bf96:	1d3a      	adds	r2, r7, #4
  40bf98:	f507 71ce 	add.w	r1, r7, #412	; 0x19c
  40bf9c:	9101      	str	r1, [sp, #4]
  40bf9e:	f107 013c 	add.w	r1, r7, #60	; 0x3c
  40bfa2:	9100      	str	r1, [sp, #0]
  40bfa4:	6815      	ldr	r5, [r2, #0]
  40bfa6:	461a      	mov	r2, r3
  40bfa8:	4623      	mov	r3, r4
  40bfaa:	210b      	movs	r1, #11
  40bfac:	6800      	ldr	r0, [r0, #0]
  40bfae:	47a8      	blx	r5
							ref_quat, &gmrv_accuracy);
					}
				}
				/* Activity recognition sample available from DMP FIFO */
				if (header2 & ACT_RECOG_SET) {
  40bfb0:	f8b7 31ee 	ldrh.w	r3, [r7, #494]	; 0x1ee
  40bfb4:	f003 0380 	and.w	r3, r3, #128	; 0x80
  40bfb8:	2b00      	cmp	r3, #0
  40bfba:	f000 80c1 	beq.w	40c140 <inv_icm20948_poll_sensor+0x1108>
					uint16_t bac_state = 0;
  40bfbe:	f107 033a 	add.w	r3, r7, #58	; 0x3a
  40bfc2:	2200      	movs	r2, #0
  40bfc4:	801a      	strh	r2, [r3, #0]
					long bac_ts = 0;
  40bfc6:	f107 0334 	add.w	r3, r7, #52	; 0x34
  40bfca:	2200      	movs	r2, #0
  40bfcc:	601a      	str	r2, [r3, #0]
					int bac_event = 0;
  40bfce:	f107 0330 	add.w	r3, r7, #48	; 0x30
  40bfd2:	2200      	movs	r2, #0
  40bfd4:	601a      	str	r2, [r3, #0]
					struct bac_map{
						uint8_t act_id;
						enum inv_sensor_bac_event sensor_bac;
					} map[] = {
  40bfd6:	f107 0324 	add.w	r3, r7, #36	; 0x24
  40bfda:	4aa1      	ldr	r2, [pc, #644]	; (40c260 <inv_icm20948_poll_sensor+0x1228>)
  40bfdc:	ca07      	ldmia	r2, {r0, r1, r2}
  40bfde:	e883 0007 	stmia.w	r3, {r0, r1, r2}
						{ BAC_RUN, INV_SENSOR_BAC_EVENT_ACT_RUNNING_BEGIN},
						{ BAC_BIKE, INV_SENSOR_BAC_EVENT_ACT_ON_BICYCLE_BEGIN},
						{ BAC_STILL, INV_SENSOR_BAC_EVENT_ACT_STILL_BEGIN},
						{ BAC_TILT, INV_SENSOR_BAC_EVENT_ACT_TILT_BEGIN},
					};
					int i = 0;
  40bfe2:	2300      	movs	r3, #0
  40bfe4:	f8c7 3214 	str.w	r3, [r7, #532]	; 0x214
					/* Read activity type and associated timestamp out of DMP FIFO
					activity type is a set of 2 bytes :
					- high byte indicates activity start
					- low byte indicates activity end */
					inv_icm20948_dmp_get_bac_state(&bac_state);
  40bfe8:	f107 033a 	add.w	r3, r7, #58	; 0x3a
  40bfec:	4618      	mov	r0, r3
  40bfee:	4b9d      	ldr	r3, [pc, #628]	; (40c264 <inv_icm20948_poll_sensor+0x122c>)
  40bff0:	4798      	blx	r3
					inv_icm20948_dmp_get_bac_ts(&bac_ts);
  40bff2:	f107 0334 	add.w	r3, r7, #52	; 0x34
  40bff6:	4618      	mov	r0, r3
  40bff8:	4b9b      	ldr	r3, [pc, #620]	; (40c268 <inv_icm20948_poll_sensor+0x1230>)
  40bffa:	4798      	blx	r3
					//Map according to dmp bac events
					for(i = 0; i < 6; i++) {
  40bffc:	2300      	movs	r3, #0
  40bffe:	f8c7 3214 	str.w	r3, [r7, #532]	; 0x214
  40c002:	e098      	b.n	40c136 <inv_icm20948_poll_sensor+0x10fe>
						if ((bac_state >> 8) & map[i].act_id){
  40c004:	f107 033a 	add.w	r3, r7, #58	; 0x3a
  40c008:	881b      	ldrh	r3, [r3, #0]
  40c00a:	0a1b      	lsrs	r3, r3, #8
  40c00c:	b29b      	uxth	r3, r3
  40c00e:	4619      	mov	r1, r3
  40c010:	f107 0324 	add.w	r3, r7, #36	; 0x24
  40c014:	f8d7 2214 	ldr.w	r2, [r7, #532]	; 0x214
  40c018:	f813 3012 	ldrb.w	r3, [r3, r2, lsl #1]
  40c01c:	400b      	ands	r3, r1
  40c01e:	2b00      	cmp	r3, #0
  40c020:	d04e      	beq.n	40c0c0 <inv_icm20948_poll_sensor+0x1088>
							//Check if BAC is enabled
							if (inv_icm20948_ctrl_get_activitiy_classifier_on_flag(s)) {
  40c022:	f107 030c 	add.w	r3, r7, #12
  40c026:	6818      	ldr	r0, [r3, #0]
  40c028:	4b90      	ldr	r3, [pc, #576]	; (40c26c <inv_icm20948_poll_sensor+0x1234>)
  40c02a:	4798      	blx	r3
  40c02c:	4603      	mov	r3, r0
  40c02e:	2b00      	cmp	r3, #0
  40c030:	d020      	beq.n	40c074 <inv_icm20948_poll_sensor+0x103c>
								/* Start detected */
								bac_event = map[i].sensor_bac;
  40c032:	f107 0224 	add.w	r2, r7, #36	; 0x24
  40c036:	f8d7 3214 	ldr.w	r3, [r7, #532]	; 0x214
  40c03a:	005b      	lsls	r3, r3, #1
  40c03c:	4413      	add	r3, r2
  40c03e:	f993 3001 	ldrsb.w	r3, [r3, #1]
  40c042:	461a      	mov	r2, r3
  40c044:	f107 0330 	add.w	r3, r7, #48	; 0x30
  40c048:	601a      	str	r2, [r3, #0]
								handler(context, INV_ICM20948_SENSOR_ACTIVITY_CLASSIFICATON, s->timestamp[INV_ICM20948_SENSOR_ACTIVITY_CLASSIFICATON], &bac_event, 0);
  40c04a:	f107 030c 	add.w	r3, r7, #12
  40c04e:	681b      	ldr	r3, [r3, #0]
  40c050:	f503 733e 	add.w	r3, r3, #760	; 0x2f8
  40c054:	e9d3 3400 	ldrd	r3, r4, [r3]
  40c058:	f107 0008 	add.w	r0, r7, #8
  40c05c:	1d3a      	adds	r2, r7, #4
  40c05e:	2100      	movs	r1, #0
  40c060:	9101      	str	r1, [sp, #4]
  40c062:	f107 0130 	add.w	r1, r7, #48	; 0x30
  40c066:	9100      	str	r1, [sp, #0]
  40c068:	6815      	ldr	r5, [r2, #0]
  40c06a:	461a      	mov	r2, r3
  40c06c:	4623      	mov	r3, r4
  40c06e:	2106      	movs	r1, #6
  40c070:	6800      	ldr	r0, [r0, #0]
  40c072:	47a8      	blx	r5
							}
							//build event TILT only if enabled
							if((map[i].act_id == BAC_TILT) && inv_icm20948_ctrl_androidSensor_enabled(s, ANDROID_SENSOR_WAKEUP_TILT_DETECTOR))
  40c074:	f107 0324 	add.w	r3, r7, #36	; 0x24
  40c078:	f8d7 2214 	ldr.w	r2, [r7, #532]	; 0x214
  40c07c:	f813 3012 	ldrb.w	r3, [r3, r2, lsl #1]
  40c080:	2b10      	cmp	r3, #16
  40c082:	d153      	bne.n	40c12c <inv_icm20948_poll_sensor+0x10f4>
  40c084:	f107 030c 	add.w	r3, r7, #12
  40c088:	2129      	movs	r1, #41	; 0x29
  40c08a:	6818      	ldr	r0, [r3, #0]
  40c08c:	4b78      	ldr	r3, [pc, #480]	; (40c270 <inv_icm20948_poll_sensor+0x1238>)
  40c08e:	4798      	blx	r3
  40c090:	4603      	mov	r3, r0
  40c092:	2b00      	cmp	r3, #0
  40c094:	d04a      	beq.n	40c12c <inv_icm20948_poll_sensor+0x10f4>
								handler(context, INV_ICM20948_SENSOR_WAKEUP_TILT_DETECTOR, s->timestamp[INV_ICM20948_SENSOR_WAKEUP_TILT_DETECTOR], 0, 0);
  40c096:	f107 030c 	add.w	r3, r7, #12
  40c09a:	681b      	ldr	r3, [r3, #0]
  40c09c:	f503 7350 	add.w	r3, r3, #832	; 0x340
  40c0a0:	e9d3 3400 	ldrd	r3, r4, [r3]
  40c0a4:	f107 0008 	add.w	r0, r7, #8
  40c0a8:	1d3a      	adds	r2, r7, #4
  40c0aa:	2100      	movs	r1, #0
  40c0ac:	9101      	str	r1, [sp, #4]
  40c0ae:	2100      	movs	r1, #0
  40c0b0:	9100      	str	r1, [sp, #0]
  40c0b2:	6815      	ldr	r5, [r2, #0]
  40c0b4:	461a      	mov	r2, r3
  40c0b6:	4623      	mov	r3, r4
  40c0b8:	210f      	movs	r1, #15
  40c0ba:	6800      	ldr	r0, [r0, #0]
  40c0bc:	47a8      	blx	r5
  40c0be:	e035      	b.n	40c12c <inv_icm20948_poll_sensor+0x10f4>
						}
						/* Check if bit tilt is set for activity end byte */
						else if (bac_state & map[i].act_id) {
  40c0c0:	f107 033a 	add.w	r3, r7, #58	; 0x3a
  40c0c4:	881b      	ldrh	r3, [r3, #0]
  40c0c6:	4619      	mov	r1, r3
  40c0c8:	f107 0324 	add.w	r3, r7, #36	; 0x24
  40c0cc:	f8d7 2214 	ldr.w	r2, [r7, #532]	; 0x214
  40c0d0:	f813 3012 	ldrb.w	r3, [r3, r2, lsl #1]
  40c0d4:	400b      	ands	r3, r1
  40c0d6:	2b00      	cmp	r3, #0
  40c0d8:	d028      	beq.n	40c12c <inv_icm20948_poll_sensor+0x10f4>
							//Check if BAC is enabled
							if (inv_icm20948_ctrl_get_activitiy_classifier_on_flag(s)) {
  40c0da:	f107 030c 	add.w	r3, r7, #12
  40c0de:	6818      	ldr	r0, [r3, #0]
  40c0e0:	4b62      	ldr	r3, [pc, #392]	; (40c26c <inv_icm20948_poll_sensor+0x1234>)
  40c0e2:	4798      	blx	r3
  40c0e4:	4603      	mov	r3, r0
  40c0e6:	2b00      	cmp	r3, #0
  40c0e8:	d020      	beq.n	40c12c <inv_icm20948_poll_sensor+0x10f4>
								/* End detected */
								bac_event = -map[i].sensor_bac;
  40c0ea:	f107 0224 	add.w	r2, r7, #36	; 0x24
  40c0ee:	f8d7 3214 	ldr.w	r3, [r7, #532]	; 0x214
  40c0f2:	005b      	lsls	r3, r3, #1
  40c0f4:	4413      	add	r3, r2
  40c0f6:	f993 3001 	ldrsb.w	r3, [r3, #1]
  40c0fa:	425a      	negs	r2, r3
  40c0fc:	f107 0330 	add.w	r3, r7, #48	; 0x30
  40c100:	601a      	str	r2, [r3, #0]
								handler(context, INV_ICM20948_SENSOR_ACTIVITY_CLASSIFICATON, s->timestamp[INV_ICM20948_SENSOR_ACTIVITY_CLASSIFICATON], &bac_event, 0);
  40c102:	f107 030c 	add.w	r3, r7, #12
  40c106:	681b      	ldr	r3, [r3, #0]
  40c108:	f503 733e 	add.w	r3, r3, #760	; 0x2f8
  40c10c:	e9d3 3400 	ldrd	r3, r4, [r3]
  40c110:	f107 0008 	add.w	r0, r7, #8
  40c114:	1d3a      	adds	r2, r7, #4
  40c116:	2100      	movs	r1, #0
  40c118:	9101      	str	r1, [sp, #4]
  40c11a:	f107 0130 	add.w	r1, r7, #48	; 0x30
  40c11e:	9100      	str	r1, [sp, #0]
  40c120:	6815      	ldr	r5, [r2, #0]
  40c122:	461a      	mov	r2, r3
  40c124:	4623      	mov	r3, r4
  40c126:	2106      	movs	r1, #6
  40c128:	6800      	ldr	r0, [r0, #0]
  40c12a:	47a8      	blx	r5
					for(i = 0; i < 6; i++) {
  40c12c:	f8d7 3214 	ldr.w	r3, [r7, #532]	; 0x214
  40c130:	3301      	adds	r3, #1
  40c132:	f8c7 3214 	str.w	r3, [r7, #532]	; 0x214
  40c136:	f8d7 3214 	ldr.w	r3, [r7, #532]	; 0x214
  40c13a:	2b05      	cmp	r3, #5
  40c13c:	f77f af62 	ble.w	40c004 <inv_icm20948_poll_sensor+0xfcc>
							}
						}
					}
				}
				/* Pickup sample available from DMP FIFO */
				if (header2 & FLIP_PICKUP_SET) {
  40c140:	f8b7 31ee 	ldrh.w	r3, [r7, #494]	; 0x1ee
  40c144:	f403 6380 	and.w	r3, r3, #1024	; 0x400
  40c148:	2b00      	cmp	r3, #0
  40c14a:	d019      	beq.n	40c180 <inv_icm20948_poll_sensor+0x1148>
					/* Read pickup type and associated timestamp out of DMP FIFO */
					inv_icm20948_dmp_get_flip_pickup_state(&pickup_state);
  40c14c:	f507 739d 	add.w	r3, r7, #314	; 0x13a
  40c150:	4618      	mov	r0, r3
  40c152:	4b48      	ldr	r3, [pc, #288]	; (40c274 <inv_icm20948_poll_sensor+0x123c>)
  40c154:	4798      	blx	r3
					handler(context, INV_ICM20948_SENSOR_FLIP_PICKUP, s->timestamp[INV_ICM20948_SENSOR_FLIP_PICKUP], &pickup_state, 0);
  40c156:	f107 030c 	add.w	r3, r7, #12
  40c15a:	681b      	ldr	r3, [r3, #0]
  40c15c:	f503 734e 	add.w	r3, r3, #824	; 0x338
  40c160:	e9d3 3400 	ldrd	r3, r4, [r3]
  40c164:	f107 0008 	add.w	r0, r7, #8
  40c168:	1d3a      	adds	r2, r7, #4
  40c16a:	2100      	movs	r1, #0
  40c16c:	9101      	str	r1, [sp, #4]
  40c16e:	f507 719d 	add.w	r1, r7, #314	; 0x13a
  40c172:	9100      	str	r1, [sp, #0]
  40c174:	6815      	ldr	r5, [r2, #0]
  40c176:	461a      	mov	r2, r3
  40c178:	4623      	mov	r3, r4
  40c17a:	210e      	movs	r1, #14
  40c17c:	6800      	ldr	r0, [r0, #0]
  40c17e:	47a8      	blx	r5
				}

				/* Step detector available from DMP FIFO and step counter sensor is enabled*/
				// If step detector enabled => step counter started too
				// So don't watch the step counter data if the user doesn't start the sensor
				if((header & PED_STEPDET_SET) && (inv_icm20948_ctrl_androidSensor_enabled(s, ANDROID_SENSOR_STEP_COUNTER))) {
  40c180:	f8b7 31f0 	ldrh.w	r3, [r7, #496]	; 0x1f0
  40c184:	f003 0310 	and.w	r3, r3, #16
  40c188:	2b00      	cmp	r3, #0
  40c18a:	d057      	beq.n	40c23c <inv_icm20948_poll_sensor+0x1204>
  40c18c:	f107 030c 	add.w	r3, r7, #12
  40c190:	2113      	movs	r1, #19
  40c192:	6818      	ldr	r0, [r3, #0]
  40c194:	4b36      	ldr	r3, [pc, #216]	; (40c270 <inv_icm20948_poll_sensor+0x1238>)
  40c196:	4798      	blx	r3
  40c198:	4603      	mov	r3, r0
  40c19a:	2b00      	cmp	r3, #0
  40c19c:	d04e      	beq.n	40c23c <inv_icm20948_poll_sensor+0x1204>
					unsigned long steps;
					unsigned long lsteps;
					uint64_t stepc = 0;
  40c19e:	f107 0218 	add.w	r2, r7, #24
  40c1a2:	f04f 0300 	mov.w	r3, #0
  40c1a6:	f04f 0400 	mov.w	r4, #0
  40c1aa:	e9c2 3400 	strd	r3, r4, [r2]
					/* Read amount of steps counted out of DMP FIFO and notify them only if updated */
					dmp_icm20948_get_pedometer_num_of_steps(s, &lsteps);
  40c1ae:	f107 0220 	add.w	r2, r7, #32
  40c1b2:	f107 030c 	add.w	r3, r7, #12
  40c1b6:	4611      	mov	r1, r2
  40c1b8:	6818      	ldr	r0, [r3, #0]
  40c1ba:	4b2f      	ldr	r3, [pc, #188]	; (40c278 <inv_icm20948_poll_sensor+0x1240>)
  40c1bc:	4798      	blx	r3
					// need to subtract the steps accumulated while Step Counter sensor is not active.
					steps = lsteps - s->sStepCounterToBeSubtracted;
  40c1be:	f107 0320 	add.w	r3, r7, #32
  40c1c2:	681a      	ldr	r2, [r3, #0]
  40c1c4:	f107 030c 	add.w	r3, r7, #12
  40c1c8:	681b      	ldr	r3, [r3, #0]
  40c1ca:	f8d3 30a0 	ldr.w	r3, [r3, #160]	; 0xa0
  40c1ce:	1ad3      	subs	r3, r2, r3
  40c1d0:	f8c7 31f4 	str.w	r3, [r7, #500]	; 0x1f4
					stepc = steps;
  40c1d4:	f8d7 31f4 	ldr.w	r3, [r7, #500]	; 0x1f4
  40c1d8:	f04f 0400 	mov.w	r4, #0
  40c1dc:	f107 0218 	add.w	r2, r7, #24
  40c1e0:	e9c2 3400 	strd	r3, r4, [r2]
					if(stepc != s->sOldSteps) {
  40c1e4:	f107 030c 	add.w	r3, r7, #12
  40c1e8:	681b      	ldr	r3, [r3, #0]
  40c1ea:	f8d3 30a4 	ldr.w	r3, [r3, #164]	; 0xa4
  40c1ee:	4619      	mov	r1, r3
  40c1f0:	f04f 0200 	mov.w	r2, #0
  40c1f4:	f107 0318 	add.w	r3, r7, #24
  40c1f8:	e9d3 3400 	ldrd	r3, r4, [r3]
  40c1fc:	42a2      	cmp	r2, r4
  40c1fe:	bf08      	it	eq
  40c200:	4299      	cmpeq	r1, r3
  40c202:	d01b      	beq.n	40c23c <inv_icm20948_poll_sensor+0x1204>
						s->sOldSteps = steps;
  40c204:	f107 030c 	add.w	r3, r7, #12
  40c208:	681b      	ldr	r3, [r3, #0]
  40c20a:	f8d7 21f4 	ldr.w	r2, [r7, #500]	; 0x1f4
  40c20e:	f8c3 20a4 	str.w	r2, [r3, #164]	; 0xa4
						handler(context, INV_ICM20948_SENSOR_STEP_COUNTER, s->timestamp[INV_ICM20948_SENSOR_STEP_COUNTER], &stepc, 0);
  40c212:	f107 030c 	add.w	r3, r7, #12
  40c216:	681b      	ldr	r3, [r3, #0]
  40c218:	f503 7342 	add.w	r3, r3, #776	; 0x308
  40c21c:	e9d3 3400 	ldrd	r3, r4, [r3]
  40c220:	f107 0008 	add.w	r0, r7, #8
  40c224:	1d3a      	adds	r2, r7, #4
  40c226:	2100      	movs	r1, #0
  40c228:	9101      	str	r1, [sp, #4]
  40c22a:	f107 0118 	add.w	r1, r7, #24
  40c22e:	9100      	str	r1, [sp, #0]
  40c230:	6815      	ldr	r5, [r2, #0]
  40c232:	461a      	mov	r2, r3
  40c234:	4623      	mov	r3, r4
  40c236:	2108      	movs	r1, #8
  40c238:	6800      	ldr	r0, [r0, #0]
  40c23a:	47a8      	blx	r5
			while(total_sample_cnt--) {
  40c23c:	f8b7 312e 	ldrh.w	r3, [r7, #302]	; 0x12e
  40c240:	1e5a      	subs	r2, r3, #1
  40c242:	b292      	uxth	r2, r2
  40c244:	f8a7 212e 	strh.w	r2, [r7, #302]	; 0x12e
  40c248:	2b00      	cmp	r3, #0
  40c24a:	f47e af6d 	bne.w	40b128 <inv_icm20948_poll_sensor+0xf0>
  40c24e:	e000      	b.n	40c252 <inv_icm20948_poll_sensor+0x121a>
					break;
  40c250:	bf00      	nop
					}
				}
			}
		} while(data_left_in_fifo);
  40c252:	f8d7 31e8 	ldr.w	r3, [r7, #488]	; 0x1e8
  40c256:	2b00      	cmp	r3, #0
  40c258:	f47e af4c 	bne.w	40b0f4 <inv_icm20948_poll_sensor+0xbc>
  40c25c:	e00f      	b.n	40c27e <inv_icm20948_poll_sensor+0x1246>
  40c25e:	bf00      	nop
  40c260:	0041bf10 	.word	0x0041bf10
  40c264:	004098d9 	.word	0x004098d9
  40c268:	00409909 	.word	0x00409909
  40c26c:	00412309 	.word	0x00412309
  40c270:	004107b9 	.word	0x004107b9
  40c274:	00409939 	.word	0x00409939
  40c278:	0040827d 	.word	0x0040827d
				break;
  40c27c:	bf00      	nop

		/* SMD detected by DMP */
		if (int_read_back & BIT_MSG_DMP_INT_2) {
  40c27e:	f9b7 31f2 	ldrsh.w	r3, [r7, #498]	; 0x1f2
  40c282:	b29b      	uxth	r3, r3
  40c284:	f403 7300 	and.w	r3, r3, #512	; 0x200
  40c288:	2b00      	cmp	r3, #0
  40c28a:	d018      	beq.n	40c2be <inv_icm20948_poll_sensor+0x1286>
			uint8_t event = 0;
  40c28c:	f107 0317 	add.w	r3, r7, #23
  40c290:	2200      	movs	r2, #0
  40c292:	701a      	strb	r2, [r3, #0]
			handler(context, INV_ICM20948_SENSOR_WAKEUP_SIGNIFICANT_MOTION, s->timestamp[INV_ICM20948_SENSOR_WAKEUP_SIGNIFICANT_MOTION], &event, 0);
  40c294:	f107 030c 	add.w	r3, r7, #12
  40c298:	681b      	ldr	r3, [r3, #0]
  40c29a:	f503 734c 	add.w	r3, r3, #816	; 0x330
  40c29e:	e9d3 3400 	ldrd	r3, r4, [r3]
  40c2a2:	f107 0008 	add.w	r0, r7, #8
  40c2a6:	1d3a      	adds	r2, r7, #4
  40c2a8:	2100      	movs	r1, #0
  40c2aa:	9101      	str	r1, [sp, #4]
  40c2ac:	f107 0117 	add.w	r1, r7, #23
  40c2b0:	9100      	str	r1, [sp, #0]
  40c2b2:	6815      	ldr	r5, [r2, #0]
  40c2b4:	461a      	mov	r2, r3
  40c2b6:	4623      	mov	r3, r4
  40c2b8:	210d      	movs	r1, #13
  40c2ba:	6800      	ldr	r0, [r0, #0]
  40c2bc:	47a8      	blx	r5
		}
		/* Step detector triggered by DMP */
		if (int_read_back & BIT_MSG_DMP_INT_3) {
  40c2be:	f9b7 31f2 	ldrsh.w	r3, [r7, #498]	; 0x1f2
  40c2c2:	b29b      	uxth	r3, r3
  40c2c4:	f403 6380 	and.w	r3, r3, #1024	; 0x400
  40c2c8:	2b00      	cmp	r3, #0
  40c2ca:	d018      	beq.n	40c2fe <inv_icm20948_poll_sensor+0x12c6>
			uint8_t event = 0;
  40c2cc:	f107 0316 	add.w	r3, r7, #22
  40c2d0:	2200      	movs	r2, #0
  40c2d2:	701a      	strb	r2, [r3, #0]
			handler(context, INV_ICM20948_SENSOR_STEP_DETECTOR, s->timestamp[INV_ICM20948_SENSOR_STEP_DETECTOR], &event, 0);
  40c2d4:	f107 030c 	add.w	r3, r7, #12
  40c2d8:	681b      	ldr	r3, [r3, #0]
  40c2da:	f503 7340 	add.w	r3, r3, #768	; 0x300
  40c2de:	e9d3 3400 	ldrd	r3, r4, [r3]
  40c2e2:	f107 0008 	add.w	r0, r7, #8
  40c2e6:	1d3a      	adds	r2, r7, #4
  40c2e8:	2100      	movs	r1, #0
  40c2ea:	9101      	str	r1, [sp, #4]
  40c2ec:	f107 0116 	add.w	r1, r7, #22
  40c2f0:	9100      	str	r1, [sp, #0]
  40c2f2:	6815      	ldr	r5, [r2, #0]
  40c2f4:	461a      	mov	r2, r3
  40c2f6:	4623      	mov	r3, r4
  40c2f8:	2107      	movs	r1, #7
  40c2fa:	6800      	ldr	r0, [r0, #0]
  40c2fc:	47a8      	blx	r5
		}
		/* Bring to see detected by DMP */
		if (int_read_back & BIT_MSG_DMP_INT_5) {
  40c2fe:	f9b7 31f2 	ldrsh.w	r3, [r7, #498]	; 0x1f2
  40c302:	b29b      	uxth	r3, r3
  40c304:	f403 5300 	and.w	r3, r3, #8192	; 0x2000
  40c308:	2b00      	cmp	r3, #0
  40c30a:	d018      	beq.n	40c33e <inv_icm20948_poll_sensor+0x1306>
			uint8_t event = 0;
  40c30c:	f107 0315 	add.w	r3, r7, #21
  40c310:	2200      	movs	r2, #0
  40c312:	701a      	strb	r2, [r3, #0]
			handler(context, INV_ICM20948_SENSOR_B2S, s->timestamp[INV_ICM20948_SENSOR_B2S], &event, 0);
  40c314:	f107 030c 	add.w	r3, r7, #12
  40c318:	681b      	ldr	r3, [r3, #0]
  40c31a:	f503 7358 	add.w	r3, r3, #864	; 0x360
  40c31e:	e9d3 3400 	ldrd	r3, r4, [r3]
  40c322:	f107 0008 	add.w	r0, r7, #8
  40c326:	1d3a      	adds	r2, r7, #4
  40c328:	2100      	movs	r1, #0
  40c32a:	9101      	str	r1, [sp, #4]
  40c32c:	f107 0115 	add.w	r1, r7, #21
  40c330:	9100      	str	r1, [sp, #0]
  40c332:	6815      	ldr	r5, [r2, #0]
  40c334:	461a      	mov	r2, r3
  40c336:	4623      	mov	r3, r4
  40c338:	2113      	movs	r1, #19
  40c33a:	6800      	ldr	r0, [r0, #0]
  40c33c:	47a8      	blx	r5
		}
	}

	/* Sometimes, the chip can be put in sleep mode even if there is data in the FIFO. If we poll at this moment, the transport layer will wake-up the chip, but never put it back in sleep. */
	if (s->mems_put_to_sleep) {
  40c33e:	f107 030c 	add.w	r3, r7, #12
  40c342:	681b      	ldr	r3, [r3, #0]
  40c344:	f993 323c 	ldrsb.w	r3, [r3, #572]	; 0x23c
  40c348:	2b00      	cmp	r3, #0
  40c34a:	d004      	beq.n	40c356 <inv_icm20948_poll_sensor+0x131e>
		inv_icm20948_sleep_mems(s);
  40c34c:	f107 030c 	add.w	r3, r7, #12
  40c350:	6818      	ldr	r0, [r3, #0]
  40c352:	4b04      	ldr	r3, [pc, #16]	; (40c364 <inv_icm20948_poll_sensor+0x132c>)
  40c354:	4798      	blx	r3
	}

	return 0;
  40c356:	2300      	movs	r3, #0
}
  40c358:	4618      	mov	r0, r3
  40c35a:	f507 7706 	add.w	r7, r7, #536	; 0x218
  40c35e:	46bd      	mov	sp, r7
  40c360:	bdb0      	pop	{r4, r5, r7, pc}
  40c362:	bf00      	nop
  40c364:	004059d1 	.word	0x004059d1

0040c368 <inv_icm20948_serif_read_reg>:
	return s->max_write;
}

static inline int inv_icm20948_serif_read_reg(struct inv_icm20948_serif * s,
		uint8_t reg, uint8_t * buf, uint32_t len)
{
  40c368:	b590      	push	{r4, r7, lr}
  40c36a:	b085      	sub	sp, #20
  40c36c:	af00      	add	r7, sp, #0
  40c36e:	60f8      	str	r0, [r7, #12]
  40c370:	607a      	str	r2, [r7, #4]
  40c372:	603b      	str	r3, [r7, #0]
  40c374:	460b      	mov	r3, r1
  40c376:	72fb      	strb	r3, [r7, #11]
	assert(s);

	if(len > s->max_read)
  40c378:	68fb      	ldr	r3, [r7, #12]
  40c37a:	68da      	ldr	r2, [r3, #12]
  40c37c:	683b      	ldr	r3, [r7, #0]
  40c37e:	429a      	cmp	r2, r3
  40c380:	d202      	bcs.n	40c388 <inv_icm20948_serif_read_reg+0x20>
		return INV_ERROR_SIZE;
  40c382:	f06f 0304 	mvn.w	r3, #4
  40c386:	e00e      	b.n	40c3a6 <inv_icm20948_serif_read_reg+0x3e>

	if(s->read_reg(s->context, reg, buf, len) != 0)
  40c388:	68fb      	ldr	r3, [r7, #12]
  40c38a:	685c      	ldr	r4, [r3, #4]
  40c38c:	68fb      	ldr	r3, [r7, #12]
  40c38e:	6818      	ldr	r0, [r3, #0]
  40c390:	7af9      	ldrb	r1, [r7, #11]
  40c392:	683b      	ldr	r3, [r7, #0]
  40c394:	687a      	ldr	r2, [r7, #4]
  40c396:	47a0      	blx	r4
  40c398:	4603      	mov	r3, r0
  40c39a:	2b00      	cmp	r3, #0
  40c39c:	d002      	beq.n	40c3a4 <inv_icm20948_serif_read_reg+0x3c>
		return INV_ERROR_TRANSPORT;
  40c39e:	f06f 0302 	mvn.w	r3, #2
  40c3a2:	e000      	b.n	40c3a6 <inv_icm20948_serif_read_reg+0x3e>

	return 0;
  40c3a4:	2300      	movs	r3, #0
}
  40c3a6:	4618      	mov	r0, r3
  40c3a8:	3714      	adds	r7, #20
  40c3aa:	46bd      	mov	sp, r7
  40c3ac:	bd90      	pop	{r4, r7, pc}

0040c3ae <inv_icm20948_serif_write_reg>:

static inline int inv_icm20948_serif_write_reg(struct inv_icm20948_serif * s,
		uint8_t reg, const uint8_t * buf, uint32_t len)
{
  40c3ae:	b590      	push	{r4, r7, lr}
  40c3b0:	b085      	sub	sp, #20
  40c3b2:	af00      	add	r7, sp, #0
  40c3b4:	60f8      	str	r0, [r7, #12]
  40c3b6:	607a      	str	r2, [r7, #4]
  40c3b8:	603b      	str	r3, [r7, #0]
  40c3ba:	460b      	mov	r3, r1
  40c3bc:	72fb      	strb	r3, [r7, #11]
	assert(s);

	if(len > s->max_write)
  40c3be:	68fb      	ldr	r3, [r7, #12]
  40c3c0:	691a      	ldr	r2, [r3, #16]
  40c3c2:	683b      	ldr	r3, [r7, #0]
  40c3c4:	429a      	cmp	r2, r3
  40c3c6:	d202      	bcs.n	40c3ce <inv_icm20948_serif_write_reg+0x20>
		return INV_ERROR_SIZE;
  40c3c8:	f06f 0304 	mvn.w	r3, #4
  40c3cc:	e00e      	b.n	40c3ec <inv_icm20948_serif_write_reg+0x3e>

	if(s->write_reg(s->context, reg, buf, len) != 0)
  40c3ce:	68fb      	ldr	r3, [r7, #12]
  40c3d0:	689c      	ldr	r4, [r3, #8]
  40c3d2:	68fb      	ldr	r3, [r7, #12]
  40c3d4:	6818      	ldr	r0, [r3, #0]
  40c3d6:	7af9      	ldrb	r1, [r7, #11]
  40c3d8:	683b      	ldr	r3, [r7, #0]
  40c3da:	687a      	ldr	r2, [r7, #4]
  40c3dc:	47a0      	blx	r4
  40c3de:	4603      	mov	r3, r0
  40c3e0:	2b00      	cmp	r3, #0
  40c3e2:	d002      	beq.n	40c3ea <inv_icm20948_serif_write_reg+0x3c>
		return INV_ERROR_TRANSPORT;
  40c3e4:	f06f 0302 	mvn.w	r3, #2
  40c3e8:	e000      	b.n	40c3ec <inv_icm20948_serif_write_reg+0x3e>

	return 0;
  40c3ea:	2300      	movs	r3, #0
}
  40c3ec:	4618      	mov	r0, r3
  40c3ee:	3714      	adds	r7, #20
  40c3f0:	46bd      	mov	sp, r7
  40c3f2:	bd90      	pop	{r4, r7, pc}

0040c3f4 <inv_icm20948_read_reg>:
#include "Icm20948.h"

struct inv_icm20948 * icm20948_instance;

int inv_icm20948_read_reg(struct inv_icm20948 * s, uint8_t reg,	uint8_t * buf, uint32_t len)
{
  40c3f4:	b590      	push	{r4, r7, lr}
  40c3f6:	b085      	sub	sp, #20
  40c3f8:	af00      	add	r7, sp, #0
  40c3fa:	60f8      	str	r0, [r7, #12]
  40c3fc:	607a      	str	r2, [r7, #4]
  40c3fe:	603b      	str	r3, [r7, #0]
  40c400:	460b      	mov	r3, r1
  40c402:	72fb      	strb	r3, [r7, #11]
	return inv_icm20948_serif_read_reg(&s->serif, reg, buf, len);
  40c404:	68f8      	ldr	r0, [r7, #12]
  40c406:	7af9      	ldrb	r1, [r7, #11]
  40c408:	683b      	ldr	r3, [r7, #0]
  40c40a:	687a      	ldr	r2, [r7, #4]
  40c40c:	4c03      	ldr	r4, [pc, #12]	; (40c41c <inv_icm20948_read_reg+0x28>)
  40c40e:	47a0      	blx	r4
  40c410:	4603      	mov	r3, r0
}
  40c412:	4618      	mov	r0, r3
  40c414:	3714      	adds	r7, #20
  40c416:	46bd      	mov	sp, r7
  40c418:	bd90      	pop	{r4, r7, pc}
  40c41a:	bf00      	nop
  40c41c:	0040c369 	.word	0x0040c369

0040c420 <inv_icm20948_write_reg>:

int inv_icm20948_write_reg(struct inv_icm20948 * s, uint8_t reg, const uint8_t * buf, uint32_t len)
{
  40c420:	b590      	push	{r4, r7, lr}
  40c422:	b085      	sub	sp, #20
  40c424:	af00      	add	r7, sp, #0
  40c426:	60f8      	str	r0, [r7, #12]
  40c428:	607a      	str	r2, [r7, #4]
  40c42a:	603b      	str	r3, [r7, #0]
  40c42c:	460b      	mov	r3, r1
  40c42e:	72fb      	strb	r3, [r7, #11]
	return inv_icm20948_serif_write_reg(&s->serif, reg, buf, len);
  40c430:	68f8      	ldr	r0, [r7, #12]
  40c432:	7af9      	ldrb	r1, [r7, #11]
  40c434:	683b      	ldr	r3, [r7, #0]
  40c436:	687a      	ldr	r2, [r7, #4]
  40c438:	4c03      	ldr	r4, [pc, #12]	; (40c448 <inv_icm20948_write_reg+0x28>)
  40c43a:	47a0      	blx	r4
  40c43c:	4603      	mov	r3, r0
}
  40c43e:	4618      	mov	r0, r3
  40c440:	3714      	adds	r7, #20
  40c442:	46bd      	mov	sp, r7
  40c444:	bd90      	pop	{r4, r7, pc}
  40c446:	bf00      	nop
  40c448:	0040c3af 	.word	0x0040c3af

0040c44c <inv_icm20948_sleep_100us>:

void inv_icm20948_sleep_100us(unsigned long nHowMany100MicroSecondsToSleep)  // time in 100 us
{
  40c44c:	b580      	push	{r7, lr}
  40c44e:	b082      	sub	sp, #8
  40c450:	af00      	add	r7, sp, #0
  40c452:	6078      	str	r0, [r7, #4]
	inv_icm20948_sleep_us(nHowMany100MicroSecondsToSleep * 100);
  40c454:	687b      	ldr	r3, [r7, #4]
  40c456:	2264      	movs	r2, #100	; 0x64
  40c458:	fb02 f303 	mul.w	r3, r2, r3
  40c45c:	4618      	mov	r0, r3
  40c45e:	4b03      	ldr	r3, [pc, #12]	; (40c46c <inv_icm20948_sleep_100us+0x20>)
  40c460:	4798      	blx	r3
}
  40c462:	bf00      	nop
  40c464:	3708      	adds	r7, #8
  40c466:	46bd      	mov	sp, r7
  40c468:	bd80      	pop	{r7, pc}
  40c46a:	bf00      	nop
  40c46c:	004015f9 	.word	0x004015f9

0040c470 <inv_icm20948_transport_init>:
#include "Icm20948Defs.h"
#include "Icm20948DataBaseDriver.h"
#include "Icm20948DataBaseControl.h"

void inv_icm20948_transport_init(struct inv_icm20948 * s)
{
  40c470:	b480      	push	{r7}
  40c472:	b083      	sub	sp, #12
  40c474:	af00      	add	r7, sp, #0
  40c476:	6078      	str	r0, [r7, #4]
	s->lastBank = 0x7E;
  40c478:	687b      	ldr	r3, [r7, #4]
  40c47a:	227e      	movs	r2, #126	; 0x7e
  40c47c:	f883 24db 	strb.w	r2, [r3, #1243]	; 0x4db
	s->lLastBankSelected = 0xFF;
  40c480:	687b      	ldr	r3, [r7, #4]
  40c482:	22ff      	movs	r2, #255	; 0xff
  40c484:	f883 24dc 	strb.w	r2, [r3, #1244]	; 0x4dc
}
  40c488:	bf00      	nop
  40c48a:	370c      	adds	r7, #12
  40c48c:	46bd      	mov	sp, r7
  40c48e:	f85d 7b04 	ldr.w	r7, [sp], #4
  40c492:	4770      	bx	lr

0040c494 <check_reg_access_lp_disable>:

static uint8_t check_reg_access_lp_disable(struct inv_icm20948 * s, unsigned short reg)
{
  40c494:	b580      	push	{r7, lr}
  40c496:	b082      	sub	sp, #8
  40c498:	af00      	add	r7, sp, #0
  40c49a:	6078      	str	r0, [r7, #4]
  40c49c:	460b      	mov	r3, r1
  40c49e:	807b      	strh	r3, [r7, #2]
	switch(reg){
  40c4a0:	887b      	ldrh	r3, [r7, #2]
  40c4a2:	2b19      	cmp	r3, #25
  40c4a4:	dc09      	bgt.n	40c4ba <check_reg_access_lp_disable+0x26>
  40c4a6:	2b18      	cmp	r3, #24
  40c4a8:	da18      	bge.n	40c4dc <check_reg_access_lp_disable+0x48>
  40c4aa:	2b05      	cmp	r3, #5
  40c4ac:	db18      	blt.n	40c4e0 <check_reg_access_lp_disable+0x4c>
  40c4ae:	2b07      	cmp	r3, #7
  40c4b0:	dd0f      	ble.n	40c4d2 <check_reg_access_lp_disable+0x3e>
  40c4b2:	3b0f      	subs	r3, #15
  40c4b4:	2b01      	cmp	r3, #1
  40c4b6:	d813      	bhi.n	40c4e0 <check_reg_access_lp_disable+0x4c>
  40c4b8:	e00b      	b.n	40c4d2 <check_reg_access_lp_disable+0x3e>
  40c4ba:	2b76      	cmp	r3, #118	; 0x76
  40c4bc:	d00e      	beq.n	40c4dc <check_reg_access_lp_disable+0x48>
  40c4be:	2b76      	cmp	r3, #118	; 0x76
  40c4c0:	dc03      	bgt.n	40c4ca <check_reg_access_lp_disable+0x36>
  40c4c2:	3b70      	subs	r3, #112	; 0x70
  40c4c4:	2b02      	cmp	r3, #2
  40c4c6:	d80b      	bhi.n	40c4e0 <check_reg_access_lp_disable+0x4c>
  40c4c8:	e003      	b.n	40c4d2 <check_reg_access_lp_disable+0x3e>
  40c4ca:	3b7e      	subs	r3, #126	; 0x7e
  40c4cc:	2b01      	cmp	r3, #1
  40c4ce:	d807      	bhi.n	40c4e0 <check_reg_access_lp_disable+0x4c>
  40c4d0:	e004      	b.n	40c4dc <check_reg_access_lp_disable+0x48>
	case REG_INT_PIN_CFG:    /** (BANK_0 | 0x0F) */
	case REG_INT_ENABLE:     /** (BANK_0 | 0x10) */
	case REG_FIFO_COUNT_H:   /** (BANK_0 | 0x70) */
	case REG_FIFO_COUNT_L:   /** (BANK_0 | 0x71) */
	case REG_FIFO_R_W:       /** (BANK_0 | 0x72) */
		return inv_icm20948_ctrl_get_batch_mode_status(s);
  40c4d2:	6878      	ldr	r0, [r7, #4]
  40c4d4:	4b05      	ldr	r3, [pc, #20]	; (40c4ec <check_reg_access_lp_disable+0x58>)
  40c4d6:	4798      	blx	r3
  40c4d8:	4603      	mov	r3, r0
  40c4da:	e003      	b.n	40c4e4 <check_reg_access_lp_disable+0x50>
	case REG_FIFO_CFG:       /** (BANK_0 | 0x76) */
	case REG_MEM_BANK_SEL:   /** (BANK_0 | 0x7E) */
	case REG_BANK_SEL:       /** 0x7F */
	case REG_INT_STATUS:     /** (BANK_0 | 0x19) */
	case REG_DMP_INT_STATUS: /** (BANK_0 | 0x18) */
		return 0;
  40c4dc:	2300      	movs	r3, #0
  40c4de:	e001      	b.n	40c4e4 <check_reg_access_lp_disable+0x50>
		break;
	default:
		break;
  40c4e0:	bf00      	nop
	}
	return 1;
  40c4e2:	2301      	movs	r3, #1
}
  40c4e4:	4618      	mov	r0, r3
  40c4e6:	3708      	adds	r7, #8
  40c4e8:	46bd      	mov	sp, r7
  40c4ea:	bd80      	pop	{r7, pc}
  40c4ec:	004122ef 	.word	0x004122ef

0040c4f0 <inv_set_bank>:
*  @param[in]  register bank number
*  @return     0 if successful.
*/

static int inv_set_bank(struct inv_icm20948 * s, unsigned char bank)
{
  40c4f0:	b590      	push	{r4, r7, lr}
  40c4f2:	b085      	sub	sp, #20
  40c4f4:	af00      	add	r7, sp, #0
  40c4f6:	6078      	str	r0, [r7, #4]
  40c4f8:	460b      	mov	r3, r1
  40c4fa:	70fb      	strb	r3, [r7, #3]
	int result;
	//if bank reg was set before, just return
	if(bank==s->lastBank) 
  40c4fc:	687b      	ldr	r3, [r7, #4]
  40c4fe:	f893 34db 	ldrb.w	r3, [r3, #1243]	; 0x4db
  40c502:	78fa      	ldrb	r2, [r7, #3]
  40c504:	429a      	cmp	r2, r3
  40c506:	d101      	bne.n	40c50c <inv_set_bank+0x1c>
		return 0;
  40c508:	2300      	movs	r3, #0
  40c50a:	e031      	b.n	40c570 <inv_set_bank+0x80>
	else 
		s->lastBank = bank;
  40c50c:	687b      	ldr	r3, [r7, #4]
  40c50e:	78fa      	ldrb	r2, [r7, #3]
  40c510:	f883 24db 	strb.w	r2, [r3, #1243]	; 0x4db

	result = inv_icm20948_read_reg(s, REG_BANK_SEL, &s->reg, 1);
  40c514:	687b      	ldr	r3, [r7, #4]
  40c516:	f203 42da 	addw	r2, r3, #1242	; 0x4da
  40c51a:	2301      	movs	r3, #1
  40c51c:	217f      	movs	r1, #127	; 0x7f
  40c51e:	6878      	ldr	r0, [r7, #4]
  40c520:	4c15      	ldr	r4, [pc, #84]	; (40c578 <inv_set_bank+0x88>)
  40c522:	47a0      	blx	r4
  40c524:	60f8      	str	r0, [r7, #12]

	if (result)
  40c526:	68fb      	ldr	r3, [r7, #12]
  40c528:	2b00      	cmp	r3, #0
  40c52a:	d001      	beq.n	40c530 <inv_set_bank+0x40>
		return result;
  40c52c:	68fb      	ldr	r3, [r7, #12]
  40c52e:	e01f      	b.n	40c570 <inv_set_bank+0x80>

	s->reg &= 0xce;
  40c530:	687b      	ldr	r3, [r7, #4]
  40c532:	f893 34da 	ldrb.w	r3, [r3, #1242]	; 0x4da
  40c536:	f023 0331 	bic.w	r3, r3, #49	; 0x31
  40c53a:	b2da      	uxtb	r2, r3
  40c53c:	687b      	ldr	r3, [r7, #4]
  40c53e:	f883 24da 	strb.w	r2, [r3, #1242]	; 0x4da
	s->reg |= (bank << 4);
  40c542:	687b      	ldr	r3, [r7, #4]
  40c544:	f893 34da 	ldrb.w	r3, [r3, #1242]	; 0x4da
  40c548:	b25a      	sxtb	r2, r3
  40c54a:	78fb      	ldrb	r3, [r7, #3]
  40c54c:	011b      	lsls	r3, r3, #4
  40c54e:	b25b      	sxtb	r3, r3
  40c550:	4313      	orrs	r3, r2
  40c552:	b25b      	sxtb	r3, r3
  40c554:	b2da      	uxtb	r2, r3
  40c556:	687b      	ldr	r3, [r7, #4]
  40c558:	f883 24da 	strb.w	r2, [r3, #1242]	; 0x4da
	result = inv_icm20948_write_reg(s, REG_BANK_SEL, &s->reg, 1);
  40c55c:	687b      	ldr	r3, [r7, #4]
  40c55e:	f203 42da 	addw	r2, r3, #1242	; 0x4da
  40c562:	2301      	movs	r3, #1
  40c564:	217f      	movs	r1, #127	; 0x7f
  40c566:	6878      	ldr	r0, [r7, #4]
  40c568:	4c04      	ldr	r4, [pc, #16]	; (40c57c <inv_set_bank+0x8c>)
  40c56a:	47a0      	blx	r4
  40c56c:	60f8      	str	r0, [r7, #12]

	return result;
  40c56e:	68fb      	ldr	r3, [r7, #12]
}
  40c570:	4618      	mov	r0, r3
  40c572:	3714      	adds	r7, #20
  40c574:	46bd      	mov	sp, r7
  40c576:	bd90      	pop	{r4, r7, pc}
  40c578:	0040c3f5 	.word	0x0040c3f5
  40c57c:	0040c421 	.word	0x0040c421

0040c580 <inv_icm20948_write_mems_reg>:
*  @param[in]  Length of data
*  @param[in]  Data to be written
*  @return     0 if successful.
*/
int inv_icm20948_write_mems_reg(struct inv_icm20948 * s, uint16_t reg, unsigned int length, const unsigned char *data)
{
  40c580:	b590      	push	{r4, r7, lr}
  40c582:	b089      	sub	sp, #36	; 0x24
  40c584:	af00      	add	r7, sp, #0
  40c586:	60f8      	str	r0, [r7, #12]
  40c588:	607a      	str	r2, [r7, #4]
  40c58a:	603b      	str	r3, [r7, #0]
  40c58c:	460b      	mov	r3, r1
  40c58e:	817b      	strh	r3, [r7, #10]
	int result = 0;
  40c590:	2300      	movs	r3, #0
  40c592:	61fb      	str	r3, [r7, #28]
	unsigned int bytesWrite = 0;
  40c594:	2300      	movs	r3, #0
  40c596:	61bb      	str	r3, [r7, #24]
	unsigned char regOnly = (unsigned char)(reg & 0x7F);
  40c598:	897b      	ldrh	r3, [r7, #10]
  40c59a:	b2db      	uxtb	r3, r3
  40c59c:	f003 037f 	and.w	r3, r3, #127	; 0x7f
  40c5a0:	75fb      	strb	r3, [r7, #23]

	unsigned char power_state = inv_icm20948_get_chip_power_state(s);
  40c5a2:	68f8      	ldr	r0, [r7, #12]
  40c5a4:	4b33      	ldr	r3, [pc, #204]	; (40c674 <inv_icm20948_write_mems_reg+0xf4>)
  40c5a6:	4798      	blx	r3
  40c5a8:	4603      	mov	r3, r0
  40c5aa:	75bb      	strb	r3, [r7, #22]

	if((power_state & CHIP_AWAKE) == 0)   // Wake up chip since it is asleep
  40c5ac:	7dbb      	ldrb	r3, [r7, #22]
  40c5ae:	f003 0301 	and.w	r3, r3, #1
  40c5b2:	2b00      	cmp	r3, #0
  40c5b4:	d105      	bne.n	40c5c2 <inv_icm20948_write_mems_reg+0x42>
		result = inv_icm20948_set_chip_power_state(s, CHIP_AWAKE, 1);
  40c5b6:	2201      	movs	r2, #1
  40c5b8:	2101      	movs	r1, #1
  40c5ba:	68f8      	ldr	r0, [r7, #12]
  40c5bc:	4b2e      	ldr	r3, [pc, #184]	; (40c678 <inv_icm20948_write_mems_reg+0xf8>)
  40c5be:	4798      	blx	r3
  40c5c0:	61f8      	str	r0, [r7, #28]

	if(check_reg_access_lp_disable(s, reg))    // Check if register needs LP_EN to be disabled   
  40c5c2:	897b      	ldrh	r3, [r7, #10]
  40c5c4:	4619      	mov	r1, r3
  40c5c6:	68f8      	ldr	r0, [r7, #12]
  40c5c8:	4b2c      	ldr	r3, [pc, #176]	; (40c67c <inv_icm20948_write_mems_reg+0xfc>)
  40c5ca:	4798      	blx	r3
  40c5cc:	4603      	mov	r3, r0
  40c5ce:	2b00      	cmp	r3, #0
  40c5d0:	d008      	beq.n	40c5e4 <inv_icm20948_write_mems_reg+0x64>
		result |= inv_icm20948_set_chip_power_state(s, CHIP_LP_ENABLE, 0);  //Disable LP_EN
  40c5d2:	2200      	movs	r2, #0
  40c5d4:	2102      	movs	r1, #2
  40c5d6:	68f8      	ldr	r0, [r7, #12]
  40c5d8:	4b27      	ldr	r3, [pc, #156]	; (40c678 <inv_icm20948_write_mems_reg+0xf8>)
  40c5da:	4798      	blx	r3
  40c5dc:	4602      	mov	r2, r0
  40c5de:	69fb      	ldr	r3, [r7, #28]
  40c5e0:	4313      	orrs	r3, r2
  40c5e2:	61fb      	str	r3, [r7, #28]

	result |= inv_set_bank(s, reg >> 7);
  40c5e4:	897b      	ldrh	r3, [r7, #10]
  40c5e6:	09db      	lsrs	r3, r3, #7
  40c5e8:	b29b      	uxth	r3, r3
  40c5ea:	b2db      	uxtb	r3, r3
  40c5ec:	4619      	mov	r1, r3
  40c5ee:	68f8      	ldr	r0, [r7, #12]
  40c5f0:	4b23      	ldr	r3, [pc, #140]	; (40c680 <inv_icm20948_write_mems_reg+0x100>)
  40c5f2:	4798      	blx	r3
  40c5f4:	4602      	mov	r2, r0
  40c5f6:	69fb      	ldr	r3, [r7, #28]
  40c5f8:	4313      	orrs	r3, r2
  40c5fa:	61fb      	str	r3, [r7, #28]

	while (bytesWrite<length) 
  40c5fc:	e01f      	b.n	40c63e <inv_icm20948_write_mems_reg+0xbe>
	{
		int thisLen = min(INV_MAX_SERIAL_WRITE, length-bytesWrite);
  40c5fe:	687a      	ldr	r2, [r7, #4]
  40c600:	69bb      	ldr	r3, [r7, #24]
  40c602:	1ad3      	subs	r3, r2, r3
  40c604:	2b10      	cmp	r3, #16
  40c606:	bf28      	it	cs
  40c608:	2310      	movcs	r3, #16
  40c60a:	613b      	str	r3, [r7, #16]

		result |= inv_icm20948_write_reg(s, regOnly+bytesWrite,&data[bytesWrite], thisLen);
  40c60c:	69bb      	ldr	r3, [r7, #24]
  40c60e:	b2da      	uxtb	r2, r3
  40c610:	7dfb      	ldrb	r3, [r7, #23]
  40c612:	4413      	add	r3, r2
  40c614:	b2d9      	uxtb	r1, r3
  40c616:	683a      	ldr	r2, [r7, #0]
  40c618:	69bb      	ldr	r3, [r7, #24]
  40c61a:	441a      	add	r2, r3
  40c61c:	693b      	ldr	r3, [r7, #16]
  40c61e:	68f8      	ldr	r0, [r7, #12]
  40c620:	4c18      	ldr	r4, [pc, #96]	; (40c684 <inv_icm20948_write_mems_reg+0x104>)
  40c622:	47a0      	blx	r4
  40c624:	4602      	mov	r2, r0
  40c626:	69fb      	ldr	r3, [r7, #28]
  40c628:	4313      	orrs	r3, r2
  40c62a:	61fb      	str	r3, [r7, #28]

		if (result)
  40c62c:	69fb      	ldr	r3, [r7, #28]
  40c62e:	2b00      	cmp	r3, #0
  40c630:	d001      	beq.n	40c636 <inv_icm20948_write_mems_reg+0xb6>
			return result;
  40c632:	69fb      	ldr	r3, [r7, #28]
  40c634:	e019      	b.n	40c66a <inv_icm20948_write_mems_reg+0xea>

		bytesWrite += thisLen;
  40c636:	693b      	ldr	r3, [r7, #16]
  40c638:	69ba      	ldr	r2, [r7, #24]
  40c63a:	4413      	add	r3, r2
  40c63c:	61bb      	str	r3, [r7, #24]
	while (bytesWrite<length) 
  40c63e:	69ba      	ldr	r2, [r7, #24]
  40c640:	687b      	ldr	r3, [r7, #4]
  40c642:	429a      	cmp	r2, r3
  40c644:	d3db      	bcc.n	40c5fe <inv_icm20948_write_mems_reg+0x7e>
	}

	if(check_reg_access_lp_disable(s, reg))   //Enable LP_EN since we disabled it at begining of this function.
  40c646:	897b      	ldrh	r3, [r7, #10]
  40c648:	4619      	mov	r1, r3
  40c64a:	68f8      	ldr	r0, [r7, #12]
  40c64c:	4b0b      	ldr	r3, [pc, #44]	; (40c67c <inv_icm20948_write_mems_reg+0xfc>)
  40c64e:	4798      	blx	r3
  40c650:	4603      	mov	r3, r0
  40c652:	2b00      	cmp	r3, #0
  40c654:	d008      	beq.n	40c668 <inv_icm20948_write_mems_reg+0xe8>
		result |= inv_icm20948_set_chip_power_state(s, CHIP_LP_ENABLE, 1);
  40c656:	2201      	movs	r2, #1
  40c658:	2102      	movs	r1, #2
  40c65a:	68f8      	ldr	r0, [r7, #12]
  40c65c:	4b06      	ldr	r3, [pc, #24]	; (40c678 <inv_icm20948_write_mems_reg+0xf8>)
  40c65e:	4798      	blx	r3
  40c660:	4602      	mov	r2, r0
  40c662:	69fb      	ldr	r3, [r7, #28]
  40c664:	4313      	orrs	r3, r2
  40c666:	61fb      	str	r3, [r7, #28]

	return result;
  40c668:	69fb      	ldr	r3, [r7, #28]
}
  40c66a:	4618      	mov	r0, r3
  40c66c:	3724      	adds	r7, #36	; 0x24
  40c66e:	46bd      	mov	sp, r7
  40c670:	bd90      	pop	{r4, r7, pc}
  40c672:	bf00      	nop
  40c674:	00405905 	.word	0x00405905
  40c678:	004057a5 	.word	0x004057a5
  40c67c:	0040c495 	.word	0x0040c495
  40c680:	0040c4f1 	.word	0x0040c4f1
  40c684:	0040c421 	.word	0x0040c421

0040c688 <inv_icm20948_write_single_mems_reg>:
*  @param[in]  Register address
*  @param[in]  Data to be written
*  @return     0 if successful.
*/
int inv_icm20948_write_single_mems_reg(struct inv_icm20948 * s, uint16_t reg, const unsigned char data)
{
  40c688:	b590      	push	{r4, r7, lr}
  40c68a:	b085      	sub	sp, #20
  40c68c:	af00      	add	r7, sp, #0
  40c68e:	6078      	str	r0, [r7, #4]
  40c690:	460b      	mov	r3, r1
  40c692:	807b      	strh	r3, [r7, #2]
  40c694:	4613      	mov	r3, r2
  40c696:	707b      	strb	r3, [r7, #1]
	int result = 0;
  40c698:	2300      	movs	r3, #0
  40c69a:	60fb      	str	r3, [r7, #12]
	unsigned char regOnly = (unsigned char)(reg & 0x7F);
  40c69c:	887b      	ldrh	r3, [r7, #2]
  40c69e:	b2db      	uxtb	r3, r3
  40c6a0:	f003 037f 	and.w	r3, r3, #127	; 0x7f
  40c6a4:	72fb      	strb	r3, [r7, #11]


	unsigned char power_state = inv_icm20948_get_chip_power_state(s);
  40c6a6:	6878      	ldr	r0, [r7, #4]
  40c6a8:	4b25      	ldr	r3, [pc, #148]	; (40c740 <inv_icm20948_write_single_mems_reg+0xb8>)
  40c6aa:	4798      	blx	r3
  40c6ac:	4603      	mov	r3, r0
  40c6ae:	72bb      	strb	r3, [r7, #10]

	if((power_state & CHIP_AWAKE) == 0)   // Wake up chip since it is asleep
  40c6b0:	7abb      	ldrb	r3, [r7, #10]
  40c6b2:	f003 0301 	and.w	r3, r3, #1
  40c6b6:	2b00      	cmp	r3, #0
  40c6b8:	d105      	bne.n	40c6c6 <inv_icm20948_write_single_mems_reg+0x3e>
		result = inv_icm20948_set_chip_power_state(s, CHIP_AWAKE, 1);
  40c6ba:	2201      	movs	r2, #1
  40c6bc:	2101      	movs	r1, #1
  40c6be:	6878      	ldr	r0, [r7, #4]
  40c6c0:	4b20      	ldr	r3, [pc, #128]	; (40c744 <inv_icm20948_write_single_mems_reg+0xbc>)
  40c6c2:	4798      	blx	r3
  40c6c4:	60f8      	str	r0, [r7, #12]

	if(check_reg_access_lp_disable(s, reg))   // Check if register needs LP_EN to be disabled
  40c6c6:	887b      	ldrh	r3, [r7, #2]
  40c6c8:	4619      	mov	r1, r3
  40c6ca:	6878      	ldr	r0, [r7, #4]
  40c6cc:	4b1e      	ldr	r3, [pc, #120]	; (40c748 <inv_icm20948_write_single_mems_reg+0xc0>)
  40c6ce:	4798      	blx	r3
  40c6d0:	4603      	mov	r3, r0
  40c6d2:	2b00      	cmp	r3, #0
  40c6d4:	d008      	beq.n	40c6e8 <inv_icm20948_write_single_mems_reg+0x60>
		result |= inv_icm20948_set_chip_power_state(s, CHIP_LP_ENABLE, 0);  //Disable LP_EN
  40c6d6:	2200      	movs	r2, #0
  40c6d8:	2102      	movs	r1, #2
  40c6da:	6878      	ldr	r0, [r7, #4]
  40c6dc:	4b19      	ldr	r3, [pc, #100]	; (40c744 <inv_icm20948_write_single_mems_reg+0xbc>)
  40c6de:	4798      	blx	r3
  40c6e0:	4602      	mov	r2, r0
  40c6e2:	68fb      	ldr	r3, [r7, #12]
  40c6e4:	4313      	orrs	r3, r2
  40c6e6:	60fb      	str	r3, [r7, #12]

	result |= inv_set_bank(s, reg >> 7);
  40c6e8:	887b      	ldrh	r3, [r7, #2]
  40c6ea:	09db      	lsrs	r3, r3, #7
  40c6ec:	b29b      	uxth	r3, r3
  40c6ee:	b2db      	uxtb	r3, r3
  40c6f0:	4619      	mov	r1, r3
  40c6f2:	6878      	ldr	r0, [r7, #4]
  40c6f4:	4b15      	ldr	r3, [pc, #84]	; (40c74c <inv_icm20948_write_single_mems_reg+0xc4>)
  40c6f6:	4798      	blx	r3
  40c6f8:	4602      	mov	r2, r0
  40c6fa:	68fb      	ldr	r3, [r7, #12]
  40c6fc:	4313      	orrs	r3, r2
  40c6fe:	60fb      	str	r3, [r7, #12]
	result |= inv_icm20948_write_reg(s, regOnly, &data, 1);
  40c700:	1c7a      	adds	r2, r7, #1
  40c702:	7af9      	ldrb	r1, [r7, #11]
  40c704:	2301      	movs	r3, #1
  40c706:	6878      	ldr	r0, [r7, #4]
  40c708:	4c11      	ldr	r4, [pc, #68]	; (40c750 <inv_icm20948_write_single_mems_reg+0xc8>)
  40c70a:	47a0      	blx	r4
  40c70c:	4602      	mov	r2, r0
  40c70e:	68fb      	ldr	r3, [r7, #12]
  40c710:	4313      	orrs	r3, r2
  40c712:	60fb      	str	r3, [r7, #12]

	if(check_reg_access_lp_disable(s, reg))   //Enable LP_EN since we disabled it at begining of this function.
  40c714:	887b      	ldrh	r3, [r7, #2]
  40c716:	4619      	mov	r1, r3
  40c718:	6878      	ldr	r0, [r7, #4]
  40c71a:	4b0b      	ldr	r3, [pc, #44]	; (40c748 <inv_icm20948_write_single_mems_reg+0xc0>)
  40c71c:	4798      	blx	r3
  40c71e:	4603      	mov	r3, r0
  40c720:	2b00      	cmp	r3, #0
  40c722:	d008      	beq.n	40c736 <inv_icm20948_write_single_mems_reg+0xae>
		result |= inv_icm20948_set_chip_power_state(s, CHIP_LP_ENABLE, 1);
  40c724:	2201      	movs	r2, #1
  40c726:	2102      	movs	r1, #2
  40c728:	6878      	ldr	r0, [r7, #4]
  40c72a:	4b06      	ldr	r3, [pc, #24]	; (40c744 <inv_icm20948_write_single_mems_reg+0xbc>)
  40c72c:	4798      	blx	r3
  40c72e:	4602      	mov	r2, r0
  40c730:	68fb      	ldr	r3, [r7, #12]
  40c732:	4313      	orrs	r3, r2
  40c734:	60fb      	str	r3, [r7, #12]

	return result;
  40c736:	68fb      	ldr	r3, [r7, #12]
}
  40c738:	4618      	mov	r0, r3
  40c73a:	3714      	adds	r7, #20
  40c73c:	46bd      	mov	sp, r7
  40c73e:	bd90      	pop	{r4, r7, pc}
  40c740:	00405905 	.word	0x00405905
  40c744:	004057a5 	.word	0x004057a5
  40c748:	0040c495 	.word	0x0040c495
  40c74c:	0040c4f1 	.word	0x0040c4f1
  40c750:	0040c421 	.word	0x0040c421

0040c754 <inv_icm20948_read_mems_reg>:
*  @param[in]  Length of data
*  @param[in]  Data to be written
*  @return     0 if successful.
*/
int inv_icm20948_read_mems_reg(struct inv_icm20948 * s, uint16_t reg, unsigned int length, unsigned char *data)
{
  40c754:	b590      	push	{r4, r7, lr}
  40c756:	b08d      	sub	sp, #52	; 0x34
  40c758:	af00      	add	r7, sp, #0
  40c75a:	60f8      	str	r0, [r7, #12]
  40c75c:	607a      	str	r2, [r7, #4]
  40c75e:	603b      	str	r3, [r7, #0]
  40c760:	460b      	mov	r3, r1
  40c762:	817b      	strh	r3, [r7, #10]
	int result = 0;
  40c764:	2300      	movs	r3, #0
  40c766:	62fb      	str	r3, [r7, #44]	; 0x2c
	unsigned int bytesRead = 0;
  40c768:	2300      	movs	r3, #0
  40c76a:	62bb      	str	r3, [r7, #40]	; 0x28
	unsigned char regOnly = (unsigned char)(reg & 0x7F);
  40c76c:	897b      	ldrh	r3, [r7, #10]
  40c76e:	b2db      	uxtb	r3, r3
  40c770:	f003 037f 	and.w	r3, r3, #127	; 0x7f
  40c774:	f887 3026 	strb.w	r3, [r7, #38]	; 0x26
	unsigned char i, dat[INV_MAX_SERIAL_READ];
	unsigned char power_state = inv_icm20948_get_chip_power_state(s);
  40c778:	68f8      	ldr	r0, [r7, #12]
  40c77a:	4b50      	ldr	r3, [pc, #320]	; (40c8bc <inv_icm20948_read_mems_reg+0x168>)
  40c77c:	4798      	blx	r3
  40c77e:	4603      	mov	r3, r0
  40c780:	f887 3025 	strb.w	r3, [r7, #37]	; 0x25

	if((power_state & CHIP_AWAKE) == 0)   // Wake up chip since it is asleep
  40c784:	f897 3025 	ldrb.w	r3, [r7, #37]	; 0x25
  40c788:	f003 0301 	and.w	r3, r3, #1
  40c78c:	2b00      	cmp	r3, #0
  40c78e:	d105      	bne.n	40c79c <inv_icm20948_read_mems_reg+0x48>
		result = inv_icm20948_set_chip_power_state(s, CHIP_AWAKE, 1);
  40c790:	2201      	movs	r2, #1
  40c792:	2101      	movs	r1, #1
  40c794:	68f8      	ldr	r0, [r7, #12]
  40c796:	4b4a      	ldr	r3, [pc, #296]	; (40c8c0 <inv_icm20948_read_mems_reg+0x16c>)
  40c798:	4798      	blx	r3
  40c79a:	62f8      	str	r0, [r7, #44]	; 0x2c

	if(check_reg_access_lp_disable(s, reg))   // Check if register needs LP_EN to be disabled
  40c79c:	897b      	ldrh	r3, [r7, #10]
  40c79e:	4619      	mov	r1, r3
  40c7a0:	68f8      	ldr	r0, [r7, #12]
  40c7a2:	4b48      	ldr	r3, [pc, #288]	; (40c8c4 <inv_icm20948_read_mems_reg+0x170>)
  40c7a4:	4798      	blx	r3
  40c7a6:	4603      	mov	r3, r0
  40c7a8:	2b00      	cmp	r3, #0
  40c7aa:	d008      	beq.n	40c7be <inv_icm20948_read_mems_reg+0x6a>
		result |= inv_icm20948_set_chip_power_state(s, CHIP_LP_ENABLE, 0);  //Disable LP_EN
  40c7ac:	2200      	movs	r2, #0
  40c7ae:	2102      	movs	r1, #2
  40c7b0:	68f8      	ldr	r0, [r7, #12]
  40c7b2:	4b43      	ldr	r3, [pc, #268]	; (40c8c0 <inv_icm20948_read_mems_reg+0x16c>)
  40c7b4:	4798      	blx	r3
  40c7b6:	4602      	mov	r2, r0
  40c7b8:	6afb      	ldr	r3, [r7, #44]	; 0x2c
  40c7ba:	4313      	orrs	r3, r2
  40c7bc:	62fb      	str	r3, [r7, #44]	; 0x2c

	result |= inv_set_bank(s, reg >> 7);
  40c7be:	897b      	ldrh	r3, [r7, #10]
  40c7c0:	09db      	lsrs	r3, r3, #7
  40c7c2:	b29b      	uxth	r3, r3
  40c7c4:	b2db      	uxtb	r3, r3
  40c7c6:	4619      	mov	r1, r3
  40c7c8:	68f8      	ldr	r0, [r7, #12]
  40c7ca:	4b3f      	ldr	r3, [pc, #252]	; (40c8c8 <inv_icm20948_read_mems_reg+0x174>)
  40c7cc:	4798      	blx	r3
  40c7ce:	4602      	mov	r2, r0
  40c7d0:	6afb      	ldr	r3, [r7, #44]	; 0x2c
  40c7d2:	4313      	orrs	r3, r2
  40c7d4:	62fb      	str	r3, [r7, #44]	; 0x2c

	while (bytesRead<length) 
  40c7d6:	e038      	b.n	40c84a <inv_icm20948_read_mems_reg+0xf6>
	{
		int thisLen = min(INV_MAX_SERIAL_READ, length-bytesRead);
  40c7d8:	687a      	ldr	r2, [r7, #4]
  40c7da:	6abb      	ldr	r3, [r7, #40]	; 0x28
  40c7dc:	1ad3      	subs	r3, r2, r3
  40c7de:	2b10      	cmp	r3, #16
  40c7e0:	bf28      	it	cs
  40c7e2:	2310      	movcs	r3, #16
  40c7e4:	623b      	str	r3, [r7, #32]
		if(s->base_state.serial_interface == SERIAL_INTERFACE_SPI) {
  40c7e6:	68fb      	ldr	r3, [r7, #12]
  40c7e8:	f893 3027 	ldrb.w	r3, [r3, #39]	; 0x27
  40c7ec:	2b02      	cmp	r3, #2
  40c7ee:	d112      	bne.n	40c816 <inv_icm20948_read_mems_reg+0xc2>
			result |= inv_icm20948_read_reg(s, regOnly+bytesRead, &dat[bytesRead], thisLen);
  40c7f0:	6abb      	ldr	r3, [r7, #40]	; 0x28
  40c7f2:	b2da      	uxtb	r2, r3
  40c7f4:	f897 3026 	ldrb.w	r3, [r7, #38]	; 0x26
  40c7f8:	4413      	add	r3, r2
  40c7fa:	b2d9      	uxtb	r1, r3
  40c7fc:	f107 0210 	add.w	r2, r7, #16
  40c800:	6abb      	ldr	r3, [r7, #40]	; 0x28
  40c802:	441a      	add	r2, r3
  40c804:	6a3b      	ldr	r3, [r7, #32]
  40c806:	68f8      	ldr	r0, [r7, #12]
  40c808:	4c30      	ldr	r4, [pc, #192]	; (40c8cc <inv_icm20948_read_mems_reg+0x178>)
  40c80a:	47a0      	blx	r4
  40c80c:	4602      	mov	r2, r0
  40c80e:	6afb      	ldr	r3, [r7, #44]	; 0x2c
  40c810:	4313      	orrs	r3, r2
  40c812:	62fb      	str	r3, [r7, #44]	; 0x2c
  40c814:	e010      	b.n	40c838 <inv_icm20948_read_mems_reg+0xe4>
		} else {
			result |= inv_icm20948_read_reg(s, regOnly+bytesRead, &data[bytesRead],thisLen);
  40c816:	6abb      	ldr	r3, [r7, #40]	; 0x28
  40c818:	b2da      	uxtb	r2, r3
  40c81a:	f897 3026 	ldrb.w	r3, [r7, #38]	; 0x26
  40c81e:	4413      	add	r3, r2
  40c820:	b2d9      	uxtb	r1, r3
  40c822:	683a      	ldr	r2, [r7, #0]
  40c824:	6abb      	ldr	r3, [r7, #40]	; 0x28
  40c826:	441a      	add	r2, r3
  40c828:	6a3b      	ldr	r3, [r7, #32]
  40c82a:	68f8      	ldr	r0, [r7, #12]
  40c82c:	4c27      	ldr	r4, [pc, #156]	; (40c8cc <inv_icm20948_read_mems_reg+0x178>)
  40c82e:	47a0      	blx	r4
  40c830:	4602      	mov	r2, r0
  40c832:	6afb      	ldr	r3, [r7, #44]	; 0x2c
  40c834:	4313      	orrs	r3, r2
  40c836:	62fb      	str	r3, [r7, #44]	; 0x2c
		}

		if (result)
  40c838:	6afb      	ldr	r3, [r7, #44]	; 0x2c
  40c83a:	2b00      	cmp	r3, #0
  40c83c:	d001      	beq.n	40c842 <inv_icm20948_read_mems_reg+0xee>
			return result;
  40c83e:	6afb      	ldr	r3, [r7, #44]	; 0x2c
  40c840:	e038      	b.n	40c8b4 <inv_icm20948_read_mems_reg+0x160>

		bytesRead += thisLen;
  40c842:	6a3b      	ldr	r3, [r7, #32]
  40c844:	6aba      	ldr	r2, [r7, #40]	; 0x28
  40c846:	4413      	add	r3, r2
  40c848:	62bb      	str	r3, [r7, #40]	; 0x28
	while (bytesRead<length) 
  40c84a:	6aba      	ldr	r2, [r7, #40]	; 0x28
  40c84c:	687b      	ldr	r3, [r7, #4]
  40c84e:	429a      	cmp	r2, r3
  40c850:	d3c2      	bcc.n	40c7d8 <inv_icm20948_read_mems_reg+0x84>
	}

	if(s->base_state.serial_interface == SERIAL_INTERFACE_SPI) {
  40c852:	68fb      	ldr	r3, [r7, #12]
  40c854:	f893 3027 	ldrb.w	r3, [r3, #39]	; 0x27
  40c858:	2b02      	cmp	r3, #2
  40c85a:	d119      	bne.n	40c890 <inv_icm20948_read_mems_reg+0x13c>
		for (i=0; i< length; i++) {
  40c85c:	2300      	movs	r3, #0
  40c85e:	f887 3027 	strb.w	r3, [r7, #39]	; 0x27
  40c862:	e010      	b.n	40c886 <inv_icm20948_read_mems_reg+0x132>
			*data= dat[i];
  40c864:	f897 3027 	ldrb.w	r3, [r7, #39]	; 0x27
  40c868:	f107 0230 	add.w	r2, r7, #48	; 0x30
  40c86c:	4413      	add	r3, r2
  40c86e:	f813 2c20 	ldrb.w	r2, [r3, #-32]
  40c872:	683b      	ldr	r3, [r7, #0]
  40c874:	701a      	strb	r2, [r3, #0]
			data++;
  40c876:	683b      	ldr	r3, [r7, #0]
  40c878:	3301      	adds	r3, #1
  40c87a:	603b      	str	r3, [r7, #0]
		for (i=0; i< length; i++) {
  40c87c:	f897 3027 	ldrb.w	r3, [r7, #39]	; 0x27
  40c880:	3301      	adds	r3, #1
  40c882:	f887 3027 	strb.w	r3, [r7, #39]	; 0x27
  40c886:	f897 2027 	ldrb.w	r2, [r7, #39]	; 0x27
  40c88a:	687b      	ldr	r3, [r7, #4]
  40c88c:	429a      	cmp	r2, r3
  40c88e:	d3e9      	bcc.n	40c864 <inv_icm20948_read_mems_reg+0x110>
		}
	}

	if(check_reg_access_lp_disable(s, reg))    // Check if register needs LP_EN to be enabled  
  40c890:	897b      	ldrh	r3, [r7, #10]
  40c892:	4619      	mov	r1, r3
  40c894:	68f8      	ldr	r0, [r7, #12]
  40c896:	4b0b      	ldr	r3, [pc, #44]	; (40c8c4 <inv_icm20948_read_mems_reg+0x170>)
  40c898:	4798      	blx	r3
  40c89a:	4603      	mov	r3, r0
  40c89c:	2b00      	cmp	r3, #0
  40c89e:	d008      	beq.n	40c8b2 <inv_icm20948_read_mems_reg+0x15e>
		result |= inv_icm20948_set_chip_power_state(s, CHIP_LP_ENABLE, 1);  //Enable LP_EN
  40c8a0:	2201      	movs	r2, #1
  40c8a2:	2102      	movs	r1, #2
  40c8a4:	68f8      	ldr	r0, [r7, #12]
  40c8a6:	4b06      	ldr	r3, [pc, #24]	; (40c8c0 <inv_icm20948_read_mems_reg+0x16c>)
  40c8a8:	4798      	blx	r3
  40c8aa:	4602      	mov	r2, r0
  40c8ac:	6afb      	ldr	r3, [r7, #44]	; 0x2c
  40c8ae:	4313      	orrs	r3, r2
  40c8b0:	62fb      	str	r3, [r7, #44]	; 0x2c

	return result;
  40c8b2:	6afb      	ldr	r3, [r7, #44]	; 0x2c
}
  40c8b4:	4618      	mov	r0, r3
  40c8b6:	3734      	adds	r7, #52	; 0x34
  40c8b8:	46bd      	mov	sp, r7
  40c8ba:	bd90      	pop	{r4, r7, pc}
  40c8bc:	00405905 	.word	0x00405905
  40c8c0:	004057a5 	.word	0x004057a5
  40c8c4:	0040c495 	.word	0x0040c495
  40c8c8:	0040c4f1 	.word	0x0040c4f1
  40c8cc:	0040c3f5 	.word	0x0040c3f5

0040c8d0 <inv_icm20948_read_mems>:
*  @param[in]  number of byte to be read
*  @param[in]  input data from the register
*  @return     0 if successful.
*/
int inv_icm20948_read_mems(struct inv_icm20948 * s, unsigned short reg, unsigned int length, unsigned char *data)
{
  40c8d0:	b590      	push	{r4, r7, lr}
  40c8d2:	b08f      	sub	sp, #60	; 0x3c
  40c8d4:	af00      	add	r7, sp, #0
  40c8d6:	60f8      	str	r0, [r7, #12]
  40c8d8:	607a      	str	r2, [r7, #4]
  40c8da:	603b      	str	r3, [r7, #0]
  40c8dc:	460b      	mov	r3, r1
  40c8de:	817b      	strh	r3, [r7, #10]
	int result=0;
  40c8e0:	2300      	movs	r3, #0
  40c8e2:	637b      	str	r3, [r7, #52]	; 0x34
	unsigned int bytesWritten = 0;
  40c8e4:	2300      	movs	r3, #0
  40c8e6:	633b      	str	r3, [r7, #48]	; 0x30
	unsigned int thisLen;
	unsigned char i, dat[INV_MAX_SERIAL_READ] = {0};
  40c8e8:	f107 0318 	add.w	r3, r7, #24
  40c8ec:	2200      	movs	r2, #0
  40c8ee:	601a      	str	r2, [r3, #0]
  40c8f0:	605a      	str	r2, [r3, #4]
  40c8f2:	609a      	str	r2, [r3, #8]
  40c8f4:	60da      	str	r2, [r3, #12]
	unsigned char power_state = inv_icm20948_get_chip_power_state(s);
  40c8f6:	68f8      	ldr	r0, [r7, #12]
  40c8f8:	4b67      	ldr	r3, [pc, #412]	; (40ca98 <inv_icm20948_read_mems+0x1c8>)
  40c8fa:	4798      	blx	r3
  40c8fc:	4603      	mov	r3, r0
  40c8fe:	f887 302e 	strb.w	r3, [r7, #46]	; 0x2e
	unsigned char lBankSelected;
	unsigned char lStartAddrSelected;

	if(!data)
  40c902:	683b      	ldr	r3, [r7, #0]
  40c904:	2b00      	cmp	r3, #0
  40c906:	d102      	bne.n	40c90e <inv_icm20948_read_mems+0x3e>
		return -1;
  40c908:	f04f 33ff 	mov.w	r3, #4294967295
  40c90c:	e0c0      	b.n	40ca90 <inv_icm20948_read_mems+0x1c0>

	if((power_state & CHIP_AWAKE) == 0)   // Wake up chip since it is asleep
  40c90e:	f897 302e 	ldrb.w	r3, [r7, #46]	; 0x2e
  40c912:	f003 0301 	and.w	r3, r3, #1
  40c916:	2b00      	cmp	r3, #0
  40c918:	d105      	bne.n	40c926 <inv_icm20948_read_mems+0x56>
		result = inv_icm20948_set_chip_power_state(s, CHIP_AWAKE, 1);
  40c91a:	2201      	movs	r2, #1
  40c91c:	2101      	movs	r1, #1
  40c91e:	68f8      	ldr	r0, [r7, #12]
  40c920:	4b5e      	ldr	r3, [pc, #376]	; (40ca9c <inv_icm20948_read_mems+0x1cc>)
  40c922:	4798      	blx	r3
  40c924:	6378      	str	r0, [r7, #52]	; 0x34

	if(check_reg_access_lp_disable(s, reg))
  40c926:	897b      	ldrh	r3, [r7, #10]
  40c928:	4619      	mov	r1, r3
  40c92a:	68f8      	ldr	r0, [r7, #12]
  40c92c:	4b5c      	ldr	r3, [pc, #368]	; (40caa0 <inv_icm20948_read_mems+0x1d0>)
  40c92e:	4798      	blx	r3
  40c930:	4603      	mov	r3, r0
  40c932:	2b00      	cmp	r3, #0
  40c934:	d008      	beq.n	40c948 <inv_icm20948_read_mems+0x78>
		result |= inv_icm20948_set_chip_power_state(s, CHIP_LP_ENABLE, 0);
  40c936:	2200      	movs	r2, #0
  40c938:	2102      	movs	r1, #2
  40c93a:	68f8      	ldr	r0, [r7, #12]
  40c93c:	4b57      	ldr	r3, [pc, #348]	; (40ca9c <inv_icm20948_read_mems+0x1cc>)
  40c93e:	4798      	blx	r3
  40c940:	4602      	mov	r2, r0
  40c942:	6b7b      	ldr	r3, [r7, #52]	; 0x34
  40c944:	4313      	orrs	r3, r2
  40c946:	637b      	str	r3, [r7, #52]	; 0x34

	result |= inv_set_bank(s, 0);
  40c948:	2100      	movs	r1, #0
  40c94a:	68f8      	ldr	r0, [r7, #12]
  40c94c:	4b55      	ldr	r3, [pc, #340]	; (40caa4 <inv_icm20948_read_mems+0x1d4>)
  40c94e:	4798      	blx	r3
  40c950:	4602      	mov	r2, r0
  40c952:	6b7b      	ldr	r3, [r7, #52]	; 0x34
  40c954:	4313      	orrs	r3, r2
  40c956:	637b      	str	r3, [r7, #52]	; 0x34

	lBankSelected = (reg >> 8);
  40c958:	897b      	ldrh	r3, [r7, #10]
  40c95a:	0a1b      	lsrs	r3, r3, #8
  40c95c:	b29b      	uxth	r3, r3
  40c95e:	b2db      	uxtb	r3, r3
  40c960:	75fb      	strb	r3, [r7, #23]
	if (lBankSelected != s->lLastBankSelected)
  40c962:	68fb      	ldr	r3, [r7, #12]
  40c964:	f893 24dc 	ldrb.w	r2, [r3, #1244]	; 0x4dc
  40c968:	7dfb      	ldrb	r3, [r7, #23]
  40c96a:	429a      	cmp	r2, r3
  40c96c:	d05b      	beq.n	40ca26 <inv_icm20948_read_mems+0x156>
	{
		result |= inv_icm20948_write_reg(s, REG_MEM_BANK_SEL, &lBankSelected, 1);
  40c96e:	f107 0217 	add.w	r2, r7, #23
  40c972:	2301      	movs	r3, #1
  40c974:	217e      	movs	r1, #126	; 0x7e
  40c976:	68f8      	ldr	r0, [r7, #12]
  40c978:	4c4b      	ldr	r4, [pc, #300]	; (40caa8 <inv_icm20948_read_mems+0x1d8>)
  40c97a:	47a0      	blx	r4
  40c97c:	4602      	mov	r2, r0
  40c97e:	6b7b      	ldr	r3, [r7, #52]	; 0x34
  40c980:	4313      	orrs	r3, r2
  40c982:	637b      	str	r3, [r7, #52]	; 0x34
		if (result)
  40c984:	6b7b      	ldr	r3, [r7, #52]	; 0x34
  40c986:	2b00      	cmp	r3, #0
  40c988:	d001      	beq.n	40c98e <inv_icm20948_read_mems+0xbe>
			return result;
  40c98a:	6b7b      	ldr	r3, [r7, #52]	; 0x34
  40c98c:	e080      	b.n	40ca90 <inv_icm20948_read_mems+0x1c0>
		s->lLastBankSelected = lBankSelected;
  40c98e:	7dfa      	ldrb	r2, [r7, #23]
  40c990:	68fb      	ldr	r3, [r7, #12]
  40c992:	f883 24dc 	strb.w	r2, [r3, #1244]	; 0x4dc
	}

	while (bytesWritten < length) 
  40c996:	e046      	b.n	40ca26 <inv_icm20948_read_mems+0x156>
	{
		lStartAddrSelected = (reg & 0xff);
  40c998:	897b      	ldrh	r3, [r7, #10]
  40c99a:	b2db      	uxtb	r3, r3
  40c99c:	75bb      	strb	r3, [r7, #22]
		/* Sets the starting read or write address for the selected memory, inside of the selected page (see MEM_SEL Register).
		Contents are changed after read or write of the selected memory.
		This register must be written prior to each access to initialize the register to the proper starting address.
		The address will auto increment during burst transactions.  Two consecutive bursts without re-initializing the start address would skip one address. */
		result |= inv_icm20948_write_reg(s, REG_MEM_START_ADDR, &lStartAddrSelected, 1);
  40c99e:	f107 0216 	add.w	r2, r7, #22
  40c9a2:	2301      	movs	r3, #1
  40c9a4:	217c      	movs	r1, #124	; 0x7c
  40c9a6:	68f8      	ldr	r0, [r7, #12]
  40c9a8:	4c3f      	ldr	r4, [pc, #252]	; (40caa8 <inv_icm20948_read_mems+0x1d8>)
  40c9aa:	47a0      	blx	r4
  40c9ac:	4602      	mov	r2, r0
  40c9ae:	6b7b      	ldr	r3, [r7, #52]	; 0x34
  40c9b0:	4313      	orrs	r3, r2
  40c9b2:	637b      	str	r3, [r7, #52]	; 0x34
		if (result)
  40c9b4:	6b7b      	ldr	r3, [r7, #52]	; 0x34
  40c9b6:	2b00      	cmp	r3, #0
  40c9b8:	d001      	beq.n	40c9be <inv_icm20948_read_mems+0xee>
			return result;
  40c9ba:	6b7b      	ldr	r3, [r7, #52]	; 0x34
  40c9bc:	e068      	b.n	40ca90 <inv_icm20948_read_mems+0x1c0>

		thisLen = min(INV_MAX_SERIAL_READ, length-bytesWritten);
  40c9be:	687a      	ldr	r2, [r7, #4]
  40c9c0:	6b3b      	ldr	r3, [r7, #48]	; 0x30
  40c9c2:	1ad3      	subs	r3, r2, r3
  40c9c4:	2b10      	cmp	r3, #16
  40c9c6:	bf28      	it	cs
  40c9c8:	2310      	movcs	r3, #16
  40c9ca:	62bb      	str	r3, [r7, #40]	; 0x28
		/* Write data */
		if(s->base_state.serial_interface == SERIAL_INTERFACE_SPI) {
  40c9cc:	68fb      	ldr	r3, [r7, #12]
  40c9ce:	f893 3027 	ldrb.w	r3, [r3, #39]	; 0x27
  40c9d2:	2b02      	cmp	r3, #2
  40c9d4:	d10d      	bne.n	40c9f2 <inv_icm20948_read_mems+0x122>
			result |= inv_icm20948_read_reg(s, REG_MEM_R_W, &dat[bytesWritten], thisLen);
  40c9d6:	f107 0218 	add.w	r2, r7, #24
  40c9da:	6b3b      	ldr	r3, [r7, #48]	; 0x30
  40c9dc:	441a      	add	r2, r3
  40c9de:	6abb      	ldr	r3, [r7, #40]	; 0x28
  40c9e0:	217d      	movs	r1, #125	; 0x7d
  40c9e2:	68f8      	ldr	r0, [r7, #12]
  40c9e4:	4c31      	ldr	r4, [pc, #196]	; (40caac <inv_icm20948_read_mems+0x1dc>)
  40c9e6:	47a0      	blx	r4
  40c9e8:	4602      	mov	r2, r0
  40c9ea:	6b7b      	ldr	r3, [r7, #52]	; 0x34
  40c9ec:	4313      	orrs	r3, r2
  40c9ee:	637b      	str	r3, [r7, #52]	; 0x34
  40c9f0:	e00b      	b.n	40ca0a <inv_icm20948_read_mems+0x13a>
		} else {
			result |= inv_icm20948_read_reg(s, REG_MEM_R_W, &data[bytesWritten], thisLen);
  40c9f2:	683a      	ldr	r2, [r7, #0]
  40c9f4:	6b3b      	ldr	r3, [r7, #48]	; 0x30
  40c9f6:	441a      	add	r2, r3
  40c9f8:	6abb      	ldr	r3, [r7, #40]	; 0x28
  40c9fa:	217d      	movs	r1, #125	; 0x7d
  40c9fc:	68f8      	ldr	r0, [r7, #12]
  40c9fe:	4c2b      	ldr	r4, [pc, #172]	; (40caac <inv_icm20948_read_mems+0x1dc>)
  40ca00:	47a0      	blx	r4
  40ca02:	4602      	mov	r2, r0
  40ca04:	6b7b      	ldr	r3, [r7, #52]	; 0x34
  40ca06:	4313      	orrs	r3, r2
  40ca08:	637b      	str	r3, [r7, #52]	; 0x34
		}
		if (result)
  40ca0a:	6b7b      	ldr	r3, [r7, #52]	; 0x34
  40ca0c:	2b00      	cmp	r3, #0
  40ca0e:	d001      	beq.n	40ca14 <inv_icm20948_read_mems+0x144>
			return result;
  40ca10:	6b7b      	ldr	r3, [r7, #52]	; 0x34
  40ca12:	e03d      	b.n	40ca90 <inv_icm20948_read_mems+0x1c0>

		bytesWritten += thisLen;
  40ca14:	6b3a      	ldr	r2, [r7, #48]	; 0x30
  40ca16:	6abb      	ldr	r3, [r7, #40]	; 0x28
  40ca18:	4413      	add	r3, r2
  40ca1a:	633b      	str	r3, [r7, #48]	; 0x30
		reg += thisLen;
  40ca1c:	6abb      	ldr	r3, [r7, #40]	; 0x28
  40ca1e:	b29a      	uxth	r2, r3
  40ca20:	897b      	ldrh	r3, [r7, #10]
  40ca22:	4413      	add	r3, r2
  40ca24:	817b      	strh	r3, [r7, #10]
	while (bytesWritten < length) 
  40ca26:	6b3a      	ldr	r2, [r7, #48]	; 0x30
  40ca28:	687b      	ldr	r3, [r7, #4]
  40ca2a:	429a      	cmp	r2, r3
  40ca2c:	d3b4      	bcc.n	40c998 <inv_icm20948_read_mems+0xc8>
	}

	if(s->base_state.serial_interface == SERIAL_INTERFACE_SPI) {
  40ca2e:	68fb      	ldr	r3, [r7, #12]
  40ca30:	f893 3027 	ldrb.w	r3, [r3, #39]	; 0x27
  40ca34:	2b02      	cmp	r3, #2
  40ca36:	d119      	bne.n	40ca6c <inv_icm20948_read_mems+0x19c>
		for (i=0; i< length; i++) {
  40ca38:	2300      	movs	r3, #0
  40ca3a:	f887 302f 	strb.w	r3, [r7, #47]	; 0x2f
  40ca3e:	e010      	b.n	40ca62 <inv_icm20948_read_mems+0x192>
			*data= dat[i];
  40ca40:	f897 302f 	ldrb.w	r3, [r7, #47]	; 0x2f
  40ca44:	f107 0238 	add.w	r2, r7, #56	; 0x38
  40ca48:	4413      	add	r3, r2
  40ca4a:	f813 2c20 	ldrb.w	r2, [r3, #-32]
  40ca4e:	683b      	ldr	r3, [r7, #0]
  40ca50:	701a      	strb	r2, [r3, #0]
			data++;
  40ca52:	683b      	ldr	r3, [r7, #0]
  40ca54:	3301      	adds	r3, #1
  40ca56:	603b      	str	r3, [r7, #0]
		for (i=0; i< length; i++) {
  40ca58:	f897 302f 	ldrb.w	r3, [r7, #47]	; 0x2f
  40ca5c:	3301      	adds	r3, #1
  40ca5e:	f887 302f 	strb.w	r3, [r7, #47]	; 0x2f
  40ca62:	f897 202f 	ldrb.w	r2, [r7, #47]	; 0x2f
  40ca66:	687b      	ldr	r3, [r7, #4]
  40ca68:	429a      	cmp	r2, r3
  40ca6a:	d3e9      	bcc.n	40ca40 <inv_icm20948_read_mems+0x170>
		}
	}

	//Enable LP_EN if we disabled it at begining of this function.
	if(check_reg_access_lp_disable(s, reg))
  40ca6c:	897b      	ldrh	r3, [r7, #10]
  40ca6e:	4619      	mov	r1, r3
  40ca70:	68f8      	ldr	r0, [r7, #12]
  40ca72:	4b0b      	ldr	r3, [pc, #44]	; (40caa0 <inv_icm20948_read_mems+0x1d0>)
  40ca74:	4798      	blx	r3
  40ca76:	4603      	mov	r3, r0
  40ca78:	2b00      	cmp	r3, #0
  40ca7a:	d008      	beq.n	40ca8e <inv_icm20948_read_mems+0x1be>
		result |= inv_icm20948_set_chip_power_state(s, CHIP_LP_ENABLE, 1);
  40ca7c:	2201      	movs	r2, #1
  40ca7e:	2102      	movs	r1, #2
  40ca80:	68f8      	ldr	r0, [r7, #12]
  40ca82:	4b06      	ldr	r3, [pc, #24]	; (40ca9c <inv_icm20948_read_mems+0x1cc>)
  40ca84:	4798      	blx	r3
  40ca86:	4602      	mov	r2, r0
  40ca88:	6b7b      	ldr	r3, [r7, #52]	; 0x34
  40ca8a:	4313      	orrs	r3, r2
  40ca8c:	637b      	str	r3, [r7, #52]	; 0x34

	return result;
  40ca8e:	6b7b      	ldr	r3, [r7, #52]	; 0x34
}
  40ca90:	4618      	mov	r0, r3
  40ca92:	373c      	adds	r7, #60	; 0x3c
  40ca94:	46bd      	mov	sp, r7
  40ca96:	bd90      	pop	{r4, r7, pc}
  40ca98:	00405905 	.word	0x00405905
  40ca9c:	004057a5 	.word	0x004057a5
  40caa0:	0040c495 	.word	0x0040c495
  40caa4:	0040c4f1 	.word	0x0040c4f1
  40caa8:	0040c421 	.word	0x0040c421
  40caac:	0040c3f5 	.word	0x0040c3f5

0040cab0 <inv_icm20948_write_mems>:
*  @param[in]   number of byte to be written
*  @param[out]  output data from the register
*  @return     0 if successful.
*/
int inv_icm20948_write_mems(struct inv_icm20948 * s, unsigned short reg, unsigned int length, const unsigned char *data)
{
  40cab0:	b590      	push	{r4, r7, lr}
  40cab2:	b08b      	sub	sp, #44	; 0x2c
  40cab4:	af00      	add	r7, sp, #0
  40cab6:	60f8      	str	r0, [r7, #12]
  40cab8:	607a      	str	r2, [r7, #4]
  40caba:	603b      	str	r3, [r7, #0]
  40cabc:	460b      	mov	r3, r1
  40cabe:	817b      	strh	r3, [r7, #10]
	int result=0;
  40cac0:	2300      	movs	r3, #0
  40cac2:	627b      	str	r3, [r7, #36]	; 0x24
	unsigned int bytesWritten = 0;
  40cac4:	2300      	movs	r3, #0
  40cac6:	623b      	str	r3, [r7, #32]
	unsigned int thisLen;
	unsigned char lBankSelected;
	unsigned char lStartAddrSelected;

	unsigned char power_state = inv_icm20948_get_chip_power_state(s);
  40cac8:	68f8      	ldr	r0, [r7, #12]
  40caca:	4b46      	ldr	r3, [pc, #280]	; (40cbe4 <inv_icm20948_write_mems+0x134>)
  40cacc:	4798      	blx	r3
  40cace:	4603      	mov	r3, r0
  40cad0:	77fb      	strb	r3, [r7, #31]

	if(!data)
  40cad2:	683b      	ldr	r3, [r7, #0]
  40cad4:	2b00      	cmp	r3, #0
  40cad6:	d102      	bne.n	40cade <inv_icm20948_write_mems+0x2e>
		return -1;
  40cad8:	f04f 33ff 	mov.w	r3, #4294967295
  40cadc:	e07d      	b.n	40cbda <inv_icm20948_write_mems+0x12a>

	if((power_state & CHIP_AWAKE) == 0)   // Wake up chip since it is asleep
  40cade:	7ffb      	ldrb	r3, [r7, #31]
  40cae0:	f003 0301 	and.w	r3, r3, #1
  40cae4:	2b00      	cmp	r3, #0
  40cae6:	d105      	bne.n	40caf4 <inv_icm20948_write_mems+0x44>
		result = inv_icm20948_set_chip_power_state(s, CHIP_AWAKE, 1);
  40cae8:	2201      	movs	r2, #1
  40caea:	2101      	movs	r1, #1
  40caec:	68f8      	ldr	r0, [r7, #12]
  40caee:	4b3e      	ldr	r3, [pc, #248]	; (40cbe8 <inv_icm20948_write_mems+0x138>)
  40caf0:	4798      	blx	r3
  40caf2:	6278      	str	r0, [r7, #36]	; 0x24

	result |= inv_icm20948_set_chip_power_state(s, CHIP_LP_ENABLE, 0);
  40caf4:	2200      	movs	r2, #0
  40caf6:	2102      	movs	r1, #2
  40caf8:	68f8      	ldr	r0, [r7, #12]
  40cafa:	4b3b      	ldr	r3, [pc, #236]	; (40cbe8 <inv_icm20948_write_mems+0x138>)
  40cafc:	4798      	blx	r3
  40cafe:	4602      	mov	r2, r0
  40cb00:	6a7b      	ldr	r3, [r7, #36]	; 0x24
  40cb02:	4313      	orrs	r3, r2
  40cb04:	627b      	str	r3, [r7, #36]	; 0x24

	result |= inv_set_bank(s, 0);
  40cb06:	2100      	movs	r1, #0
  40cb08:	68f8      	ldr	r0, [r7, #12]
  40cb0a:	4b38      	ldr	r3, [pc, #224]	; (40cbec <inv_icm20948_write_mems+0x13c>)
  40cb0c:	4798      	blx	r3
  40cb0e:	4602      	mov	r2, r0
  40cb10:	6a7b      	ldr	r3, [r7, #36]	; 0x24
  40cb12:	4313      	orrs	r3, r2
  40cb14:	627b      	str	r3, [r7, #36]	; 0x24

	lBankSelected = (reg >> 8);
  40cb16:	897b      	ldrh	r3, [r7, #10]
  40cb18:	0a1b      	lsrs	r3, r3, #8
  40cb1a:	b29b      	uxth	r3, r3
  40cb1c:	b2db      	uxtb	r3, r3
  40cb1e:	75fb      	strb	r3, [r7, #23]
	if (lBankSelected != s->lLastBankSelected)
  40cb20:	68fb      	ldr	r3, [r7, #12]
  40cb22:	f893 24dc 	ldrb.w	r2, [r3, #1244]	; 0x4dc
  40cb26:	7dfb      	ldrb	r3, [r7, #23]
  40cb28:	429a      	cmp	r2, r3
  40cb2a:	d048      	beq.n	40cbbe <inv_icm20948_write_mems+0x10e>
	{
		result |= inv_icm20948_write_reg(s, REG_MEM_BANK_SEL, &lBankSelected, 1);
  40cb2c:	f107 0217 	add.w	r2, r7, #23
  40cb30:	2301      	movs	r3, #1
  40cb32:	217e      	movs	r1, #126	; 0x7e
  40cb34:	68f8      	ldr	r0, [r7, #12]
  40cb36:	4c2e      	ldr	r4, [pc, #184]	; (40cbf0 <inv_icm20948_write_mems+0x140>)
  40cb38:	47a0      	blx	r4
  40cb3a:	4602      	mov	r2, r0
  40cb3c:	6a7b      	ldr	r3, [r7, #36]	; 0x24
  40cb3e:	4313      	orrs	r3, r2
  40cb40:	627b      	str	r3, [r7, #36]	; 0x24
		if (result)
  40cb42:	6a7b      	ldr	r3, [r7, #36]	; 0x24
  40cb44:	2b00      	cmp	r3, #0
  40cb46:	d001      	beq.n	40cb4c <inv_icm20948_write_mems+0x9c>
			return result;
  40cb48:	6a7b      	ldr	r3, [r7, #36]	; 0x24
  40cb4a:	e046      	b.n	40cbda <inv_icm20948_write_mems+0x12a>
		s->lLastBankSelected = lBankSelected;
  40cb4c:	7dfa      	ldrb	r2, [r7, #23]
  40cb4e:	68fb      	ldr	r3, [r7, #12]
  40cb50:	f883 24dc 	strb.w	r2, [r3, #1244]	; 0x4dc
	}

	while (bytesWritten < length) 
  40cb54:	e033      	b.n	40cbbe <inv_icm20948_write_mems+0x10e>
	{
		lStartAddrSelected = (reg & 0xff);
  40cb56:	897b      	ldrh	r3, [r7, #10]
  40cb58:	b2db      	uxtb	r3, r3
  40cb5a:	75bb      	strb	r3, [r7, #22]
		/* Sets the starting read or write address for the selected memory, inside of the selected page (see MEM_SEL Register).
		Contents are changed after read or write of the selected memory.
		This register must be written prior to each access to initialize the register to the proper starting address.
		The address will auto increment during burst transactions.  Two consecutive bursts without re-initializing the start address would skip one address. */
		result |= inv_icm20948_write_reg(s, REG_MEM_START_ADDR, &lStartAddrSelected, 1);
  40cb5c:	f107 0216 	add.w	r2, r7, #22
  40cb60:	2301      	movs	r3, #1
  40cb62:	217c      	movs	r1, #124	; 0x7c
  40cb64:	68f8      	ldr	r0, [r7, #12]
  40cb66:	4c22      	ldr	r4, [pc, #136]	; (40cbf0 <inv_icm20948_write_mems+0x140>)
  40cb68:	47a0      	blx	r4
  40cb6a:	4602      	mov	r2, r0
  40cb6c:	6a7b      	ldr	r3, [r7, #36]	; 0x24
  40cb6e:	4313      	orrs	r3, r2
  40cb70:	627b      	str	r3, [r7, #36]	; 0x24
		if (result)
  40cb72:	6a7b      	ldr	r3, [r7, #36]	; 0x24
  40cb74:	2b00      	cmp	r3, #0
  40cb76:	d001      	beq.n	40cb7c <inv_icm20948_write_mems+0xcc>
			return result;
  40cb78:	6a7b      	ldr	r3, [r7, #36]	; 0x24
  40cb7a:	e02e      	b.n	40cbda <inv_icm20948_write_mems+0x12a>

		thisLen = min(INV_MAX_SERIAL_WRITE, length-bytesWritten);
  40cb7c:	687a      	ldr	r2, [r7, #4]
  40cb7e:	6a3b      	ldr	r3, [r7, #32]
  40cb80:	1ad3      	subs	r3, r2, r3
  40cb82:	2b10      	cmp	r3, #16
  40cb84:	bf28      	it	cs
  40cb86:	2310      	movcs	r3, #16
  40cb88:	61bb      	str	r3, [r7, #24]

		/* Write data */ 
		result |= inv_icm20948_write_reg(s, REG_MEM_R_W, &data[bytesWritten], thisLen);
  40cb8a:	683a      	ldr	r2, [r7, #0]
  40cb8c:	6a3b      	ldr	r3, [r7, #32]
  40cb8e:	441a      	add	r2, r3
  40cb90:	69bb      	ldr	r3, [r7, #24]
  40cb92:	217d      	movs	r1, #125	; 0x7d
  40cb94:	68f8      	ldr	r0, [r7, #12]
  40cb96:	4c16      	ldr	r4, [pc, #88]	; (40cbf0 <inv_icm20948_write_mems+0x140>)
  40cb98:	47a0      	blx	r4
  40cb9a:	4602      	mov	r2, r0
  40cb9c:	6a7b      	ldr	r3, [r7, #36]	; 0x24
  40cb9e:	4313      	orrs	r3, r2
  40cba0:	627b      	str	r3, [r7, #36]	; 0x24
		if (result)
  40cba2:	6a7b      	ldr	r3, [r7, #36]	; 0x24
  40cba4:	2b00      	cmp	r3, #0
  40cba6:	d001      	beq.n	40cbac <inv_icm20948_write_mems+0xfc>
			return result;
  40cba8:	6a7b      	ldr	r3, [r7, #36]	; 0x24
  40cbaa:	e016      	b.n	40cbda <inv_icm20948_write_mems+0x12a>

		bytesWritten += thisLen;
  40cbac:	6a3a      	ldr	r2, [r7, #32]
  40cbae:	69bb      	ldr	r3, [r7, #24]
  40cbb0:	4413      	add	r3, r2
  40cbb2:	623b      	str	r3, [r7, #32]
		reg += thisLen;
  40cbb4:	69bb      	ldr	r3, [r7, #24]
  40cbb6:	b29a      	uxth	r2, r3
  40cbb8:	897b      	ldrh	r3, [r7, #10]
  40cbba:	4413      	add	r3, r2
  40cbbc:	817b      	strh	r3, [r7, #10]
	while (bytesWritten < length) 
  40cbbe:	6a3a      	ldr	r2, [r7, #32]
  40cbc0:	687b      	ldr	r3, [r7, #4]
  40cbc2:	429a      	cmp	r2, r3
  40cbc4:	d3c7      	bcc.n	40cb56 <inv_icm20948_write_mems+0xa6>
	}

	//Enable LP_EN since we disabled it at begining of this function.
	result |= inv_icm20948_set_chip_power_state(s, CHIP_LP_ENABLE, 1);
  40cbc6:	2201      	movs	r2, #1
  40cbc8:	2102      	movs	r1, #2
  40cbca:	68f8      	ldr	r0, [r7, #12]
  40cbcc:	4b06      	ldr	r3, [pc, #24]	; (40cbe8 <inv_icm20948_write_mems+0x138>)
  40cbce:	4798      	blx	r3
  40cbd0:	4602      	mov	r2, r0
  40cbd2:	6a7b      	ldr	r3, [r7, #36]	; 0x24
  40cbd4:	4313      	orrs	r3, r2
  40cbd6:	627b      	str	r3, [r7, #36]	; 0x24

	return result;
  40cbd8:	6a7b      	ldr	r3, [r7, #36]	; 0x24
}
  40cbda:	4618      	mov	r0, r3
  40cbdc:	372c      	adds	r7, #44	; 0x2c
  40cbde:	46bd      	mov	sp, r7
  40cbe0:	bd90      	pop	{r4, r7, pc}
  40cbe2:	bf00      	nop
  40cbe4:	00405905 	.word	0x00405905
  40cbe8:	004057a5 	.word	0x004057a5
  40cbec:	0040c4f1 	.word	0x0040c4f1
  40cbf0:	0040c421 	.word	0x0040c421

0040cbf4 <inv_icm20948_write_single_mems_reg_core>:
*  @param[in]  Register address
*  @param[in]  Data to be written
*  @return     0 if successful.
*/
int inv_icm20948_write_single_mems_reg_core(struct inv_icm20948 * s, uint16_t reg, const uint8_t data)
{
  40cbf4:	b590      	push	{r4, r7, lr}
  40cbf6:	b085      	sub	sp, #20
  40cbf8:	af00      	add	r7, sp, #0
  40cbfa:	6078      	str	r0, [r7, #4]
  40cbfc:	460b      	mov	r3, r1
  40cbfe:	807b      	strh	r3, [r7, #2]
  40cc00:	4613      	mov	r3, r2
  40cc02:	707b      	strb	r3, [r7, #1]
	int result = 0;
  40cc04:	2300      	movs	r3, #0
  40cc06:	60fb      	str	r3, [r7, #12]
	unsigned char regOnly = (unsigned char)(reg & 0x7F);
  40cc08:	887b      	ldrh	r3, [r7, #2]
  40cc0a:	b2db      	uxtb	r3, r3
  40cc0c:	f003 037f 	and.w	r3, r3, #127	; 0x7f
  40cc10:	72fb      	strb	r3, [r7, #11]

	result |= inv_set_bank(s, reg >> 7);
  40cc12:	887b      	ldrh	r3, [r7, #2]
  40cc14:	09db      	lsrs	r3, r3, #7
  40cc16:	b29b      	uxth	r3, r3
  40cc18:	b2db      	uxtb	r3, r3
  40cc1a:	4619      	mov	r1, r3
  40cc1c:	6878      	ldr	r0, [r7, #4]
  40cc1e:	4b0a      	ldr	r3, [pc, #40]	; (40cc48 <inv_icm20948_write_single_mems_reg_core+0x54>)
  40cc20:	4798      	blx	r3
  40cc22:	4602      	mov	r2, r0
  40cc24:	68fb      	ldr	r3, [r7, #12]
  40cc26:	4313      	orrs	r3, r2
  40cc28:	60fb      	str	r3, [r7, #12]
	result |= inv_icm20948_write_reg(s, regOnly, &data, 1);
  40cc2a:	1c7a      	adds	r2, r7, #1
  40cc2c:	7af9      	ldrb	r1, [r7, #11]
  40cc2e:	2301      	movs	r3, #1
  40cc30:	6878      	ldr	r0, [r7, #4]
  40cc32:	4c06      	ldr	r4, [pc, #24]	; (40cc4c <inv_icm20948_write_single_mems_reg_core+0x58>)
  40cc34:	47a0      	blx	r4
  40cc36:	4602      	mov	r2, r0
  40cc38:	68fb      	ldr	r3, [r7, #12]
  40cc3a:	4313      	orrs	r3, r2
  40cc3c:	60fb      	str	r3, [r7, #12]

	return result;
  40cc3e:	68fb      	ldr	r3, [r7, #12]
}
  40cc40:	4618      	mov	r0, r3
  40cc42:	3714      	adds	r7, #20
  40cc44:	46bd      	mov	sp, r7
  40cc46:	bd90      	pop	{r4, r7, pc}
  40cc48:	0040c4f1 	.word	0x0040c4f1
  40cc4c:	0040c421 	.word	0x0040c421

0040cc50 <inv_sensor_str>:
#include "SensorTypes.h"

#include <assert.h>

const char * inv_sensor_2str(int sensor)
{
  40cc50:	b480      	push	{r7}
  40cc52:	b085      	sub	sp, #20
  40cc54:	af00      	add	r7, sp, #0
  40cc56:	6078      	str	r0, [r7, #4]
		{ "SENSOR_PRED_QUAT_0",            "SENSOR_PRED_QUAT_0_WU"},
		{ "SENSOR_PRED_QUAT_1",            "SENSOR_PRED_QUAT_1_WU"},
		{ "SENSOR_OIS_1",                  "SENSOR_OIS_1_WU"},
	};

	if (INV_SENSOR_IS_VALID(sensor)) {
  40cc58:	687b      	ldr	r3, [r7, #4]
  40cc5a:	f023 4300 	bic.w	r3, r3, #2147483648	; 0x80000000
  40cc5e:	2b43      	cmp	r3, #67	; 0x43
  40cc60:	d811      	bhi.n	40cc86 <inv_sensor_str+0x36>
		const char * s = sensor_str[INV_SENSOR_ID_TO_TYPE(sensor)][INV_SENSOR_IS_WU(sensor)];
  40cc62:	687b      	ldr	r3, [r7, #4]
  40cc64:	f023 4300 	bic.w	r3, r3, #2147483648	; 0x80000000
  40cc68:	687a      	ldr	r2, [r7, #4]
  40cc6a:	0fd2      	lsrs	r2, r2, #31
  40cc6c:	b2d2      	uxtb	r2, r2
  40cc6e:	4611      	mov	r1, r2
  40cc70:	4a08      	ldr	r2, [pc, #32]	; (40cc94 <inv_sensor_str+0x44>)
  40cc72:	005b      	lsls	r3, r3, #1
  40cc74:	440b      	add	r3, r1
  40cc76:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
  40cc7a:	60fb      	str	r3, [r7, #12]

		assert(s != 0); // we forgot to update the array after adding a sensor!

		if(s != 0)
  40cc7c:	68fb      	ldr	r3, [r7, #12]
  40cc7e:	2b00      	cmp	r3, #0
  40cc80:	d001      	beq.n	40cc86 <inv_sensor_str+0x36>
			return s;
  40cc82:	68fb      	ldr	r3, [r7, #12]
  40cc84:	e000      	b.n	40cc88 <inv_sensor_str+0x38>
	}

	return "";
  40cc86:	4b04      	ldr	r3, [pc, #16]	; (40cc98 <inv_sensor_str+0x48>)
}
  40cc88:	4618      	mov	r0, r3
  40cc8a:	3714      	adds	r7, #20
  40cc8c:	46bd      	mov	sp, r7
  40cc8e:	f85d 7b04 	ldr.w	r7, [sp], #4
  40cc92:	4770      	bx	lr
  40cc94:	20000134 	.word	0x20000134
  40cc98:	0041bf1c 	.word	0x0041bf1c

0040cc9c <DynProtocol_decodeVect16QxToQy>:
#define PROTOCOL_HEADING_ACCURACY_PRECISION   7

#define DYN_PROTOCOL_QX_TO_QY(value, qx, qy)	((qx >= qy) ? (value >> (qx-qy)) : (value << (qy-qx)) )

static inline int DynProtocol_decodeVect16QxToQy(const uint8_t * bytes, unsigned len, int qxIn, int qxOut,  int32_t * out)
{
  40cc9c:	b480      	push	{r7}
  40cc9e:	b087      	sub	sp, #28
  40cca0:	af00      	add	r7, sp, #0
  40cca2:	60f8      	str	r0, [r7, #12]
  40cca4:	60b9      	str	r1, [r7, #8]
  40cca6:	607a      	str	r2, [r7, #4]
  40cca8:	603b      	str	r3, [r7, #0]
	unsigned i;
	for(i = 0; i < len; ++i) {
  40ccaa:	2300      	movs	r3, #0
  40ccac:	617b      	str	r3, [r7, #20]
  40ccae:	e027      	b.n	40cd00 <DynProtocol_decodeVect16QxToQy+0x64>
		int32_t x = (int32_t)(((int8_t *)bytes)[2*i+1] << 8) | bytes[2*i];
  40ccb0:	697b      	ldr	r3, [r7, #20]
  40ccb2:	005b      	lsls	r3, r3, #1
  40ccb4:	3301      	adds	r3, #1
  40ccb6:	68fa      	ldr	r2, [r7, #12]
  40ccb8:	4413      	add	r3, r2
  40ccba:	f993 3000 	ldrsb.w	r3, [r3]
  40ccbe:	021b      	lsls	r3, r3, #8
  40ccc0:	697a      	ldr	r2, [r7, #20]
  40ccc2:	0052      	lsls	r2, r2, #1
  40ccc4:	68f9      	ldr	r1, [r7, #12]
  40ccc6:	440a      	add	r2, r1
  40ccc8:	7812      	ldrb	r2, [r2, #0]
  40ccca:	4313      	orrs	r3, r2
  40cccc:	613b      	str	r3, [r7, #16]
		out[i] = (int32_t)DYN_PROTOCOL_QX_TO_QY(x, qxIn ,qxOut);
  40ccce:	697b      	ldr	r3, [r7, #20]
  40ccd0:	009b      	lsls	r3, r3, #2
  40ccd2:	6a3a      	ldr	r2, [r7, #32]
  40ccd4:	441a      	add	r2, r3
  40ccd6:	6879      	ldr	r1, [r7, #4]
  40ccd8:	683b      	ldr	r3, [r7, #0]
  40ccda:	4299      	cmp	r1, r3
  40ccdc:	db06      	blt.n	40ccec <DynProtocol_decodeVect16QxToQy+0x50>
  40ccde:	6879      	ldr	r1, [r7, #4]
  40cce0:	683b      	ldr	r3, [r7, #0]
  40cce2:	1acb      	subs	r3, r1, r3
  40cce4:	6939      	ldr	r1, [r7, #16]
  40cce6:	fa41 f303 	asr.w	r3, r1, r3
  40ccea:	e005      	b.n	40ccf8 <DynProtocol_decodeVect16QxToQy+0x5c>
  40ccec:	6839      	ldr	r1, [r7, #0]
  40ccee:	687b      	ldr	r3, [r7, #4]
  40ccf0:	1acb      	subs	r3, r1, r3
  40ccf2:	6939      	ldr	r1, [r7, #16]
  40ccf4:	fa01 f303 	lsl.w	r3, r1, r3
  40ccf8:	6013      	str	r3, [r2, #0]
	for(i = 0; i < len; ++i) {
  40ccfa:	697b      	ldr	r3, [r7, #20]
  40ccfc:	3301      	adds	r3, #1
  40ccfe:	617b      	str	r3, [r7, #20]
  40cd00:	697a      	ldr	r2, [r7, #20]
  40cd02:	68bb      	ldr	r3, [r7, #8]
  40cd04:	429a      	cmp	r2, r3
  40cd06:	d3d3      	bcc.n	40ccb0 <DynProtocol_decodeVect16QxToQy+0x14>
	}

	return 2*len;
  40cd08:	68bb      	ldr	r3, [r7, #8]
  40cd0a:	005b      	lsls	r3, r3, #1
}
  40cd0c:	4618      	mov	r0, r3
  40cd0e:	371c      	adds	r7, #28
  40cd10:	46bd      	mov	sp, r7
  40cd12:	f85d 7b04 	ldr.w	r7, [sp], #4
  40cd16:	4770      	bx	lr

0040cd18 <DynProtocol_encodeQxToQyVect16>:

static inline int DynProtocol_encodeQxToQyVect16(const int32_t * in, unsigned len, int qxIn, int qxOut, uint8_t * bytes)
{
  40cd18:	b480      	push	{r7}
  40cd1a:	b087      	sub	sp, #28
  40cd1c:	af00      	add	r7, sp, #0
  40cd1e:	60f8      	str	r0, [r7, #12]
  40cd20:	60b9      	str	r1, [r7, #8]
  40cd22:	607a      	str	r2, [r7, #4]
  40cd24:	603b      	str	r3, [r7, #0]
	unsigned i;
	for(i = 0; i < len; ++i) {
  40cd26:	2300      	movs	r3, #0
  40cd28:	617b      	str	r3, [r7, #20]
  40cd2a:	e02f      	b.n	40cd8c <DynProtocol_encodeQxToQyVect16+0x74>
		int16_t x = (int16_t)DYN_PROTOCOL_QX_TO_QY(in[i], qxIn ,qxOut);
  40cd2c:	687a      	ldr	r2, [r7, #4]
  40cd2e:	683b      	ldr	r3, [r7, #0]
  40cd30:	429a      	cmp	r2, r3
  40cd32:	db0b      	blt.n	40cd4c <DynProtocol_encodeQxToQyVect16+0x34>
  40cd34:	697b      	ldr	r3, [r7, #20]
  40cd36:	009b      	lsls	r3, r3, #2
  40cd38:	68fa      	ldr	r2, [r7, #12]
  40cd3a:	4413      	add	r3, r2
  40cd3c:	681a      	ldr	r2, [r3, #0]
  40cd3e:	6879      	ldr	r1, [r7, #4]
  40cd40:	683b      	ldr	r3, [r7, #0]
  40cd42:	1acb      	subs	r3, r1, r3
  40cd44:	fa42 f303 	asr.w	r3, r2, r3
  40cd48:	b21b      	sxth	r3, r3
  40cd4a:	e00a      	b.n	40cd62 <DynProtocol_encodeQxToQyVect16+0x4a>
  40cd4c:	697b      	ldr	r3, [r7, #20]
  40cd4e:	009b      	lsls	r3, r3, #2
  40cd50:	68fa      	ldr	r2, [r7, #12]
  40cd52:	4413      	add	r3, r2
  40cd54:	681a      	ldr	r2, [r3, #0]
  40cd56:	6839      	ldr	r1, [r7, #0]
  40cd58:	687b      	ldr	r3, [r7, #4]
  40cd5a:	1acb      	subs	r3, r1, r3
  40cd5c:	fa02 f303 	lsl.w	r3, r2, r3
  40cd60:	b21b      	sxth	r3, r3
  40cd62:	827b      	strh	r3, [r7, #18]
		bytes[2*i]   = (uint8_t)((uint16_t)x & 0xFF);
  40cd64:	697b      	ldr	r3, [r7, #20]
  40cd66:	005b      	lsls	r3, r3, #1
  40cd68:	6a3a      	ldr	r2, [r7, #32]
  40cd6a:	4413      	add	r3, r2
  40cd6c:	8a7a      	ldrh	r2, [r7, #18]
  40cd6e:	b2d2      	uxtb	r2, r2
  40cd70:	701a      	strb	r2, [r3, #0]
		bytes[2*i+1] = (uint8_t)(((uint16_t)x & 0xFF00) >> 8U);
  40cd72:	697b      	ldr	r3, [r7, #20]
  40cd74:	005b      	lsls	r3, r3, #1
  40cd76:	3301      	adds	r3, #1
  40cd78:	6a3a      	ldr	r2, [r7, #32]
  40cd7a:	4413      	add	r3, r2
  40cd7c:	8a7a      	ldrh	r2, [r7, #18]
  40cd7e:	0a12      	lsrs	r2, r2, #8
  40cd80:	b292      	uxth	r2, r2
  40cd82:	b2d2      	uxtb	r2, r2
  40cd84:	701a      	strb	r2, [r3, #0]
	for(i = 0; i < len; ++i) {
  40cd86:	697b      	ldr	r3, [r7, #20]
  40cd88:	3301      	adds	r3, #1
  40cd8a:	617b      	str	r3, [r7, #20]
  40cd8c:	697a      	ldr	r2, [r7, #20]
  40cd8e:	68bb      	ldr	r3, [r7, #8]
  40cd90:	429a      	cmp	r2, r3
  40cd92:	d3cb      	bcc.n	40cd2c <DynProtocol_encodeQxToQyVect16+0x14>
	}

	return 2*len;
  40cd94:	68bb      	ldr	r3, [r7, #8]
  40cd96:	005b      	lsls	r3, r3, #1
}
  40cd98:	4618      	mov	r0, r3
  40cd9a:	371c      	adds	r7, #28
  40cd9c:	46bd      	mov	sp, r7
  40cd9e:	f85d 7b04 	ldr.w	r7, [sp], #4
  40cda2:	4770      	bx	lr

0040cda4 <DynProtocol_getPrecision>:

static int DynProtocol_getPrecision(DynProtocol_t * self, int sensor_id)
{
  40cda4:	b480      	push	{r7}
  40cda6:	b085      	sub	sp, #20
  40cda8:	af00      	add	r7, sp, #0
  40cdaa:	6078      	str	r0, [r7, #4]
  40cdac:	6039      	str	r1, [r7, #0]
	int QxIn;

	switch (sensor_id)
  40cdae:	683b      	ldr	r3, [r7, #0]
  40cdb0:	3b01      	subs	r3, #1
  40cdb2:	2b40      	cmp	r3, #64	; 0x40
  40cdb4:	f200 809c 	bhi.w	40cef0 <DynProtocol_getPrecision+0x14c>
  40cdb8:	a201      	add	r2, pc, #4	; (adr r2, 40cdc0 <DynProtocol_getPrecision+0x1c>)
  40cdba:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
  40cdbe:	bf00      	nop
  40cdc0:	0040cec5 	.word	0x0040cec5
  40cdc4:	0040ced9 	.word	0x0040ced9
  40cdc8:	0040cee5 	.word	0x0040cee5
  40cdcc:	0040cecf 	.word	0x0040cecf
  40cdd0:	0040cef1 	.word	0x0040cef1
  40cdd4:	0040cef1 	.word	0x0040cef1
  40cdd8:	0040ceeb 	.word	0x0040ceeb
  40cddc:	0040cef1 	.word	0x0040cef1
  40cde0:	0040cec5 	.word	0x0040cec5
  40cde4:	0040cec5 	.word	0x0040cec5
  40cde8:	0040cedf 	.word	0x0040cedf
  40cdec:	0040cef1 	.word	0x0040cef1
  40cdf0:	0040ceeb 	.word	0x0040ceeb
  40cdf4:	0040ced9 	.word	0x0040ced9
  40cdf8:	0040cedf 	.word	0x0040cedf
  40cdfc:	0040cecf 	.word	0x0040cecf
  40ce00:	0040cef1 	.word	0x0040cef1
  40ce04:	0040cef1 	.word	0x0040cef1
  40ce08:	0040cef1 	.word	0x0040cef1
  40ce0c:	0040cedf 	.word	0x0040cedf
  40ce10:	0040cef1 	.word	0x0040cef1
  40ce14:	0040cef1 	.word	0x0040cef1
  40ce18:	0040cef1 	.word	0x0040cef1
  40ce1c:	0040cef1 	.word	0x0040cef1
  40ce20:	0040cef1 	.word	0x0040cef1
  40ce24:	0040cef1 	.word	0x0040cef1
  40ce28:	0040cef1 	.word	0x0040cef1
  40ce2c:	0040cef1 	.word	0x0040cef1
  40ce30:	0040cedf 	.word	0x0040cedf
  40ce34:	0040cef1 	.word	0x0040cef1
  40ce38:	0040cef1 	.word	0x0040cef1
  40ce3c:	0040cef1 	.word	0x0040cef1
  40ce40:	0040cef1 	.word	0x0040cef1
  40ce44:	0040cef1 	.word	0x0040cef1
  40ce48:	0040cef1 	.word	0x0040cef1
  40ce4c:	0040cef1 	.word	0x0040cef1
  40ce50:	0040cef1 	.word	0x0040cef1
  40ce54:	0040cef1 	.word	0x0040cef1
  40ce58:	0040cef1 	.word	0x0040cef1
  40ce5c:	0040cef1 	.word	0x0040cef1
  40ce60:	0040cef1 	.word	0x0040cef1
  40ce64:	0040cef1 	.word	0x0040cef1
  40ce68:	0040cef1 	.word	0x0040cef1
  40ce6c:	0040cef1 	.word	0x0040cef1
  40ce70:	0040cef1 	.word	0x0040cef1
  40ce74:	0040cef1 	.word	0x0040cef1
  40ce78:	0040cef1 	.word	0x0040cef1
  40ce7c:	0040cef1 	.word	0x0040cef1
  40ce80:	0040cef1 	.word	0x0040cef1
  40ce84:	0040cef1 	.word	0x0040cef1
  40ce88:	0040cef1 	.word	0x0040cef1
  40ce8c:	0040cef1 	.word	0x0040cef1
  40ce90:	0040cef1 	.word	0x0040cef1
  40ce94:	0040cef1 	.word	0x0040cef1
  40ce98:	0040cef1 	.word	0x0040cef1
  40ce9c:	0040cef1 	.word	0x0040cef1
  40cea0:	0040cef1 	.word	0x0040cef1
  40cea4:	0040cef1 	.word	0x0040cef1
  40cea8:	0040cef1 	.word	0x0040cef1
  40ceac:	0040cef1 	.word	0x0040cef1
  40ceb0:	0040cef1 	.word	0x0040cef1
  40ceb4:	0040cef1 	.word	0x0040cef1
  40ceb8:	0040cef1 	.word	0x0040cef1
  40cebc:	0040cedf 	.word	0x0040cedf
  40cec0:	0040cedf 	.word	0x0040cedf
	{
	case DYN_PRO_SENSOR_TYPE_ACCELEROMETER:
	case DYN_PRO_SENSOR_TYPE_GRAVITY:
	case DYN_PRO_SENSOR_TYPE_LINEAR_ACCELERATION:
		QxIn = self->precision.acc;
  40cec4:	687b      	ldr	r3, [r7, #4]
  40cec6:	f893 3294 	ldrb.w	r3, [r3, #660]	; 0x294
  40ceca:	60fb      	str	r3, [r7, #12]
		break;
  40cecc:	e013      	b.n	40cef6 <DynProtocol_getPrecision+0x152>
	case DYN_PRO_SENSOR_TYPE_GYROSCOPE:
	case DYN_PRO_SENSOR_TYPE_UNCAL_GYROSCOPE:
		QxIn = self->precision.gyro;
  40cece:	687b      	ldr	r3, [r7, #4]
  40ced0:	f893 3295 	ldrb.w	r3, [r3, #661]	; 0x295
  40ced4:	60fb      	str	r3, [r7, #12]
		break;
  40ced6:	e00e      	b.n	40cef6 <DynProtocol_getPrecision+0x152>
	case DYN_PRO_SENSOR_TYPE_MAGNETOMETER:
	case DYN_PRO_SENSOR_TYPE_UNCAL_MAGNETOMETER:
		QxIn = PROTOCOL_MAGNETOMETER_PRECISION;
  40ced8:	2304      	movs	r3, #4
  40ceda:	60fb      	str	r3, [r7, #12]
		break;
  40cedc:	e00b      	b.n	40cef6 <DynProtocol_getPrecision+0x152>
	case DYN_PRO_SENSOR_TYPE_ROTATION_VECTOR:
	case DYN_PRO_SENSOR_TYPE_GAME_ROTATION_VECTOR:
	case DYN_PRO_SENSOR_TYPE_PRED_QUAT_0:
	case DYN_PRO_SENSOR_TYPE_PRED_QUAT_1:
	case DYN_PRO_SENSOR_TYPE_GEOMAG_ROTATION_VECTOR:
		QxIn = PROTOCOL_QUATERNION_PRECISION;
  40cede:	230e      	movs	r3, #14
  40cee0:	60fb      	str	r3, [r7, #12]
		break;
  40cee2:	e008      	b.n	40cef6 <DynProtocol_getPrecision+0x152>
	case DYN_PRO_SENSOR_TYPE_ORIENTATION:
		QxIn = PROTOCOL_ORIENTATION_PRECISION;
  40cee4:	2306      	movs	r3, #6
  40cee6:	60fb      	str	r3, [r7, #12]
		break;
  40cee8:	e005      	b.n	40cef6 <DynProtocol_getPrecision+0x152>
	case DYN_PRO_SENSOR_TYPE_TEMPERATURE:
	case DYN_PRO_SENSOR_TYPE_AMBIENT_TEMPERATURE:
		QxIn = PROTOCOL_TEMPERATURE_PRECISION;
  40ceea:	2308      	movs	r3, #8
  40ceec:	60fb      	str	r3, [r7, #12]
		break;
  40ceee:	e002      	b.n	40cef6 <DynProtocol_getPrecision+0x152>
	default:
		QxIn = PROTOCOL_RAW_PRECISION;
  40cef0:	2300      	movs	r3, #0
  40cef2:	60fb      	str	r3, [r7, #12]
		break;
  40cef4:	bf00      	nop
	}

	return QxIn;
  40cef6:	68fb      	ldr	r3, [r7, #12]
}
  40cef8:	4618      	mov	r0, r3
  40cefa:	3714      	adds	r7, #20
  40cefc:	46bd      	mov	sp, r7
  40cefe:	f85d 7b04 	ldr.w	r7, [sp], #4
  40cf02:	4770      	bx	lr

0040cf04 <DynProtocol_getPayload>:

static int16_t DynProtocol_getPayload(DynProtocol_t * self)
{
  40cf04:	b580      	push	{r7, lr}
  40cf06:	b084      	sub	sp, #16
  40cf08:	af00      	add	r7, sp, #0
  40cf0a:	6078      	str	r0, [r7, #4]
	const uint8_t eventType = self->decode_state_machine.event_type;
  40cf0c:	687b      	ldr	r3, [r7, #4]
  40cf0e:	7b1b      	ldrb	r3, [r3, #12]
  40cf10:	73fb      	strb	r3, [r7, #15]
	const enum DynProtocolEid cmdId = (enum DynProtocolEid)self->decode_state_machine.cmd_id;
  40cf12:	687b      	ldr	r3, [r7, #4]
  40cf14:	7b9b      	ldrb	r3, [r3, #14]
  40cf16:	73bb      	strb	r3, [r7, #14]

	if(self->decode_state_machine.received_size == 0) {
  40cf18:	687b      	ldr	r3, [r7, #4]
  40cf1a:	8a5b      	ldrh	r3, [r3, #18]
  40cf1c:	2b00      	cmp	r3, #0
  40cf1e:	f040 8120 	bne.w	40d162 <DynProtocol_getPayload+0x25e>
		switch(eventType) {
  40cf22:	7bfb      	ldrb	r3, [r7, #15]
  40cf24:	2b40      	cmp	r3, #64	; 0x40
  40cf26:	f000 808e 	beq.w	40d046 <DynProtocol_getPayload+0x142>
  40cf2a:	2b80      	cmp	r3, #128	; 0x80
  40cf2c:	f000 8112 	beq.w	40d154 <DynProtocol_getPayload+0x250>
  40cf30:	2b00      	cmp	r3, #0
  40cf32:	d000      	beq.n	40cf36 <DynProtocol_getPayload+0x32>
				break;
			}
			break;

		default:
			break;
  40cf34:	e1f1      	b.n	40d31a <DynProtocol_getPayload+0x416>
			switch(cmdId) {
  40cf36:	7bbb      	ldrb	r3, [r7, #14]
  40cf38:	2b27      	cmp	r3, #39	; 0x27
  40cf3a:	f200 8082 	bhi.w	40d042 <DynProtocol_getPayload+0x13e>
  40cf3e:	a201      	add	r2, pc, #4	; (adr r2, 40cf44 <DynProtocol_getPayload+0x40>)
  40cf40:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
  40cf44:	0040cfe5 	.word	0x0040cfe5
  40cf48:	0040d043 	.word	0x0040d043
  40cf4c:	0040d043 	.word	0x0040d043
  40cf50:	0040d043 	.word	0x0040d043
  40cf54:	0040d043 	.word	0x0040d043
  40cf58:	0040d043 	.word	0x0040d043
  40cf5c:	0040d043 	.word	0x0040d043
  40cf60:	0040d043 	.word	0x0040d043
  40cf64:	0040d043 	.word	0x0040d043
  40cf68:	0040d043 	.word	0x0040d043
  40cf6c:	0040d043 	.word	0x0040d043
  40cf70:	0040d043 	.word	0x0040d043
  40cf74:	0040d043 	.word	0x0040d043
  40cf78:	0040d043 	.word	0x0040d043
  40cf7c:	0040d043 	.word	0x0040d043
  40cf80:	0040d043 	.word	0x0040d043
  40cf84:	0040cfed 	.word	0x0040cfed
  40cf88:	0040cff1 	.word	0x0040cff1
  40cf8c:	0040cff5 	.word	0x0040cff5
  40cf90:	0040cff9 	.word	0x0040cff9
  40cf94:	0040d043 	.word	0x0040d043
  40cf98:	0040cffd 	.word	0x0040cffd
  40cf9c:	0040cfe9 	.word	0x0040cfe9
  40cfa0:	0040d001 	.word	0x0040d001
  40cfa4:	0040d043 	.word	0x0040d043
  40cfa8:	0040d005 	.word	0x0040d005
  40cfac:	0040d009 	.word	0x0040d009
  40cfb0:	0040d00d 	.word	0x0040d00d
  40cfb4:	0040d011 	.word	0x0040d011
  40cfb8:	0040d015 	.word	0x0040d015
  40cfbc:	0040d02d 	.word	0x0040d02d
  40cfc0:	0040d031 	.word	0x0040d031
  40cfc4:	0040d019 	.word	0x0040d019
  40cfc8:	0040d01d 	.word	0x0040d01d
  40cfcc:	0040d021 	.word	0x0040d021
  40cfd0:	0040d025 	.word	0x0040d025
  40cfd4:	0040d029 	.word	0x0040d029
  40cfd8:	0040d035 	.word	0x0040d035
  40cfdc:	0040d039 	.word	0x0040d039
  40cfe0:	0040d03d 	.word	0x0040d03d
			case DYN_PROTOCOL_EID_PROTOCOLVERSION:    return 0;
  40cfe4:	2300      	movs	r3, #0
  40cfe6:	e19e      	b.n	40d326 <DynProtocol_getPayload+0x422>
			case DYN_PROTOCOL_EID_GET_FW_INFO:        return 0;
  40cfe8:	2300      	movs	r3, #0
  40cfea:	e19c      	b.n	40d326 <DynProtocol_getPayload+0x422>
			case DYN_PROTOCOL_EID_WHO_AM_I:           return 0;
  40cfec:	2300      	movs	r3, #0
  40cfee:	e19a      	b.n	40d326 <DynProtocol_getPayload+0x422>
			case DYN_PROTOCOL_EID_RESET:              return 0;
  40cff0:	2300      	movs	r3, #0
  40cff2:	e198      	b.n	40d326 <DynProtocol_getPayload+0x422>
			case DYN_PROTOCOL_EID_SETUP:              return 0;
  40cff4:	2300      	movs	r3, #0
  40cff6:	e196      	b.n	40d326 <DynProtocol_getPayload+0x422>
			case DYN_PROTOCOL_EID_CLEANUP:            return 0;
  40cff8:	2300      	movs	r3, #0
  40cffa:	e194      	b.n	40d326 <DynProtocol_getPayload+0x422>
			case DYN_PROTOCOL_EID_SELF_TEST:          return 1;
  40cffc:	2301      	movs	r3, #1
  40cffe:	e192      	b.n	40d326 <DynProtocol_getPayload+0x422>
			case DYN_PROTOCOL_EID_PING_SENSOR:        return 1;
  40d000:	2301      	movs	r3, #1
  40d002:	e190      	b.n	40d326 <DynProtocol_getPayload+0x422>
			case DYN_PROTOCOL_EID_START_SENSOR:       return 1;
  40d004:	2301      	movs	r3, #1
  40d006:	e18e      	b.n	40d326 <DynProtocol_getPayload+0x422>
			case DYN_PROTOCOL_EID_STOP_SENSOR:        return 1;
  40d008:	2301      	movs	r3, #1
  40d00a:	e18c      	b.n	40d326 <DynProtocol_getPayload+0x422>
			case DYN_PROTOCOL_EID_SET_SENSOR_PERIOD:  return 1 + 4;
  40d00c:	2305      	movs	r3, #5
  40d00e:	e18a      	b.n	40d326 <DynProtocol_getPayload+0x422>
			case DYN_PROTOCOL_EID_SET_SENSOR_TIMEOUT: return 1 + 4;
  40d010:	2305      	movs	r3, #5
  40d012:	e188      	b.n	40d326 <DynProtocol_getPayload+0x422>
			case DYN_PROTOCOL_EID_FLUSH_SENSOR:       return 1;
  40d014:	2301      	movs	r3, #1
  40d016:	e186      	b.n	40d326 <DynProtocol_getPayload+0x422>
			case DYN_PROTOCOL_EID_SET_SENSOR_MMATRIX: return 1 + 1 + (9 * 4); /* sensor + cfg_type + 3x3 q30 */
  40d018:	2326      	movs	r3, #38	; 0x26
  40d01a:	e184      	b.n	40d326 <DynProtocol_getPayload+0x422>
			case DYN_PROTOCOL_EID_GET_SENSOR_DATA:    return 1;
  40d01c:	2301      	movs	r3, #1
  40d01e:	e182      	b.n	40d326 <DynProtocol_getPayload+0x422>
			case DYN_PROTOCOL_EID_GET_SW_REG:         return 1 + 1;
  40d020:	2302      	movs	r3, #2
  40d022:	e180      	b.n	40d326 <DynProtocol_getPayload+0x422>
			case DYN_PROTOCOL_EID_SET_SENSOR_CFG:     return 1 + 1 + 1 + 64; // sensor + size + cfg_type + max_data_size
  40d024:	2343      	movs	r3, #67	; 0x43
  40d026:	e17e      	b.n	40d326 <DynProtocol_getPayload+0x422>
			case DYN_PROTOCOL_EID_GET_SENSOR_CFG:     return 1 + 1; // sensor + cfg_type
  40d028:	2302      	movs	r3, #2
  40d02a:	e17c      	b.n	40d326 <DynProtocol_getPayload+0x422>
			case DYN_PROTOCOL_EID_SET_SENSOR_BIAS:    return 1 + 1 + (3 * 2); /* sensor + cfg_type + bias (x,y,z) in Qx */
  40d02c:	2308      	movs	r3, #8
  40d02e:	e17a      	b.n	40d326 <DynProtocol_getPayload+0x422>
			case DYN_PROTOCOL_EID_GET_SENSOR_BIAS:    return 1 + 1; /* sensor + cfg_type */
  40d030:	2302      	movs	r3, #2
  40d032:	e178      	b.n	40d326 <DynProtocol_getPayload+0x422>
			case DYN_PROTOCOL_EID_WRITE_MEMS_REG:     return 1 + 1 + 1; /* sensor + reg_addr + reg_value */
  40d034:	2303      	movs	r3, #3
  40d036:	e176      	b.n	40d326 <DynProtocol_getPayload+0x422>
			case DYN_PROTOCOL_EID_READ_MEMS_REG:      return 1 + 1; /* sensor + reg_addr */
  40d038:	2302      	movs	r3, #2
  40d03a:	e174      	b.n	40d326 <DynProtocol_getPayload+0x422>
			case DYN_PROTOCOL_EID_TRANSFER_BUFFER:    return 2 + 512; /* payload size + actual payload */
  40d03c:	f240 2302 	movw	r3, #514	; 0x202
  40d040:	e171      	b.n	40d326 <DynProtocol_getPayload+0x422>
				break;
  40d042:	bf00      	nop
			break;
  40d044:	e169      	b.n	40d31a <DynProtocol_getPayload+0x416>
			switch(cmdId) {
  40d046:	7bbb      	ldrb	r3, [r7, #14]
  40d048:	2b27      	cmp	r3, #39	; 0x27
  40d04a:	f200 8081 	bhi.w	40d150 <DynProtocol_getPayload+0x24c>
  40d04e:	a201      	add	r2, pc, #4	; (adr r2, 40d054 <DynProtocol_getPayload+0x150>)
  40d050:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
  40d054:	0040d0f5 	.word	0x0040d0f5
  40d058:	0040d151 	.word	0x0040d151
  40d05c:	0040d151 	.word	0x0040d151
  40d060:	0040d151 	.word	0x0040d151
  40d064:	0040d151 	.word	0x0040d151
  40d068:	0040d151 	.word	0x0040d151
  40d06c:	0040d151 	.word	0x0040d151
  40d070:	0040d151 	.word	0x0040d151
  40d074:	0040d151 	.word	0x0040d151
  40d078:	0040d151 	.word	0x0040d151
  40d07c:	0040d151 	.word	0x0040d151
  40d080:	0040d151 	.word	0x0040d151
  40d084:	0040d151 	.word	0x0040d151
  40d088:	0040d151 	.word	0x0040d151
  40d08c:	0040d151 	.word	0x0040d151
  40d090:	0040d151 	.word	0x0040d151
  40d094:	0040d0fd 	.word	0x0040d0fd
  40d098:	0040d101 	.word	0x0040d101
  40d09c:	0040d105 	.word	0x0040d105
  40d0a0:	0040d109 	.word	0x0040d109
  40d0a4:	0040d151 	.word	0x0040d151
  40d0a8:	0040d10d 	.word	0x0040d10d
  40d0ac:	0040d0f9 	.word	0x0040d0f9
  40d0b0:	0040d111 	.word	0x0040d111
  40d0b4:	0040d151 	.word	0x0040d151
  40d0b8:	0040d115 	.word	0x0040d115
  40d0bc:	0040d119 	.word	0x0040d119
  40d0c0:	0040d11d 	.word	0x0040d11d
  40d0c4:	0040d121 	.word	0x0040d121
  40d0c8:	0040d125 	.word	0x0040d125
  40d0cc:	0040d13d 	.word	0x0040d13d
  40d0d0:	0040d141 	.word	0x0040d141
  40d0d4:	0040d129 	.word	0x0040d129
  40d0d8:	0040d12d 	.word	0x0040d12d
  40d0dc:	0040d131 	.word	0x0040d131
  40d0e0:	0040d135 	.word	0x0040d135
  40d0e4:	0040d139 	.word	0x0040d139
  40d0e8:	0040d145 	.word	0x0040d145
  40d0ec:	0040d149 	.word	0x0040d149
  40d0f0:	0040d14d 	.word	0x0040d14d
			case DYN_PROTOCOL_EID_PROTOCOLVERSION:    return 16;
  40d0f4:	2310      	movs	r3, #16
  40d0f6:	e116      	b.n	40d326 <DynProtocol_getPayload+0x422>
			case DYN_PROTOCOL_EID_GET_FW_INFO:        return 16;
  40d0f8:	2310      	movs	r3, #16
  40d0fa:	e114      	b.n	40d326 <DynProtocol_getPayload+0x422>
			case DYN_PROTOCOL_EID_WHO_AM_I:           return 1;
  40d0fc:	2301      	movs	r3, #1
  40d0fe:	e112      	b.n	40d326 <DynProtocol_getPayload+0x422>
			case DYN_PROTOCOL_EID_RESET:              return 1;
  40d100:	2301      	movs	r3, #1
  40d102:	e110      	b.n	40d326 <DynProtocol_getPayload+0x422>
			case DYN_PROTOCOL_EID_SETUP:              return 1;
  40d104:	2301      	movs	r3, #1
  40d106:	e10e      	b.n	40d326 <DynProtocol_getPayload+0x422>
			case DYN_PROTOCOL_EID_CLEANUP:            return 1;
  40d108:	2301      	movs	r3, #1
  40d10a:	e10c      	b.n	40d326 <DynProtocol_getPayload+0x422>
			case DYN_PROTOCOL_EID_SELF_TEST:          return 1;
  40d10c:	2301      	movs	r3, #1
  40d10e:	e10a      	b.n	40d326 <DynProtocol_getPayload+0x422>
			case DYN_PROTOCOL_EID_PING_SENSOR:        return 1;
  40d110:	2301      	movs	r3, #1
  40d112:	e108      	b.n	40d326 <DynProtocol_getPayload+0x422>
			case DYN_PROTOCOL_EID_START_SENSOR:       return 1;
  40d114:	2301      	movs	r3, #1
  40d116:	e106      	b.n	40d326 <DynProtocol_getPayload+0x422>
			case DYN_PROTOCOL_EID_STOP_SENSOR:        return 1;
  40d118:	2301      	movs	r3, #1
  40d11a:	e104      	b.n	40d326 <DynProtocol_getPayload+0x422>
			case DYN_PROTOCOL_EID_SET_SENSOR_PERIOD:  return 1;
  40d11c:	2301      	movs	r3, #1
  40d11e:	e102      	b.n	40d326 <DynProtocol_getPayload+0x422>
			case DYN_PROTOCOL_EID_SET_SENSOR_TIMEOUT: return 1;
  40d120:	2301      	movs	r3, #1
  40d122:	e100      	b.n	40d326 <DynProtocol_getPayload+0x422>
			case DYN_PROTOCOL_EID_FLUSH_SENSOR:       return 1;
  40d124:	2301      	movs	r3, #1
  40d126:	e0fe      	b.n	40d326 <DynProtocol_getPayload+0x422>
			case DYN_PROTOCOL_EID_SET_SENSOR_MMATRIX: return 1;
  40d128:	2301      	movs	r3, #1
  40d12a:	e0fc      	b.n	40d326 <DynProtocol_getPayload+0x422>
			case DYN_PROTOCOL_EID_GET_SENSOR_DATA:    return 1+1+1+4+64; // rc + sensorStatus + sensorId + timestamp[0-3] + max_data_size
  40d12c:	2347      	movs	r3, #71	; 0x47
  40d12e:	e0fa      	b.n	40d326 <DynProtocol_getPayload+0x422>
			case DYN_PROTOCOL_EID_GET_SW_REG:         return 1;
  40d130:	2301      	movs	r3, #1
  40d132:	e0f8      	b.n	40d326 <DynProtocol_getPayload+0x422>
			case DYN_PROTOCOL_EID_SET_SENSOR_CFG:     return 1;
  40d134:	2301      	movs	r3, #1
  40d136:	e0f6      	b.n	40d326 <DynProtocol_getPayload+0x422>
			case DYN_PROTOCOL_EID_GET_SENSOR_CFG:     return 1+1+1+1+64; // rc + sensor + size + cfg_type + max_data_size
  40d138:	2344      	movs	r3, #68	; 0x44
  40d13a:	e0f4      	b.n	40d326 <DynProtocol_getPayload+0x422>
			case DYN_PROTOCOL_EID_SET_SENSOR_BIAS:    return 1; /* rc */
  40d13c:	2301      	movs	r3, #1
  40d13e:	e0f2      	b.n	40d326 <DynProtocol_getPayload+0x422>
			case DYN_PROTOCOL_EID_GET_SENSOR_BIAS:    return 1 + 1 + 1 + (3 * 2); /* rc + precision + cfg_type + bias (x,y,z) in Qx */
  40d140:	2309      	movs	r3, #9
  40d142:	e0f0      	b.n	40d326 <DynProtocol_getPayload+0x422>
			case DYN_PROTOCOL_EID_WRITE_MEMS_REG:     return 1;
  40d144:	2301      	movs	r3, #1
  40d146:	e0ee      	b.n	40d326 <DynProtocol_getPayload+0x422>
			case DYN_PROTOCOL_EID_READ_MEMS_REG:      return 1 + 1; // rc + reg_value
  40d148:	2302      	movs	r3, #2
  40d14a:	e0ec      	b.n	40d326 <DynProtocol_getPayload+0x422>
			case DYN_PROTOCOL_EID_TRANSFER_BUFFER:    return 1; // rc
  40d14c:	2301      	movs	r3, #1
  40d14e:	e0ea      	b.n	40d326 <DynProtocol_getPayload+0x422>
				break;
  40d150:	bf00      	nop
			break;
  40d152:	e0e2      	b.n	40d31a <DynProtocol_getPayload+0x416>
			switch(cmdId) {
  40d154:	7bbb      	ldrb	r3, [r7, #14]
  40d156:	2b30      	cmp	r3, #48	; 0x30
  40d158:	d001      	beq.n	40d15e <DynProtocol_getPayload+0x25a>
				break;
  40d15a:	bf00      	nop
			break;
  40d15c:	e0dd      	b.n	40d31a <DynProtocol_getPayload+0x416>
				return 2;
  40d15e:	2302      	movs	r3, #2
  40d160:	e0e1      	b.n	40d326 <DynProtocol_getPayload+0x422>
		/* Payload content : 
		 *   - byte 0 <sensor status> 
		 *   - byte 1 <sensor id> 
		 *   - <sensor data> 
		 */
		const uint8_t sensor_id = self->decode_state_machine.tmp_buffer[1];
  40d162:	687b      	ldr	r3, [r7, #4]
  40d164:	7d5b      	ldrb	r3, [r3, #21]
  40d166:	737b      	strb	r3, [r7, #13]

		switch(eventType) {
  40d168:	7bfb      	ldrb	r3, [r7, #15]
  40d16a:	2b80      	cmp	r3, #128	; 0x80
  40d16c:	f040 80d1 	bne.w	40d312 <DynProtocol_getPayload+0x40e>
		case EVENT_TYPE_ASYNC:
			switch(sensor_id) {
  40d170:	7b7b      	ldrb	r3, [r7, #13]
  40d172:	2b45      	cmp	r3, #69	; 0x45
  40d174:	f200 80ca 	bhi.w	40d30c <DynProtocol_getPayload+0x408>
  40d178:	a201      	add	r2, pc, #4	; (adr r2, 40d180 <DynProtocol_getPayload+0x27c>)
  40d17a:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
  40d17e:	bf00      	nop
  40d180:	0040d299 	.word	0x0040d299
  40d184:	0040d2dd 	.word	0x0040d2dd
  40d188:	0040d2dd 	.word	0x0040d2dd
  40d18c:	0040d2d9 	.word	0x0040d2d9
  40d190:	0040d2dd 	.word	0x0040d2dd
  40d194:	0040d2ed 	.word	0x0040d2ed
  40d198:	0040d2ed 	.word	0x0040d2ed
  40d19c:	0040d2b5 	.word	0x0040d2b5
  40d1a0:	0040d2f9 	.word	0x0040d2f9
  40d1a4:	0040d2d9 	.word	0x0040d2d9
  40d1a8:	0040d2d9 	.word	0x0040d2d9
  40d1ac:	0040d2e9 	.word	0x0040d2e9
  40d1b0:	0040d30d 	.word	0x0040d30d
  40d1b4:	0040d2b5 	.word	0x0040d2b5
  40d1b8:	0040d2e1 	.word	0x0040d2e1
  40d1bc:	0040d2e5 	.word	0x0040d2e5
  40d1c0:	0040d2e1 	.word	0x0040d2e1
  40d1c4:	0040d2ed 	.word	0x0040d2ed
  40d1c8:	0040d2ed 	.word	0x0040d2ed
  40d1cc:	0040d2f5 	.word	0x0040d2f5
  40d1d0:	0040d2e9 	.word	0x0040d2e9
  40d1d4:	0040d301 	.word	0x0040d301
  40d1d8:	0040d2ed 	.word	0x0040d2ed
  40d1dc:	0040d2ed 	.word	0x0040d2ed
  40d1e0:	0040d2ed 	.word	0x0040d2ed
  40d1e4:	0040d2ed 	.word	0x0040d2ed
  40d1e8:	0040d2f1 	.word	0x0040d2f1
  40d1ec:	0040d30d 	.word	0x0040d30d
  40d1f0:	0040d2ed 	.word	0x0040d2ed
  40d1f4:	0040d2e5 	.word	0x0040d2e5
  40d1f8:	0040d2b1 	.word	0x0040d2b1
  40d1fc:	0040d2a9 	.word	0x0040d2a9
  40d200:	0040d2a9 	.word	0x0040d2a9
  40d204:	0040d2a9 	.word	0x0040d2a9
  40d208:	0040d2a9 	.word	0x0040d2a9
  40d20c:	0040d2b9 	.word	0x0040d2b9
  40d210:	0040d2a1 	.word	0x0040d2a1
  40d214:	0040d30d 	.word	0x0040d30d
  40d218:	0040d30d 	.word	0x0040d30d
  40d21c:	0040d2bd 	.word	0x0040d2bd
  40d220:	0040d305 	.word	0x0040d305
  40d224:	0040d2c9 	.word	0x0040d2c9
  40d228:	0040d2cd 	.word	0x0040d2cd
  40d22c:	0040d2d1 	.word	0x0040d2d1
  40d230:	0040d2d5 	.word	0x0040d2d5
  40d234:	0040d2c1 	.word	0x0040d2c1
  40d238:	0040d2c5 	.word	0x0040d2c5
  40d23c:	0040d2ed 	.word	0x0040d2ed
  40d240:	0040d2ed 	.word	0x0040d2ed
  40d244:	0040d2fd 	.word	0x0040d2fd
  40d248:	0040d2fd 	.word	0x0040d2fd
  40d24c:	0040d2fd 	.word	0x0040d2fd
  40d250:	0040d2fd 	.word	0x0040d2fd
  40d254:	0040d2fd 	.word	0x0040d2fd
  40d258:	0040d2fd 	.word	0x0040d2fd
  40d25c:	0040d2fd 	.word	0x0040d2fd
  40d260:	0040d2fd 	.word	0x0040d2fd
  40d264:	0040d2f1 	.word	0x0040d2f1
  40d268:	0040d2ed 	.word	0x0040d2ed
  40d26c:	0040d309 	.word	0x0040d309
  40d270:	0040d2ad 	.word	0x0040d2ad
  40d274:	0040d2a5 	.word	0x0040d2a5
  40d278:	0040d30d 	.word	0x0040d30d
  40d27c:	0040d30d 	.word	0x0040d30d
  40d280:	0040d2e5 	.word	0x0040d2e5
  40d284:	0040d2e5 	.word	0x0040d2e5
  40d288:	0040d2a9 	.word	0x0040d2a9
  40d28c:	0040d2ed 	.word	0x0040d2ed
  40d290:	0040d2ed 	.word	0x0040d2ed
  40d294:	0040d2f1 	.word	0x0040d2f1
			case DYN_PRO_SENSOR_TYPE_RESERVED:
				return self->decode_state_machine.received_size;
  40d298:	687b      	ldr	r3, [r7, #4]
  40d29a:	8a5b      	ldrh	r3, [r3, #18]
  40d29c:	b21b      	sxth	r3, r3
  40d29e:	e042      	b.n	40d326 <DynProtocol_getPayload+0x422>
			case DYN_PRO_SENSOR_TYPE_CUSTOM_PRESSURE:
				return 1+1+4+16;
  40d2a0:	2316      	movs	r3, #22
  40d2a2:	e040      	b.n	40d326 <DynProtocol_getPayload+0x422>
			case DYN_PRO_SENSOR_TYPE_HIGH_RATE_GYRO:
				return 1+1+6;
  40d2a4:	2308      	movs	r3, #8
  40d2a6:	e03e      	b.n	40d326 <DynProtocol_getPayload+0x422>
			case DYN_PRO_SENSOR_TYPE_RAW_ACCELEROMETER:
			case DYN_PRO_SENSOR_TYPE_RAW_MAGNETOMETER:
			case DYN_PRO_SENSOR_TYPE_RAW_GYROSCOPE:
			case DYN_PRO_SENSOR_TYPE_OIS:
			case DYN_PRO_SENSOR_TYPE_OIS_1:
				return 1+1+4+6;
  40d2a8:	230c      	movs	r3, #12
  40d2aa:	e03c      	b.n	40d326 <DynProtocol_getPayload+0x422>
			case DYN_PRO_SENSOR_TYPE_FSYNC_EVENT:
				return 1+1+4+2;
  40d2ac:	2308      	movs	r3, #8
  40d2ae:	e03a      	b.n	40d326 <DynProtocol_getPayload+0x422>
			case DYN_PRO_SENSOR_TYPE_EIS:
				return 1+1+4+6+6+2;
  40d2b0:	2314      	movs	r3, #20
  40d2b2:	e038      	b.n	40d326 <DynProtocol_getPayload+0x422>
			case DYN_PRO_SENSOR_TYPE_TEMPERATURE:
			case DYN_PRO_SENSOR_TYPE_AMBIENT_TEMPERATURE:
				return 1+1+4+2;
  40d2b4:	2308      	movs	r3, #8
  40d2b6:	e036      	b.n	40d326 <DynProtocol_getPayload+0x422>
			case DYN_PRO_SENSOR_TYPE_RAW_TEMPERATURE:
				return 1+1+4+4;
  40d2b8:	230a      	movs	r3, #10
  40d2ba:	e034      	b.n	40d326 <DynProtocol_getPayload+0x422>
			case DYN_PRO_SENSOR_TYPE_RAW_PPG:
				return 1+1+4+4+1;
  40d2bc:	230b      	movs	r3, #11
  40d2be:	e032      	b.n	40d326 <DynProtocol_getPayload+0x422>
			case DYN_PRO_SENSOR_TYPE_ENERGY_EXPENDITURE:
				return 1+1+4+16;
  40d2c0:	2316      	movs	r3, #22
  40d2c2:	e030      	b.n	40d326 <DynProtocol_getPayload+0x422>
			case DYN_PRO_SENSOR_TYPE_DISTANCE:
				return 1+1+4+8;
  40d2c4:	230e      	movs	r3, #14
  40d2c6:	e02e      	b.n	40d326 <DynProtocol_getPayload+0x422>
			case DYN_PRO_SENSOR_TYPE_SLEEP_ANALYSIS: 
				return 1+1+4+25;
  40d2c8:	231f      	movs	r3, #31
  40d2ca:	e02c      	b.n	40d326 <DynProtocol_getPayload+0x422>
			case DYN_PRO_SENSOR_TYPE_BAC_EXTENDED:
				return 1+1+4+4;
  40d2cc:	230a      	movs	r3, #10
  40d2ce:	e02a      	b.n	40d326 <DynProtocol_getPayload+0x422>
			case DYN_PRO_SENSOR_TYPE_BAC_STATISTICS:
				return 1+1+4+44;
  40d2d0:	2332      	movs	r3, #50	; 0x32
  40d2d2:	e028      	b.n	40d326 <DynProtocol_getPayload+0x422>
			case DYN_PRO_SENSOR_TYPE_FLOOR_CLIMB_COUNTER:
				return 1+1+4+8;
  40d2d4:	230e      	movs	r3, #14
  40d2d6:	e026      	b.n	40d326 <DynProtocol_getPayload+0x422>
			case DYN_PRO_SENSOR_TYPE_LINEAR_ACCELERATION:
			case DYN_PRO_SENSOR_TYPE_GRAVITY:
			case DYN_PRO_SENSOR_TYPE_ORIENTATION:
				return 1+1+4+6+1;
  40d2d8:	230d      	movs	r3, #13
  40d2da:	e024      	b.n	40d326 <DynProtocol_getPayload+0x422>
			case DYN_PRO_SENSOR_TYPE_ACCELEROMETER:
			case DYN_PRO_SENSOR_TYPE_GYROSCOPE:
			case DYN_PRO_SENSOR_TYPE_MAGNETOMETER:
				return 1+1+4+6+1;
  40d2dc:	230d      	movs	r3, #13
  40d2de:	e022      	b.n	40d326 <DynProtocol_getPayload+0x422>
			case DYN_PRO_SENSOR_TYPE_UNCAL_MAGNETOMETER:
			case DYN_PRO_SENSOR_TYPE_UNCAL_GYROSCOPE:
				return 1+1+4+12+1;
  40d2e0:	2313      	movs	r3, #19
  40d2e2:	e020      	b.n	40d326 <DynProtocol_getPayload+0x422>
			case DYN_PRO_SENSOR_TYPE_PRED_QUAT_0:
			case DYN_PRO_SENSOR_TYPE_PRED_QUAT_1:
			
			case DYN_PRO_SENSOR_TYPE_3AXIS:
			case DYN_PRO_SENSOR_TYPE_GAME_ROTATION_VECTOR:
				return 1+1+4+8+1;
  40d2e4:	230f      	movs	r3, #15
  40d2e6:	e01e      	b.n	40d326 <DynProtocol_getPayload+0x422>
			case DYN_PRO_SENSOR_TYPE_ROTATION_VECTOR:
			case DYN_PRO_SENSOR_TYPE_GEOMAG_ROTATION_VECTOR:
				return 1+1+4+10+1;
  40d2e8:	2311      	movs	r3, #17
  40d2ea:	e01c      	b.n	40d326 <DynProtocol_getPayload+0x422>
			case DYN_PRO_SENSOR_TYPE_PICK_UP_GESTURE:
			case DYN_PRO_SENSOR_TYPE_PRESSURE:
			case DYN_PRO_SENSOR_TYPE_LIGHT:
			case DYN_PRO_SENSOR_TYPE_LOW_G:
			case DYN_PRO_SENSOR_TYPE_HIGH_G:
				return 1+1+4+4;
  40d2ec:	230a      	movs	r3, #10
  40d2ee:	e01a      	b.n	40d326 <DynProtocol_getPayload+0x422>
			case DYN_PRO_SENSOR_TYPE_WOM:
			case DYN_PRO_SENSOR_TYPE_BAC:
			case DYN_PRO_SENSOR_TYPE_TAP:
				return 1+1+4+1+4;
  40d2f0:	230b      	movs	r3, #11
  40d2f2:	e018      	b.n	40d326 <DynProtocol_getPayload+0x422>
			case DYN_PRO_SENSOR_TYPE_STEP_COUNTER:
				return 1+1+4+4+4;
  40d2f4:	230e      	movs	r3, #14
  40d2f6:	e016      	b.n	40d326 <DynProtocol_getPayload+0x422>
			case DYN_PRO_SENSOR_TYPE_PROXIMITY:
				return 1+1+4+2;
  40d2f8:	2308      	movs	r3, #8
  40d2fa:	e014      	b.n	40d326 <DynProtocol_getPayload+0x422>
			case DYN_PRO_SENSOR_TYPE_CUSTOM3:
			case DYN_PRO_SENSOR_TYPE_CUSTOM4:
			case DYN_PRO_SENSOR_TYPE_CUSTOM5:
			case DYN_PRO_SENSOR_TYPE_CUSTOM6:
			case DYN_PRO_SENSOR_TYPE_CUSTOM7:
				return 1+1+4+65;
  40d2fc:	2347      	movs	r3, #71	; 0x47
  40d2fe:	e012      	b.n	40d326 <DynProtocol_getPayload+0x422>
			case DYN_PRO_SENSOR_TYPE_HEART_RATE:
				return 1+1+4+2+1+1;
  40d300:	230a      	movs	r3, #10
  40d302:	e010      	b.n	40d326 <DynProtocol_getPayload+0x422>
			case DYN_PRO_SENSOR_TYPE_HRV:
				return 1+1+4+1+1+(2*4);
  40d304:	2310      	movs	r3, #16
  40d306:	e00e      	b.n	40d326 <DynProtocol_getPayload+0x422>
			case DYN_PRO_SENSOR_TYPE_DATA_ENCRYPTION:
				return 1+1+4+(7*4);
  40d308:	2322      	movs	r3, #34	; 0x22
  40d30a:	e00c      	b.n	40d326 <DynProtocol_getPayload+0x422>

			default:
				/* undefined for now */
				return -1;
  40d30c:	f04f 33ff 	mov.w	r3, #4294967295
  40d310:	e009      	b.n	40d326 <DynProtocol_getPayload+0x422>
			}

		default:
			/* do not need to update expected payload */
			return self->decode_state_machine.expected_size;
  40d312:	687b      	ldr	r3, [r7, #4]
  40d314:	8a1b      	ldrh	r3, [r3, #16]
  40d316:	b21b      	sxth	r3, r3
  40d318:	e005      	b.n	40d326 <DynProtocol_getPayload+0x422>
		}
	}

	INV_MSG(INV_MSG_LEVEL_WARNING, "DynProtocol: returned payload is -1");
  40d31a:	4905      	ldr	r1, [pc, #20]	; (40d330 <DynProtocol_getPayload+0x42c>)
  40d31c:	2002      	movs	r0, #2
  40d31e:	4b05      	ldr	r3, [pc, #20]	; (40d334 <DynProtocol_getPayload+0x430>)
  40d320:	4798      	blx	r3

	return -1;
  40d322:	f04f 33ff 	mov.w	r3, #4294967295
}
  40d326:	4618      	mov	r0, r3
  40d328:	3710      	adds	r7, #16
  40d32a:	46bd      	mov	sp, r7
  40d32c:	bd80      	pop	{r7, pc}
  40d32e:	bf00      	nop
  40d330:	0041ca54 	.word	0x0041ca54
  40d334:	0040fd19 	.word	0x0040fd19

0040d338 <DynProtocol_decodeSensorEvent>:

static int DynProtocol_decodeSensorEvent(DynProtocol_t * self, const uint8_t * buffer, uint16_t size,
		DynProtocolEdata_t *edata, enum DynProtocolEtype etype)
{
  40d338:	b590      	push	{r4, r7, lr}
  40d33a:	b08b      	sub	sp, #44	; 0x2c
  40d33c:	af02      	add	r7, sp, #8
  40d33e:	60f8      	str	r0, [r7, #12]
  40d340:	60b9      	str	r1, [r7, #8]
  40d342:	603b      	str	r3, [r7, #0]
  40d344:	4613      	mov	r3, r2
  40d346:	80fb      	strh	r3, [r7, #6]
	uint16_t idx = 0, i=0;
  40d348:	2300      	movs	r3, #0
  40d34a:	83fb      	strh	r3, [r7, #30]
  40d34c:	2300      	movs	r3, #0
  40d34e:	83bb      	strh	r3, [r7, #28]
	uint32_t *sensorStatus;
	VSensorDataAny *vSensordata;

	switch(etype) {
  40d350:	f897 3030 	ldrb.w	r3, [r7, #48]	; 0x30
  40d354:	2b01      	cmp	r3, #1
  40d356:	d002      	beq.n	40d35e <DynProtocol_decodeSensorEvent+0x26>
  40d358:	2b02      	cmp	r3, #2
  40d35a:	d007      	beq.n	40d36c <DynProtocol_decodeSensorEvent+0x34>
  40d35c:	e00d      	b.n	40d37a <DynProtocol_decodeSensorEvent+0x42>
	case DYN_PROTOCOL_ETYPE_RESP:
		sensorStatus = &edata->d.response.sensorData.status;
  40d35e:	683b      	ldr	r3, [r7, #0]
  40d360:	3308      	adds	r3, #8
  40d362:	61bb      	str	r3, [r7, #24]
		vSensordata = &edata->d.response.sensorData.vdata;
  40d364:	683b      	ldr	r3, [r7, #0]
  40d366:	330c      	adds	r3, #12
  40d368:	617b      	str	r3, [r7, #20]
		break;
  40d36a:	e00a      	b.n	40d382 <DynProtocol_decodeSensorEvent+0x4a>
	case DYN_PROTOCOL_ETYPE_ASYNC:
		sensorStatus = &edata->d.async.sensorEvent.status;
  40d36c:	683b      	ldr	r3, [r7, #0]
  40d36e:	3304      	adds	r3, #4
  40d370:	61bb      	str	r3, [r7, #24]
		vSensordata = &edata->d.async.sensorEvent.vdata;
  40d372:	683b      	ldr	r3, [r7, #0]
  40d374:	3308      	adds	r3, #8
  40d376:	617b      	str	r3, [r7, #20]
		break;
  40d378:	e003      	b.n	40d382 <DynProtocol_decodeSensorEvent+0x4a>
	case DYN_PROTOCOL_ETYPE_CMD:
	default:
		return INV_ERROR_BAD_ARG;
  40d37a:	f06f 030a 	mvn.w	r3, #10
  40d37e:	f000 bccc 	b.w	40dd1a <DynProtocol_decodeSensorEvent+0x9e2>
	}

	memset(vSensordata, 0, sizeof(VSensorDataAny));
  40d382:	2248      	movs	r2, #72	; 0x48
  40d384:	2100      	movs	r1, #0
  40d386:	6978      	ldr	r0, [r7, #20]
  40d388:	4bb5      	ldr	r3, [pc, #724]	; (40d660 <DynProtocol_decodeSensorEvent+0x328>)
  40d38a:	4798      	blx	r3

	*sensorStatus    = (uint32_t)(buffer[idx] & 0x03);
  40d38c:	8bfb      	ldrh	r3, [r7, #30]
  40d38e:	68ba      	ldr	r2, [r7, #8]
  40d390:	4413      	add	r3, r2
  40d392:	781b      	ldrb	r3, [r3, #0]
  40d394:	f003 0203 	and.w	r2, r3, #3
  40d398:	69bb      	ldr	r3, [r7, #24]
  40d39a:	601a      	str	r2, [r3, #0]
	idx += 1;
  40d39c:	8bfb      	ldrh	r3, [r7, #30]
  40d39e:	3301      	adds	r3, #1
  40d3a0:	83fb      	strh	r3, [r7, #30]
	edata->sensor_id = (int)(buffer[idx]);
  40d3a2:	8bfb      	ldrh	r3, [r7, #30]
  40d3a4:	68ba      	ldr	r2, [r7, #8]
  40d3a6:	4413      	add	r3, r2
  40d3a8:	781b      	ldrb	r3, [r3, #0]
  40d3aa:	461a      	mov	r2, r3
  40d3ac:	683b      	ldr	r3, [r7, #0]
  40d3ae:	601a      	str	r2, [r3, #0]
	idx += 1;
  40d3b0:	8bfb      	ldrh	r3, [r7, #30]
  40d3b2:	3301      	adds	r3, #1
  40d3b4:	83fb      	strh	r3, [r7, #30]

	vSensordata->base.timestamp = (uint32_t)inv_dc_little8_to_int32(&buffer[idx]);
  40d3b6:	8bfb      	ldrh	r3, [r7, #30]
  40d3b8:	68ba      	ldr	r2, [r7, #8]
  40d3ba:	4413      	add	r3, r2
  40d3bc:	4618      	mov	r0, r3
  40d3be:	4ba9      	ldr	r3, [pc, #676]	; (40d664 <DynProtocol_decodeSensorEvent+0x32c>)
  40d3c0:	4798      	blx	r3
  40d3c2:	4603      	mov	r3, r0
  40d3c4:	461a      	mov	r2, r3
  40d3c6:	697b      	ldr	r3, [r7, #20]
  40d3c8:	601a      	str	r2, [r3, #0]
	idx += 4;
  40d3ca:	8bfb      	ldrh	r3, [r7, #30]
  40d3cc:	3304      	adds	r3, #4
  40d3ce:	83fb      	strh	r3, [r7, #30]

	switch(edata->sensor_id) {
  40d3d0:	683b      	ldr	r3, [r7, #0]
  40d3d2:	681b      	ldr	r3, [r3, #0]
  40d3d4:	2b45      	cmp	r3, #69	; 0x45
  40d3d6:	f200 8494 	bhi.w	40dd02 <DynProtocol_decodeSensorEvent+0x9ca>
  40d3da:	a201      	add	r2, pc, #4	; (adr r2, 40d3e0 <DynProtocol_decodeSensorEvent+0xa8>)
  40d3dc:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
  40d3e0:	0040dd09 	.word	0x0040dd09
  40d3e4:	0040d4f9 	.word	0x0040d4f9
  40d3e8:	0040d535 	.word	0x0040d535
  40d3ec:	0040dad7 	.word	0x0040dad7
  40d3f0:	0040d5c1 	.word	0x0040d5c1
  40d3f4:	0040db0d 	.word	0x0040db0d
  40d3f8:	0040dac1 	.word	0x0040dac1
  40d3fc:	0040d789 	.word	0x0040d789
  40d400:	0040db2d 	.word	0x0040db2d
  40d404:	0040d4f9 	.word	0x0040d4f9
  40d408:	0040d4f9 	.word	0x0040d4f9
  40d40c:	0040d6a3 	.word	0x0040d6a3
  40d410:	0040dd03 	.word	0x0040dd03
  40d414:	0040d789 	.word	0x0040d789
  40d418:	0040d56b 	.word	0x0040d56b
  40d41c:	0040d66d 	.word	0x0040d66d
  40d420:	0040d5fd 	.word	0x0040d5fd
  40d424:	0040daab 	.word	0x0040daab
  40d428:	0040daab 	.word	0x0040daab
  40d42c:	0040da57 	.word	0x0040da57
  40d430:	0040d6a3 	.word	0x0040d6a3
  40d434:	0040dc2f 	.word	0x0040dc2f
  40d438:	0040daab 	.word	0x0040daab
  40d43c:	0040daab 	.word	0x0040daab
  40d440:	0040daab 	.word	0x0040daab
  40d444:	0040daab 	.word	0x0040daab
  40d448:	0040da83 	.word	0x0040da83
  40d44c:	0040dd03 	.word	0x0040dd03
  40d450:	0040daab 	.word	0x0040daab
  40d454:	0040d66d 	.word	0x0040d66d
  40d458:	0040db59 	.word	0x0040db59
  40d45c:	0040d747 	.word	0x0040d747
  40d460:	0040d747 	.word	0x0040d747
  40d464:	0040d747 	.word	0x0040d747
  40d468:	0040d747 	.word	0x0040d747
  40d46c:	0040d7a1 	.word	0x0040d7a1
  40d470:	0040dbfb 	.word	0x0040dbfb
  40d474:	0040dd03 	.word	0x0040dd03
  40d478:	0040dd03 	.word	0x0040dd03
  40d47c:	0040d7b7 	.word	0x0040d7b7
  40d480:	0040dc75 	.word	0x0040dc75
  40d484:	0040d86d 	.word	0x0040d86d
  40d488:	0040d923 	.word	0x0040d923
  40d48c:	0040d939 	.word	0x0040d939
  40d490:	0040da2b 	.word	0x0040da2b
  40d494:	0040d7db 	.word	0x0040d7db
  40d498:	0040d833 	.word	0x0040d833
  40d49c:	0040daab 	.word	0x0040daab
  40d4a0:	0040daab 	.word	0x0040daab
  40d4a4:	0040dbbb 	.word	0x0040dbbb
  40d4a8:	0040dbbb 	.word	0x0040dbbb
  40d4ac:	0040dbbb 	.word	0x0040dbbb
  40d4b0:	0040dbbb 	.word	0x0040dbbb
  40d4b4:	0040dbbb 	.word	0x0040dbbb
  40d4b8:	0040dbbb 	.word	0x0040dbbb
  40d4bc:	0040dbbb 	.word	0x0040dbbb
  40d4c0:	0040dbbb 	.word	0x0040dbbb
  40d4c4:	0040da83 	.word	0x0040da83
  40d4c8:	0040daab 	.word	0x0040daab
  40d4cc:	0040dccf 	.word	0x0040dccf
  40d4d0:	0040db43 	.word	0x0040db43
  40d4d4:	0040d6f9 	.word	0x0040d6f9
  40d4d8:	0040dd03 	.word	0x0040dd03
  40d4dc:	0040dd03 	.word	0x0040dd03
  40d4e0:	0040d66d 	.word	0x0040d66d
  40d4e4:	0040d66d 	.word	0x0040d66d
  40d4e8:	0040d747 	.word	0x0040d747
  40d4ec:	0040daab 	.word	0x0040daab
  40d4f0:	0040daab 	.word	0x0040daab
  40d4f4:	0040da83 	.word	0x0040da83
	case DYN_PRO_SENSOR_TYPE_RESERVED:
		break;
	case DYN_PRO_SENSOR_TYPE_ACCELEROMETER:
	case DYN_PRO_SENSOR_TYPE_GRAVITY:
	case DYN_PRO_SENSOR_TYPE_LINEAR_ACCELERATION:
		idx += DynProtocol_decodeVect16QxToQy(&buffer[idx], 3, self->precision.acc, 16, (int32_t*)&vSensordata->data.u32[0]);
  40d4f8:	8bfb      	ldrh	r3, [r7, #30]
  40d4fa:	68ba      	ldr	r2, [r7, #8]
  40d4fc:	18d0      	adds	r0, r2, r3
  40d4fe:	68fb      	ldr	r3, [r7, #12]
  40d500:	f893 3294 	ldrb.w	r3, [r3, #660]	; 0x294
  40d504:	461a      	mov	r2, r3
  40d506:	697b      	ldr	r3, [r7, #20]
  40d508:	3308      	adds	r3, #8
  40d50a:	9300      	str	r3, [sp, #0]
  40d50c:	2310      	movs	r3, #16
  40d50e:	2103      	movs	r1, #3
  40d510:	4c55      	ldr	r4, [pc, #340]	; (40d668 <DynProtocol_decodeSensorEvent+0x330>)
  40d512:	47a0      	blx	r4
  40d514:	4603      	mov	r3, r0
  40d516:	b29a      	uxth	r2, r3
  40d518:	8bfb      	ldrh	r3, [r7, #30]
  40d51a:	4413      	add	r3, r2
  40d51c:	83fb      	strh	r3, [r7, #30]
		vSensordata->base.meta_data = (uint32_t)buffer[idx++];
  40d51e:	8bfb      	ldrh	r3, [r7, #30]
  40d520:	1c5a      	adds	r2, r3, #1
  40d522:	83fa      	strh	r2, [r7, #30]
  40d524:	461a      	mov	r2, r3
  40d526:	68bb      	ldr	r3, [r7, #8]
  40d528:	4413      	add	r3, r2
  40d52a:	781b      	ldrb	r3, [r3, #0]
  40d52c:	461a      	mov	r2, r3
  40d52e:	697b      	ldr	r3, [r7, #20]
  40d530:	605a      	str	r2, [r3, #4]
		break;
  40d532:	e3ea      	b.n	40dd0a <DynProtocol_decodeSensorEvent+0x9d2>
	case DYN_PRO_SENSOR_TYPE_MAGNETOMETER:
		idx += DynProtocol_decodeVect16QxToQy(&buffer[idx], 3, PROTOCOL_MAGNETOMETER_PRECISION, 16, (int32_t*)&vSensordata->data.u32[0]);
  40d534:	8bfb      	ldrh	r3, [r7, #30]
  40d536:	68ba      	ldr	r2, [r7, #8]
  40d538:	18d0      	adds	r0, r2, r3
  40d53a:	697b      	ldr	r3, [r7, #20]
  40d53c:	3308      	adds	r3, #8
  40d53e:	9300      	str	r3, [sp, #0]
  40d540:	2310      	movs	r3, #16
  40d542:	2204      	movs	r2, #4
  40d544:	2103      	movs	r1, #3
  40d546:	4c48      	ldr	r4, [pc, #288]	; (40d668 <DynProtocol_decodeSensorEvent+0x330>)
  40d548:	47a0      	blx	r4
  40d54a:	4603      	mov	r3, r0
  40d54c:	b29a      	uxth	r2, r3
  40d54e:	8bfb      	ldrh	r3, [r7, #30]
  40d550:	4413      	add	r3, r2
  40d552:	83fb      	strh	r3, [r7, #30]
		vSensordata->base.meta_data = (uint32_t)buffer[idx++];
  40d554:	8bfb      	ldrh	r3, [r7, #30]
  40d556:	1c5a      	adds	r2, r3, #1
  40d558:	83fa      	strh	r2, [r7, #30]
  40d55a:	461a      	mov	r2, r3
  40d55c:	68bb      	ldr	r3, [r7, #8]
  40d55e:	4413      	add	r3, r2
  40d560:	781b      	ldrb	r3, [r3, #0]
  40d562:	461a      	mov	r2, r3
  40d564:	697b      	ldr	r3, [r7, #20]
  40d566:	605a      	str	r2, [r3, #4]
		break;
  40d568:	e3cf      	b.n	40dd0a <DynProtocol_decodeSensorEvent+0x9d2>
	case DYN_PRO_SENSOR_TYPE_UNCAL_MAGNETOMETER:
		idx += DynProtocol_decodeVect16QxToQy(&buffer[idx], 3, PROTOCOL_MAGNETOMETER_PRECISION, 16, (int32_t*)&vSensordata->data.u32[0]);
  40d56a:	8bfb      	ldrh	r3, [r7, #30]
  40d56c:	68ba      	ldr	r2, [r7, #8]
  40d56e:	18d0      	adds	r0, r2, r3
  40d570:	697b      	ldr	r3, [r7, #20]
  40d572:	3308      	adds	r3, #8
  40d574:	9300      	str	r3, [sp, #0]
  40d576:	2310      	movs	r3, #16
  40d578:	2204      	movs	r2, #4
  40d57a:	2103      	movs	r1, #3
  40d57c:	4c3a      	ldr	r4, [pc, #232]	; (40d668 <DynProtocol_decodeSensorEvent+0x330>)
  40d57e:	47a0      	blx	r4
  40d580:	4603      	mov	r3, r0
  40d582:	b29a      	uxth	r2, r3
  40d584:	8bfb      	ldrh	r3, [r7, #30]
  40d586:	4413      	add	r3, r2
  40d588:	83fb      	strh	r3, [r7, #30]
		idx += DynProtocol_decodeVect16QxToQy(&buffer[idx], 3, PROTOCOL_MAGNETOMETER_PRECISION, 16, (int32_t*)&vSensordata->data.u32[3]);
  40d58a:	8bfb      	ldrh	r3, [r7, #30]
  40d58c:	68ba      	ldr	r2, [r7, #8]
  40d58e:	18d0      	adds	r0, r2, r3
  40d590:	697b      	ldr	r3, [r7, #20]
  40d592:	3314      	adds	r3, #20
  40d594:	9300      	str	r3, [sp, #0]
  40d596:	2310      	movs	r3, #16
  40d598:	2204      	movs	r2, #4
  40d59a:	2103      	movs	r1, #3
  40d59c:	4c32      	ldr	r4, [pc, #200]	; (40d668 <DynProtocol_decodeSensorEvent+0x330>)
  40d59e:	47a0      	blx	r4
  40d5a0:	4603      	mov	r3, r0
  40d5a2:	b29a      	uxth	r2, r3
  40d5a4:	8bfb      	ldrh	r3, [r7, #30]
  40d5a6:	4413      	add	r3, r2
  40d5a8:	83fb      	strh	r3, [r7, #30]
		vSensordata->base.meta_data = (uint32_t)buffer[idx++];
  40d5aa:	8bfb      	ldrh	r3, [r7, #30]
  40d5ac:	1c5a      	adds	r2, r3, #1
  40d5ae:	83fa      	strh	r2, [r7, #30]
  40d5b0:	461a      	mov	r2, r3
  40d5b2:	68bb      	ldr	r3, [r7, #8]
  40d5b4:	4413      	add	r3, r2
  40d5b6:	781b      	ldrb	r3, [r3, #0]
  40d5b8:	461a      	mov	r2, r3
  40d5ba:	697b      	ldr	r3, [r7, #20]
  40d5bc:	605a      	str	r2, [r3, #4]
		break;
  40d5be:	e3a4      	b.n	40dd0a <DynProtocol_decodeSensorEvent+0x9d2>
	case DYN_PRO_SENSOR_TYPE_GYROSCOPE:
		idx += DynProtocol_decodeVect16QxToQy(&buffer[idx], 3, self->precision.gyro, 16, (int32_t*)&vSensordata->data.u32[0]);
  40d5c0:	8bfb      	ldrh	r3, [r7, #30]
  40d5c2:	68ba      	ldr	r2, [r7, #8]
  40d5c4:	18d0      	adds	r0, r2, r3
  40d5c6:	68fb      	ldr	r3, [r7, #12]
  40d5c8:	f893 3295 	ldrb.w	r3, [r3, #661]	; 0x295
  40d5cc:	461a      	mov	r2, r3
  40d5ce:	697b      	ldr	r3, [r7, #20]
  40d5d0:	3308      	adds	r3, #8
  40d5d2:	9300      	str	r3, [sp, #0]
  40d5d4:	2310      	movs	r3, #16
  40d5d6:	2103      	movs	r1, #3
  40d5d8:	4c23      	ldr	r4, [pc, #140]	; (40d668 <DynProtocol_decodeSensorEvent+0x330>)
  40d5da:	47a0      	blx	r4
  40d5dc:	4603      	mov	r3, r0
  40d5de:	b29a      	uxth	r2, r3
  40d5e0:	8bfb      	ldrh	r3, [r7, #30]
  40d5e2:	4413      	add	r3, r2
  40d5e4:	83fb      	strh	r3, [r7, #30]
		vSensordata->base.meta_data = (uint32_t)buffer[idx++];
  40d5e6:	8bfb      	ldrh	r3, [r7, #30]
  40d5e8:	1c5a      	adds	r2, r3, #1
  40d5ea:	83fa      	strh	r2, [r7, #30]
  40d5ec:	461a      	mov	r2, r3
  40d5ee:	68bb      	ldr	r3, [r7, #8]
  40d5f0:	4413      	add	r3, r2
  40d5f2:	781b      	ldrb	r3, [r3, #0]
  40d5f4:	461a      	mov	r2, r3
  40d5f6:	697b      	ldr	r3, [r7, #20]
  40d5f8:	605a      	str	r2, [r3, #4]
		break;
  40d5fa:	e386      	b.n	40dd0a <DynProtocol_decodeSensorEvent+0x9d2>
	case DYN_PRO_SENSOR_TYPE_UNCAL_GYROSCOPE:
		idx += DynProtocol_decodeVect16QxToQy(&buffer[idx], 3, self->precision.gyro, 16, (int32_t*)&vSensordata->data.u32[0]);
  40d5fc:	8bfb      	ldrh	r3, [r7, #30]
  40d5fe:	68ba      	ldr	r2, [r7, #8]
  40d600:	18d0      	adds	r0, r2, r3
  40d602:	68fb      	ldr	r3, [r7, #12]
  40d604:	f893 3295 	ldrb.w	r3, [r3, #661]	; 0x295
  40d608:	461a      	mov	r2, r3
  40d60a:	697b      	ldr	r3, [r7, #20]
  40d60c:	3308      	adds	r3, #8
  40d60e:	9300      	str	r3, [sp, #0]
  40d610:	2310      	movs	r3, #16
  40d612:	2103      	movs	r1, #3
  40d614:	4c14      	ldr	r4, [pc, #80]	; (40d668 <DynProtocol_decodeSensorEvent+0x330>)
  40d616:	47a0      	blx	r4
  40d618:	4603      	mov	r3, r0
  40d61a:	b29a      	uxth	r2, r3
  40d61c:	8bfb      	ldrh	r3, [r7, #30]
  40d61e:	4413      	add	r3, r2
  40d620:	83fb      	strh	r3, [r7, #30]
		idx += DynProtocol_decodeVect16QxToQy(&buffer[idx], 3, self->precision.gyro, 16, (int32_t*)&vSensordata->data.u32[3]);
  40d622:	8bfb      	ldrh	r3, [r7, #30]
  40d624:	68ba      	ldr	r2, [r7, #8]
  40d626:	18d0      	adds	r0, r2, r3
  40d628:	68fb      	ldr	r3, [r7, #12]
  40d62a:	f893 3295 	ldrb.w	r3, [r3, #661]	; 0x295
  40d62e:	461a      	mov	r2, r3
  40d630:	697b      	ldr	r3, [r7, #20]
  40d632:	3314      	adds	r3, #20
  40d634:	9300      	str	r3, [sp, #0]
  40d636:	2310      	movs	r3, #16
  40d638:	2103      	movs	r1, #3
  40d63a:	4c0b      	ldr	r4, [pc, #44]	; (40d668 <DynProtocol_decodeSensorEvent+0x330>)
  40d63c:	47a0      	blx	r4
  40d63e:	4603      	mov	r3, r0
  40d640:	b29a      	uxth	r2, r3
  40d642:	8bfb      	ldrh	r3, [r7, #30]
  40d644:	4413      	add	r3, r2
  40d646:	83fb      	strh	r3, [r7, #30]
		vSensordata->base.meta_data = (uint32_t)buffer[idx++];
  40d648:	8bfb      	ldrh	r3, [r7, #30]
  40d64a:	1c5a      	adds	r2, r3, #1
  40d64c:	83fa      	strh	r2, [r7, #30]
  40d64e:	461a      	mov	r2, r3
  40d650:	68bb      	ldr	r3, [r7, #8]
  40d652:	4413      	add	r3, r2
  40d654:	781b      	ldrb	r3, [r3, #0]
  40d656:	461a      	mov	r2, r3
  40d658:	697b      	ldr	r3, [r7, #20]
  40d65a:	605a      	str	r2, [r3, #4]
		break;
  40d65c:	e355      	b.n	40dd0a <DynProtocol_decodeSensorEvent+0x9d2>
  40d65e:	bf00      	nop
  40d660:	00414241 	.word	0x00414241
  40d664:	0040f807 	.word	0x0040f807
  40d668:	0040cc9d 	.word	0x0040cc9d
	case DYN_PRO_SENSOR_TYPE_3AXIS:
	case DYN_PRO_SENSOR_TYPE_GAME_ROTATION_VECTOR:
	case DYN_PRO_SENSOR_TYPE_PRED_QUAT_0:
	case DYN_PRO_SENSOR_TYPE_PRED_QUAT_1:
		idx += DynProtocol_decodeVect16QxToQy(&buffer[idx], 4, PROTOCOL_QUATERNION_PRECISION, 30, (int32_t*)&vSensordata->data.u32[0]);
  40d66c:	8bfb      	ldrh	r3, [r7, #30]
  40d66e:	68ba      	ldr	r2, [r7, #8]
  40d670:	18d0      	adds	r0, r2, r3
  40d672:	697b      	ldr	r3, [r7, #20]
  40d674:	3308      	adds	r3, #8
  40d676:	9300      	str	r3, [sp, #0]
  40d678:	231e      	movs	r3, #30
  40d67a:	220e      	movs	r2, #14
  40d67c:	2104      	movs	r1, #4
  40d67e:	4c78      	ldr	r4, [pc, #480]	; (40d860 <DynProtocol_decodeSensorEvent+0x528>)
  40d680:	47a0      	blx	r4
  40d682:	4603      	mov	r3, r0
  40d684:	b29a      	uxth	r2, r3
  40d686:	8bfb      	ldrh	r3, [r7, #30]
  40d688:	4413      	add	r3, r2
  40d68a:	83fb      	strh	r3, [r7, #30]
		vSensordata->base.meta_data = (uint32_t)buffer[idx++];
  40d68c:	8bfb      	ldrh	r3, [r7, #30]
  40d68e:	1c5a      	adds	r2, r3, #1
  40d690:	83fa      	strh	r2, [r7, #30]
  40d692:	461a      	mov	r2, r3
  40d694:	68bb      	ldr	r3, [r7, #8]
  40d696:	4413      	add	r3, r2
  40d698:	781b      	ldrb	r3, [r3, #0]
  40d69a:	461a      	mov	r2, r3
  40d69c:	697b      	ldr	r3, [r7, #20]
  40d69e:	605a      	str	r2, [r3, #4]
		break;
  40d6a0:	e333      	b.n	40dd0a <DynProtocol_decodeSensorEvent+0x9d2>
	case DYN_PRO_SENSOR_TYPE_ROTATION_VECTOR:
	case DYN_PRO_SENSOR_TYPE_GEOMAG_ROTATION_VECTOR:
		idx += DynProtocol_decodeVect16QxToQy(&buffer[idx], 4, PROTOCOL_QUATERNION_PRECISION, 30, (int32_t*)&vSensordata->data.u32[0]);
  40d6a2:	8bfb      	ldrh	r3, [r7, #30]
  40d6a4:	68ba      	ldr	r2, [r7, #8]
  40d6a6:	18d0      	adds	r0, r2, r3
  40d6a8:	697b      	ldr	r3, [r7, #20]
  40d6aa:	3308      	adds	r3, #8
  40d6ac:	9300      	str	r3, [sp, #0]
  40d6ae:	231e      	movs	r3, #30
  40d6b0:	220e      	movs	r2, #14
  40d6b2:	2104      	movs	r1, #4
  40d6b4:	4c6a      	ldr	r4, [pc, #424]	; (40d860 <DynProtocol_decodeSensorEvent+0x528>)
  40d6b6:	47a0      	blx	r4
  40d6b8:	4603      	mov	r3, r0
  40d6ba:	b29a      	uxth	r2, r3
  40d6bc:	8bfb      	ldrh	r3, [r7, #30]
  40d6be:	4413      	add	r3, r2
  40d6c0:	83fb      	strh	r3, [r7, #30]
		idx += DynProtocol_decodeVect16QxToQy(&buffer[idx], 1, PROTOCOL_HEADING_ACCURACY_PRECISION, 16, (int32_t*)&vSensordata->data.u32[4]);
  40d6c2:	8bfb      	ldrh	r3, [r7, #30]
  40d6c4:	68ba      	ldr	r2, [r7, #8]
  40d6c6:	18d0      	adds	r0, r2, r3
  40d6c8:	697b      	ldr	r3, [r7, #20]
  40d6ca:	3318      	adds	r3, #24
  40d6cc:	9300      	str	r3, [sp, #0]
  40d6ce:	2310      	movs	r3, #16
  40d6d0:	2207      	movs	r2, #7
  40d6d2:	2101      	movs	r1, #1
  40d6d4:	4c62      	ldr	r4, [pc, #392]	; (40d860 <DynProtocol_decodeSensorEvent+0x528>)
  40d6d6:	47a0      	blx	r4
  40d6d8:	4603      	mov	r3, r0
  40d6da:	b29a      	uxth	r2, r3
  40d6dc:	8bfb      	ldrh	r3, [r7, #30]
  40d6de:	4413      	add	r3, r2
  40d6e0:	83fb      	strh	r3, [r7, #30]
		vSensordata->base.meta_data = (uint32_t)buffer[idx++];
  40d6e2:	8bfb      	ldrh	r3, [r7, #30]
  40d6e4:	1c5a      	adds	r2, r3, #1
  40d6e6:	83fa      	strh	r2, [r7, #30]
  40d6e8:	461a      	mov	r2, r3
  40d6ea:	68bb      	ldr	r3, [r7, #8]
  40d6ec:	4413      	add	r3, r2
  40d6ee:	781b      	ldrb	r3, [r3, #0]
  40d6f0:	461a      	mov	r2, r3
  40d6f2:	697b      	ldr	r3, [r7, #20]
  40d6f4:	605a      	str	r2, [r3, #4]
		break;
  40d6f6:	e308      	b.n	40dd0a <DynProtocol_decodeSensorEvent+0x9d2>
	case DYN_PRO_SENSOR_TYPE_HIGH_RATE_GYRO:
		vSensordata->base.timestamp = 0;
  40d6f8:	697b      	ldr	r3, [r7, #20]
  40d6fa:	2200      	movs	r2, #0
  40d6fc:	601a      	str	r2, [r3, #0]
		idx -= 4;
  40d6fe:	8bfb      	ldrh	r3, [r7, #30]
  40d700:	3b04      	subs	r3, #4
  40d702:	83fb      	strh	r3, [r7, #30]
		vSensordata->data.u32[0] = inv_dc_le_to_int16(&buffer[idx]);
  40d704:	8bfb      	ldrh	r3, [r7, #30]
  40d706:	68ba      	ldr	r2, [r7, #8]
  40d708:	4413      	add	r3, r2
  40d70a:	4618      	mov	r0, r3
  40d70c:	4b55      	ldr	r3, [pc, #340]	; (40d864 <DynProtocol_decodeSensorEvent+0x52c>)
  40d70e:	4798      	blx	r3
  40d710:	4603      	mov	r3, r0
  40d712:	461a      	mov	r2, r3
  40d714:	697b      	ldr	r3, [r7, #20]
  40d716:	609a      	str	r2, [r3, #8]
		vSensordata->data.u32[1] = inv_dc_le_to_int16(&buffer[idx+2]);
  40d718:	8bfb      	ldrh	r3, [r7, #30]
  40d71a:	3302      	adds	r3, #2
  40d71c:	68ba      	ldr	r2, [r7, #8]
  40d71e:	4413      	add	r3, r2
  40d720:	4618      	mov	r0, r3
  40d722:	4b50      	ldr	r3, [pc, #320]	; (40d864 <DynProtocol_decodeSensorEvent+0x52c>)
  40d724:	4798      	blx	r3
  40d726:	4603      	mov	r3, r0
  40d728:	461a      	mov	r2, r3
  40d72a:	697b      	ldr	r3, [r7, #20]
  40d72c:	60da      	str	r2, [r3, #12]
		vSensordata->data.u32[2] = inv_dc_le_to_int16(&buffer[idx+4]);
  40d72e:	8bfb      	ldrh	r3, [r7, #30]
  40d730:	3304      	adds	r3, #4
  40d732:	68ba      	ldr	r2, [r7, #8]
  40d734:	4413      	add	r3, r2
  40d736:	4618      	mov	r0, r3
  40d738:	4b4a      	ldr	r3, [pc, #296]	; (40d864 <DynProtocol_decodeSensorEvent+0x52c>)
  40d73a:	4798      	blx	r3
  40d73c:	4603      	mov	r3, r0
  40d73e:	461a      	mov	r2, r3
  40d740:	697b      	ldr	r3, [r7, #20]
  40d742:	611a      	str	r2, [r3, #16]
		break;
  40d744:	e2e1      	b.n	40dd0a <DynProtocol_decodeSensorEvent+0x9d2>
	case DYN_PRO_SENSOR_TYPE_RAW_ACCELEROMETER:
	case DYN_PRO_SENSOR_TYPE_RAW_GYROSCOPE:
	case DYN_PRO_SENSOR_TYPE_RAW_MAGNETOMETER:
	case DYN_PRO_SENSOR_TYPE_OIS:
	case DYN_PRO_SENSOR_TYPE_OIS_1:
		vSensordata->data.u32[0] = inv_dc_le_to_int16(&buffer[idx]);
  40d746:	8bfb      	ldrh	r3, [r7, #30]
  40d748:	68ba      	ldr	r2, [r7, #8]
  40d74a:	4413      	add	r3, r2
  40d74c:	4618      	mov	r0, r3
  40d74e:	4b45      	ldr	r3, [pc, #276]	; (40d864 <DynProtocol_decodeSensorEvent+0x52c>)
  40d750:	4798      	blx	r3
  40d752:	4603      	mov	r3, r0
  40d754:	461a      	mov	r2, r3
  40d756:	697b      	ldr	r3, [r7, #20]
  40d758:	609a      	str	r2, [r3, #8]
		vSensordata->data.u32[1] = inv_dc_le_to_int16(&buffer[idx+2]);
  40d75a:	8bfb      	ldrh	r3, [r7, #30]
  40d75c:	3302      	adds	r3, #2
  40d75e:	68ba      	ldr	r2, [r7, #8]
  40d760:	4413      	add	r3, r2
  40d762:	4618      	mov	r0, r3
  40d764:	4b3f      	ldr	r3, [pc, #252]	; (40d864 <DynProtocol_decodeSensorEvent+0x52c>)
  40d766:	4798      	blx	r3
  40d768:	4603      	mov	r3, r0
  40d76a:	461a      	mov	r2, r3
  40d76c:	697b      	ldr	r3, [r7, #20]
  40d76e:	60da      	str	r2, [r3, #12]
		vSensordata->data.u32[2] = inv_dc_le_to_int16(&buffer[idx+4]);
  40d770:	8bfb      	ldrh	r3, [r7, #30]
  40d772:	3304      	adds	r3, #4
  40d774:	68ba      	ldr	r2, [r7, #8]
  40d776:	4413      	add	r3, r2
  40d778:	4618      	mov	r0, r3
  40d77a:	4b3a      	ldr	r3, [pc, #232]	; (40d864 <DynProtocol_decodeSensorEvent+0x52c>)
  40d77c:	4798      	blx	r3
  40d77e:	4603      	mov	r3, r0
  40d780:	461a      	mov	r2, r3
  40d782:	697b      	ldr	r3, [r7, #20]
  40d784:	611a      	str	r2, [r3, #16]
		break;
  40d786:	e2c0      	b.n	40dd0a <DynProtocol_decodeSensorEvent+0x9d2>
	case DYN_PRO_SENSOR_TYPE_TEMPERATURE:
	case DYN_PRO_SENSOR_TYPE_AMBIENT_TEMPERATURE:
		DynProtocol_decodeVect16QxToQy(&buffer[idx], 1, PROTOCOL_TEMPERATURE_PRECISION, 16, (int32_t*)&vSensordata->data.u32[0]);
  40d788:	8bfb      	ldrh	r3, [r7, #30]
  40d78a:	68ba      	ldr	r2, [r7, #8]
  40d78c:	18d0      	adds	r0, r2, r3
  40d78e:	697b      	ldr	r3, [r7, #20]
  40d790:	3308      	adds	r3, #8
  40d792:	9300      	str	r3, [sp, #0]
  40d794:	2310      	movs	r3, #16
  40d796:	2208      	movs	r2, #8
  40d798:	2101      	movs	r1, #1
  40d79a:	4c31      	ldr	r4, [pc, #196]	; (40d860 <DynProtocol_decodeSensorEvent+0x528>)
  40d79c:	47a0      	blx	r4
		break;
  40d79e:	e2b4      	b.n	40dd0a <DynProtocol_decodeSensorEvent+0x9d2>
	case DYN_PRO_SENSOR_TYPE_RAW_TEMPERATURE:
		vSensordata->data.u32[0] = inv_dc_little8_to_int32(&buffer[idx]);
  40d7a0:	8bfb      	ldrh	r3, [r7, #30]
  40d7a2:	68ba      	ldr	r2, [r7, #8]
  40d7a4:	4413      	add	r3, r2
  40d7a6:	4618      	mov	r0, r3
  40d7a8:	4b2f      	ldr	r3, [pc, #188]	; (40d868 <DynProtocol_decodeSensorEvent+0x530>)
  40d7aa:	4798      	blx	r3
  40d7ac:	4603      	mov	r3, r0
  40d7ae:	461a      	mov	r2, r3
  40d7b0:	697b      	ldr	r3, [r7, #20]
  40d7b2:	609a      	str	r2, [r3, #8]
		break;
  40d7b4:	e2a9      	b.n	40dd0a <DynProtocol_decodeSensorEvent+0x9d2>
	case DYN_PRO_SENSOR_TYPE_RAW_PPG:
		vSensordata->data.u32[0] = inv_dc_little8_to_int32(&buffer[idx]);
  40d7b6:	8bfb      	ldrh	r3, [r7, #30]
  40d7b8:	68ba      	ldr	r2, [r7, #8]
  40d7ba:	4413      	add	r3, r2
  40d7bc:	4618      	mov	r0, r3
  40d7be:	4b2a      	ldr	r3, [pc, #168]	; (40d868 <DynProtocol_decodeSensorEvent+0x530>)
  40d7c0:	4798      	blx	r3
  40d7c2:	4603      	mov	r3, r0
  40d7c4:	461a      	mov	r2, r3
  40d7c6:	697b      	ldr	r3, [r7, #20]
  40d7c8:	609a      	str	r2, [r3, #8]
		vSensordata->data.u8[4] = buffer[idx+4];
  40d7ca:	8bfb      	ldrh	r3, [r7, #30]
  40d7cc:	3304      	adds	r3, #4
  40d7ce:	68ba      	ldr	r2, [r7, #8]
  40d7d0:	4413      	add	r3, r2
  40d7d2:	781a      	ldrb	r2, [r3, #0]
  40d7d4:	697b      	ldr	r3, [r7, #20]
  40d7d6:	731a      	strb	r2, [r3, #12]
		break;
  40d7d8:	e297      	b.n	40dd0a <DynProtocol_decodeSensorEvent+0x9d2>
	case DYN_PRO_SENSOR_TYPE_ENERGY_EXPENDITURE:
		vSensordata->data.u32[0] = inv_dc_little8_to_int32(&buffer[idx]);
  40d7da:	8bfb      	ldrh	r3, [r7, #30]
  40d7dc:	68ba      	ldr	r2, [r7, #8]
  40d7de:	4413      	add	r3, r2
  40d7e0:	4618      	mov	r0, r3
  40d7e2:	4b21      	ldr	r3, [pc, #132]	; (40d868 <DynProtocol_decodeSensorEvent+0x530>)
  40d7e4:	4798      	blx	r3
  40d7e6:	4603      	mov	r3, r0
  40d7e8:	461a      	mov	r2, r3
  40d7ea:	697b      	ldr	r3, [r7, #20]
  40d7ec:	609a      	str	r2, [r3, #8]
		vSensordata->data.u32[1] = inv_dc_little8_to_int32(&buffer[idx+4]);
  40d7ee:	8bfb      	ldrh	r3, [r7, #30]
  40d7f0:	3304      	adds	r3, #4
  40d7f2:	68ba      	ldr	r2, [r7, #8]
  40d7f4:	4413      	add	r3, r2
  40d7f6:	4618      	mov	r0, r3
  40d7f8:	4b1b      	ldr	r3, [pc, #108]	; (40d868 <DynProtocol_decodeSensorEvent+0x530>)
  40d7fa:	4798      	blx	r3
  40d7fc:	4603      	mov	r3, r0
  40d7fe:	461a      	mov	r2, r3
  40d800:	697b      	ldr	r3, [r7, #20]
  40d802:	60da      	str	r2, [r3, #12]
		vSensordata->data.u32[2] = inv_dc_little8_to_int32(&buffer[idx+8]);
  40d804:	8bfb      	ldrh	r3, [r7, #30]
  40d806:	3308      	adds	r3, #8
  40d808:	68ba      	ldr	r2, [r7, #8]
  40d80a:	4413      	add	r3, r2
  40d80c:	4618      	mov	r0, r3
  40d80e:	4b16      	ldr	r3, [pc, #88]	; (40d868 <DynProtocol_decodeSensorEvent+0x530>)
  40d810:	4798      	blx	r3
  40d812:	4603      	mov	r3, r0
  40d814:	461a      	mov	r2, r3
  40d816:	697b      	ldr	r3, [r7, #20]
  40d818:	611a      	str	r2, [r3, #16]
		vSensordata->data.u32[3] = inv_dc_little8_to_int32(&buffer[idx+12]);
  40d81a:	8bfb      	ldrh	r3, [r7, #30]
  40d81c:	330c      	adds	r3, #12
  40d81e:	68ba      	ldr	r2, [r7, #8]
  40d820:	4413      	add	r3, r2
  40d822:	4618      	mov	r0, r3
  40d824:	4b10      	ldr	r3, [pc, #64]	; (40d868 <DynProtocol_decodeSensorEvent+0x530>)
  40d826:	4798      	blx	r3
  40d828:	4603      	mov	r3, r0
  40d82a:	461a      	mov	r2, r3
  40d82c:	697b      	ldr	r3, [r7, #20]
  40d82e:	615a      	str	r2, [r3, #20]
		break;
  40d830:	e26b      	b.n	40dd0a <DynProtocol_decodeSensorEvent+0x9d2>
	case DYN_PRO_SENSOR_TYPE_DISTANCE:
		vSensordata->data.u32[0] = inv_dc_little8_to_int32(&buffer[idx]);
  40d832:	8bfb      	ldrh	r3, [r7, #30]
  40d834:	68ba      	ldr	r2, [r7, #8]
  40d836:	4413      	add	r3, r2
  40d838:	4618      	mov	r0, r3
  40d83a:	4b0b      	ldr	r3, [pc, #44]	; (40d868 <DynProtocol_decodeSensorEvent+0x530>)
  40d83c:	4798      	blx	r3
  40d83e:	4603      	mov	r3, r0
  40d840:	461a      	mov	r2, r3
  40d842:	697b      	ldr	r3, [r7, #20]
  40d844:	609a      	str	r2, [r3, #8]
		vSensordata->data.u32[1] = inv_dc_little8_to_int32(&buffer[idx+4]);
  40d846:	8bfb      	ldrh	r3, [r7, #30]
  40d848:	3304      	adds	r3, #4
  40d84a:	68ba      	ldr	r2, [r7, #8]
  40d84c:	4413      	add	r3, r2
  40d84e:	4618      	mov	r0, r3
  40d850:	4b05      	ldr	r3, [pc, #20]	; (40d868 <DynProtocol_decodeSensorEvent+0x530>)
  40d852:	4798      	blx	r3
  40d854:	4603      	mov	r3, r0
  40d856:	461a      	mov	r2, r3
  40d858:	697b      	ldr	r3, [r7, #20]
  40d85a:	60da      	str	r2, [r3, #12]
		break;
  40d85c:	e255      	b.n	40dd0a <DynProtocol_decodeSensorEvent+0x9d2>
  40d85e:	bf00      	nop
  40d860:	0040cc9d 	.word	0x0040cc9d
  40d864:	0040f857 	.word	0x0040f857
  40d868:	0040f807 	.word	0x0040f807
	case DYN_PRO_SENSOR_TYPE_SLEEP_ANALYSIS:
		vSensordata->data.u8[0]  = buffer[idx];
  40d86c:	8bfb      	ldrh	r3, [r7, #30]
  40d86e:	68ba      	ldr	r2, [r7, #8]
  40d870:	4413      	add	r3, r2
  40d872:	781a      	ldrb	r2, [r3, #0]
  40d874:	697b      	ldr	r3, [r7, #20]
  40d876:	721a      	strb	r2, [r3, #8]
		vSensordata->data.u8[1]  = buffer[idx+1];
  40d878:	8bfb      	ldrh	r3, [r7, #30]
  40d87a:	3301      	adds	r3, #1
  40d87c:	68ba      	ldr	r2, [r7, #8]
  40d87e:	4413      	add	r3, r2
  40d880:	781a      	ldrb	r2, [r3, #0]
  40d882:	697b      	ldr	r3, [r7, #20]
  40d884:	725a      	strb	r2, [r3, #9]
		vSensordata->data.u8[2]  = buffer[idx+2];
  40d886:	8bfb      	ldrh	r3, [r7, #30]
  40d888:	3302      	adds	r3, #2
  40d88a:	68ba      	ldr	r2, [r7, #8]
  40d88c:	4413      	add	r3, r2
  40d88e:	781a      	ldrb	r2, [r3, #0]
  40d890:	697b      	ldr	r3, [r7, #20]
  40d892:	729a      	strb	r2, [r3, #10]
		vSensordata->data.u8[3]  = buffer[idx+3];
  40d894:	8bfb      	ldrh	r3, [r7, #30]
  40d896:	3303      	adds	r3, #3
  40d898:	68ba      	ldr	r2, [r7, #8]
  40d89a:	4413      	add	r3, r2
  40d89c:	781a      	ldrb	r2, [r3, #0]
  40d89e:	697b      	ldr	r3, [r7, #20]
  40d8a0:	72da      	strb	r2, [r3, #11]
		vSensordata->data.u32[1] = inv_dc_little8_to_int32(&buffer[idx+4]);
  40d8a2:	8bfb      	ldrh	r3, [r7, #30]
  40d8a4:	3304      	adds	r3, #4
  40d8a6:	68ba      	ldr	r2, [r7, #8]
  40d8a8:	4413      	add	r3, r2
  40d8aa:	4618      	mov	r0, r3
  40d8ac:	4b9d      	ldr	r3, [pc, #628]	; (40db24 <DynProtocol_decodeSensorEvent+0x7ec>)
  40d8ae:	4798      	blx	r3
  40d8b0:	4603      	mov	r3, r0
  40d8b2:	461a      	mov	r2, r3
  40d8b4:	697b      	ldr	r3, [r7, #20]
  40d8b6:	60da      	str	r2, [r3, #12]
		vSensordata->data.u32[2] = inv_dc_little8_to_int32(&buffer[idx+8]);
  40d8b8:	8bfb      	ldrh	r3, [r7, #30]
  40d8ba:	3308      	adds	r3, #8
  40d8bc:	68ba      	ldr	r2, [r7, #8]
  40d8be:	4413      	add	r3, r2
  40d8c0:	4618      	mov	r0, r3
  40d8c2:	4b98      	ldr	r3, [pc, #608]	; (40db24 <DynProtocol_decodeSensorEvent+0x7ec>)
  40d8c4:	4798      	blx	r3
  40d8c6:	4603      	mov	r3, r0
  40d8c8:	461a      	mov	r2, r3
  40d8ca:	697b      	ldr	r3, [r7, #20]
  40d8cc:	611a      	str	r2, [r3, #16]
		vSensordata->data.u32[3] = inv_dc_little8_to_int32(&buffer[idx+12]);
  40d8ce:	8bfb      	ldrh	r3, [r7, #30]
  40d8d0:	330c      	adds	r3, #12
  40d8d2:	68ba      	ldr	r2, [r7, #8]
  40d8d4:	4413      	add	r3, r2
  40d8d6:	4618      	mov	r0, r3
  40d8d8:	4b92      	ldr	r3, [pc, #584]	; (40db24 <DynProtocol_decodeSensorEvent+0x7ec>)
  40d8da:	4798      	blx	r3
  40d8dc:	4603      	mov	r3, r0
  40d8de:	461a      	mov	r2, r3
  40d8e0:	697b      	ldr	r3, [r7, #20]
  40d8e2:	615a      	str	r2, [r3, #20]
		vSensordata->data.u32[4] = inv_dc_little8_to_int32(&buffer[idx+16]);
  40d8e4:	8bfb      	ldrh	r3, [r7, #30]
  40d8e6:	3310      	adds	r3, #16
  40d8e8:	68ba      	ldr	r2, [r7, #8]
  40d8ea:	4413      	add	r3, r2
  40d8ec:	4618      	mov	r0, r3
  40d8ee:	4b8d      	ldr	r3, [pc, #564]	; (40db24 <DynProtocol_decodeSensorEvent+0x7ec>)
  40d8f0:	4798      	blx	r3
  40d8f2:	4603      	mov	r3, r0
  40d8f4:	461a      	mov	r2, r3
  40d8f6:	697b      	ldr	r3, [r7, #20]
  40d8f8:	619a      	str	r2, [r3, #24]
		vSensordata->data.u32[5] = inv_dc_little8_to_int32(&buffer[idx+20]);
  40d8fa:	8bfb      	ldrh	r3, [r7, #30]
  40d8fc:	3314      	adds	r3, #20
  40d8fe:	68ba      	ldr	r2, [r7, #8]
  40d900:	4413      	add	r3, r2
  40d902:	4618      	mov	r0, r3
  40d904:	4b87      	ldr	r3, [pc, #540]	; (40db24 <DynProtocol_decodeSensorEvent+0x7ec>)
  40d906:	4798      	blx	r3
  40d908:	4603      	mov	r3, r0
  40d90a:	461a      	mov	r2, r3
  40d90c:	697b      	ldr	r3, [r7, #20]
  40d90e:	61da      	str	r2, [r3, #28]
		vSensordata->data.u8[24]  = buffer[idx+24];
  40d910:	8bfb      	ldrh	r3, [r7, #30]
  40d912:	3318      	adds	r3, #24
  40d914:	68ba      	ldr	r2, [r7, #8]
  40d916:	4413      	add	r3, r2
  40d918:	781a      	ldrb	r2, [r3, #0]
  40d91a:	697b      	ldr	r3, [r7, #20]
  40d91c:	f883 2020 	strb.w	r2, [r3, #32]
		break;
  40d920:	e1f3      	b.n	40dd0a <DynProtocol_decodeSensorEvent+0x9d2>
	case DYN_PRO_SENSOR_TYPE_BAC_EXTENDED:
		vSensordata->data.u32[0] = inv_dc_little8_to_int32(&buffer[idx]);
  40d922:	8bfb      	ldrh	r3, [r7, #30]
  40d924:	68ba      	ldr	r2, [r7, #8]
  40d926:	4413      	add	r3, r2
  40d928:	4618      	mov	r0, r3
  40d92a:	4b7e      	ldr	r3, [pc, #504]	; (40db24 <DynProtocol_decodeSensorEvent+0x7ec>)
  40d92c:	4798      	blx	r3
  40d92e:	4603      	mov	r3, r0
  40d930:	461a      	mov	r2, r3
  40d932:	697b      	ldr	r3, [r7, #20]
  40d934:	609a      	str	r2, [r3, #8]
		break;
  40d936:	e1e8      	b.n	40dd0a <DynProtocol_decodeSensorEvent+0x9d2>
	case DYN_PRO_SENSOR_TYPE_BAC_STATISTICS:
		vSensordata->data.u32[0]  = inv_dc_little8_to_int32(&buffer[idx]);
  40d938:	8bfb      	ldrh	r3, [r7, #30]
  40d93a:	68ba      	ldr	r2, [r7, #8]
  40d93c:	4413      	add	r3, r2
  40d93e:	4618      	mov	r0, r3
  40d940:	4b78      	ldr	r3, [pc, #480]	; (40db24 <DynProtocol_decodeSensorEvent+0x7ec>)
  40d942:	4798      	blx	r3
  40d944:	4603      	mov	r3, r0
  40d946:	461a      	mov	r2, r3
  40d948:	697b      	ldr	r3, [r7, #20]
  40d94a:	609a      	str	r2, [r3, #8]
		vSensordata->data.u32[1]  = inv_dc_little8_to_int32(&buffer[idx+4]);
  40d94c:	8bfb      	ldrh	r3, [r7, #30]
  40d94e:	3304      	adds	r3, #4
  40d950:	68ba      	ldr	r2, [r7, #8]
  40d952:	4413      	add	r3, r2
  40d954:	4618      	mov	r0, r3
  40d956:	4b73      	ldr	r3, [pc, #460]	; (40db24 <DynProtocol_decodeSensorEvent+0x7ec>)
  40d958:	4798      	blx	r3
  40d95a:	4603      	mov	r3, r0
  40d95c:	461a      	mov	r2, r3
  40d95e:	697b      	ldr	r3, [r7, #20]
  40d960:	60da      	str	r2, [r3, #12]
		vSensordata->data.u32[2]  = inv_dc_little8_to_int32(&buffer[idx+8]);
  40d962:	8bfb      	ldrh	r3, [r7, #30]
  40d964:	3308      	adds	r3, #8
  40d966:	68ba      	ldr	r2, [r7, #8]
  40d968:	4413      	add	r3, r2
  40d96a:	4618      	mov	r0, r3
  40d96c:	4b6d      	ldr	r3, [pc, #436]	; (40db24 <DynProtocol_decodeSensorEvent+0x7ec>)
  40d96e:	4798      	blx	r3
  40d970:	4603      	mov	r3, r0
  40d972:	461a      	mov	r2, r3
  40d974:	697b      	ldr	r3, [r7, #20]
  40d976:	611a      	str	r2, [r3, #16]
		vSensordata->data.u32[3]  = inv_dc_little8_to_int32(&buffer[idx+12]);
  40d978:	8bfb      	ldrh	r3, [r7, #30]
  40d97a:	330c      	adds	r3, #12
  40d97c:	68ba      	ldr	r2, [r7, #8]
  40d97e:	4413      	add	r3, r2
  40d980:	4618      	mov	r0, r3
  40d982:	4b68      	ldr	r3, [pc, #416]	; (40db24 <DynProtocol_decodeSensorEvent+0x7ec>)
  40d984:	4798      	blx	r3
  40d986:	4603      	mov	r3, r0
  40d988:	461a      	mov	r2, r3
  40d98a:	697b      	ldr	r3, [r7, #20]
  40d98c:	615a      	str	r2, [r3, #20]
		vSensordata->data.u32[4]  = inv_dc_little8_to_int32(&buffer[idx+16]);
  40d98e:	8bfb      	ldrh	r3, [r7, #30]
  40d990:	3310      	adds	r3, #16
  40d992:	68ba      	ldr	r2, [r7, #8]
  40d994:	4413      	add	r3, r2
  40d996:	4618      	mov	r0, r3
  40d998:	4b62      	ldr	r3, [pc, #392]	; (40db24 <DynProtocol_decodeSensorEvent+0x7ec>)
  40d99a:	4798      	blx	r3
  40d99c:	4603      	mov	r3, r0
  40d99e:	461a      	mov	r2, r3
  40d9a0:	697b      	ldr	r3, [r7, #20]
  40d9a2:	619a      	str	r2, [r3, #24]
		vSensordata->data.u32[5]  = inv_dc_little8_to_int32(&buffer[idx+20]);
  40d9a4:	8bfb      	ldrh	r3, [r7, #30]
  40d9a6:	3314      	adds	r3, #20
  40d9a8:	68ba      	ldr	r2, [r7, #8]
  40d9aa:	4413      	add	r3, r2
  40d9ac:	4618      	mov	r0, r3
  40d9ae:	4b5d      	ldr	r3, [pc, #372]	; (40db24 <DynProtocol_decodeSensorEvent+0x7ec>)
  40d9b0:	4798      	blx	r3
  40d9b2:	4603      	mov	r3, r0
  40d9b4:	461a      	mov	r2, r3
  40d9b6:	697b      	ldr	r3, [r7, #20]
  40d9b8:	61da      	str	r2, [r3, #28]
		vSensordata->data.u32[6]  = inv_dc_little8_to_int32(&buffer[idx+24]);
  40d9ba:	8bfb      	ldrh	r3, [r7, #30]
  40d9bc:	3318      	adds	r3, #24
  40d9be:	68ba      	ldr	r2, [r7, #8]
  40d9c0:	4413      	add	r3, r2
  40d9c2:	4618      	mov	r0, r3
  40d9c4:	4b57      	ldr	r3, [pc, #348]	; (40db24 <DynProtocol_decodeSensorEvent+0x7ec>)
  40d9c6:	4798      	blx	r3
  40d9c8:	4603      	mov	r3, r0
  40d9ca:	461a      	mov	r2, r3
  40d9cc:	697b      	ldr	r3, [r7, #20]
  40d9ce:	621a      	str	r2, [r3, #32]
		vSensordata->data.u32[7]  = inv_dc_little8_to_int32(&buffer[idx+28]);
  40d9d0:	8bfb      	ldrh	r3, [r7, #30]
  40d9d2:	331c      	adds	r3, #28
  40d9d4:	68ba      	ldr	r2, [r7, #8]
  40d9d6:	4413      	add	r3, r2
  40d9d8:	4618      	mov	r0, r3
  40d9da:	4b52      	ldr	r3, [pc, #328]	; (40db24 <DynProtocol_decodeSensorEvent+0x7ec>)
  40d9dc:	4798      	blx	r3
  40d9de:	4603      	mov	r3, r0
  40d9e0:	461a      	mov	r2, r3
  40d9e2:	697b      	ldr	r3, [r7, #20]
  40d9e4:	625a      	str	r2, [r3, #36]	; 0x24
		vSensordata->data.u32[8]  = inv_dc_little8_to_int32(&buffer[idx+32]);
  40d9e6:	8bfb      	ldrh	r3, [r7, #30]
  40d9e8:	3320      	adds	r3, #32
  40d9ea:	68ba      	ldr	r2, [r7, #8]
  40d9ec:	4413      	add	r3, r2
  40d9ee:	4618      	mov	r0, r3
  40d9f0:	4b4c      	ldr	r3, [pc, #304]	; (40db24 <DynProtocol_decodeSensorEvent+0x7ec>)
  40d9f2:	4798      	blx	r3
  40d9f4:	4603      	mov	r3, r0
  40d9f6:	461a      	mov	r2, r3
  40d9f8:	697b      	ldr	r3, [r7, #20]
  40d9fa:	629a      	str	r2, [r3, #40]	; 0x28
		vSensordata->data.u32[9]  = inv_dc_little8_to_int32(&buffer[idx+36]);
  40d9fc:	8bfb      	ldrh	r3, [r7, #30]
  40d9fe:	3324      	adds	r3, #36	; 0x24
  40da00:	68ba      	ldr	r2, [r7, #8]
  40da02:	4413      	add	r3, r2
  40da04:	4618      	mov	r0, r3
  40da06:	4b47      	ldr	r3, [pc, #284]	; (40db24 <DynProtocol_decodeSensorEvent+0x7ec>)
  40da08:	4798      	blx	r3
  40da0a:	4603      	mov	r3, r0
  40da0c:	461a      	mov	r2, r3
  40da0e:	697b      	ldr	r3, [r7, #20]
  40da10:	62da      	str	r2, [r3, #44]	; 0x2c
		vSensordata->data.u32[10] = inv_dc_little8_to_int32(&buffer[idx+40]);
  40da12:	8bfb      	ldrh	r3, [r7, #30]
  40da14:	3328      	adds	r3, #40	; 0x28
  40da16:	68ba      	ldr	r2, [r7, #8]
  40da18:	4413      	add	r3, r2
  40da1a:	4618      	mov	r0, r3
  40da1c:	4b41      	ldr	r3, [pc, #260]	; (40db24 <DynProtocol_decodeSensorEvent+0x7ec>)
  40da1e:	4798      	blx	r3
  40da20:	4603      	mov	r3, r0
  40da22:	461a      	mov	r2, r3
  40da24:	697b      	ldr	r3, [r7, #20]
  40da26:	631a      	str	r2, [r3, #48]	; 0x30
		break;
  40da28:	e16f      	b.n	40dd0a <DynProtocol_decodeSensorEvent+0x9d2>
	case DYN_PRO_SENSOR_TYPE_FLOOR_CLIMB_COUNTER:
		vSensordata->data.u32[0] = inv_dc_little8_to_int32(&buffer[idx]);
  40da2a:	8bfb      	ldrh	r3, [r7, #30]
  40da2c:	68ba      	ldr	r2, [r7, #8]
  40da2e:	4413      	add	r3, r2
  40da30:	4618      	mov	r0, r3
  40da32:	4b3c      	ldr	r3, [pc, #240]	; (40db24 <DynProtocol_decodeSensorEvent+0x7ec>)
  40da34:	4798      	blx	r3
  40da36:	4603      	mov	r3, r0
  40da38:	461a      	mov	r2, r3
  40da3a:	697b      	ldr	r3, [r7, #20]
  40da3c:	609a      	str	r2, [r3, #8]
		vSensordata->data.u32[1] = inv_dc_little8_to_int32(&buffer[idx+4]);
  40da3e:	8bfb      	ldrh	r3, [r7, #30]
  40da40:	3304      	adds	r3, #4
  40da42:	68ba      	ldr	r2, [r7, #8]
  40da44:	4413      	add	r3, r2
  40da46:	4618      	mov	r0, r3
  40da48:	4b36      	ldr	r3, [pc, #216]	; (40db24 <DynProtocol_decodeSensorEvent+0x7ec>)
  40da4a:	4798      	blx	r3
  40da4c:	4603      	mov	r3, r0
  40da4e:	461a      	mov	r2, r3
  40da50:	697b      	ldr	r3, [r7, #20]
  40da52:	60da      	str	r2, [r3, #12]
		break;
  40da54:	e159      	b.n	40dd0a <DynProtocol_decodeSensorEvent+0x9d2>
	case DYN_PRO_SENSOR_TYPE_STEP_COUNTER:
		vSensordata->data.u32[0] = inv_dc_little8_to_int32(&buffer[idx]);
  40da56:	8bfb      	ldrh	r3, [r7, #30]
  40da58:	68ba      	ldr	r2, [r7, #8]
  40da5a:	4413      	add	r3, r2
  40da5c:	4618      	mov	r0, r3
  40da5e:	4b31      	ldr	r3, [pc, #196]	; (40db24 <DynProtocol_decodeSensorEvent+0x7ec>)
  40da60:	4798      	blx	r3
  40da62:	4603      	mov	r3, r0
  40da64:	461a      	mov	r2, r3
  40da66:	697b      	ldr	r3, [r7, #20]
  40da68:	609a      	str	r2, [r3, #8]
		vSensordata->base.timestamp = inv_dc_little8_to_int32(&buffer[idx+4]);
  40da6a:	8bfb      	ldrh	r3, [r7, #30]
  40da6c:	3304      	adds	r3, #4
  40da6e:	68ba      	ldr	r2, [r7, #8]
  40da70:	4413      	add	r3, r2
  40da72:	4618      	mov	r0, r3
  40da74:	4b2b      	ldr	r3, [pc, #172]	; (40db24 <DynProtocol_decodeSensorEvent+0x7ec>)
  40da76:	4798      	blx	r3
  40da78:	4603      	mov	r3, r0
  40da7a:	461a      	mov	r2, r3
  40da7c:	697b      	ldr	r3, [r7, #20]
  40da7e:	601a      	str	r2, [r3, #0]
		break;
  40da80:	e143      	b.n	40dd0a <DynProtocol_decodeSensorEvent+0x9d2>
	case DYN_PRO_SENSOR_TYPE_BAC:
	case DYN_PRO_SENSOR_TYPE_WOM:
	case DYN_PRO_SENSOR_TYPE_TAP:
		vSensordata->data.u8[0] = buffer[idx++];
  40da82:	8bfb      	ldrh	r3, [r7, #30]
  40da84:	1c5a      	adds	r2, r3, #1
  40da86:	83fa      	strh	r2, [r7, #30]
  40da88:	461a      	mov	r2, r3
  40da8a:	68bb      	ldr	r3, [r7, #8]
  40da8c:	4413      	add	r3, r2
  40da8e:	781a      	ldrb	r2, [r3, #0]
  40da90:	697b      	ldr	r3, [r7, #20]
  40da92:	721a      	strb	r2, [r3, #8]
		vSensordata->base.timestamp = inv_dc_little8_to_int32(&buffer[idx]);
  40da94:	8bfb      	ldrh	r3, [r7, #30]
  40da96:	68ba      	ldr	r2, [r7, #8]
  40da98:	4413      	add	r3, r2
  40da9a:	4618      	mov	r0, r3
  40da9c:	4b21      	ldr	r3, [pc, #132]	; (40db24 <DynProtocol_decodeSensorEvent+0x7ec>)
  40da9e:	4798      	blx	r3
  40daa0:	4603      	mov	r3, r0
  40daa2:	461a      	mov	r2, r3
  40daa4:	697b      	ldr	r3, [r7, #20]
  40daa6:	601a      	str	r2, [r3, #0]
		break;
  40daa8:	e12f      	b.n	40dd0a <DynProtocol_decodeSensorEvent+0x9d2>
	case DYN_PRO_SENSOR_TYPE_WAKE_GESTURE:
	case DYN_PRO_SENSOR_TYPE_GLANCE_GESTURE:
	case DYN_PRO_SENSOR_TYPE_PICK_UP_GESTURE:
	case DYN_PRO_SENSOR_TYPE_LOW_G:
	case DYN_PRO_SENSOR_TYPE_HIGH_G:
		vSensordata->base.timestamp = inv_dc_little8_to_int32(&buffer[idx]);
  40daaa:	8bfb      	ldrh	r3, [r7, #30]
  40daac:	68ba      	ldr	r2, [r7, #8]
  40daae:	4413      	add	r3, r2
  40dab0:	4618      	mov	r0, r3
  40dab2:	4b1c      	ldr	r3, [pc, #112]	; (40db24 <DynProtocol_decodeSensorEvent+0x7ec>)
  40dab4:	4798      	blx	r3
  40dab6:	4603      	mov	r3, r0
  40dab8:	461a      	mov	r2, r3
  40daba:	697b      	ldr	r3, [r7, #20]
  40dabc:	601a      	str	r2, [r3, #0]
		break;
  40dabe:	e124      	b.n	40dd0a <DynProtocol_decodeSensorEvent+0x9d2>
	case DYN_PRO_SENSOR_TYPE_PRESSURE:
		vSensordata->data.u32[0] = inv_dc_little8_to_int32(&buffer[idx]);
  40dac0:	8bfb      	ldrh	r3, [r7, #30]
  40dac2:	68ba      	ldr	r2, [r7, #8]
  40dac4:	4413      	add	r3, r2
  40dac6:	4618      	mov	r0, r3
  40dac8:	4b16      	ldr	r3, [pc, #88]	; (40db24 <DynProtocol_decodeSensorEvent+0x7ec>)
  40daca:	4798      	blx	r3
  40dacc:	4603      	mov	r3, r0
  40dace:	461a      	mov	r2, r3
  40dad0:	697b      	ldr	r3, [r7, #20]
  40dad2:	609a      	str	r2, [r3, #8]
		break;
  40dad4:	e119      	b.n	40dd0a <DynProtocol_decodeSensorEvent+0x9d2>
	case DYN_PRO_SENSOR_TYPE_ORIENTATION:
		idx += DynProtocol_decodeVect16QxToQy(&buffer[idx], 3, PROTOCOL_ORIENTATION_PRECISION, 16, (int32_t*)&vSensordata->data.u32[0]);
  40dad6:	8bfb      	ldrh	r3, [r7, #30]
  40dad8:	68ba      	ldr	r2, [r7, #8]
  40dada:	18d0      	adds	r0, r2, r3
  40dadc:	697b      	ldr	r3, [r7, #20]
  40dade:	3308      	adds	r3, #8
  40dae0:	9300      	str	r3, [sp, #0]
  40dae2:	2310      	movs	r3, #16
  40dae4:	2206      	movs	r2, #6
  40dae6:	2103      	movs	r1, #3
  40dae8:	4c0f      	ldr	r4, [pc, #60]	; (40db28 <DynProtocol_decodeSensorEvent+0x7f0>)
  40daea:	47a0      	blx	r4
  40daec:	4603      	mov	r3, r0
  40daee:	b29a      	uxth	r2, r3
  40daf0:	8bfb      	ldrh	r3, [r7, #30]
  40daf2:	4413      	add	r3, r2
  40daf4:	83fb      	strh	r3, [r7, #30]
		vSensordata->base.meta_data = (uint32_t)buffer[idx++];
  40daf6:	8bfb      	ldrh	r3, [r7, #30]
  40daf8:	1c5a      	adds	r2, r3, #1
  40dafa:	83fa      	strh	r2, [r7, #30]
  40dafc:	461a      	mov	r2, r3
  40dafe:	68bb      	ldr	r3, [r7, #8]
  40db00:	4413      	add	r3, r2
  40db02:	781b      	ldrb	r3, [r3, #0]
  40db04:	461a      	mov	r2, r3
  40db06:	697b      	ldr	r3, [r7, #20]
  40db08:	605a      	str	r2, [r3, #4]
		break;
  40db0a:	e0fe      	b.n	40dd0a <DynProtocol_decodeSensorEvent+0x9d2>
	case DYN_PRO_SENSOR_TYPE_LIGHT:
		vSensordata->data.u32[0] = inv_dc_little8_to_int32(&buffer[idx]);
  40db0c:	8bfb      	ldrh	r3, [r7, #30]
  40db0e:	68ba      	ldr	r2, [r7, #8]
  40db10:	4413      	add	r3, r2
  40db12:	4618      	mov	r0, r3
  40db14:	4b03      	ldr	r3, [pc, #12]	; (40db24 <DynProtocol_decodeSensorEvent+0x7ec>)
  40db16:	4798      	blx	r3
  40db18:	4603      	mov	r3, r0
  40db1a:	461a      	mov	r2, r3
  40db1c:	697b      	ldr	r3, [r7, #20]
  40db1e:	609a      	str	r2, [r3, #8]
		break;
  40db20:	e0f3      	b.n	40dd0a <DynProtocol_decodeSensorEvent+0x9d2>
  40db22:	bf00      	nop
  40db24:	0040f807 	.word	0x0040f807
  40db28:	0040cc9d 	.word	0x0040cc9d
	case DYN_PRO_SENSOR_TYPE_PROXIMITY:
		vSensordata->data.u32[0] = (uint32_t)inv_dc_le_to_int16(&buffer[idx]);
  40db2c:	8bfb      	ldrh	r3, [r7, #30]
  40db2e:	68ba      	ldr	r2, [r7, #8]
  40db30:	4413      	add	r3, r2
  40db32:	4618      	mov	r0, r3
  40db34:	4b7b      	ldr	r3, [pc, #492]	; (40dd24 <DynProtocol_decodeSensorEvent+0x9ec>)
  40db36:	4798      	blx	r3
  40db38:	4603      	mov	r3, r0
  40db3a:	461a      	mov	r2, r3
  40db3c:	697b      	ldr	r3, [r7, #20]
  40db3e:	609a      	str	r2, [r3, #8]
		break;
  40db40:	e0e3      	b.n	40dd0a <DynProtocol_decodeSensorEvent+0x9d2>
	case DYN_PRO_SENSOR_TYPE_FSYNC_EVENT:
		vSensordata->data.u32[0] = (uint32_t)inv_dc_le_to_int16(&buffer[idx]);
  40db42:	8bfb      	ldrh	r3, [r7, #30]
  40db44:	68ba      	ldr	r2, [r7, #8]
  40db46:	4413      	add	r3, r2
  40db48:	4618      	mov	r0, r3
  40db4a:	4b76      	ldr	r3, [pc, #472]	; (40dd24 <DynProtocol_decodeSensorEvent+0x9ec>)
  40db4c:	4798      	blx	r3
  40db4e:	4603      	mov	r3, r0
  40db50:	461a      	mov	r2, r3
  40db52:	697b      	ldr	r3, [r7, #20]
  40db54:	609a      	str	r2, [r3, #8]
		break;
  40db56:	e0d8      	b.n	40dd0a <DynProtocol_decodeSensorEvent+0x9d2>
	case DYN_PRO_SENSOR_TYPE_EIS:
		idx += DynProtocol_decodeVect16QxToQy(&buffer[idx], 3, self->precision.gyro, 16, (int32_t*)&vSensordata->data.u32[0]);
  40db58:	8bfb      	ldrh	r3, [r7, #30]
  40db5a:	68ba      	ldr	r2, [r7, #8]
  40db5c:	18d0      	adds	r0, r2, r3
  40db5e:	68fb      	ldr	r3, [r7, #12]
  40db60:	f893 3295 	ldrb.w	r3, [r3, #661]	; 0x295
  40db64:	461a      	mov	r2, r3
  40db66:	697b      	ldr	r3, [r7, #20]
  40db68:	3308      	adds	r3, #8
  40db6a:	9300      	str	r3, [sp, #0]
  40db6c:	2310      	movs	r3, #16
  40db6e:	2103      	movs	r1, #3
  40db70:	4c6d      	ldr	r4, [pc, #436]	; (40dd28 <DynProtocol_decodeSensorEvent+0x9f0>)
  40db72:	47a0      	blx	r4
  40db74:	4603      	mov	r3, r0
  40db76:	b29a      	uxth	r2, r3
  40db78:	8bfb      	ldrh	r3, [r7, #30]
  40db7a:	4413      	add	r3, r2
  40db7c:	83fb      	strh	r3, [r7, #30]
		idx += DynProtocol_decodeVect16QxToQy(&buffer[idx], 3, self->precision.gyro, 16, (int32_t*)&vSensordata->data.u32[3]);
  40db7e:	8bfb      	ldrh	r3, [r7, #30]
  40db80:	68ba      	ldr	r2, [r7, #8]
  40db82:	18d0      	adds	r0, r2, r3
  40db84:	68fb      	ldr	r3, [r7, #12]
  40db86:	f893 3295 	ldrb.w	r3, [r3, #661]	; 0x295
  40db8a:	461a      	mov	r2, r3
  40db8c:	697b      	ldr	r3, [r7, #20]
  40db8e:	3314      	adds	r3, #20
  40db90:	9300      	str	r3, [sp, #0]
  40db92:	2310      	movs	r3, #16
  40db94:	2103      	movs	r1, #3
  40db96:	4c64      	ldr	r4, [pc, #400]	; (40dd28 <DynProtocol_decodeSensorEvent+0x9f0>)
  40db98:	47a0      	blx	r4
  40db9a:	4603      	mov	r3, r0
  40db9c:	b29a      	uxth	r2, r3
  40db9e:	8bfb      	ldrh	r3, [r7, #30]
  40dba0:	4413      	add	r3, r2
  40dba2:	83fb      	strh	r3, [r7, #30]
		vSensordata->data.u32[6] = (uint32_t)inv_dc_le_to_int16(&buffer[idx]);
  40dba4:	8bfb      	ldrh	r3, [r7, #30]
  40dba6:	68ba      	ldr	r2, [r7, #8]
  40dba8:	4413      	add	r3, r2
  40dbaa:	4618      	mov	r0, r3
  40dbac:	4b5d      	ldr	r3, [pc, #372]	; (40dd24 <DynProtocol_decodeSensorEvent+0x9ec>)
  40dbae:	4798      	blx	r3
  40dbb0:	4603      	mov	r3, r0
  40dbb2:	461a      	mov	r2, r3
  40dbb4:	697b      	ldr	r3, [r7, #20]
  40dbb6:	621a      	str	r2, [r3, #32]
		break;
  40dbb8:	e0a7      	b.n	40dd0a <DynProtocol_decodeSensorEvent+0x9d2>
	case DYN_PRO_SENSOR_TYPE_CUSTOM6:
	case DYN_PRO_SENSOR_TYPE_CUSTOM7:
	{
		/* meta data contains size of custom sensors.
		 * Check size is not bigger than VSensorData array */
		vSensordata->base.meta_data = buffer[idx++];
  40dbba:	8bfb      	ldrh	r3, [r7, #30]
  40dbbc:	1c5a      	adds	r2, r3, #1
  40dbbe:	83fa      	strh	r2, [r7, #30]
  40dbc0:	461a      	mov	r2, r3
  40dbc2:	68bb      	ldr	r3, [r7, #8]
  40dbc4:	4413      	add	r3, r2
  40dbc6:	781b      	ldrb	r3, [r3, #0]
  40dbc8:	461a      	mov	r2, r3
  40dbca:	697b      	ldr	r3, [r7, #20]
  40dbcc:	605a      	str	r2, [r3, #4]
		if(vSensordata->base.meta_data > sizeof(vSensordata->data.u8))
  40dbce:	697b      	ldr	r3, [r7, #20]
  40dbd0:	685b      	ldr	r3, [r3, #4]
  40dbd2:	2b40      	cmp	r3, #64	; 0x40
  40dbd4:	d902      	bls.n	40dbdc <DynProtocol_decodeSensorEvent+0x8a4>
			return -1;
  40dbd6:	f04f 33ff 	mov.w	r3, #4294967295
  40dbda:	e09e      	b.n	40dd1a <DynProtocol_decodeSensorEvent+0x9e2>

		memcpy(vSensordata->data.u8, &buffer[idx], vSensordata->base.meta_data);
  40dbdc:	697b      	ldr	r3, [r7, #20]
  40dbde:	f103 0008 	add.w	r0, r3, #8
  40dbe2:	8bfb      	ldrh	r3, [r7, #30]
  40dbe4:	68ba      	ldr	r2, [r7, #8]
  40dbe6:	18d1      	adds	r1, r2, r3
  40dbe8:	697b      	ldr	r3, [r7, #20]
  40dbea:	685b      	ldr	r3, [r3, #4]
  40dbec:	461a      	mov	r2, r3
  40dbee:	4b4f      	ldr	r3, [pc, #316]	; (40dd2c <DynProtocol_decodeSensorEvent+0x9f4>)
  40dbf0:	4798      	blx	r3
		//hard code the payload size until payload has a fixed value for custom sensors
		idx += sizeof(vSensordata->data.u8);
  40dbf2:	8bfb      	ldrh	r3, [r7, #30]
  40dbf4:	3340      	adds	r3, #64	; 0x40
  40dbf6:	83fb      	strh	r3, [r7, #30]
		break;
  40dbf8:	e087      	b.n	40dd0a <DynProtocol_decodeSensorEvent+0x9d2>
	}

	case DYN_PRO_SENSOR_TYPE_CUSTOM_PRESSURE:
		for (i=0; i<4; i++) {
  40dbfa:	2300      	movs	r3, #0
  40dbfc:	83bb      	strh	r3, [r7, #28]
  40dbfe:	e012      	b.n	40dc26 <DynProtocol_decodeSensorEvent+0x8ee>
			vSensordata->data.u32[i] = inv_dc_little8_to_int32(&buffer[idx]); // raw pressure
  40dc00:	8bbc      	ldrh	r4, [r7, #28]
  40dc02:	8bfb      	ldrh	r3, [r7, #30]
  40dc04:	68ba      	ldr	r2, [r7, #8]
  40dc06:	4413      	add	r3, r2
  40dc08:	4618      	mov	r0, r3
  40dc0a:	4b49      	ldr	r3, [pc, #292]	; (40dd30 <DynProtocol_decodeSensorEvent+0x9f8>)
  40dc0c:	4798      	blx	r3
  40dc0e:	4603      	mov	r3, r0
  40dc10:	4619      	mov	r1, r3
  40dc12:	697b      	ldr	r3, [r7, #20]
  40dc14:	1ca2      	adds	r2, r4, #2
  40dc16:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
			idx += 4;
  40dc1a:	8bfb      	ldrh	r3, [r7, #30]
  40dc1c:	3304      	adds	r3, #4
  40dc1e:	83fb      	strh	r3, [r7, #30]
		for (i=0; i<4; i++) {
  40dc20:	8bbb      	ldrh	r3, [r7, #28]
  40dc22:	3301      	adds	r3, #1
  40dc24:	83bb      	strh	r3, [r7, #28]
  40dc26:	8bbb      	ldrh	r3, [r7, #28]
  40dc28:	2b03      	cmp	r3, #3
  40dc2a:	d9e9      	bls.n	40dc00 <DynProtocol_decodeSensorEvent+0x8c8>
		}
		break;
  40dc2c:	e06d      	b.n	40dd0a <DynProtocol_decodeSensorEvent+0x9d2>

	case DYN_PRO_SENSOR_TYPE_HEART_RATE:
	{
		// ppm
		idx += DynProtocol_decodeVect16QxToQy(&buffer[idx], 1, PROTOCOL_HRM_PRECISION, 16, (int32_t*)&vSensordata->data.u32[0]);
  40dc2e:	8bfb      	ldrh	r3, [r7, #30]
  40dc30:	68ba      	ldr	r2, [r7, #8]
  40dc32:	18d0      	adds	r0, r2, r3
  40dc34:	697b      	ldr	r3, [r7, #20]
  40dc36:	3308      	adds	r3, #8
  40dc38:	9300      	str	r3, [sp, #0]
  40dc3a:	2310      	movs	r3, #16
  40dc3c:	2207      	movs	r2, #7
  40dc3e:	2101      	movs	r1, #1
  40dc40:	4c39      	ldr	r4, [pc, #228]	; (40dd28 <DynProtocol_decodeSensorEvent+0x9f0>)
  40dc42:	47a0      	blx	r4
  40dc44:	4603      	mov	r3, r0
  40dc46:	b29a      	uxth	r2, r3
  40dc48:	8bfb      	ldrh	r3, [r7, #30]
  40dc4a:	4413      	add	r3, r2
  40dc4c:	83fb      	strh	r3, [r7, #30]
		
		// confidence
		vSensordata->data.u8[4] = buffer[idx++];
  40dc4e:	8bfb      	ldrh	r3, [r7, #30]
  40dc50:	1c5a      	adds	r2, r3, #1
  40dc52:	83fa      	strh	r2, [r7, #30]
  40dc54:	461a      	mov	r2, r3
  40dc56:	68bb      	ldr	r3, [r7, #8]
  40dc58:	4413      	add	r3, r2
  40dc5a:	781a      	ldrb	r2, [r3, #0]
  40dc5c:	697b      	ldr	r3, [r7, #20]
  40dc5e:	731a      	strb	r2, [r3, #12]

		// sqi
		vSensordata->data.u8[5] = buffer[idx++];
  40dc60:	8bfb      	ldrh	r3, [r7, #30]
  40dc62:	1c5a      	adds	r2, r3, #1
  40dc64:	83fa      	strh	r2, [r7, #30]
  40dc66:	461a      	mov	r2, r3
  40dc68:	68bb      	ldr	r3, [r7, #8]
  40dc6a:	4413      	add	r3, r2
  40dc6c:	781a      	ldrb	r2, [r3, #0]
  40dc6e:	697b      	ldr	r3, [r7, #20]
  40dc70:	735a      	strb	r2, [r3, #13]

		break;
  40dc72:	e04a      	b.n	40dd0a <DynProtocol_decodeSensorEvent+0x9d2>
	}

	case DYN_PRO_SENSOR_TYPE_HRV:
	{
		// RR_count
		vSensordata->data.u8[0] = buffer[idx];
  40dc74:	8bfb      	ldrh	r3, [r7, #30]
  40dc76:	68ba      	ldr	r2, [r7, #8]
  40dc78:	4413      	add	r3, r2
  40dc7a:	781a      	ldrb	r2, [r3, #0]
  40dc7c:	697b      	ldr	r3, [r7, #20]
  40dc7e:	721a      	strb	r2, [r3, #8]
		idx += 1;
  40dc80:	8bfb      	ldrh	r3, [r7, #30]
  40dc82:	3301      	adds	r3, #1
  40dc84:	83fb      	strh	r3, [r7, #30]

		// paddingDummy
		vSensordata->data.u8[1] = buffer[idx];
  40dc86:	8bfb      	ldrh	r3, [r7, #30]
  40dc88:	68ba      	ldr	r2, [r7, #8]
  40dc8a:	4413      	add	r3, r2
  40dc8c:	781a      	ldrb	r2, [r3, #0]
  40dc8e:	697b      	ldr	r3, [r7, #20]
  40dc90:	725a      	strb	r2, [r3, #9]
		idx += 1;
  40dc92:	8bfb      	ldrh	r3, [r7, #30]
  40dc94:	3301      	adds	r3, #1
  40dc96:	83fb      	strh	r3, [r7, #30]
		
		// RR_interval
		for (i=0; i<4; i++) {
  40dc98:	2300      	movs	r3, #0
  40dc9a:	83bb      	strh	r3, [r7, #28]
  40dc9c:	e013      	b.n	40dcc6 <DynProtocol_decodeSensorEvent+0x98e>
			vSensordata->data.u16[i + 1] = inv_dc_le_to_int16(&buffer[idx]);
  40dc9e:	8bbb      	ldrh	r3, [r7, #28]
  40dca0:	1c5c      	adds	r4, r3, #1
  40dca2:	8bfb      	ldrh	r3, [r7, #30]
  40dca4:	68ba      	ldr	r2, [r7, #8]
  40dca6:	4413      	add	r3, r2
  40dca8:	4618      	mov	r0, r3
  40dcaa:	4b1e      	ldr	r3, [pc, #120]	; (40dd24 <DynProtocol_decodeSensorEvent+0x9ec>)
  40dcac:	4798      	blx	r3
  40dcae:	4603      	mov	r3, r0
  40dcb0:	b299      	uxth	r1, r3
  40dcb2:	697b      	ldr	r3, [r7, #20]
  40dcb4:	1d22      	adds	r2, r4, #4
  40dcb6:	f823 1012 	strh.w	r1, [r3, r2, lsl #1]
			idx += 2;
  40dcba:	8bfb      	ldrh	r3, [r7, #30]
  40dcbc:	3302      	adds	r3, #2
  40dcbe:	83fb      	strh	r3, [r7, #30]
		for (i=0; i<4; i++) {
  40dcc0:	8bbb      	ldrh	r3, [r7, #28]
  40dcc2:	3301      	adds	r3, #1
  40dcc4:	83bb      	strh	r3, [r7, #28]
  40dcc6:	8bbb      	ldrh	r3, [r7, #28]
  40dcc8:	2b03      	cmp	r3, #3
  40dcca:	d9e8      	bls.n	40dc9e <DynProtocol_decodeSensorEvent+0x966>
		}

		break;
  40dccc:	e01d      	b.n	40dd0a <DynProtocol_decodeSensorEvent+0x9d2>
	}

	case DYN_PRO_SENSOR_TYPE_DATA_ENCRYPTION:
	{
		for (i=0; i<7; i++) {
  40dcce:	2300      	movs	r3, #0
  40dcd0:	83bb      	strh	r3, [r7, #28]
  40dcd2:	e012      	b.n	40dcfa <DynProtocol_decodeSensorEvent+0x9c2>
			vSensordata->data.u32[i] = inv_dc_little8_to_int32(&buffer[idx]);
  40dcd4:	8bbc      	ldrh	r4, [r7, #28]
  40dcd6:	8bfb      	ldrh	r3, [r7, #30]
  40dcd8:	68ba      	ldr	r2, [r7, #8]
  40dcda:	4413      	add	r3, r2
  40dcdc:	4618      	mov	r0, r3
  40dcde:	4b14      	ldr	r3, [pc, #80]	; (40dd30 <DynProtocol_decodeSensorEvent+0x9f8>)
  40dce0:	4798      	blx	r3
  40dce2:	4603      	mov	r3, r0
  40dce4:	4619      	mov	r1, r3
  40dce6:	697b      	ldr	r3, [r7, #20]
  40dce8:	1ca2      	adds	r2, r4, #2
  40dcea:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
			idx += 4;
  40dcee:	8bfb      	ldrh	r3, [r7, #30]
  40dcf0:	3304      	adds	r3, #4
  40dcf2:	83fb      	strh	r3, [r7, #30]
		for (i=0; i<7; i++) {
  40dcf4:	8bbb      	ldrh	r3, [r7, #28]
  40dcf6:	3301      	adds	r3, #1
  40dcf8:	83bb      	strh	r3, [r7, #28]
  40dcfa:	8bbb      	ldrh	r3, [r7, #28]
  40dcfc:	2b06      	cmp	r3, #6
  40dcfe:	d9e9      	bls.n	40dcd4 <DynProtocol_decodeSensorEvent+0x99c>
		}
		
		break;
  40dd00:	e003      	b.n	40dd0a <DynProtocol_decodeSensorEvent+0x9d2>
	}

	default:
		return -1;
  40dd02:	f04f 33ff 	mov.w	r3, #4294967295
  40dd06:	e008      	b.n	40dd1a <DynProtocol_decodeSensorEvent+0x9e2>
		break;
  40dd08:	bf00      	nop
	}

	// check if we did not read more bytes than actually transfered by protocol
	if(idx > size)
  40dd0a:	8bfa      	ldrh	r2, [r7, #30]
  40dd0c:	88fb      	ldrh	r3, [r7, #6]
  40dd0e:	429a      	cmp	r2, r3
  40dd10:	d902      	bls.n	40dd18 <DynProtocol_decodeSensorEvent+0x9e0>
		return -1;
  40dd12:	f04f 33ff 	mov.w	r3, #4294967295
  40dd16:	e000      	b.n	40dd1a <DynProtocol_decodeSensorEvent+0x9e2>

	return 0;
  40dd18:	2300      	movs	r3, #0
}
  40dd1a:	4618      	mov	r0, r3
  40dd1c:	3724      	adds	r7, #36	; 0x24
  40dd1e:	46bd      	mov	sp, r7
  40dd20:	bd90      	pop	{r4, r7, pc}
  40dd22:	bf00      	nop
  40dd24:	0040f857 	.word	0x0040f857
  40dd28:	0040cc9d 	.word	0x0040cc9d
  40dd2c:	00414045 	.word	0x00414045
  40dd30:	0040f807 	.word	0x0040f807

0040dd34 <DynProtocol_decodePktCommand>:

static int DynProtocol_decodePktCommand(DynProtocol_t * self,
		struct DynProtocolEdata * edata)
{
  40dd34:	b590      	push	{r4, r7, lr}
  40dd36:	b089      	sub	sp, #36	; 0x24
  40dd38:	af02      	add	r7, sp, #8
  40dd3a:	6078      	str	r0, [r7, #4]
  40dd3c:	6039      	str	r1, [r7, #0]
	int i, precision;
	const uint8_t * buf = self->decode_state_machine.tmp_buffer;
  40dd3e:	687b      	ldr	r3, [r7, #4]
  40dd40:	3314      	adds	r3, #20
  40dd42:	613b      	str	r3, [r7, #16]

	if(self->decode_state_machine.cmd_id == DYN_PROTOCOL_EID_PROTOCOLVERSION) {
  40dd44:	687b      	ldr	r3, [r7, #4]
  40dd46:	7b9b      	ldrb	r3, [r3, #14]
  40dd48:	2b00      	cmp	r3, #0
  40dd4a:	d103      	bne.n	40dd54 <DynProtocol_decodePktCommand+0x20>
		edata->sensor_id = 0;
  40dd4c:	683b      	ldr	r3, [r7, #0]
  40dd4e:	2200      	movs	r2, #0
  40dd50:	601a      	str	r2, [r3, #0]
  40dd52:	e0e4      	b.n	40df1e <DynProtocol_decodePktCommand+0x1ea>
	}
	else {
		edata->sensor_id = buf[0];
  40dd54:	693b      	ldr	r3, [r7, #16]
  40dd56:	781b      	ldrb	r3, [r3, #0]
  40dd58:	461a      	mov	r2, r3
  40dd5a:	683b      	ldr	r3, [r7, #0]
  40dd5c:	601a      	str	r2, [r3, #0]

		switch(self->decode_state_machine.cmd_id) {
  40dd5e:	687b      	ldr	r3, [r7, #4]
  40dd60:	7b9b      	ldrb	r3, [r3, #14]
  40dd62:	3b1b      	subs	r3, #27
  40dd64:	2b0c      	cmp	r3, #12
  40dd66:	f200 80d9 	bhi.w	40df1c <DynProtocol_decodePktCommand+0x1e8>
  40dd6a:	a201      	add	r2, pc, #4	; (adr r2, 40dd70 <DynProtocol_decodePktCommand+0x3c>)
  40dd6c:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
  40dd70:	0040dda5 	.word	0x0040dda5
  40dd74:	0040ddb9 	.word	0x0040ddb9
  40dd78:	0040df1d 	.word	0x0040df1d
  40dd7c:	0040dea1 	.word	0x0040dea1
  40dd80:	0040de93 	.word	0x0040de93
  40dd84:	0040ddcd 	.word	0x0040ddcd
  40dd88:	0040df1d 	.word	0x0040df1d
  40dd8c:	0040de0d 	.word	0x0040de0d
  40dd90:	0040de17 	.word	0x0040de17
  40dd94:	0040de85 	.word	0x0040de85
  40dd98:	0040ded3 	.word	0x0040ded3
  40dd9c:	0040dee5 	.word	0x0040dee5
  40dda0:	0040deef 	.word	0x0040deef
		case DYN_PROTOCOL_EID_SET_SENSOR_PERIOD:
			edata->d.command.period = (uint32_t)inv_dc_little8_to_int32(&buf[1]);
  40dda4:	693b      	ldr	r3, [r7, #16]
  40dda6:	3301      	adds	r3, #1
  40dda8:	4618      	mov	r0, r3
  40ddaa:	4b5f      	ldr	r3, [pc, #380]	; (40df28 <DynProtocol_decodePktCommand+0x1f4>)
  40ddac:	4798      	blx	r3
  40ddae:	4603      	mov	r3, r0
  40ddb0:	461a      	mov	r2, r3
  40ddb2:	683b      	ldr	r3, [r7, #0]
  40ddb4:	605a      	str	r2, [r3, #4]
			break;
  40ddb6:	e0b2      	b.n	40df1e <DynProtocol_decodePktCommand+0x1ea>

		case DYN_PROTOCOL_EID_SET_SENSOR_TIMEOUT:
			edata->d.command.timeout = (uint32_t)inv_dc_little8_to_int32(&buf[1]);
  40ddb8:	693b      	ldr	r3, [r7, #16]
  40ddba:	3301      	adds	r3, #1
  40ddbc:	4618      	mov	r0, r3
  40ddbe:	4b5a      	ldr	r3, [pc, #360]	; (40df28 <DynProtocol_decodePktCommand+0x1f4>)
  40ddc0:	4798      	blx	r3
  40ddc2:	4603      	mov	r3, r0
  40ddc4:	461a      	mov	r2, r3
  40ddc6:	683b      	ldr	r3, [r7, #0]
  40ddc8:	605a      	str	r2, [r3, #4]
			break;
  40ddca:	e0a8      	b.n	40df1e <DynProtocol_decodePktCommand+0x1ea>

		case DYN_PROTOCOL_EID_SET_SENSOR_MMATRIX:
		{
			edata->d.command.cfg.base.type = buf[1];
  40ddcc:	693b      	ldr	r3, [r7, #16]
  40ddce:	3301      	adds	r3, #1
  40ddd0:	781b      	ldrb	r3, [r3, #0]
  40ddd2:	461a      	mov	r2, r3
  40ddd4:	683b      	ldr	r3, [r7, #0]
  40ddd6:	605a      	str	r2, [r3, #4]
			for (i = 0; i < 9; i++)
  40ddd8:	2300      	movs	r3, #0
  40ddda:	617b      	str	r3, [r7, #20]
  40dddc:	e012      	b.n	40de04 <DynProtocol_decodePktCommand+0xd0>
				((VSensorConfigReferenceFrame *)&edata->d.command.cfg)->matrix[i] = (intq30_t) inv_dc_little8_to_int32(&buf[2 + i * 4]);
  40ddde:	683b      	ldr	r3, [r7, #0]
  40dde0:	1d1c      	adds	r4, r3, #4
  40dde2:	697b      	ldr	r3, [r7, #20]
  40dde4:	009b      	lsls	r3, r3, #2
  40dde6:	3302      	adds	r3, #2
  40dde8:	461a      	mov	r2, r3
  40ddea:	693b      	ldr	r3, [r7, #16]
  40ddec:	4413      	add	r3, r2
  40ddee:	4618      	mov	r0, r3
  40ddf0:	4b4d      	ldr	r3, [pc, #308]	; (40df28 <DynProtocol_decodePktCommand+0x1f4>)
  40ddf2:	4798      	blx	r3
  40ddf4:	4602      	mov	r2, r0
  40ddf6:	697b      	ldr	r3, [r7, #20]
  40ddf8:	3302      	adds	r3, #2
  40ddfa:	f844 2023 	str.w	r2, [r4, r3, lsl #2]
			for (i = 0; i < 9; i++)
  40ddfe:	697b      	ldr	r3, [r7, #20]
  40de00:	3301      	adds	r3, #1
  40de02:	617b      	str	r3, [r7, #20]
  40de04:	697b      	ldr	r3, [r7, #20]
  40de06:	2b08      	cmp	r3, #8
  40de08:	dde9      	ble.n	40ddde <DynProtocol_decodePktCommand+0xaa>
			break;
  40de0a:	e088      	b.n	40df1e <DynProtocol_decodePktCommand+0x1ea>
		}

		case DYN_PROTOCOL_EID_GET_SW_REG:
			edata->d.command.regAddr = buf[1];
  40de0c:	693b      	ldr	r3, [r7, #16]
  40de0e:	785a      	ldrb	r2, [r3, #1]
  40de10:	683b      	ldr	r3, [r7, #0]
  40de12:	711a      	strb	r2, [r3, #4]
			break;
  40de14:	e083      	b.n	40df1e <DynProtocol_decodePktCommand+0x1ea>

		case DYN_PROTOCOL_EID_SET_SENSOR_CFG:
		{
			edata->d.command.cfg.base.type = buf[1];
  40de16:	693b      	ldr	r3, [r7, #16]
  40de18:	3301      	adds	r3, #1
  40de1a:	781b      	ldrb	r3, [r3, #0]
  40de1c:	461a      	mov	r2, r3
  40de1e:	683b      	ldr	r3, [r7, #0]
  40de20:	605a      	str	r2, [r3, #4]
			edata->d.command.cfg.base.size = (uint32_t)buf[2];
  40de22:	693b      	ldr	r3, [r7, #16]
  40de24:	3302      	adds	r3, #2
  40de26:	781b      	ldrb	r3, [r3, #0]
  40de28:	461a      	mov	r2, r3
  40de2a:	683b      	ldr	r3, [r7, #0]
  40de2c:	609a      	str	r2, [r3, #8]

			switch (edata->d.command.cfg.base.type) {
  40de2e:	683b      	ldr	r3, [r7, #0]
  40de30:	685b      	ldr	r3, [r3, #4]
  40de32:	2b03      	cmp	r3, #3
  40de34:	d111      	bne.n	40de5a <DynProtocol_decodePktCommand+0x126>
			case VSENSOR_CONFIG_TYPE_OFFSET:
			{
				precision = DynProtocol_getPrecision(self, edata->sensor_id);
  40de36:	683b      	ldr	r3, [r7, #0]
  40de38:	681b      	ldr	r3, [r3, #0]
  40de3a:	4619      	mov	r1, r3
  40de3c:	6878      	ldr	r0, [r7, #4]
  40de3e:	4b3b      	ldr	r3, [pc, #236]	; (40df2c <DynProtocol_decodePktCommand+0x1f8>)
  40de40:	4798      	blx	r3
  40de42:	60f8      	str	r0, [r7, #12]
				DynProtocol_decodeVect16QxToQy(&buf[3], 3, precision, 16, (int32_t*)&edata->d.command.cfg.buffer[0]);
  40de44:	693b      	ldr	r3, [r7, #16]
  40de46:	1cd8      	adds	r0, r3, #3
  40de48:	683b      	ldr	r3, [r7, #0]
  40de4a:	330c      	adds	r3, #12
  40de4c:	9300      	str	r3, [sp, #0]
  40de4e:	2310      	movs	r3, #16
  40de50:	68fa      	ldr	r2, [r7, #12]
  40de52:	2103      	movs	r1, #3
  40de54:	4c36      	ldr	r4, [pc, #216]	; (40df30 <DynProtocol_decodePktCommand+0x1fc>)
  40de56:	47a0      	blx	r4
				break;
  40de58:	e013      	b.n	40de82 <DynProtocol_decodePktCommand+0x14e>
			}

			default:
				if(buf[2] > sizeof(edata->d.command.cfg.buffer))
  40de5a:	693b      	ldr	r3, [r7, #16]
  40de5c:	3302      	adds	r3, #2
  40de5e:	781b      	ldrb	r3, [r3, #0]
  40de60:	2b40      	cmp	r3, #64	; 0x40
  40de62:	d902      	bls.n	40de6a <DynProtocol_decodePktCommand+0x136>
					return -1;
  40de64:	f04f 33ff 	mov.w	r3, #4294967295
  40de68:	e05a      	b.n	40df20 <DynProtocol_decodePktCommand+0x1ec>

				memcpy(edata->d.command.cfg.buffer, &buf[3], buf[2]);
  40de6a:	683b      	ldr	r3, [r7, #0]
  40de6c:	f103 000c 	add.w	r0, r3, #12
  40de70:	693b      	ldr	r3, [r7, #16]
  40de72:	1cd9      	adds	r1, r3, #3
  40de74:	693b      	ldr	r3, [r7, #16]
  40de76:	3302      	adds	r3, #2
  40de78:	781b      	ldrb	r3, [r3, #0]
  40de7a:	461a      	mov	r2, r3
  40de7c:	4b2d      	ldr	r3, [pc, #180]	; (40df34 <DynProtocol_decodePktCommand+0x200>)
  40de7e:	4798      	blx	r3
				break;
  40de80:	bf00      	nop
			}
			break;
  40de82:	e04c      	b.n	40df1e <DynProtocol_decodePktCommand+0x1ea>
		}

		case DYN_PROTOCOL_EID_GET_SENSOR_CFG:
			edata->d.command.cfg.base.type = buf[1];
  40de84:	693b      	ldr	r3, [r7, #16]
  40de86:	3301      	adds	r3, #1
  40de88:	781b      	ldrb	r3, [r3, #0]
  40de8a:	461a      	mov	r2, r3
  40de8c:	683b      	ldr	r3, [r7, #0]
  40de8e:	605a      	str	r2, [r3, #4]
			break;
  40de90:	e045      	b.n	40df1e <DynProtocol_decodePktCommand+0x1ea>

		case DYN_PROTOCOL_EID_GET_SENSOR_BIAS:
			edata->d.command.cfg.base.type = buf[1];
  40de92:	693b      	ldr	r3, [r7, #16]
  40de94:	3301      	adds	r3, #1
  40de96:	781b      	ldrb	r3, [r3, #0]
  40de98:	461a      	mov	r2, r3
  40de9a:	683b      	ldr	r3, [r7, #0]
  40de9c:	605a      	str	r2, [r3, #4]
			break;
  40de9e:	e03e      	b.n	40df1e <DynProtocol_decodePktCommand+0x1ea>

		case DYN_PROTOCOL_EID_SET_SENSOR_BIAS:
			edata->d.command.cfg.base.type = buf[1];
  40dea0:	693b      	ldr	r3, [r7, #16]
  40dea2:	3301      	adds	r3, #1
  40dea4:	781b      	ldrb	r3, [r3, #0]
  40dea6:	461a      	mov	r2, r3
  40dea8:	683b      	ldr	r3, [r7, #0]
  40deaa:	605a      	str	r2, [r3, #4]
			precision = DynProtocol_getPrecision(self, edata->sensor_id);
  40deac:	683b      	ldr	r3, [r7, #0]
  40deae:	681b      	ldr	r3, [r3, #0]
  40deb0:	4619      	mov	r1, r3
  40deb2:	6878      	ldr	r0, [r7, #4]
  40deb4:	4b1d      	ldr	r3, [pc, #116]	; (40df2c <DynProtocol_decodePktCommand+0x1f8>)
  40deb6:	4798      	blx	r3
  40deb8:	60f8      	str	r0, [r7, #12]
			DynProtocol_decodeVect16QxToQy(&buf[2], 3, precision, 16, &((VSensorConfigOffset *)&edata->d.command.cfg)->vect[0]);
  40deba:	693b      	ldr	r3, [r7, #16]
  40debc:	1c98      	adds	r0, r3, #2
  40debe:	683b      	ldr	r3, [r7, #0]
  40dec0:	3304      	adds	r3, #4
  40dec2:	3308      	adds	r3, #8
  40dec4:	9300      	str	r3, [sp, #0]
  40dec6:	2310      	movs	r3, #16
  40dec8:	68fa      	ldr	r2, [r7, #12]
  40deca:	2103      	movs	r1, #3
  40decc:	4c18      	ldr	r4, [pc, #96]	; (40df30 <DynProtocol_decodePktCommand+0x1fc>)
  40dece:	47a0      	blx	r4
			break;
  40ded0:	e025      	b.n	40df1e <DynProtocol_decodePktCommand+0x1ea>

		case DYN_PROTOCOL_EID_WRITE_MEMS_REG: 
			edata->d.command.memsReg.regAddr = buf[1];
  40ded2:	693b      	ldr	r3, [r7, #16]
  40ded4:	785a      	ldrb	r2, [r3, #1]
  40ded6:	683b      	ldr	r3, [r7, #0]
  40ded8:	711a      	strb	r2, [r3, #4]
			edata->d.command.memsReg.regValue = buf[2];
  40deda:	693b      	ldr	r3, [r7, #16]
  40dedc:	789a      	ldrb	r2, [r3, #2]
  40dede:	683b      	ldr	r3, [r7, #0]
  40dee0:	715a      	strb	r2, [r3, #5]
			break;
  40dee2:	e01c      	b.n	40df1e <DynProtocol_decodePktCommand+0x1ea>
		
		case DYN_PROTOCOL_EID_READ_MEMS_REG: 
			edata->d.command.memsReg.regAddr = buf[1];
  40dee4:	693b      	ldr	r3, [r7, #16]
  40dee6:	785a      	ldrb	r2, [r3, #1]
  40dee8:	683b      	ldr	r3, [r7, #0]
  40deea:	711a      	strb	r2, [r3, #4]
			break;
  40deec:	e017      	b.n	40df1e <DynProtocol_decodePktCommand+0x1ea>
		
		case DYN_PROTOCOL_EID_TRANSFER_BUFFER:
			edata->d.command.buffer.size = buf[0];
  40deee:	693b      	ldr	r3, [r7, #16]
  40def0:	781b      	ldrb	r3, [r3, #0]
  40def2:	b29a      	uxth	r2, r3
  40def4:	683b      	ldr	r3, [r7, #0]
  40def6:	809a      	strh	r2, [r3, #4]
			edata->d.command.buffer.size |= buf[1] << 8;
  40def8:	683b      	ldr	r3, [r7, #0]
  40defa:	889b      	ldrh	r3, [r3, #4]
  40defc:	b21a      	sxth	r2, r3
  40defe:	693b      	ldr	r3, [r7, #16]
  40df00:	3301      	adds	r3, #1
  40df02:	781b      	ldrb	r3, [r3, #0]
  40df04:	021b      	lsls	r3, r3, #8
  40df06:	b21b      	sxth	r3, r3
  40df08:	4313      	orrs	r3, r2
  40df0a:	b21b      	sxth	r3, r3
  40df0c:	b29a      	uxth	r2, r3
  40df0e:	683b      	ldr	r3, [r7, #0]
  40df10:	809a      	strh	r2, [r3, #4]
			edata->d.command.buffer.address = (uint8_t *)&buf[2];
  40df12:	693b      	ldr	r3, [r7, #16]
  40df14:	1c9a      	adds	r2, r3, #2
  40df16:	683b      	ldr	r3, [r7, #0]
  40df18:	609a      	str	r2, [r3, #8]
			break;
  40df1a:	e000      	b.n	40df1e <DynProtocol_decodePktCommand+0x1ea>
		
		default:
			break;
  40df1c:	bf00      	nop
		}
	}

	return 0;
  40df1e:	2300      	movs	r3, #0
}
  40df20:	4618      	mov	r0, r3
  40df22:	371c      	adds	r7, #28
  40df24:	46bd      	mov	sp, r7
  40df26:	bd90      	pop	{r4, r7, pc}
  40df28:	0040f807 	.word	0x0040f807
  40df2c:	0040cda5 	.word	0x0040cda5
  40df30:	0040cc9d 	.word	0x0040cc9d
  40df34:	00414045 	.word	0x00414045

0040df38 <DynProtocol_decodePktResponse>:

static int DynProtocol_decodePktResponse(DynProtocol_t * self,
		struct DynProtocolEdata * edata)
{
  40df38:	b590      	push	{r4, r7, lr}
  40df3a:	b089      	sub	sp, #36	; 0x24
  40df3c:	af02      	add	r7, sp, #8
  40df3e:	6078      	str	r0, [r7, #4]
  40df40:	6039      	str	r1, [r7, #0]
	int precision;
	int rc = 0;
  40df42:	2300      	movs	r3, #0
  40df44:	617b      	str	r3, [r7, #20]
	const uint8_t * buf = self->decode_state_machine.tmp_buffer;
  40df46:	687b      	ldr	r3, [r7, #4]
  40df48:	3314      	adds	r3, #20
  40df4a:	613b      	str	r3, [r7, #16]
	const uint16_t len = self->decode_state_machine.received_size;
  40df4c:	687b      	ldr	r3, [r7, #4]
  40df4e:	8a5b      	ldrh	r3, [r3, #18]
  40df50:	81fb      	strh	r3, [r7, #14]

	switch(self->decode_state_machine.cmd_id) {
  40df52:	687b      	ldr	r3, [r7, #4]
  40df54:	7b9b      	ldrb	r3, [r3, #14]
  40df56:	2b26      	cmp	r3, #38	; 0x26
  40df58:	f200 80e8 	bhi.w	40e12c <DynProtocol_decodePktResponse+0x1f4>
  40df5c:	a201      	add	r2, pc, #4	; (adr r2, 40df64 <DynProtocol_decodePktResponse+0x2c>)
  40df5e:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
  40df62:	bf00      	nop
  40df64:	0040e001 	.word	0x0040e001
  40df68:	0040e12d 	.word	0x0040e12d
  40df6c:	0040e12d 	.word	0x0040e12d
  40df70:	0040e12d 	.word	0x0040e12d
  40df74:	0040e12d 	.word	0x0040e12d
  40df78:	0040e12d 	.word	0x0040e12d
  40df7c:	0040e12d 	.word	0x0040e12d
  40df80:	0040e12d 	.word	0x0040e12d
  40df84:	0040e12d 	.word	0x0040e12d
  40df88:	0040e12d 	.word	0x0040e12d
  40df8c:	0040e12d 	.word	0x0040e12d
  40df90:	0040e12d 	.word	0x0040e12d
  40df94:	0040e12d 	.word	0x0040e12d
  40df98:	0040e12d 	.word	0x0040e12d
  40df9c:	0040e12d 	.word	0x0040e12d
  40dfa0:	0040e12d 	.word	0x0040e12d
  40dfa4:	0040e12d 	.word	0x0040e12d
  40dfa8:	0040e12d 	.word	0x0040e12d
  40dfac:	0040e12d 	.word	0x0040e12d
  40dfb0:	0040e12d 	.word	0x0040e12d
  40dfb4:	0040e12d 	.word	0x0040e12d
  40dfb8:	0040e12d 	.word	0x0040e12d
  40dfbc:	0040e001 	.word	0x0040e001
  40dfc0:	0040e12d 	.word	0x0040e12d
  40dfc4:	0040e12d 	.word	0x0040e12d
  40dfc8:	0040e12d 	.word	0x0040e12d
  40dfcc:	0040e12d 	.word	0x0040e12d
  40dfd0:	0040e12d 	.word	0x0040e12d
  40dfd4:	0040e12d 	.word	0x0040e12d
  40dfd8:	0040e12d 	.word	0x0040e12d
  40dfdc:	0040e12d 	.word	0x0040e12d
  40dfe0:	0040e0cb 	.word	0x0040e0cb
  40dfe4:	0040e12d 	.word	0x0040e12d
  40dfe8:	0040e017 	.word	0x0040e017
  40dfec:	0040e12d 	.word	0x0040e12d
  40dff0:	0040e12d 	.word	0x0040e12d
  40dff4:	0040e043 	.word	0x0040e043
  40dff8:	0040e12d 	.word	0x0040e12d
  40dffc:	0040e117 	.word	0x0040e117
	case DYN_PROTOCOL_EID_PROTOCOLVERSION:
	case DYN_PROTOCOL_EID_GET_FW_INFO:
		memcpy(edata->d.response.version, buf, sizeof(edata->d.response.version) - 1);
  40e000:	683b      	ldr	r3, [r7, #0]
  40e002:	3304      	adds	r3, #4
  40e004:	220f      	movs	r2, #15
  40e006:	6939      	ldr	r1, [r7, #16]
  40e008:	4618      	mov	r0, r3
  40e00a:	4b4f      	ldr	r3, [pc, #316]	; (40e148 <DynProtocol_decodePktResponse+0x210>)
  40e00c:	4798      	blx	r3
		edata->d.response.version[sizeof(edata->d.response.version)-1] = '\0';
  40e00e:	683b      	ldr	r3, [r7, #0]
  40e010:	2200      	movs	r2, #0
  40e012:	74da      	strb	r2, [r3, #19]
		break;
  40e014:	e092      	b.n	40e13c <DynProtocol_decodePktResponse+0x204>

	case DYN_PROTOCOL_EID_GET_SENSOR_DATA:
	{
		edata->d.response.sensorData.rc = (int)(int8_t)buf[0];
  40e016:	693b      	ldr	r3, [r7, #16]
  40e018:	781b      	ldrb	r3, [r3, #0]
  40e01a:	b25b      	sxtb	r3, r3
  40e01c:	461a      	mov	r2, r3
  40e01e:	683b      	ldr	r3, [r7, #0]
  40e020:	605a      	str	r2, [r3, #4]
		if(edata->d.response.sensorData.rc == 0)
  40e022:	683b      	ldr	r3, [r7, #0]
  40e024:	685b      	ldr	r3, [r3, #4]
  40e026:	2b00      	cmp	r3, #0
  40e028:	f040 8087 	bne.w	40e13a <DynProtocol_decodePktResponse+0x202>
			rc = DynProtocol_decodeSensorEvent(self, &buf[1], len, edata, DYN_PROTOCOL_ETYPE_RESP);
  40e02c:	693b      	ldr	r3, [r7, #16]
  40e02e:	1c59      	adds	r1, r3, #1
  40e030:	89fa      	ldrh	r2, [r7, #14]
  40e032:	2301      	movs	r3, #1
  40e034:	9300      	str	r3, [sp, #0]
  40e036:	683b      	ldr	r3, [r7, #0]
  40e038:	6878      	ldr	r0, [r7, #4]
  40e03a:	4c44      	ldr	r4, [pc, #272]	; (40e14c <DynProtocol_decodePktResponse+0x214>)
  40e03c:	47a0      	blx	r4
  40e03e:	6178      	str	r0, [r7, #20]
		break;
  40e040:	e07b      	b.n	40e13a <DynProtocol_decodePktResponse+0x202>
	}

	case DYN_PROTOCOL_EID_GET_SENSOR_CFG:
	{
		edata->d.response.sensorcfg.rc = (int)(int8_t)buf[0];
  40e042:	693b      	ldr	r3, [r7, #16]
  40e044:	781b      	ldrb	r3, [r3, #0]
  40e046:	b25b      	sxtb	r3, r3
  40e048:	461a      	mov	r2, r3
  40e04a:	683b      	ldr	r3, [r7, #0]
  40e04c:	605a      	str	r2, [r3, #4]
		edata->d.response.sensorcfg.cfg.base.type = buf[1];
  40e04e:	693b      	ldr	r3, [r7, #16]
  40e050:	3301      	adds	r3, #1
  40e052:	781b      	ldrb	r3, [r3, #0]
  40e054:	461a      	mov	r2, r3
  40e056:	683b      	ldr	r3, [r7, #0]
  40e058:	609a      	str	r2, [r3, #8]
		edata->d.response.sensorcfg.cfg.base.size = (uint32_t)buf[2];
  40e05a:	693b      	ldr	r3, [r7, #16]
  40e05c:	3302      	adds	r3, #2
  40e05e:	781b      	ldrb	r3, [r3, #0]
  40e060:	461a      	mov	r2, r3
  40e062:	683b      	ldr	r3, [r7, #0]
  40e064:	60da      	str	r2, [r3, #12]

		switch (edata->d.response.sensorcfg.cfg.base.type) {
  40e066:	683b      	ldr	r3, [r7, #0]
  40e068:	689b      	ldr	r3, [r3, #8]
  40e06a:	2b03      	cmp	r3, #3
  40e06c:	d118      	bne.n	40e0a0 <DynProtocol_decodePktResponse+0x168>
		case VSENSOR_CONFIG_TYPE_OFFSET:
		{
			edata->sensor_id = (int)(int8_t)buf[3];
  40e06e:	693b      	ldr	r3, [r7, #16]
  40e070:	3303      	adds	r3, #3
  40e072:	781b      	ldrb	r3, [r3, #0]
  40e074:	b25b      	sxtb	r3, r3
  40e076:	461a      	mov	r2, r3
  40e078:	683b      	ldr	r3, [r7, #0]
  40e07a:	601a      	str	r2, [r3, #0]
			precision = DynProtocol_getPrecision(self, edata->sensor_id);
  40e07c:	683b      	ldr	r3, [r7, #0]
  40e07e:	681b      	ldr	r3, [r3, #0]
  40e080:	4619      	mov	r1, r3
  40e082:	6878      	ldr	r0, [r7, #4]
  40e084:	4b32      	ldr	r3, [pc, #200]	; (40e150 <DynProtocol_decodePktResponse+0x218>)
  40e086:	4798      	blx	r3
  40e088:	60b8      	str	r0, [r7, #8]
			DynProtocol_decodeVect16QxToQy(&buf[4], 3, precision, 16, (int32_t*)&edata->d.response.sensorcfg.cfg.buffer[0]);
  40e08a:	693b      	ldr	r3, [r7, #16]
  40e08c:	1d18      	adds	r0, r3, #4
  40e08e:	683b      	ldr	r3, [r7, #0]
  40e090:	3310      	adds	r3, #16
  40e092:	9300      	str	r3, [sp, #0]
  40e094:	2310      	movs	r3, #16
  40e096:	68ba      	ldr	r2, [r7, #8]
  40e098:	2103      	movs	r1, #3
  40e09a:	4c2e      	ldr	r4, [pc, #184]	; (40e154 <DynProtocol_decodePktResponse+0x21c>)
  40e09c:	47a0      	blx	r4
			break;
  40e09e:	e013      	b.n	40e0c8 <DynProtocol_decodePktResponse+0x190>
		}

		default:
			if(buf[2] > sizeof(edata->d.response.sensorcfg.cfg.buffer))
  40e0a0:	693b      	ldr	r3, [r7, #16]
  40e0a2:	3302      	adds	r3, #2
  40e0a4:	781b      	ldrb	r3, [r3, #0]
  40e0a6:	2b40      	cmp	r3, #64	; 0x40
  40e0a8:	d902      	bls.n	40e0b0 <DynProtocol_decodePktResponse+0x178>
				return -1;
  40e0aa:	f04f 33ff 	mov.w	r3, #4294967295
  40e0ae:	e046      	b.n	40e13e <DynProtocol_decodePktResponse+0x206>

			memcpy(edata->d.response.sensorcfg.cfg.buffer, &buf[3], buf[2]);
  40e0b0:	683b      	ldr	r3, [r7, #0]
  40e0b2:	f103 0010 	add.w	r0, r3, #16
  40e0b6:	693b      	ldr	r3, [r7, #16]
  40e0b8:	1cd9      	adds	r1, r3, #3
  40e0ba:	693b      	ldr	r3, [r7, #16]
  40e0bc:	3302      	adds	r3, #2
  40e0be:	781b      	ldrb	r3, [r3, #0]
  40e0c0:	461a      	mov	r2, r3
  40e0c2:	4b21      	ldr	r3, [pc, #132]	; (40e148 <DynProtocol_decodePktResponse+0x210>)
  40e0c4:	4798      	blx	r3
			break;
  40e0c6:	bf00      	nop
		}

		break;
  40e0c8:	e038      	b.n	40e13c <DynProtocol_decodePktResponse+0x204>
	}

	case DYN_PROTOCOL_EID_GET_SENSOR_BIAS:
		edata->d.response.sensorcfg.rc = (int)(int8_t)buf[0];
  40e0ca:	693b      	ldr	r3, [r7, #16]
  40e0cc:	781b      	ldrb	r3, [r3, #0]
  40e0ce:	b25b      	sxtb	r3, r3
  40e0d0:	461a      	mov	r2, r3
  40e0d2:	683b      	ldr	r3, [r7, #0]
  40e0d4:	605a      	str	r2, [r3, #4]
		edata->sensor_id = (int)(int8_t)buf[1];
  40e0d6:	693b      	ldr	r3, [r7, #16]
  40e0d8:	3301      	adds	r3, #1
  40e0da:	781b      	ldrb	r3, [r3, #0]
  40e0dc:	b25b      	sxtb	r3, r3
  40e0de:	461a      	mov	r2, r3
  40e0e0:	683b      	ldr	r3, [r7, #0]
  40e0e2:	601a      	str	r2, [r3, #0]
		edata->d.response.sensorcfg.cfg.base.type = buf[2];
  40e0e4:	693b      	ldr	r3, [r7, #16]
  40e0e6:	3302      	adds	r3, #2
  40e0e8:	781b      	ldrb	r3, [r3, #0]
  40e0ea:	461a      	mov	r2, r3
  40e0ec:	683b      	ldr	r3, [r7, #0]
  40e0ee:	609a      	str	r2, [r3, #8]
		precision = DynProtocol_getPrecision(self, edata->sensor_id);
  40e0f0:	683b      	ldr	r3, [r7, #0]
  40e0f2:	681b      	ldr	r3, [r3, #0]
  40e0f4:	4619      	mov	r1, r3
  40e0f6:	6878      	ldr	r0, [r7, #4]
  40e0f8:	4b15      	ldr	r3, [pc, #84]	; (40e150 <DynProtocol_decodePktResponse+0x218>)
  40e0fa:	4798      	blx	r3
  40e0fc:	60b8      	str	r0, [r7, #8]
		DynProtocol_decodeVect16QxToQy(&buf[3], 3, precision, 16, &((VSensorConfigOffset *)&edata->d.response.sensorcfg.cfg)->vect[0]);
  40e0fe:	693b      	ldr	r3, [r7, #16]
  40e100:	1cd8      	adds	r0, r3, #3
  40e102:	683b      	ldr	r3, [r7, #0]
  40e104:	3308      	adds	r3, #8
  40e106:	3308      	adds	r3, #8
  40e108:	9300      	str	r3, [sp, #0]
  40e10a:	2310      	movs	r3, #16
  40e10c:	68ba      	ldr	r2, [r7, #8]
  40e10e:	2103      	movs	r1, #3
  40e110:	4c10      	ldr	r4, [pc, #64]	; (40e154 <DynProtocol_decodePktResponse+0x21c>)
  40e112:	47a0      	blx	r4
		break;
  40e114:	e012      	b.n	40e13c <DynProtocol_decodePktResponse+0x204>

	case DYN_PROTOCOL_EID_READ_MEMS_REG:
		edata->d.response.memsReg.rc = (int)(int8_t)buf[0];
  40e116:	693b      	ldr	r3, [r7, #16]
  40e118:	781b      	ldrb	r3, [r3, #0]
  40e11a:	b25b      	sxtb	r3, r3
  40e11c:	461a      	mov	r2, r3
  40e11e:	683b      	ldr	r3, [r7, #0]
  40e120:	605a      	str	r2, [r3, #4]
		edata->d.response.memsReg.regValue = buf[1];
  40e122:	693b      	ldr	r3, [r7, #16]
  40e124:	785a      	ldrb	r2, [r3, #1]
  40e126:	683b      	ldr	r3, [r7, #0]
  40e128:	721a      	strb	r2, [r3, #8]
		break;
  40e12a:	e007      	b.n	40e13c <DynProtocol_decodePktResponse+0x204>

	default:
		edata->d.response.rc = (int)(int8_t)buf[0];
  40e12c:	693b      	ldr	r3, [r7, #16]
  40e12e:	781b      	ldrb	r3, [r3, #0]
  40e130:	b25b      	sxtb	r3, r3
  40e132:	461a      	mov	r2, r3
  40e134:	683b      	ldr	r3, [r7, #0]
  40e136:	605a      	str	r2, [r3, #4]
  40e138:	e000      	b.n	40e13c <DynProtocol_decodePktResponse+0x204>
		break;
  40e13a:	bf00      	nop
	}

	return rc;
  40e13c:	697b      	ldr	r3, [r7, #20]
}
  40e13e:	4618      	mov	r0, r3
  40e140:	371c      	adds	r7, #28
  40e142:	46bd      	mov	sp, r7
  40e144:	bd90      	pop	{r4, r7, pc}
  40e146:	bf00      	nop
  40e148:	00414045 	.word	0x00414045
  40e14c:	0040d339 	.word	0x0040d339
  40e150:	0040cda5 	.word	0x0040cda5
  40e154:	0040cc9d 	.word	0x0040cc9d

0040e158 <DynProtocol_decodePktAsync>:

static int DynProtocol_decodePktAsync(DynProtocol_t * self,
		struct DynProtocolEdata * edata)
{
  40e158:	b590      	push	{r4, r7, lr}
  40e15a:	b087      	sub	sp, #28
  40e15c:	af02      	add	r7, sp, #8
  40e15e:	6078      	str	r0, [r7, #4]
  40e160:	6039      	str	r1, [r7, #0]
	const uint8_t * buf = self->decode_state_machine.tmp_buffer;
  40e162:	687b      	ldr	r3, [r7, #4]
  40e164:	3314      	adds	r3, #20
  40e166:	60fb      	str	r3, [r7, #12]
	const uint16_t len = self->decode_state_machine.received_size;
  40e168:	687b      	ldr	r3, [r7, #4]
  40e16a:	8a5b      	ldrh	r3, [r3, #18]
  40e16c:	817b      	strh	r3, [r7, #10]

	switch(self->decode_state_machine.cmd_id) {
  40e16e:	687b      	ldr	r3, [r7, #4]
  40e170:	7b9b      	ldrb	r3, [r3, #14]
  40e172:	2b30      	cmp	r3, #48	; 0x30
  40e174:	d109      	bne.n	40e18a <DynProtocol_decodePktAsync+0x32>
	case DYN_PROTOCOL_EID_NEW_SENSOR_DATA:
		return DynProtocol_decodeSensorEvent(self, buf, len, edata, DYN_PROTOCOL_ETYPE_ASYNC);
  40e176:	897a      	ldrh	r2, [r7, #10]
  40e178:	2302      	movs	r3, #2
  40e17a:	9300      	str	r3, [sp, #0]
  40e17c:	683b      	ldr	r3, [r7, #0]
  40e17e:	68f9      	ldr	r1, [r7, #12]
  40e180:	6878      	ldr	r0, [r7, #4]
  40e182:	4c05      	ldr	r4, [pc, #20]	; (40e198 <DynProtocol_decodePktAsync+0x40>)
  40e184:	47a0      	blx	r4
  40e186:	4603      	mov	r3, r0
  40e188:	e001      	b.n	40e18e <DynProtocol_decodePktAsync+0x36>

	default:
		return -1;
  40e18a:	f04f 33ff 	mov.w	r3, #4294967295
	}
}
  40e18e:	4618      	mov	r0, r3
  40e190:	3714      	adds	r7, #20
  40e192:	46bd      	mov	sp, r7
  40e194:	bd90      	pop	{r4, r7, pc}
  40e196:	bf00      	nop
  40e198:	0040d339 	.word	0x0040d339

0040e19c <DynProtocol_callEventCB>:
static inline void DynProtocol_callEventCB(DynProtocol_t * self,
	enum DynProtocolEtype etype,
	enum DynProtocolEid eid,
	const DynProtocolEdata_t * edata
)
{
  40e19c:	b590      	push	{r4, r7, lr}
  40e19e:	b085      	sub	sp, #20
  40e1a0:	af00      	add	r7, sp, #0
  40e1a2:	60f8      	str	r0, [r7, #12]
  40e1a4:	607b      	str	r3, [r7, #4]
  40e1a6:	460b      	mov	r3, r1
  40e1a8:	72fb      	strb	r3, [r7, #11]
  40e1aa:	4613      	mov	r3, r2
  40e1ac:	72bb      	strb	r3, [r7, #10]
	if(self->event_cb) {
  40e1ae:	68fb      	ldr	r3, [r7, #12]
  40e1b0:	681b      	ldr	r3, [r3, #0]
  40e1b2:	2b00      	cmp	r3, #0
  40e1b4:	d007      	beq.n	40e1c6 <DynProtocol_callEventCB+0x2a>
		self->event_cb(etype, eid, edata, self->event_cb_cookie);
  40e1b6:	68fb      	ldr	r3, [r7, #12]
  40e1b8:	681c      	ldr	r4, [r3, #0]
  40e1ba:	68fb      	ldr	r3, [r7, #12]
  40e1bc:	685b      	ldr	r3, [r3, #4]
  40e1be:	7ab9      	ldrb	r1, [r7, #10]
  40e1c0:	7af8      	ldrb	r0, [r7, #11]
  40e1c2:	687a      	ldr	r2, [r7, #4]
  40e1c4:	47a0      	blx	r4
	}
}
  40e1c6:	bf00      	nop
  40e1c8:	3714      	adds	r7, #20
  40e1ca:	46bd      	mov	sp, r7
  40e1cc:	bd90      	pop	{r4, r7, pc}
	...

0040e1d0 <DynProtocol_doProcess>:

static int DynProtocol_doProcess(DynProtocol_t * self)
{
  40e1d0:	b590      	push	{r4, r7, lr}
  40e1d2:	b0a7      	sub	sp, #156	; 0x9c
  40e1d4:	af00      	add	r7, sp, #0
  40e1d6:	6078      	str	r0, [r7, #4]
	struct DynProtocolEdata edata;
	enum DynProtocolEtype etype;
	int rc;

	self->decode_state_machine.state = PROTOCOL_STATE_IDLE;
  40e1d8:	687b      	ldr	r3, [r7, #4]
  40e1da:	2200      	movs	r2, #0
  40e1dc:	721a      	strb	r2, [r3, #8]

	switch(self->decode_state_machine.event_type) {
  40e1de:	687b      	ldr	r3, [r7, #4]
  40e1e0:	7b1b      	ldrb	r3, [r3, #12]
  40e1e2:	2b40      	cmp	r3, #64	; 0x40
  40e1e4:	d00f      	beq.n	40e206 <DynProtocol_doProcess+0x36>
  40e1e6:	2b80      	cmp	r3, #128	; 0x80
  40e1e8:	d019      	beq.n	40e21e <DynProtocol_doProcess+0x4e>
  40e1ea:	2b00      	cmp	r3, #0
  40e1ec:	d123      	bne.n	40e236 <DynProtocol_doProcess+0x66>
	case EVENT_TYPE_CMD:
		rc = DynProtocol_decodePktCommand(self, &edata);
  40e1ee:	f107 030c 	add.w	r3, r7, #12
  40e1f2:	4619      	mov	r1, r3
  40e1f4:	6878      	ldr	r0, [r7, #4]
  40e1f6:	4b20      	ldr	r3, [pc, #128]	; (40e278 <DynProtocol_doProcess+0xa8>)
  40e1f8:	4798      	blx	r3
  40e1fa:	f8c7 0090 	str.w	r0, [r7, #144]	; 0x90
		etype = DYN_PROTOCOL_ETYPE_CMD;
  40e1fe:	2300      	movs	r3, #0
  40e200:	f887 3097 	strb.w	r3, [r7, #151]	; 0x97
		break;
  40e204:	e01e      	b.n	40e244 <DynProtocol_doProcess+0x74>

	case EVENT_TYPE_RESP:
		rc = DynProtocol_decodePktResponse(self, &edata);
  40e206:	f107 030c 	add.w	r3, r7, #12
  40e20a:	4619      	mov	r1, r3
  40e20c:	6878      	ldr	r0, [r7, #4]
  40e20e:	4b1b      	ldr	r3, [pc, #108]	; (40e27c <DynProtocol_doProcess+0xac>)
  40e210:	4798      	blx	r3
  40e212:	f8c7 0090 	str.w	r0, [r7, #144]	; 0x90
		etype = DYN_PROTOCOL_ETYPE_RESP;
  40e216:	2301      	movs	r3, #1
  40e218:	f887 3097 	strb.w	r3, [r7, #151]	; 0x97
		break;
  40e21c:	e012      	b.n	40e244 <DynProtocol_doProcess+0x74>

	case EVENT_TYPE_ASYNC:
		rc = DynProtocol_decodePktAsync(self, &edata);
  40e21e:	f107 030c 	add.w	r3, r7, #12
  40e222:	4619      	mov	r1, r3
  40e224:	6878      	ldr	r0, [r7, #4]
  40e226:	4b16      	ldr	r3, [pc, #88]	; (40e280 <DynProtocol_doProcess+0xb0>)
  40e228:	4798      	blx	r3
  40e22a:	f8c7 0090 	str.w	r0, [r7, #144]	; 0x90
		etype = DYN_PROTOCOL_ETYPE_ASYNC;
  40e22e:	2302      	movs	r3, #2
  40e230:	f887 3097 	strb.w	r3, [r7, #151]	; 0x97
		break;
  40e234:	e006      	b.n	40e244 <DynProtocol_doProcess+0x74>

	default:
		INV_MSG(INV_MSG_LEVEL_WARNING, "DynProtocol: Unexpected packet type");
  40e236:	4913      	ldr	r1, [pc, #76]	; (40e284 <DynProtocol_doProcess+0xb4>)
  40e238:	2002      	movs	r0, #2
  40e23a:	4b13      	ldr	r3, [pc, #76]	; (40e288 <DynProtocol_doProcess+0xb8>)
  40e23c:	4798      	blx	r3
		return -1;
  40e23e:	f04f 33ff 	mov.w	r3, #4294967295
  40e242:	e014      	b.n	40e26e <DynProtocol_doProcess+0x9e>
	}

	if(rc == 0) {
  40e244:	f8d7 3090 	ldr.w	r3, [r7, #144]	; 0x90
  40e248:	2b00      	cmp	r3, #0
  40e24a:	d10a      	bne.n	40e262 <DynProtocol_doProcess+0x92>
		DynProtocol_callEventCB(self, etype, (enum DynProtocolEid)self->decode_state_machine.cmd_id, &edata);
  40e24c:	687b      	ldr	r3, [r7, #4]
  40e24e:	7b9a      	ldrb	r2, [r3, #14]
  40e250:	f107 030c 	add.w	r3, r7, #12
  40e254:	f897 1097 	ldrb.w	r1, [r7, #151]	; 0x97
  40e258:	6878      	ldr	r0, [r7, #4]
  40e25a:	4c0c      	ldr	r4, [pc, #48]	; (40e28c <DynProtocol_doProcess+0xbc>)
  40e25c:	47a0      	blx	r4
		return 1;
  40e25e:	2301      	movs	r3, #1
  40e260:	e005      	b.n	40e26e <DynProtocol_doProcess+0x9e>
	} else {
		INV_MSG(INV_MSG_LEVEL_ERROR, "DynProtocol: Unexpected packet received.");
  40e262:	490b      	ldr	r1, [pc, #44]	; (40e290 <DynProtocol_doProcess+0xc0>)
  40e264:	2001      	movs	r0, #1
  40e266:	4b08      	ldr	r3, [pc, #32]	; (40e288 <DynProtocol_doProcess+0xb8>)
  40e268:	4798      	blx	r3
	}

	return rc;
  40e26a:	f8d7 3090 	ldr.w	r3, [r7, #144]	; 0x90
}
  40e26e:	4618      	mov	r0, r3
  40e270:	379c      	adds	r7, #156	; 0x9c
  40e272:	46bd      	mov	sp, r7
  40e274:	bd90      	pop	{r4, r7, pc}
  40e276:	bf00      	nop
  40e278:	0040dd35 	.word	0x0040dd35
  40e27c:	0040df39 	.word	0x0040df39
  40e280:	0040e159 	.word	0x0040e159
  40e284:	0041ca78 	.word	0x0041ca78
  40e288:	0040fd19 	.word	0x0040fd19
  40e28c:	0040e19d 	.word	0x0040e19d
  40e290:	0041ca9c 	.word	0x0041ca9c

0040e294 <DynProtocol_encodeSensorEvent>:

static int DynProtocol_encodeSensorEvent(DynProtocol_t * self, const DynProtocolEdata_t *edata,
		uint8_t * outBuffer, uint16_t maxBufferSize, enum DynProtocolEtype etype)
{
  40e294:	b590      	push	{r4, r7, lr}
  40e296:	b08b      	sub	sp, #44	; 0x2c
  40e298:	af02      	add	r7, sp, #8
  40e29a:	60f8      	str	r0, [r7, #12]
  40e29c:	60b9      	str	r1, [r7, #8]
  40e29e:	607a      	str	r2, [r7, #4]
  40e2a0:	807b      	strh	r3, [r7, #2]
	uint16_t idx = 0, i=0;
  40e2a2:	2300      	movs	r3, #0
  40e2a4:	83fb      	strh	r3, [r7, #30]
  40e2a6:	2300      	movs	r3, #0
  40e2a8:	83bb      	strh	r3, [r7, #28]
	uint32_t sensorStatus;
	uint32_t timestamp;
	const VSensorDataAny *vSensordata;

	switch(etype) {
  40e2aa:	f897 3030 	ldrb.w	r3, [r7, #48]	; 0x30
  40e2ae:	2b01      	cmp	r3, #1
  40e2b0:	d002      	beq.n	40e2b8 <DynProtocol_encodeSensorEvent+0x24>
  40e2b2:	2b02      	cmp	r3, #2
  40e2b4:	d007      	beq.n	40e2c6 <DynProtocol_encodeSensorEvent+0x32>
  40e2b6:	e00d      	b.n	40e2d4 <DynProtocol_encodeSensorEvent+0x40>
	case DYN_PROTOCOL_ETYPE_RESP:
		sensorStatus = edata->d.response.sensorData.status;
  40e2b8:	68bb      	ldr	r3, [r7, #8]
  40e2ba:	689b      	ldr	r3, [r3, #8]
  40e2bc:	61bb      	str	r3, [r7, #24]
		vSensordata = &edata->d.response.sensorData.vdata;
  40e2be:	68bb      	ldr	r3, [r7, #8]
  40e2c0:	330c      	adds	r3, #12
  40e2c2:	617b      	str	r3, [r7, #20]
		break;
  40e2c4:	e00a      	b.n	40e2dc <DynProtocol_encodeSensorEvent+0x48>

	case DYN_PROTOCOL_ETYPE_ASYNC:
		sensorStatus = edata->d.async.sensorEvent.status;
  40e2c6:	68bb      	ldr	r3, [r7, #8]
  40e2c8:	685b      	ldr	r3, [r3, #4]
  40e2ca:	61bb      	str	r3, [r7, #24]
		vSensordata = &edata->d.async.sensorEvent.vdata;
  40e2cc:	68bb      	ldr	r3, [r7, #8]
  40e2ce:	3308      	adds	r3, #8
  40e2d0:	617b      	str	r3, [r7, #20]
		break;
  40e2d2:	e003      	b.n	40e2dc <DynProtocol_encodeSensorEvent+0x48>

	case DYN_PROTOCOL_ETYPE_CMD:
	default:
		return INV_ERROR_BAD_ARG;
  40e2d4:	f06f 030a 	mvn.w	r3, #10
  40e2d8:	f000 be00 	b.w	40eedc <DynProtocol_encodeSensorEvent+0xc48>
	}

	timestamp = (uint32_t)vSensordata->base.timestamp;
  40e2dc:	697b      	ldr	r3, [r7, #20]
  40e2de:	681b      	ldr	r3, [r3, #0]
  40e2e0:	613b      	str	r3, [r7, #16]

	if(maxBufferSize < 4) {
  40e2e2:	887b      	ldrh	r3, [r7, #2]
  40e2e4:	2b03      	cmp	r3, #3
  40e2e6:	f240 85b4 	bls.w	40ee52 <DynProtocol_encodeSensorEvent+0xbbe>
		goto error_size;
	}

	outBuffer[idx] = (uint8_t)(sensorStatus & 0x03);
  40e2ea:	8bfb      	ldrh	r3, [r7, #30]
  40e2ec:	687a      	ldr	r2, [r7, #4]
  40e2ee:	4413      	add	r3, r2
  40e2f0:	69ba      	ldr	r2, [r7, #24]
  40e2f2:	b2d2      	uxtb	r2, r2
  40e2f4:	f002 0203 	and.w	r2, r2, #3
  40e2f8:	b2d2      	uxtb	r2, r2
  40e2fa:	701a      	strb	r2, [r3, #0]
	idx += 1;
  40e2fc:	8bfb      	ldrh	r3, [r7, #30]
  40e2fe:	3301      	adds	r3, #1
  40e300:	83fb      	strh	r3, [r7, #30]
	outBuffer[idx] = (uint8_t)edata->sensor_id;
  40e302:	8bfb      	ldrh	r3, [r7, #30]
  40e304:	687a      	ldr	r2, [r7, #4]
  40e306:	4413      	add	r3, r2
  40e308:	68ba      	ldr	r2, [r7, #8]
  40e30a:	6812      	ldr	r2, [r2, #0]
  40e30c:	b2d2      	uxtb	r2, r2
  40e30e:	701a      	strb	r2, [r3, #0]
	idx += 1;
  40e310:	8bfb      	ldrh	r3, [r7, #30]
  40e312:	3301      	adds	r3, #1
  40e314:	83fb      	strh	r3, [r7, #30]

	inv_dc_int32_to_little8(timestamp, &outBuffer[idx]);
  40e316:	6938      	ldr	r0, [r7, #16]
  40e318:	8bfb      	ldrh	r3, [r7, #30]
  40e31a:	687a      	ldr	r2, [r7, #4]
  40e31c:	4413      	add	r3, r2
  40e31e:	4619      	mov	r1, r3
  40e320:	4bc1      	ldr	r3, [pc, #772]	; (40e628 <DynProtocol_encodeSensorEvent+0x394>)
  40e322:	4798      	blx	r3
	idx += 4;
  40e324:	8bfb      	ldrh	r3, [r7, #30]
  40e326:	3304      	adds	r3, #4
  40e328:	83fb      	strh	r3, [r7, #30]

	maxBufferSize -= idx;
  40e32a:	887a      	ldrh	r2, [r7, #2]
  40e32c:	8bfb      	ldrh	r3, [r7, #30]
  40e32e:	1ad3      	subs	r3, r2, r3
  40e330:	807b      	strh	r3, [r7, #2]

	switch(edata->sensor_id) {
  40e332:	68bb      	ldr	r3, [r7, #8]
  40e334:	681b      	ldr	r3, [r3, #0]
  40e336:	2b45      	cmp	r3, #69	; 0x45
  40e338:	f200 8585 	bhi.w	40ee46 <DynProtocol_encodeSensorEvent+0xbb2>
  40e33c:	a201      	add	r2, pc, #4	; (adr r2, 40e344 <DynProtocol_encodeSensorEvent+0xb0>)
  40e33e:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
  40e342:	bf00      	nop
  40e344:	0040ee4d 	.word	0x0040ee4d
  40e348:	0040e45d 	.word	0x0040e45d
  40e34c:	0040e4ad 	.word	0x0040e4ad
  40e350:	0040eba5 	.word	0x0040eba5
  40e354:	0040e55f 	.word	0x0040e55f
  40e358:	0040ebeb 	.word	0x0040ebeb
  40e35c:	0040eb83 	.word	0x0040eb83
  40e360:	0040e781 	.word	0x0040e781
  40e364:	0040ec0d 	.word	0x0040ec0d
  40e368:	0040e45d 	.word	0x0040e45d
  40e36c:	0040e45d 	.word	0x0040e45d
  40e370:	0040e677 	.word	0x0040e677
  40e374:	0040ee47 	.word	0x0040ee47
  40e378:	0040e781 	.word	0x0040e781
  40e37c:	0040e4f5 	.word	0x0040e4f5
  40e380:	0040e631 	.word	0x0040e631
  40e384:	0040e5af 	.word	0x0040e5af
  40e388:	0040eb65 	.word	0x0040eb65
  40e38c:	0040eb65 	.word	0x0040eb65
  40e390:	0040eaf9 	.word	0x0040eaf9
  40e394:	0040e677 	.word	0x0040e677
  40e398:	0040ed4d 	.word	0x0040ed4d
  40e39c:	0040eb65 	.word	0x0040eb65
  40e3a0:	0040eb65 	.word	0x0040eb65
  40e3a4:	0040eb65 	.word	0x0040eb65
  40e3a8:	0040eb65 	.word	0x0040eb65
  40e3ac:	0040eb2f 	.word	0x0040eb2f
  40e3b0:	0040ee47 	.word	0x0040ee47
  40e3b4:	0040eb65 	.word	0x0040eb65
  40e3b8:	0040e631 	.word	0x0040e631
  40e3bc:	0040ec51 	.word	0x0040ec51
  40e3c0:	0040e737 	.word	0x0040e737
  40e3c4:	0040e737 	.word	0x0040e737
  40e3c8:	0040e737 	.word	0x0040e737
  40e3cc:	0040e737 	.word	0x0040e737
  40e3d0:	0040e7a5 	.word	0x0040e7a5
  40e3d4:	0040ed13 	.word	0x0040ed13
  40e3d8:	0040ee47 	.word	0x0040ee47
  40e3dc:	0040ee47 	.word	0x0040ee47
  40e3e0:	0040e7c7 	.word	0x0040e7c7
  40e3e4:	0040ed9d 	.word	0x0040ed9d
  40e3e8:	0040e8ad 	.word	0x0040e8ad
  40e3ec:	0040e98b 	.word	0x0040e98b
  40e3f0:	0040e9ad 	.word	0x0040e9ad
  40e3f4:	0040eabf 	.word	0x0040eabf
  40e3f8:	0040e7fb 	.word	0x0040e7fb
  40e3fc:	0040e865 	.word	0x0040e865
  40e400:	0040eb65 	.word	0x0040eb65
  40e404:	0040eb65 	.word	0x0040eb65
  40e408:	0040ecc7 	.word	0x0040ecc7
  40e40c:	0040ecc7 	.word	0x0040ecc7
  40e410:	0040ecc7 	.word	0x0040ecc7
  40e414:	0040ecc7 	.word	0x0040ecc7
  40e418:	0040ecc7 	.word	0x0040ecc7
  40e41c:	0040ecc7 	.word	0x0040ecc7
  40e420:	0040ecc7 	.word	0x0040ecc7
  40e424:	0040ecc7 	.word	0x0040ecc7
  40e428:	0040eb2f 	.word	0x0040eb2f
  40e42c:	0040eb65 	.word	0x0040eb65
  40e430:	0040ee0f 	.word	0x0040ee0f
  40e434:	0040ec2f 	.word	0x0040ec2f
  40e438:	0040e6df 	.word	0x0040e6df
  40e43c:	0040ee47 	.word	0x0040ee47
  40e440:	0040ee47 	.word	0x0040ee47
  40e444:	0040e631 	.word	0x0040e631
  40e448:	0040e631 	.word	0x0040e631
  40e44c:	0040e737 	.word	0x0040e737
  40e450:	0040eb65 	.word	0x0040eb65
  40e454:	0040eb65 	.word	0x0040eb65
  40e458:	0040eb2f 	.word	0x0040eb2f
		break;

	case DYN_PRO_SENSOR_TYPE_ACCELEROMETER:
	case DYN_PRO_SENSOR_TYPE_GRAVITY:
	case DYN_PRO_SENSOR_TYPE_LINEAR_ACCELERATION:
		if(maxBufferSize < 6+1)
  40e45c:	887b      	ldrh	r3, [r7, #2]
  40e45e:	2b06      	cmp	r3, #6
  40e460:	f240 84f9 	bls.w	40ee56 <DynProtocol_encodeSensorEvent+0xbc2>
			goto error_size;
		idx += DynProtocol_encodeQxToQyVect16((int32_t*)&vSensordata->data.u32[0], 3, 16, self->precision.acc, &outBuffer[idx]);
  40e464:	697b      	ldr	r3, [r7, #20]
  40e466:	f103 0008 	add.w	r0, r3, #8
  40e46a:	68fb      	ldr	r3, [r7, #12]
  40e46c:	f893 3294 	ldrb.w	r3, [r3, #660]	; 0x294
  40e470:	4619      	mov	r1, r3
  40e472:	8bfb      	ldrh	r3, [r7, #30]
  40e474:	687a      	ldr	r2, [r7, #4]
  40e476:	4413      	add	r3, r2
  40e478:	9300      	str	r3, [sp, #0]
  40e47a:	460b      	mov	r3, r1
  40e47c:	2210      	movs	r2, #16
  40e47e:	2103      	movs	r1, #3
  40e480:	4c6a      	ldr	r4, [pc, #424]	; (40e62c <DynProtocol_encodeSensorEvent+0x398>)
  40e482:	47a0      	blx	r4
  40e484:	4603      	mov	r3, r0
  40e486:	b29a      	uxth	r2, r3
  40e488:	8bfb      	ldrh	r3, [r7, #30]
  40e48a:	4413      	add	r3, r2
  40e48c:	83fb      	strh	r3, [r7, #30]
		/* report accuracy */
		outBuffer[idx++] = (uint8_t)(vSensordata->base.meta_data & VSENSOR_DATA_ACCURACY_MASK);
  40e48e:	8bfb      	ldrh	r3, [r7, #30]
  40e490:	1c5a      	adds	r2, r3, #1
  40e492:	83fa      	strh	r2, [r7, #30]
  40e494:	461a      	mov	r2, r3
  40e496:	687b      	ldr	r3, [r7, #4]
  40e498:	4413      	add	r3, r2
  40e49a:	697a      	ldr	r2, [r7, #20]
  40e49c:	6852      	ldr	r2, [r2, #4]
  40e49e:	b2d2      	uxtb	r2, r2
  40e4a0:	f002 0207 	and.w	r2, r2, #7
  40e4a4:	b2d2      	uxtb	r2, r2
  40e4a6:	701a      	strb	r2, [r3, #0]
		break;
  40e4a8:	f000 bcd1 	b.w	40ee4e <DynProtocol_encodeSensorEvent+0xbba>

	case DYN_PRO_SENSOR_TYPE_MAGNETOMETER:
		if(maxBufferSize < 6+1)
  40e4ac:	887b      	ldrh	r3, [r7, #2]
  40e4ae:	2b06      	cmp	r3, #6
  40e4b0:	f240 84d3 	bls.w	40ee5a <DynProtocol_encodeSensorEvent+0xbc6>
			goto error_size;
		idx += DynProtocol_encodeQxToQyVect16((int32_t*)&vSensordata->data.u32[0], 3, 16, PROTOCOL_MAGNETOMETER_PRECISION, &outBuffer[idx]);
  40e4b4:	697b      	ldr	r3, [r7, #20]
  40e4b6:	f103 0008 	add.w	r0, r3, #8
  40e4ba:	8bfb      	ldrh	r3, [r7, #30]
  40e4bc:	687a      	ldr	r2, [r7, #4]
  40e4be:	4413      	add	r3, r2
  40e4c0:	9300      	str	r3, [sp, #0]
  40e4c2:	2304      	movs	r3, #4
  40e4c4:	2210      	movs	r2, #16
  40e4c6:	2103      	movs	r1, #3
  40e4c8:	4c58      	ldr	r4, [pc, #352]	; (40e62c <DynProtocol_encodeSensorEvent+0x398>)
  40e4ca:	47a0      	blx	r4
  40e4cc:	4603      	mov	r3, r0
  40e4ce:	b29a      	uxth	r2, r3
  40e4d0:	8bfb      	ldrh	r3, [r7, #30]
  40e4d2:	4413      	add	r3, r2
  40e4d4:	83fb      	strh	r3, [r7, #30]
		outBuffer[idx++] = (uint8_t)(vSensordata->base.meta_data & VSENSOR_DATA_ACCURACY_MASK);
  40e4d6:	8bfb      	ldrh	r3, [r7, #30]
  40e4d8:	1c5a      	adds	r2, r3, #1
  40e4da:	83fa      	strh	r2, [r7, #30]
  40e4dc:	461a      	mov	r2, r3
  40e4de:	687b      	ldr	r3, [r7, #4]
  40e4e0:	4413      	add	r3, r2
  40e4e2:	697a      	ldr	r2, [r7, #20]
  40e4e4:	6852      	ldr	r2, [r2, #4]
  40e4e6:	b2d2      	uxtb	r2, r2
  40e4e8:	f002 0207 	and.w	r2, r2, #7
  40e4ec:	b2d2      	uxtb	r2, r2
  40e4ee:	701a      	strb	r2, [r3, #0]
		break;
  40e4f0:	f000 bcad 	b.w	40ee4e <DynProtocol_encodeSensorEvent+0xbba>

	case DYN_PRO_SENSOR_TYPE_UNCAL_MAGNETOMETER:
		if(maxBufferSize < 13)
  40e4f4:	887b      	ldrh	r3, [r7, #2]
  40e4f6:	2b0c      	cmp	r3, #12
  40e4f8:	f240 84b1 	bls.w	40ee5e <DynProtocol_encodeSensorEvent+0xbca>
			goto error_size;
		// uncalibrated data
		idx += DynProtocol_encodeQxToQyVect16((int32_t*)&vSensordata->data.u32[0], 3, 16, PROTOCOL_MAGNETOMETER_PRECISION, &outBuffer[idx]);
  40e4fc:	697b      	ldr	r3, [r7, #20]
  40e4fe:	f103 0008 	add.w	r0, r3, #8
  40e502:	8bfb      	ldrh	r3, [r7, #30]
  40e504:	687a      	ldr	r2, [r7, #4]
  40e506:	4413      	add	r3, r2
  40e508:	9300      	str	r3, [sp, #0]
  40e50a:	2304      	movs	r3, #4
  40e50c:	2210      	movs	r2, #16
  40e50e:	2103      	movs	r1, #3
  40e510:	4c46      	ldr	r4, [pc, #280]	; (40e62c <DynProtocol_encodeSensorEvent+0x398>)
  40e512:	47a0      	blx	r4
  40e514:	4603      	mov	r3, r0
  40e516:	b29a      	uxth	r2, r3
  40e518:	8bfb      	ldrh	r3, [r7, #30]
  40e51a:	4413      	add	r3, r2
  40e51c:	83fb      	strh	r3, [r7, #30]
		// bias
		idx += DynProtocol_encodeQxToQyVect16((int32_t*)&vSensordata->data.u32[3], 3, 16, PROTOCOL_MAGNETOMETER_PRECISION, &outBuffer[idx]);
  40e51e:	697b      	ldr	r3, [r7, #20]
  40e520:	f103 0014 	add.w	r0, r3, #20
  40e524:	8bfb      	ldrh	r3, [r7, #30]
  40e526:	687a      	ldr	r2, [r7, #4]
  40e528:	4413      	add	r3, r2
  40e52a:	9300      	str	r3, [sp, #0]
  40e52c:	2304      	movs	r3, #4
  40e52e:	2210      	movs	r2, #16
  40e530:	2103      	movs	r1, #3
  40e532:	4c3e      	ldr	r4, [pc, #248]	; (40e62c <DynProtocol_encodeSensorEvent+0x398>)
  40e534:	47a0      	blx	r4
  40e536:	4603      	mov	r3, r0
  40e538:	b29a      	uxth	r2, r3
  40e53a:	8bfb      	ldrh	r3, [r7, #30]
  40e53c:	4413      	add	r3, r2
  40e53e:	83fb      	strh	r3, [r7, #30]
		// accuracy
		outBuffer[idx++] = (uint8_t)(vSensordata->base.meta_data & VSENSOR_DATA_ACCURACY_MASK);
  40e540:	8bfb      	ldrh	r3, [r7, #30]
  40e542:	1c5a      	adds	r2, r3, #1
  40e544:	83fa      	strh	r2, [r7, #30]
  40e546:	461a      	mov	r2, r3
  40e548:	687b      	ldr	r3, [r7, #4]
  40e54a:	4413      	add	r3, r2
  40e54c:	697a      	ldr	r2, [r7, #20]
  40e54e:	6852      	ldr	r2, [r2, #4]
  40e550:	b2d2      	uxtb	r2, r2
  40e552:	f002 0207 	and.w	r2, r2, #7
  40e556:	b2d2      	uxtb	r2, r2
  40e558:	701a      	strb	r2, [r3, #0]
		break;
  40e55a:	f000 bc78 	b.w	40ee4e <DynProtocol_encodeSensorEvent+0xbba>

	case DYN_PRO_SENSOR_TYPE_GYROSCOPE:
		if(maxBufferSize < 6+1)
  40e55e:	887b      	ldrh	r3, [r7, #2]
  40e560:	2b06      	cmp	r3, #6
  40e562:	f240 847e 	bls.w	40ee62 <DynProtocol_encodeSensorEvent+0xbce>
			goto error_size;
		idx += DynProtocol_encodeQxToQyVect16((int32_t*)&vSensordata->data.u32[0], 3, 16, self->precision.gyro, &outBuffer[idx]);
  40e566:	697b      	ldr	r3, [r7, #20]
  40e568:	f103 0008 	add.w	r0, r3, #8
  40e56c:	68fb      	ldr	r3, [r7, #12]
  40e56e:	f893 3295 	ldrb.w	r3, [r3, #661]	; 0x295
  40e572:	4619      	mov	r1, r3
  40e574:	8bfb      	ldrh	r3, [r7, #30]
  40e576:	687a      	ldr	r2, [r7, #4]
  40e578:	4413      	add	r3, r2
  40e57a:	9300      	str	r3, [sp, #0]
  40e57c:	460b      	mov	r3, r1
  40e57e:	2210      	movs	r2, #16
  40e580:	2103      	movs	r1, #3
  40e582:	4c2a      	ldr	r4, [pc, #168]	; (40e62c <DynProtocol_encodeSensorEvent+0x398>)
  40e584:	47a0      	blx	r4
  40e586:	4603      	mov	r3, r0
  40e588:	b29a      	uxth	r2, r3
  40e58a:	8bfb      	ldrh	r3, [r7, #30]
  40e58c:	4413      	add	r3, r2
  40e58e:	83fb      	strh	r3, [r7, #30]
		outBuffer[idx++] = (uint8_t)(vSensordata->base.meta_data & VSENSOR_DATA_ACCURACY_MASK);
  40e590:	8bfb      	ldrh	r3, [r7, #30]
  40e592:	1c5a      	adds	r2, r3, #1
  40e594:	83fa      	strh	r2, [r7, #30]
  40e596:	461a      	mov	r2, r3
  40e598:	687b      	ldr	r3, [r7, #4]
  40e59a:	4413      	add	r3, r2
  40e59c:	697a      	ldr	r2, [r7, #20]
  40e59e:	6852      	ldr	r2, [r2, #4]
  40e5a0:	b2d2      	uxtb	r2, r2
  40e5a2:	f002 0207 	and.w	r2, r2, #7
  40e5a6:	b2d2      	uxtb	r2, r2
  40e5a8:	701a      	strb	r2, [r3, #0]
		break;
  40e5aa:	f000 bc50 	b.w	40ee4e <DynProtocol_encodeSensorEvent+0xbba>

	case DYN_PRO_SENSOR_TYPE_UNCAL_GYROSCOPE:
		if(maxBufferSize < 13)
  40e5ae:	887b      	ldrh	r3, [r7, #2]
  40e5b0:	2b0c      	cmp	r3, #12
  40e5b2:	f240 8458 	bls.w	40ee66 <DynProtocol_encodeSensorEvent+0xbd2>
			goto error_size;
		// uncalibrated data
		idx += DynProtocol_encodeQxToQyVect16((int32_t*)&vSensordata->data.u32[0], 3, 16, self->precision.gyro, &outBuffer[idx]);
  40e5b6:	697b      	ldr	r3, [r7, #20]
  40e5b8:	f103 0008 	add.w	r0, r3, #8
  40e5bc:	68fb      	ldr	r3, [r7, #12]
  40e5be:	f893 3295 	ldrb.w	r3, [r3, #661]	; 0x295
  40e5c2:	4619      	mov	r1, r3
  40e5c4:	8bfb      	ldrh	r3, [r7, #30]
  40e5c6:	687a      	ldr	r2, [r7, #4]
  40e5c8:	4413      	add	r3, r2
  40e5ca:	9300      	str	r3, [sp, #0]
  40e5cc:	460b      	mov	r3, r1
  40e5ce:	2210      	movs	r2, #16
  40e5d0:	2103      	movs	r1, #3
  40e5d2:	4c16      	ldr	r4, [pc, #88]	; (40e62c <DynProtocol_encodeSensorEvent+0x398>)
  40e5d4:	47a0      	blx	r4
  40e5d6:	4603      	mov	r3, r0
  40e5d8:	b29a      	uxth	r2, r3
  40e5da:	8bfb      	ldrh	r3, [r7, #30]
  40e5dc:	4413      	add	r3, r2
  40e5de:	83fb      	strh	r3, [r7, #30]
		// bias
		idx += DynProtocol_encodeQxToQyVect16((int32_t*)&vSensordata->data.u32[3], 3, 16, self->precision.gyro, &outBuffer[idx]);
  40e5e0:	697b      	ldr	r3, [r7, #20]
  40e5e2:	f103 0014 	add.w	r0, r3, #20
  40e5e6:	68fb      	ldr	r3, [r7, #12]
  40e5e8:	f893 3295 	ldrb.w	r3, [r3, #661]	; 0x295
  40e5ec:	4619      	mov	r1, r3
  40e5ee:	8bfb      	ldrh	r3, [r7, #30]
  40e5f0:	687a      	ldr	r2, [r7, #4]
  40e5f2:	4413      	add	r3, r2
  40e5f4:	9300      	str	r3, [sp, #0]
  40e5f6:	460b      	mov	r3, r1
  40e5f8:	2210      	movs	r2, #16
  40e5fa:	2103      	movs	r1, #3
  40e5fc:	4c0b      	ldr	r4, [pc, #44]	; (40e62c <DynProtocol_encodeSensorEvent+0x398>)
  40e5fe:	47a0      	blx	r4
  40e600:	4603      	mov	r3, r0
  40e602:	b29a      	uxth	r2, r3
  40e604:	8bfb      	ldrh	r3, [r7, #30]
  40e606:	4413      	add	r3, r2
  40e608:	83fb      	strh	r3, [r7, #30]
		// accuracy
		outBuffer[idx++] = (uint8_t)(vSensordata->base.meta_data & VSENSOR_DATA_ACCURACY_MASK);
  40e60a:	8bfb      	ldrh	r3, [r7, #30]
  40e60c:	1c5a      	adds	r2, r3, #1
  40e60e:	83fa      	strh	r2, [r7, #30]
  40e610:	461a      	mov	r2, r3
  40e612:	687b      	ldr	r3, [r7, #4]
  40e614:	4413      	add	r3, r2
  40e616:	697a      	ldr	r2, [r7, #20]
  40e618:	6852      	ldr	r2, [r2, #4]
  40e61a:	b2d2      	uxtb	r2, r2
  40e61c:	f002 0207 	and.w	r2, r2, #7
  40e620:	b2d2      	uxtb	r2, r2
  40e622:	701a      	strb	r2, [r3, #0]
		break;
  40e624:	f000 bc13 	b.w	40ee4e <DynProtocol_encodeSensorEvent+0xbba>
  40e628:	0040f791 	.word	0x0040f791
  40e62c:	0040cd19 	.word	0x0040cd19

	case DYN_PRO_SENSOR_TYPE_3AXIS:
	case DYN_PRO_SENSOR_TYPE_GAME_ROTATION_VECTOR:
	case DYN_PRO_SENSOR_TYPE_PRED_QUAT_0:
	case DYN_PRO_SENSOR_TYPE_PRED_QUAT_1:
		if(maxBufferSize < 9)
  40e630:	887b      	ldrh	r3, [r7, #2]
  40e632:	2b08      	cmp	r3, #8
  40e634:	f240 8419 	bls.w	40ee6a <DynProtocol_encodeSensorEvent+0xbd6>
			goto error_size;
		idx += DynProtocol_encodeQxToQyVect16((int32_t*)&vSensordata->data.u32[0], 4, 30, PROTOCOL_QUATERNION_PRECISION, &outBuffer[idx]);
  40e638:	697b      	ldr	r3, [r7, #20]
  40e63a:	f103 0008 	add.w	r0, r3, #8
  40e63e:	8bfb      	ldrh	r3, [r7, #30]
  40e640:	687a      	ldr	r2, [r7, #4]
  40e642:	4413      	add	r3, r2
  40e644:	9300      	str	r3, [sp, #0]
  40e646:	230e      	movs	r3, #14
  40e648:	221e      	movs	r2, #30
  40e64a:	2104      	movs	r1, #4
  40e64c:	4c94      	ldr	r4, [pc, #592]	; (40e8a0 <DynProtocol_encodeSensorEvent+0x60c>)
  40e64e:	47a0      	blx	r4
  40e650:	4603      	mov	r3, r0
  40e652:	b29a      	uxth	r2, r3
  40e654:	8bfb      	ldrh	r3, [r7, #30]
  40e656:	4413      	add	r3, r2
  40e658:	83fb      	strh	r3, [r7, #30]
		outBuffer[idx++] = (uint8_t)(vSensordata->base.meta_data & VSENSOR_DATA_ACCURACY_MASK);
  40e65a:	8bfb      	ldrh	r3, [r7, #30]
  40e65c:	1c5a      	adds	r2, r3, #1
  40e65e:	83fa      	strh	r2, [r7, #30]
  40e660:	461a      	mov	r2, r3
  40e662:	687b      	ldr	r3, [r7, #4]
  40e664:	4413      	add	r3, r2
  40e666:	697a      	ldr	r2, [r7, #20]
  40e668:	6852      	ldr	r2, [r2, #4]
  40e66a:	b2d2      	uxtb	r2, r2
  40e66c:	f002 0207 	and.w	r2, r2, #7
  40e670:	b2d2      	uxtb	r2, r2
  40e672:	701a      	strb	r2, [r3, #0]
		break;
  40e674:	e3eb      	b.n	40ee4e <DynProtocol_encodeSensorEvent+0xbba>

	case DYN_PRO_SENSOR_TYPE_ROTATION_VECTOR:
	case DYN_PRO_SENSOR_TYPE_GEOMAG_ROTATION_VECTOR:
		if(maxBufferSize < 11)
  40e676:	887b      	ldrh	r3, [r7, #2]
  40e678:	2b0a      	cmp	r3, #10
  40e67a:	f240 83f8 	bls.w	40ee6e <DynProtocol_encodeSensorEvent+0xbda>
			goto error_size;
		// w,x,y,z in Q30
		idx += DynProtocol_encodeQxToQyVect16((int32_t*)&vSensordata->data.u32[0], 4, 30, PROTOCOL_QUATERNION_PRECISION, &outBuffer[idx]);
  40e67e:	697b      	ldr	r3, [r7, #20]
  40e680:	f103 0008 	add.w	r0, r3, #8
  40e684:	8bfb      	ldrh	r3, [r7, #30]
  40e686:	687a      	ldr	r2, [r7, #4]
  40e688:	4413      	add	r3, r2
  40e68a:	9300      	str	r3, [sp, #0]
  40e68c:	230e      	movs	r3, #14
  40e68e:	221e      	movs	r2, #30
  40e690:	2104      	movs	r1, #4
  40e692:	4c83      	ldr	r4, [pc, #524]	; (40e8a0 <DynProtocol_encodeSensorEvent+0x60c>)
  40e694:	47a0      	blx	r4
  40e696:	4603      	mov	r3, r0
  40e698:	b29a      	uxth	r2, r3
  40e69a:	8bfb      	ldrh	r3, [r7, #30]
  40e69c:	4413      	add	r3, r2
  40e69e:	83fb      	strh	r3, [r7, #30]
		// accuracy in q16
		idx += DynProtocol_encodeQxToQyVect16((int32_t*)&vSensordata->data.u32[4], 1, 16, PROTOCOL_HEADING_ACCURACY_PRECISION, &outBuffer[idx]);
  40e6a0:	697b      	ldr	r3, [r7, #20]
  40e6a2:	f103 0018 	add.w	r0, r3, #24
  40e6a6:	8bfb      	ldrh	r3, [r7, #30]
  40e6a8:	687a      	ldr	r2, [r7, #4]
  40e6aa:	4413      	add	r3, r2
  40e6ac:	9300      	str	r3, [sp, #0]
  40e6ae:	2307      	movs	r3, #7
  40e6b0:	2210      	movs	r2, #16
  40e6b2:	2101      	movs	r1, #1
  40e6b4:	4c7a      	ldr	r4, [pc, #488]	; (40e8a0 <DynProtocol_encodeSensorEvent+0x60c>)
  40e6b6:	47a0      	blx	r4
  40e6b8:	4603      	mov	r3, r0
  40e6ba:	b29a      	uxth	r2, r3
  40e6bc:	8bfb      	ldrh	r3, [r7, #30]
  40e6be:	4413      	add	r3, r2
  40e6c0:	83fb      	strh	r3, [r7, #30]
		outBuffer[idx++] = (uint8_t)(vSensordata->base.meta_data & VSENSOR_DATA_ACCURACY_MASK);
  40e6c2:	8bfb      	ldrh	r3, [r7, #30]
  40e6c4:	1c5a      	adds	r2, r3, #1
  40e6c6:	83fa      	strh	r2, [r7, #30]
  40e6c8:	461a      	mov	r2, r3
  40e6ca:	687b      	ldr	r3, [r7, #4]
  40e6cc:	4413      	add	r3, r2
  40e6ce:	697a      	ldr	r2, [r7, #20]
  40e6d0:	6852      	ldr	r2, [r2, #4]
  40e6d2:	b2d2      	uxtb	r2, r2
  40e6d4:	f002 0207 	and.w	r2, r2, #7
  40e6d8:	b2d2      	uxtb	r2, r2
  40e6da:	701a      	strb	r2, [r3, #0]
		break;
  40e6dc:	e3b7      	b.n	40ee4e <DynProtocol_encodeSensorEvent+0xbba>

	case DYN_PRO_SENSOR_TYPE_HIGH_RATE_GYRO:
		// no timestamp
		idx -= 4;
  40e6de:	8bfb      	ldrh	r3, [r7, #30]
  40e6e0:	3b04      	subs	r3, #4
  40e6e2:	83fb      	strh	r3, [r7, #30]
		maxBufferSize += idx;
  40e6e4:	887a      	ldrh	r2, [r7, #2]
  40e6e6:	8bfb      	ldrh	r3, [r7, #30]
  40e6e8:	4413      	add	r3, r2
  40e6ea:	807b      	strh	r3, [r7, #2]
		if(maxBufferSize < 6)
  40e6ec:	887b      	ldrh	r3, [r7, #2]
  40e6ee:	2b05      	cmp	r3, #5
  40e6f0:	f240 83bf 	bls.w	40ee72 <DynProtocol_encodeSensorEvent+0xbde>
			goto error_size;
		inv_dc_int16_to_little8(vSensordata->data.u32[0], &outBuffer[idx]);
  40e6f4:	697b      	ldr	r3, [r7, #20]
  40e6f6:	689b      	ldr	r3, [r3, #8]
  40e6f8:	b218      	sxth	r0, r3
  40e6fa:	8bfb      	ldrh	r3, [r7, #30]
  40e6fc:	687a      	ldr	r2, [r7, #4]
  40e6fe:	4413      	add	r3, r2
  40e700:	4619      	mov	r1, r3
  40e702:	4b68      	ldr	r3, [pc, #416]	; (40e8a4 <DynProtocol_encodeSensorEvent+0x610>)
  40e704:	4798      	blx	r3
		inv_dc_int16_to_little8(vSensordata->data.u32[1], &outBuffer[idx+2]);
  40e706:	697b      	ldr	r3, [r7, #20]
  40e708:	68db      	ldr	r3, [r3, #12]
  40e70a:	b218      	sxth	r0, r3
  40e70c:	8bfb      	ldrh	r3, [r7, #30]
  40e70e:	3302      	adds	r3, #2
  40e710:	687a      	ldr	r2, [r7, #4]
  40e712:	4413      	add	r3, r2
  40e714:	4619      	mov	r1, r3
  40e716:	4b63      	ldr	r3, [pc, #396]	; (40e8a4 <DynProtocol_encodeSensorEvent+0x610>)
  40e718:	4798      	blx	r3
		inv_dc_int16_to_little8(vSensordata->data.u32[2], &outBuffer[idx+4]);
  40e71a:	697b      	ldr	r3, [r7, #20]
  40e71c:	691b      	ldr	r3, [r3, #16]
  40e71e:	b218      	sxth	r0, r3
  40e720:	8bfb      	ldrh	r3, [r7, #30]
  40e722:	3304      	adds	r3, #4
  40e724:	687a      	ldr	r2, [r7, #4]
  40e726:	4413      	add	r3, r2
  40e728:	4619      	mov	r1, r3
  40e72a:	4b5e      	ldr	r3, [pc, #376]	; (40e8a4 <DynProtocol_encodeSensorEvent+0x610>)
  40e72c:	4798      	blx	r3
		idx += 6;
  40e72e:	8bfb      	ldrh	r3, [r7, #30]
  40e730:	3306      	adds	r3, #6
  40e732:	83fb      	strh	r3, [r7, #30]
		break;
  40e734:	e38b      	b.n	40ee4e <DynProtocol_encodeSensorEvent+0xbba>
	case DYN_PRO_SENSOR_TYPE_RAW_ACCELEROMETER:
	case DYN_PRO_SENSOR_TYPE_RAW_GYROSCOPE:
	case DYN_PRO_SENSOR_TYPE_RAW_MAGNETOMETER:
	case DYN_PRO_SENSOR_TYPE_OIS:
	case DYN_PRO_SENSOR_TYPE_OIS_1:
		if(maxBufferSize < 6)
  40e736:	887b      	ldrh	r3, [r7, #2]
  40e738:	2b05      	cmp	r3, #5
  40e73a:	f240 839c 	bls.w	40ee76 <DynProtocol_encodeSensorEvent+0xbe2>
			goto error_size;
		inv_dc_int16_to_little8(vSensordata->data.u32[0], &outBuffer[idx]);
  40e73e:	697b      	ldr	r3, [r7, #20]
  40e740:	689b      	ldr	r3, [r3, #8]
  40e742:	b218      	sxth	r0, r3
  40e744:	8bfb      	ldrh	r3, [r7, #30]
  40e746:	687a      	ldr	r2, [r7, #4]
  40e748:	4413      	add	r3, r2
  40e74a:	4619      	mov	r1, r3
  40e74c:	4b55      	ldr	r3, [pc, #340]	; (40e8a4 <DynProtocol_encodeSensorEvent+0x610>)
  40e74e:	4798      	blx	r3
		inv_dc_int16_to_little8(vSensordata->data.u32[1], &outBuffer[idx+2]);
  40e750:	697b      	ldr	r3, [r7, #20]
  40e752:	68db      	ldr	r3, [r3, #12]
  40e754:	b218      	sxth	r0, r3
  40e756:	8bfb      	ldrh	r3, [r7, #30]
  40e758:	3302      	adds	r3, #2
  40e75a:	687a      	ldr	r2, [r7, #4]
  40e75c:	4413      	add	r3, r2
  40e75e:	4619      	mov	r1, r3
  40e760:	4b50      	ldr	r3, [pc, #320]	; (40e8a4 <DynProtocol_encodeSensorEvent+0x610>)
  40e762:	4798      	blx	r3
		inv_dc_int16_to_little8(vSensordata->data.u32[2], &outBuffer[idx+4]);
  40e764:	697b      	ldr	r3, [r7, #20]
  40e766:	691b      	ldr	r3, [r3, #16]
  40e768:	b218      	sxth	r0, r3
  40e76a:	8bfb      	ldrh	r3, [r7, #30]
  40e76c:	3304      	adds	r3, #4
  40e76e:	687a      	ldr	r2, [r7, #4]
  40e770:	4413      	add	r3, r2
  40e772:	4619      	mov	r1, r3
  40e774:	4b4b      	ldr	r3, [pc, #300]	; (40e8a4 <DynProtocol_encodeSensorEvent+0x610>)
  40e776:	4798      	blx	r3
		idx += 6;
  40e778:	8bfb      	ldrh	r3, [r7, #30]
  40e77a:	3306      	adds	r3, #6
  40e77c:	83fb      	strh	r3, [r7, #30]
		break;
  40e77e:	e366      	b.n	40ee4e <DynProtocol_encodeSensorEvent+0xbba>

	case DYN_PRO_SENSOR_TYPE_TEMPERATURE:
	case DYN_PRO_SENSOR_TYPE_AMBIENT_TEMPERATURE:
		idx += DynProtocol_encodeQxToQyVect16((int32_t*)&vSensordata->data.u32[0], 1, 16, PROTOCOL_TEMPERATURE_PRECISION, &outBuffer[idx]);
  40e780:	697b      	ldr	r3, [r7, #20]
  40e782:	f103 0008 	add.w	r0, r3, #8
  40e786:	8bfb      	ldrh	r3, [r7, #30]
  40e788:	687a      	ldr	r2, [r7, #4]
  40e78a:	4413      	add	r3, r2
  40e78c:	9300      	str	r3, [sp, #0]
  40e78e:	2308      	movs	r3, #8
  40e790:	2210      	movs	r2, #16
  40e792:	2101      	movs	r1, #1
  40e794:	4c42      	ldr	r4, [pc, #264]	; (40e8a0 <DynProtocol_encodeSensorEvent+0x60c>)
  40e796:	47a0      	blx	r4
  40e798:	4603      	mov	r3, r0
  40e79a:	b29a      	uxth	r2, r3
  40e79c:	8bfb      	ldrh	r3, [r7, #30]
  40e79e:	4413      	add	r3, r2
  40e7a0:	83fb      	strh	r3, [r7, #30]
		break;
  40e7a2:	e354      	b.n	40ee4e <DynProtocol_encodeSensorEvent+0xbba>

	case DYN_PRO_SENSOR_TYPE_RAW_TEMPERATURE:
		if(maxBufferSize < 4)
  40e7a4:	887b      	ldrh	r3, [r7, #2]
  40e7a6:	2b03      	cmp	r3, #3
  40e7a8:	f240 8367 	bls.w	40ee7a <DynProtocol_encodeSensorEvent+0xbe6>
			goto error_size;
		inv_dc_int32_to_little8(vSensordata->data.u32[0], &outBuffer[idx]);
  40e7ac:	697b      	ldr	r3, [r7, #20]
  40e7ae:	689b      	ldr	r3, [r3, #8]
  40e7b0:	4618      	mov	r0, r3
  40e7b2:	8bfb      	ldrh	r3, [r7, #30]
  40e7b4:	687a      	ldr	r2, [r7, #4]
  40e7b6:	4413      	add	r3, r2
  40e7b8:	4619      	mov	r1, r3
  40e7ba:	4b3b      	ldr	r3, [pc, #236]	; (40e8a8 <DynProtocol_encodeSensorEvent+0x614>)
  40e7bc:	4798      	blx	r3
		idx += 4;
  40e7be:	8bfb      	ldrh	r3, [r7, #30]
  40e7c0:	3304      	adds	r3, #4
  40e7c2:	83fb      	strh	r3, [r7, #30]
		break;
  40e7c4:	e343      	b.n	40ee4e <DynProtocol_encodeSensorEvent+0xbba>

	case DYN_PRO_SENSOR_TYPE_RAW_PPG:
		if(maxBufferSize < 5)
  40e7c6:	887b      	ldrh	r3, [r7, #2]
  40e7c8:	2b04      	cmp	r3, #4
  40e7ca:	f240 8358 	bls.w	40ee7e <DynProtocol_encodeSensorEvent+0xbea>
			goto error_size;
		inv_dc_int32_to_little8(vSensordata->data.u32[0], &outBuffer[idx]); 
  40e7ce:	697b      	ldr	r3, [r7, #20]
  40e7d0:	689b      	ldr	r3, [r3, #8]
  40e7d2:	4618      	mov	r0, r3
  40e7d4:	8bfb      	ldrh	r3, [r7, #30]
  40e7d6:	687a      	ldr	r2, [r7, #4]
  40e7d8:	4413      	add	r3, r2
  40e7da:	4619      	mov	r1, r3
  40e7dc:	4b32      	ldr	r3, [pc, #200]	; (40e8a8 <DynProtocol_encodeSensorEvent+0x614>)
  40e7de:	4798      	blx	r3
		idx += 4;
  40e7e0:	8bfb      	ldrh	r3, [r7, #30]
  40e7e2:	3304      	adds	r3, #4
  40e7e4:	83fb      	strh	r3, [r7, #30]
		outBuffer[idx] = vSensordata->data.u8[4]; 
  40e7e6:	8bfb      	ldrh	r3, [r7, #30]
  40e7e8:	687a      	ldr	r2, [r7, #4]
  40e7ea:	4413      	add	r3, r2
  40e7ec:	697a      	ldr	r2, [r7, #20]
  40e7ee:	7b12      	ldrb	r2, [r2, #12]
  40e7f0:	701a      	strb	r2, [r3, #0]
		idx += 1;
  40e7f2:	8bfb      	ldrh	r3, [r7, #30]
  40e7f4:	3301      	adds	r3, #1
  40e7f6:	83fb      	strh	r3, [r7, #30]
		break;
  40e7f8:	e329      	b.n	40ee4e <DynProtocol_encodeSensorEvent+0xbba>

	case DYN_PRO_SENSOR_TYPE_ENERGY_EXPENDITURE:
		if(maxBufferSize < 16)
  40e7fa:	887b      	ldrh	r3, [r7, #2]
  40e7fc:	2b0f      	cmp	r3, #15
  40e7fe:	f240 8340 	bls.w	40ee82 <DynProtocol_encodeSensorEvent+0xbee>
			goto error_size;
		inv_dc_int32_to_little8(vSensordata->data.u32[0], &outBuffer[idx]);
  40e802:	697b      	ldr	r3, [r7, #20]
  40e804:	689b      	ldr	r3, [r3, #8]
  40e806:	4618      	mov	r0, r3
  40e808:	8bfb      	ldrh	r3, [r7, #30]
  40e80a:	687a      	ldr	r2, [r7, #4]
  40e80c:	4413      	add	r3, r2
  40e80e:	4619      	mov	r1, r3
  40e810:	4b25      	ldr	r3, [pc, #148]	; (40e8a8 <DynProtocol_encodeSensorEvent+0x614>)
  40e812:	4798      	blx	r3
		idx += 4;
  40e814:	8bfb      	ldrh	r3, [r7, #30]
  40e816:	3304      	adds	r3, #4
  40e818:	83fb      	strh	r3, [r7, #30]
		inv_dc_int32_to_little8(vSensordata->data.u32[1], &outBuffer[idx]);
  40e81a:	697b      	ldr	r3, [r7, #20]
  40e81c:	68db      	ldr	r3, [r3, #12]
  40e81e:	4618      	mov	r0, r3
  40e820:	8bfb      	ldrh	r3, [r7, #30]
  40e822:	687a      	ldr	r2, [r7, #4]
  40e824:	4413      	add	r3, r2
  40e826:	4619      	mov	r1, r3
  40e828:	4b1f      	ldr	r3, [pc, #124]	; (40e8a8 <DynProtocol_encodeSensorEvent+0x614>)
  40e82a:	4798      	blx	r3
		idx += 4;
  40e82c:	8bfb      	ldrh	r3, [r7, #30]
  40e82e:	3304      	adds	r3, #4
  40e830:	83fb      	strh	r3, [r7, #30]
		inv_dc_int32_to_little8(vSensordata->data.u32[2], &outBuffer[idx]);
  40e832:	697b      	ldr	r3, [r7, #20]
  40e834:	691b      	ldr	r3, [r3, #16]
  40e836:	4618      	mov	r0, r3
  40e838:	8bfb      	ldrh	r3, [r7, #30]
  40e83a:	687a      	ldr	r2, [r7, #4]
  40e83c:	4413      	add	r3, r2
  40e83e:	4619      	mov	r1, r3
  40e840:	4b19      	ldr	r3, [pc, #100]	; (40e8a8 <DynProtocol_encodeSensorEvent+0x614>)
  40e842:	4798      	blx	r3
		idx += 4;
  40e844:	8bfb      	ldrh	r3, [r7, #30]
  40e846:	3304      	adds	r3, #4
  40e848:	83fb      	strh	r3, [r7, #30]
		inv_dc_int32_to_little8(vSensordata->data.u32[3], &outBuffer[idx]);
  40e84a:	697b      	ldr	r3, [r7, #20]
  40e84c:	695b      	ldr	r3, [r3, #20]
  40e84e:	4618      	mov	r0, r3
  40e850:	8bfb      	ldrh	r3, [r7, #30]
  40e852:	687a      	ldr	r2, [r7, #4]
  40e854:	4413      	add	r3, r2
  40e856:	4619      	mov	r1, r3
  40e858:	4b13      	ldr	r3, [pc, #76]	; (40e8a8 <DynProtocol_encodeSensorEvent+0x614>)
  40e85a:	4798      	blx	r3
		idx += 4;
  40e85c:	8bfb      	ldrh	r3, [r7, #30]
  40e85e:	3304      	adds	r3, #4
  40e860:	83fb      	strh	r3, [r7, #30]
		break;
  40e862:	e2f4      	b.n	40ee4e <DynProtocol_encodeSensorEvent+0xbba>

	case DYN_PRO_SENSOR_TYPE_DISTANCE:
		if(maxBufferSize < 8)
  40e864:	887b      	ldrh	r3, [r7, #2]
  40e866:	2b07      	cmp	r3, #7
  40e868:	f240 830d 	bls.w	40ee86 <DynProtocol_encodeSensorEvent+0xbf2>
			goto error_size;
		inv_dc_int32_to_little8(vSensordata->data.u32[0], &outBuffer[idx]);
  40e86c:	697b      	ldr	r3, [r7, #20]
  40e86e:	689b      	ldr	r3, [r3, #8]
  40e870:	4618      	mov	r0, r3
  40e872:	8bfb      	ldrh	r3, [r7, #30]
  40e874:	687a      	ldr	r2, [r7, #4]
  40e876:	4413      	add	r3, r2
  40e878:	4619      	mov	r1, r3
  40e87a:	4b0b      	ldr	r3, [pc, #44]	; (40e8a8 <DynProtocol_encodeSensorEvent+0x614>)
  40e87c:	4798      	blx	r3
		idx += 4;
  40e87e:	8bfb      	ldrh	r3, [r7, #30]
  40e880:	3304      	adds	r3, #4
  40e882:	83fb      	strh	r3, [r7, #30]
		inv_dc_int32_to_little8(vSensordata->data.u32[1], &outBuffer[idx]);
  40e884:	697b      	ldr	r3, [r7, #20]
  40e886:	68db      	ldr	r3, [r3, #12]
  40e888:	4618      	mov	r0, r3
  40e88a:	8bfb      	ldrh	r3, [r7, #30]
  40e88c:	687a      	ldr	r2, [r7, #4]
  40e88e:	4413      	add	r3, r2
  40e890:	4619      	mov	r1, r3
  40e892:	4b05      	ldr	r3, [pc, #20]	; (40e8a8 <DynProtocol_encodeSensorEvent+0x614>)
  40e894:	4798      	blx	r3
		idx += 4;
  40e896:	8bfb      	ldrh	r3, [r7, #30]
  40e898:	3304      	adds	r3, #4
  40e89a:	83fb      	strh	r3, [r7, #30]
		break;
  40e89c:	e2d7      	b.n	40ee4e <DynProtocol_encodeSensorEvent+0xbba>
  40e89e:	bf00      	nop
  40e8a0:	0040cd19 	.word	0x0040cd19
  40e8a4:	0040f7d5 	.word	0x0040f7d5
  40e8a8:	0040f791 	.word	0x0040f791

	case DYN_PRO_SENSOR_TYPE_SLEEP_ANALYSIS:
		if(maxBufferSize < 25)
  40e8ac:	887b      	ldrh	r3, [r7, #2]
  40e8ae:	2b18      	cmp	r3, #24
  40e8b0:	f240 82eb 	bls.w	40ee8a <DynProtocol_encodeSensorEvent+0xbf6>
			goto error_size;
		outBuffer[idx] = vSensordata->data.u8[0];
  40e8b4:	8bfb      	ldrh	r3, [r7, #30]
  40e8b6:	687a      	ldr	r2, [r7, #4]
  40e8b8:	4413      	add	r3, r2
  40e8ba:	697a      	ldr	r2, [r7, #20]
  40e8bc:	7a12      	ldrb	r2, [r2, #8]
  40e8be:	701a      	strb	r2, [r3, #0]
		idx += 1;
  40e8c0:	8bfb      	ldrh	r3, [r7, #30]
  40e8c2:	3301      	adds	r3, #1
  40e8c4:	83fb      	strh	r3, [r7, #30]
		outBuffer[idx] = vSensordata->data.u8[1];
  40e8c6:	8bfb      	ldrh	r3, [r7, #30]
  40e8c8:	687a      	ldr	r2, [r7, #4]
  40e8ca:	4413      	add	r3, r2
  40e8cc:	697a      	ldr	r2, [r7, #20]
  40e8ce:	7a52      	ldrb	r2, [r2, #9]
  40e8d0:	701a      	strb	r2, [r3, #0]
		idx += 1;
  40e8d2:	8bfb      	ldrh	r3, [r7, #30]
  40e8d4:	3301      	adds	r3, #1
  40e8d6:	83fb      	strh	r3, [r7, #30]
		outBuffer[idx] = vSensordata->data.u8[2];
  40e8d8:	8bfb      	ldrh	r3, [r7, #30]
  40e8da:	687a      	ldr	r2, [r7, #4]
  40e8dc:	4413      	add	r3, r2
  40e8de:	697a      	ldr	r2, [r7, #20]
  40e8e0:	7a92      	ldrb	r2, [r2, #10]
  40e8e2:	701a      	strb	r2, [r3, #0]
		idx += 1;
  40e8e4:	8bfb      	ldrh	r3, [r7, #30]
  40e8e6:	3301      	adds	r3, #1
  40e8e8:	83fb      	strh	r3, [r7, #30]
		outBuffer[idx] = vSensordata->data.u8[3];
  40e8ea:	8bfb      	ldrh	r3, [r7, #30]
  40e8ec:	687a      	ldr	r2, [r7, #4]
  40e8ee:	4413      	add	r3, r2
  40e8f0:	697a      	ldr	r2, [r7, #20]
  40e8f2:	7ad2      	ldrb	r2, [r2, #11]
  40e8f4:	701a      	strb	r2, [r3, #0]
		idx += 1;
  40e8f6:	8bfb      	ldrh	r3, [r7, #30]
  40e8f8:	3301      	adds	r3, #1
  40e8fa:	83fb      	strh	r3, [r7, #30]
		inv_dc_int32_to_little8(vSensordata->data.u32[1], &outBuffer[idx]);
  40e8fc:	697b      	ldr	r3, [r7, #20]
  40e8fe:	68db      	ldr	r3, [r3, #12]
  40e900:	4618      	mov	r0, r3
  40e902:	8bfb      	ldrh	r3, [r7, #30]
  40e904:	687a      	ldr	r2, [r7, #4]
  40e906:	4413      	add	r3, r2
  40e908:	4619      	mov	r1, r3
  40e90a:	4b95      	ldr	r3, [pc, #596]	; (40eb60 <DynProtocol_encodeSensorEvent+0x8cc>)
  40e90c:	4798      	blx	r3
		idx += 4;
  40e90e:	8bfb      	ldrh	r3, [r7, #30]
  40e910:	3304      	adds	r3, #4
  40e912:	83fb      	strh	r3, [r7, #30]
		inv_dc_int32_to_little8(vSensordata->data.u32[2], &outBuffer[idx]);
  40e914:	697b      	ldr	r3, [r7, #20]
  40e916:	691b      	ldr	r3, [r3, #16]
  40e918:	4618      	mov	r0, r3
  40e91a:	8bfb      	ldrh	r3, [r7, #30]
  40e91c:	687a      	ldr	r2, [r7, #4]
  40e91e:	4413      	add	r3, r2
  40e920:	4619      	mov	r1, r3
  40e922:	4b8f      	ldr	r3, [pc, #572]	; (40eb60 <DynProtocol_encodeSensorEvent+0x8cc>)
  40e924:	4798      	blx	r3
		idx += 4;
  40e926:	8bfb      	ldrh	r3, [r7, #30]
  40e928:	3304      	adds	r3, #4
  40e92a:	83fb      	strh	r3, [r7, #30]
		inv_dc_int32_to_little8(vSensordata->data.u32[3], &outBuffer[idx]);
  40e92c:	697b      	ldr	r3, [r7, #20]
  40e92e:	695b      	ldr	r3, [r3, #20]
  40e930:	4618      	mov	r0, r3
  40e932:	8bfb      	ldrh	r3, [r7, #30]
  40e934:	687a      	ldr	r2, [r7, #4]
  40e936:	4413      	add	r3, r2
  40e938:	4619      	mov	r1, r3
  40e93a:	4b89      	ldr	r3, [pc, #548]	; (40eb60 <DynProtocol_encodeSensorEvent+0x8cc>)
  40e93c:	4798      	blx	r3
		idx += 4;
  40e93e:	8bfb      	ldrh	r3, [r7, #30]
  40e940:	3304      	adds	r3, #4
  40e942:	83fb      	strh	r3, [r7, #30]
		inv_dc_int32_to_little8(vSensordata->data.u32[4], &outBuffer[idx]);
  40e944:	697b      	ldr	r3, [r7, #20]
  40e946:	699b      	ldr	r3, [r3, #24]
  40e948:	4618      	mov	r0, r3
  40e94a:	8bfb      	ldrh	r3, [r7, #30]
  40e94c:	687a      	ldr	r2, [r7, #4]
  40e94e:	4413      	add	r3, r2
  40e950:	4619      	mov	r1, r3
  40e952:	4b83      	ldr	r3, [pc, #524]	; (40eb60 <DynProtocol_encodeSensorEvent+0x8cc>)
  40e954:	4798      	blx	r3
		idx += 4;
  40e956:	8bfb      	ldrh	r3, [r7, #30]
  40e958:	3304      	adds	r3, #4
  40e95a:	83fb      	strh	r3, [r7, #30]
		inv_dc_int32_to_little8(vSensordata->data.u32[5], &outBuffer[idx]);
  40e95c:	697b      	ldr	r3, [r7, #20]
  40e95e:	69db      	ldr	r3, [r3, #28]
  40e960:	4618      	mov	r0, r3
  40e962:	8bfb      	ldrh	r3, [r7, #30]
  40e964:	687a      	ldr	r2, [r7, #4]
  40e966:	4413      	add	r3, r2
  40e968:	4619      	mov	r1, r3
  40e96a:	4b7d      	ldr	r3, [pc, #500]	; (40eb60 <DynProtocol_encodeSensorEvent+0x8cc>)
  40e96c:	4798      	blx	r3
		idx += 4;
  40e96e:	8bfb      	ldrh	r3, [r7, #30]
  40e970:	3304      	adds	r3, #4
  40e972:	83fb      	strh	r3, [r7, #30]
		outBuffer[idx] = vSensordata->data.u8[24]; 
  40e974:	8bfb      	ldrh	r3, [r7, #30]
  40e976:	687a      	ldr	r2, [r7, #4]
  40e978:	4413      	add	r3, r2
  40e97a:	697a      	ldr	r2, [r7, #20]
  40e97c:	f892 2020 	ldrb.w	r2, [r2, #32]
  40e980:	701a      	strb	r2, [r3, #0]
		idx += 1;
  40e982:	8bfb      	ldrh	r3, [r7, #30]
  40e984:	3301      	adds	r3, #1
  40e986:	83fb      	strh	r3, [r7, #30]
		break;
  40e988:	e261      	b.n	40ee4e <DynProtocol_encodeSensorEvent+0xbba>

	case DYN_PRO_SENSOR_TYPE_BAC_EXTENDED:
		if(maxBufferSize < 4)
  40e98a:	887b      	ldrh	r3, [r7, #2]
  40e98c:	2b03      	cmp	r3, #3
  40e98e:	f240 827e 	bls.w	40ee8e <DynProtocol_encodeSensorEvent+0xbfa>
			goto error_size;
		inv_dc_int32_to_little8(vSensordata->data.u32[0], &outBuffer[idx]);
  40e992:	697b      	ldr	r3, [r7, #20]
  40e994:	689b      	ldr	r3, [r3, #8]
  40e996:	4618      	mov	r0, r3
  40e998:	8bfb      	ldrh	r3, [r7, #30]
  40e99a:	687a      	ldr	r2, [r7, #4]
  40e99c:	4413      	add	r3, r2
  40e99e:	4619      	mov	r1, r3
  40e9a0:	4b6f      	ldr	r3, [pc, #444]	; (40eb60 <DynProtocol_encodeSensorEvent+0x8cc>)
  40e9a2:	4798      	blx	r3
		idx += 4;
  40e9a4:	8bfb      	ldrh	r3, [r7, #30]
  40e9a6:	3304      	adds	r3, #4
  40e9a8:	83fb      	strh	r3, [r7, #30]
		break;
  40e9aa:	e250      	b.n	40ee4e <DynProtocol_encodeSensorEvent+0xbba>

	case DYN_PRO_SENSOR_TYPE_BAC_STATISTICS:
		if(maxBufferSize < 44)
  40e9ac:	887b      	ldrh	r3, [r7, #2]
  40e9ae:	2b2b      	cmp	r3, #43	; 0x2b
  40e9b0:	f240 826f 	bls.w	40ee92 <DynProtocol_encodeSensorEvent+0xbfe>
			goto error_size;
		inv_dc_int32_to_little8(vSensordata->data.u32[0], &outBuffer[idx]);
  40e9b4:	697b      	ldr	r3, [r7, #20]
  40e9b6:	689b      	ldr	r3, [r3, #8]
  40e9b8:	4618      	mov	r0, r3
  40e9ba:	8bfb      	ldrh	r3, [r7, #30]
  40e9bc:	687a      	ldr	r2, [r7, #4]
  40e9be:	4413      	add	r3, r2
  40e9c0:	4619      	mov	r1, r3
  40e9c2:	4b67      	ldr	r3, [pc, #412]	; (40eb60 <DynProtocol_encodeSensorEvent+0x8cc>)
  40e9c4:	4798      	blx	r3
		idx += 4;
  40e9c6:	8bfb      	ldrh	r3, [r7, #30]
  40e9c8:	3304      	adds	r3, #4
  40e9ca:	83fb      	strh	r3, [r7, #30]
		inv_dc_int32_to_little8(vSensordata->data.u32[1], &outBuffer[idx]);
  40e9cc:	697b      	ldr	r3, [r7, #20]
  40e9ce:	68db      	ldr	r3, [r3, #12]
  40e9d0:	4618      	mov	r0, r3
  40e9d2:	8bfb      	ldrh	r3, [r7, #30]
  40e9d4:	687a      	ldr	r2, [r7, #4]
  40e9d6:	4413      	add	r3, r2
  40e9d8:	4619      	mov	r1, r3
  40e9da:	4b61      	ldr	r3, [pc, #388]	; (40eb60 <DynProtocol_encodeSensorEvent+0x8cc>)
  40e9dc:	4798      	blx	r3
		idx += 4;
  40e9de:	8bfb      	ldrh	r3, [r7, #30]
  40e9e0:	3304      	adds	r3, #4
  40e9e2:	83fb      	strh	r3, [r7, #30]
		inv_dc_int32_to_little8(vSensordata->data.u32[2], &outBuffer[idx]);
  40e9e4:	697b      	ldr	r3, [r7, #20]
  40e9e6:	691b      	ldr	r3, [r3, #16]
  40e9e8:	4618      	mov	r0, r3
  40e9ea:	8bfb      	ldrh	r3, [r7, #30]
  40e9ec:	687a      	ldr	r2, [r7, #4]
  40e9ee:	4413      	add	r3, r2
  40e9f0:	4619      	mov	r1, r3
  40e9f2:	4b5b      	ldr	r3, [pc, #364]	; (40eb60 <DynProtocol_encodeSensorEvent+0x8cc>)
  40e9f4:	4798      	blx	r3
		idx += 4;
  40e9f6:	8bfb      	ldrh	r3, [r7, #30]
  40e9f8:	3304      	adds	r3, #4
  40e9fa:	83fb      	strh	r3, [r7, #30]
		inv_dc_int32_to_little8(vSensordata->data.u32[3], &outBuffer[idx]);
  40e9fc:	697b      	ldr	r3, [r7, #20]
  40e9fe:	695b      	ldr	r3, [r3, #20]
  40ea00:	4618      	mov	r0, r3
  40ea02:	8bfb      	ldrh	r3, [r7, #30]
  40ea04:	687a      	ldr	r2, [r7, #4]
  40ea06:	4413      	add	r3, r2
  40ea08:	4619      	mov	r1, r3
  40ea0a:	4b55      	ldr	r3, [pc, #340]	; (40eb60 <DynProtocol_encodeSensorEvent+0x8cc>)
  40ea0c:	4798      	blx	r3
		idx += 4;
  40ea0e:	8bfb      	ldrh	r3, [r7, #30]
  40ea10:	3304      	adds	r3, #4
  40ea12:	83fb      	strh	r3, [r7, #30]
		inv_dc_int32_to_little8(vSensordata->data.u32[4], &outBuffer[idx]);
  40ea14:	697b      	ldr	r3, [r7, #20]
  40ea16:	699b      	ldr	r3, [r3, #24]
  40ea18:	4618      	mov	r0, r3
  40ea1a:	8bfb      	ldrh	r3, [r7, #30]
  40ea1c:	687a      	ldr	r2, [r7, #4]
  40ea1e:	4413      	add	r3, r2
  40ea20:	4619      	mov	r1, r3
  40ea22:	4b4f      	ldr	r3, [pc, #316]	; (40eb60 <DynProtocol_encodeSensorEvent+0x8cc>)
  40ea24:	4798      	blx	r3
		idx += 4;
  40ea26:	8bfb      	ldrh	r3, [r7, #30]
  40ea28:	3304      	adds	r3, #4
  40ea2a:	83fb      	strh	r3, [r7, #30]
		inv_dc_int32_to_little8(vSensordata->data.u32[5], &outBuffer[idx]);
  40ea2c:	697b      	ldr	r3, [r7, #20]
  40ea2e:	69db      	ldr	r3, [r3, #28]
  40ea30:	4618      	mov	r0, r3
  40ea32:	8bfb      	ldrh	r3, [r7, #30]
  40ea34:	687a      	ldr	r2, [r7, #4]
  40ea36:	4413      	add	r3, r2
  40ea38:	4619      	mov	r1, r3
  40ea3a:	4b49      	ldr	r3, [pc, #292]	; (40eb60 <DynProtocol_encodeSensorEvent+0x8cc>)
  40ea3c:	4798      	blx	r3
		idx += 4;
  40ea3e:	8bfb      	ldrh	r3, [r7, #30]
  40ea40:	3304      	adds	r3, #4
  40ea42:	83fb      	strh	r3, [r7, #30]
		inv_dc_int32_to_little8(vSensordata->data.u32[6], &outBuffer[idx]);
  40ea44:	697b      	ldr	r3, [r7, #20]
  40ea46:	6a1b      	ldr	r3, [r3, #32]
  40ea48:	4618      	mov	r0, r3
  40ea4a:	8bfb      	ldrh	r3, [r7, #30]
  40ea4c:	687a      	ldr	r2, [r7, #4]
  40ea4e:	4413      	add	r3, r2
  40ea50:	4619      	mov	r1, r3
  40ea52:	4b43      	ldr	r3, [pc, #268]	; (40eb60 <DynProtocol_encodeSensorEvent+0x8cc>)
  40ea54:	4798      	blx	r3
		idx += 4;
  40ea56:	8bfb      	ldrh	r3, [r7, #30]
  40ea58:	3304      	adds	r3, #4
  40ea5a:	83fb      	strh	r3, [r7, #30]
		inv_dc_int32_to_little8(vSensordata->data.u32[7], &outBuffer[idx]);
  40ea5c:	697b      	ldr	r3, [r7, #20]
  40ea5e:	6a5b      	ldr	r3, [r3, #36]	; 0x24
  40ea60:	4618      	mov	r0, r3
  40ea62:	8bfb      	ldrh	r3, [r7, #30]
  40ea64:	687a      	ldr	r2, [r7, #4]
  40ea66:	4413      	add	r3, r2
  40ea68:	4619      	mov	r1, r3
  40ea6a:	4b3d      	ldr	r3, [pc, #244]	; (40eb60 <DynProtocol_encodeSensorEvent+0x8cc>)
  40ea6c:	4798      	blx	r3
		idx += 4;
  40ea6e:	8bfb      	ldrh	r3, [r7, #30]
  40ea70:	3304      	adds	r3, #4
  40ea72:	83fb      	strh	r3, [r7, #30]
		inv_dc_int32_to_little8(vSensordata->data.u32[8], &outBuffer[idx]);
  40ea74:	697b      	ldr	r3, [r7, #20]
  40ea76:	6a9b      	ldr	r3, [r3, #40]	; 0x28
  40ea78:	4618      	mov	r0, r3
  40ea7a:	8bfb      	ldrh	r3, [r7, #30]
  40ea7c:	687a      	ldr	r2, [r7, #4]
  40ea7e:	4413      	add	r3, r2
  40ea80:	4619      	mov	r1, r3
  40ea82:	4b37      	ldr	r3, [pc, #220]	; (40eb60 <DynProtocol_encodeSensorEvent+0x8cc>)
  40ea84:	4798      	blx	r3
		idx += 4;
  40ea86:	8bfb      	ldrh	r3, [r7, #30]
  40ea88:	3304      	adds	r3, #4
  40ea8a:	83fb      	strh	r3, [r7, #30]
		inv_dc_int32_to_little8(vSensordata->data.u32[9], &outBuffer[idx]);
  40ea8c:	697b      	ldr	r3, [r7, #20]
  40ea8e:	6adb      	ldr	r3, [r3, #44]	; 0x2c
  40ea90:	4618      	mov	r0, r3
  40ea92:	8bfb      	ldrh	r3, [r7, #30]
  40ea94:	687a      	ldr	r2, [r7, #4]
  40ea96:	4413      	add	r3, r2
  40ea98:	4619      	mov	r1, r3
  40ea9a:	4b31      	ldr	r3, [pc, #196]	; (40eb60 <DynProtocol_encodeSensorEvent+0x8cc>)
  40ea9c:	4798      	blx	r3
		idx += 4;
  40ea9e:	8bfb      	ldrh	r3, [r7, #30]
  40eaa0:	3304      	adds	r3, #4
  40eaa2:	83fb      	strh	r3, [r7, #30]
		inv_dc_int32_to_little8(vSensordata->data.u32[10], &outBuffer[idx]);
  40eaa4:	697b      	ldr	r3, [r7, #20]
  40eaa6:	6b1b      	ldr	r3, [r3, #48]	; 0x30
  40eaa8:	4618      	mov	r0, r3
  40eaaa:	8bfb      	ldrh	r3, [r7, #30]
  40eaac:	687a      	ldr	r2, [r7, #4]
  40eaae:	4413      	add	r3, r2
  40eab0:	4619      	mov	r1, r3
  40eab2:	4b2b      	ldr	r3, [pc, #172]	; (40eb60 <DynProtocol_encodeSensorEvent+0x8cc>)
  40eab4:	4798      	blx	r3
		idx += 4;
  40eab6:	8bfb      	ldrh	r3, [r7, #30]
  40eab8:	3304      	adds	r3, #4
  40eaba:	83fb      	strh	r3, [r7, #30]
		break;
  40eabc:	e1c7      	b.n	40ee4e <DynProtocol_encodeSensorEvent+0xbba>

	case DYN_PRO_SENSOR_TYPE_FLOOR_CLIMB_COUNTER:
		if(maxBufferSize < 8)
  40eabe:	887b      	ldrh	r3, [r7, #2]
  40eac0:	2b07      	cmp	r3, #7
  40eac2:	f240 81e8 	bls.w	40ee96 <DynProtocol_encodeSensorEvent+0xc02>
			goto error_size;
		inv_dc_int32_to_little8(vSensordata->data.u32[0], &outBuffer[idx]);
  40eac6:	697b      	ldr	r3, [r7, #20]
  40eac8:	689b      	ldr	r3, [r3, #8]
  40eaca:	4618      	mov	r0, r3
  40eacc:	8bfb      	ldrh	r3, [r7, #30]
  40eace:	687a      	ldr	r2, [r7, #4]
  40ead0:	4413      	add	r3, r2
  40ead2:	4619      	mov	r1, r3
  40ead4:	4b22      	ldr	r3, [pc, #136]	; (40eb60 <DynProtocol_encodeSensorEvent+0x8cc>)
  40ead6:	4798      	blx	r3
		idx += 4;
  40ead8:	8bfb      	ldrh	r3, [r7, #30]
  40eada:	3304      	adds	r3, #4
  40eadc:	83fb      	strh	r3, [r7, #30]
		inv_dc_int32_to_little8(vSensordata->data.u32[1], &outBuffer[idx]);
  40eade:	697b      	ldr	r3, [r7, #20]
  40eae0:	68db      	ldr	r3, [r3, #12]
  40eae2:	4618      	mov	r0, r3
  40eae4:	8bfb      	ldrh	r3, [r7, #30]
  40eae6:	687a      	ldr	r2, [r7, #4]
  40eae8:	4413      	add	r3, r2
  40eaea:	4619      	mov	r1, r3
  40eaec:	4b1c      	ldr	r3, [pc, #112]	; (40eb60 <DynProtocol_encodeSensorEvent+0x8cc>)
  40eaee:	4798      	blx	r3
		idx += 4;
  40eaf0:	8bfb      	ldrh	r3, [r7, #30]
  40eaf2:	3304      	adds	r3, #4
  40eaf4:	83fb      	strh	r3, [r7, #30]
		break;
  40eaf6:	e1aa      	b.n	40ee4e <DynProtocol_encodeSensorEvent+0xbba>

	case DYN_PRO_SENSOR_TYPE_STEP_COUNTER:
		if(maxBufferSize < 8)
  40eaf8:	887b      	ldrh	r3, [r7, #2]
  40eafa:	2b07      	cmp	r3, #7
  40eafc:	f240 81cd 	bls.w	40ee9a <DynProtocol_encodeSensorEvent+0xc06>
			goto error_size;
		inv_dc_int32_to_little8((int32_t)vSensordata->data.u32[0], &outBuffer[idx]);
  40eb00:	697b      	ldr	r3, [r7, #20]
  40eb02:	689b      	ldr	r3, [r3, #8]
  40eb04:	4618      	mov	r0, r3
  40eb06:	8bfb      	ldrh	r3, [r7, #30]
  40eb08:	687a      	ldr	r2, [r7, #4]
  40eb0a:	4413      	add	r3, r2
  40eb0c:	4619      	mov	r1, r3
  40eb0e:	4b14      	ldr	r3, [pc, #80]	; (40eb60 <DynProtocol_encodeSensorEvent+0x8cc>)
  40eb10:	4798      	blx	r3
		idx += 4;
  40eb12:	8bfb      	ldrh	r3, [r7, #30]
  40eb14:	3304      	adds	r3, #4
  40eb16:	83fb      	strh	r3, [r7, #30]
		inv_dc_int32_to_little8(timestamp, &outBuffer[idx]);
  40eb18:	6938      	ldr	r0, [r7, #16]
  40eb1a:	8bfb      	ldrh	r3, [r7, #30]
  40eb1c:	687a      	ldr	r2, [r7, #4]
  40eb1e:	4413      	add	r3, r2
  40eb20:	4619      	mov	r1, r3
  40eb22:	4b0f      	ldr	r3, [pc, #60]	; (40eb60 <DynProtocol_encodeSensorEvent+0x8cc>)
  40eb24:	4798      	blx	r3
		idx += 4;
  40eb26:	8bfb      	ldrh	r3, [r7, #30]
  40eb28:	3304      	adds	r3, #4
  40eb2a:	83fb      	strh	r3, [r7, #30]
		break;
  40eb2c:	e18f      	b.n	40ee4e <DynProtocol_encodeSensorEvent+0xbba>

	case DYN_PRO_SENSOR_TYPE_BAC:
	case DYN_PRO_SENSOR_TYPE_WOM:
	case DYN_PRO_SENSOR_TYPE_TAP:
		if(maxBufferSize < 5)
  40eb2e:	887b      	ldrh	r3, [r7, #2]
  40eb30:	2b04      	cmp	r3, #4
  40eb32:	f240 81b4 	bls.w	40ee9e <DynProtocol_encodeSensorEvent+0xc0a>
			goto error_size;
		outBuffer[idx++] = vSensordata->data.u8[0];
  40eb36:	8bfb      	ldrh	r3, [r7, #30]
  40eb38:	1c5a      	adds	r2, r3, #1
  40eb3a:	83fa      	strh	r2, [r7, #30]
  40eb3c:	461a      	mov	r2, r3
  40eb3e:	687b      	ldr	r3, [r7, #4]
  40eb40:	4413      	add	r3, r2
  40eb42:	697a      	ldr	r2, [r7, #20]
  40eb44:	7a12      	ldrb	r2, [r2, #8]
  40eb46:	701a      	strb	r2, [r3, #0]
		inv_dc_int32_to_little8(timestamp, &outBuffer[idx]);
  40eb48:	6938      	ldr	r0, [r7, #16]
  40eb4a:	8bfb      	ldrh	r3, [r7, #30]
  40eb4c:	687a      	ldr	r2, [r7, #4]
  40eb4e:	4413      	add	r3, r2
  40eb50:	4619      	mov	r1, r3
  40eb52:	4b03      	ldr	r3, [pc, #12]	; (40eb60 <DynProtocol_encodeSensorEvent+0x8cc>)
  40eb54:	4798      	blx	r3
		idx += 4;
  40eb56:	8bfb      	ldrh	r3, [r7, #30]
  40eb58:	3304      	adds	r3, #4
  40eb5a:	83fb      	strh	r3, [r7, #30]
		break;
  40eb5c:	e177      	b.n	40ee4e <DynProtocol_encodeSensorEvent+0xbba>
  40eb5e:	bf00      	nop
  40eb60:	0040f791 	.word	0x0040f791
	case DYN_PRO_SENSOR_TYPE_GLANCE_GESTURE:
	case DYN_PRO_SENSOR_TYPE_PICK_UP_GESTURE:
	case DYN_PRO_SENSOR_TYPE_LOW_G:
	case DYN_PRO_SENSOR_TYPE_HIGH_G:
	{
		if(maxBufferSize < 4)
  40eb64:	887b      	ldrh	r3, [r7, #2]
  40eb66:	2b03      	cmp	r3, #3
  40eb68:	f240 819b 	bls.w	40eea2 <DynProtocol_encodeSensorEvent+0xc0e>
			goto error_size;
		inv_dc_int32_to_little8(timestamp, &outBuffer[idx]);
  40eb6c:	6938      	ldr	r0, [r7, #16]
  40eb6e:	8bfb      	ldrh	r3, [r7, #30]
  40eb70:	687a      	ldr	r2, [r7, #4]
  40eb72:	4413      	add	r3, r2
  40eb74:	4619      	mov	r1, r3
  40eb76:	4b96      	ldr	r3, [pc, #600]	; (40edd0 <DynProtocol_encodeSensorEvent+0xb3c>)
  40eb78:	4798      	blx	r3
		idx += 4;
  40eb7a:	8bfb      	ldrh	r3, [r7, #30]
  40eb7c:	3304      	adds	r3, #4
  40eb7e:	83fb      	strh	r3, [r7, #30]
		break;
  40eb80:	e165      	b.n	40ee4e <DynProtocol_encodeSensorEvent+0xbba>
	}

	case DYN_PRO_SENSOR_TYPE_PRESSURE:
	{
		if(maxBufferSize < 4)
  40eb82:	887b      	ldrh	r3, [r7, #2]
  40eb84:	2b03      	cmp	r3, #3
  40eb86:	f240 818e 	bls.w	40eea6 <DynProtocol_encodeSensorEvent+0xc12>
			goto error_size;
		inv_dc_int32_to_little8(vSensordata->data.u32[0], &outBuffer[idx]);
  40eb8a:	697b      	ldr	r3, [r7, #20]
  40eb8c:	689b      	ldr	r3, [r3, #8]
  40eb8e:	4618      	mov	r0, r3
  40eb90:	8bfb      	ldrh	r3, [r7, #30]
  40eb92:	687a      	ldr	r2, [r7, #4]
  40eb94:	4413      	add	r3, r2
  40eb96:	4619      	mov	r1, r3
  40eb98:	4b8d      	ldr	r3, [pc, #564]	; (40edd0 <DynProtocol_encodeSensorEvent+0xb3c>)
  40eb9a:	4798      	blx	r3
		idx += 4;
  40eb9c:	8bfb      	ldrh	r3, [r7, #30]
  40eb9e:	3304      	adds	r3, #4
  40eba0:	83fb      	strh	r3, [r7, #30]
		break;
  40eba2:	e154      	b.n	40ee4e <DynProtocol_encodeSensorEvent+0xbba>
	}

	case DYN_PRO_SENSOR_TYPE_ORIENTATION:
	{
		if(maxBufferSize < 6+1)
  40eba4:	887b      	ldrh	r3, [r7, #2]
  40eba6:	2b06      	cmp	r3, #6
  40eba8:	f240 817f 	bls.w	40eeaa <DynProtocol_encodeSensorEvent+0xc16>
			goto error_size;
		idx += DynProtocol_encodeQxToQyVect16((int32_t*)&vSensordata->data.u32[0], 3, 16, PROTOCOL_ORIENTATION_PRECISION, &outBuffer[idx]);
  40ebac:	697b      	ldr	r3, [r7, #20]
  40ebae:	f103 0008 	add.w	r0, r3, #8
  40ebb2:	8bfb      	ldrh	r3, [r7, #30]
  40ebb4:	687a      	ldr	r2, [r7, #4]
  40ebb6:	4413      	add	r3, r2
  40ebb8:	9300      	str	r3, [sp, #0]
  40ebba:	2306      	movs	r3, #6
  40ebbc:	2210      	movs	r2, #16
  40ebbe:	2103      	movs	r1, #3
  40ebc0:	4c84      	ldr	r4, [pc, #528]	; (40edd4 <DynProtocol_encodeSensorEvent+0xb40>)
  40ebc2:	47a0      	blx	r4
  40ebc4:	4603      	mov	r3, r0
  40ebc6:	b29a      	uxth	r2, r3
  40ebc8:	8bfb      	ldrh	r3, [r7, #30]
  40ebca:	4413      	add	r3, r2
  40ebcc:	83fb      	strh	r3, [r7, #30]
		outBuffer[idx++] = (uint8_t)(vSensordata->base.meta_data & VSENSOR_DATA_ACCURACY_MASK);
  40ebce:	8bfb      	ldrh	r3, [r7, #30]
  40ebd0:	1c5a      	adds	r2, r3, #1
  40ebd2:	83fa      	strh	r2, [r7, #30]
  40ebd4:	461a      	mov	r2, r3
  40ebd6:	687b      	ldr	r3, [r7, #4]
  40ebd8:	4413      	add	r3, r2
  40ebda:	697a      	ldr	r2, [r7, #20]
  40ebdc:	6852      	ldr	r2, [r2, #4]
  40ebde:	b2d2      	uxtb	r2, r2
  40ebe0:	f002 0207 	and.w	r2, r2, #7
  40ebe4:	b2d2      	uxtb	r2, r2
  40ebe6:	701a      	strb	r2, [r3, #0]
		break;
  40ebe8:	e131      	b.n	40ee4e <DynProtocol_encodeSensorEvent+0xbba>
	}

	case DYN_PRO_SENSOR_TYPE_LIGHT:
	{
		if(maxBufferSize < 4)
  40ebea:	887b      	ldrh	r3, [r7, #2]
  40ebec:	2b03      	cmp	r3, #3
  40ebee:	f240 815e 	bls.w	40eeae <DynProtocol_encodeSensorEvent+0xc1a>
			goto error_size;
		inv_dc_int32_to_little8(vSensordata->data.u32[0], &outBuffer[idx]);
  40ebf2:	697b      	ldr	r3, [r7, #20]
  40ebf4:	689b      	ldr	r3, [r3, #8]
  40ebf6:	4618      	mov	r0, r3
  40ebf8:	8bfb      	ldrh	r3, [r7, #30]
  40ebfa:	687a      	ldr	r2, [r7, #4]
  40ebfc:	4413      	add	r3, r2
  40ebfe:	4619      	mov	r1, r3
  40ec00:	4b73      	ldr	r3, [pc, #460]	; (40edd0 <DynProtocol_encodeSensorEvent+0xb3c>)
  40ec02:	4798      	blx	r3
		idx += 4;
  40ec04:	8bfb      	ldrh	r3, [r7, #30]
  40ec06:	3304      	adds	r3, #4
  40ec08:	83fb      	strh	r3, [r7, #30]
		break;
  40ec0a:	e120      	b.n	40ee4e <DynProtocol_encodeSensorEvent+0xbba>
	}

	case DYN_PRO_SENSOR_TYPE_PROXIMITY:
	{
		if(maxBufferSize < 2)
  40ec0c:	887b      	ldrh	r3, [r7, #2]
  40ec0e:	2b01      	cmp	r3, #1
  40ec10:	f240 814f 	bls.w	40eeb2 <DynProtocol_encodeSensorEvent+0xc1e>
			goto error_size;
		inv_dc_int16_to_little8((int16_t)vSensordata->data.u32[0], &outBuffer[idx]);
  40ec14:	697b      	ldr	r3, [r7, #20]
  40ec16:	689b      	ldr	r3, [r3, #8]
  40ec18:	b218      	sxth	r0, r3
  40ec1a:	8bfb      	ldrh	r3, [r7, #30]
  40ec1c:	687a      	ldr	r2, [r7, #4]
  40ec1e:	4413      	add	r3, r2
  40ec20:	4619      	mov	r1, r3
  40ec22:	4b6d      	ldr	r3, [pc, #436]	; (40edd8 <DynProtocol_encodeSensorEvent+0xb44>)
  40ec24:	4798      	blx	r3
		idx += 2;
  40ec26:	8bfb      	ldrh	r3, [r7, #30]
  40ec28:	3302      	adds	r3, #2
  40ec2a:	83fb      	strh	r3, [r7, #30]
		break;
  40ec2c:	e10f      	b.n	40ee4e <DynProtocol_encodeSensorEvent+0xbba>
	}

	case DYN_PRO_SENSOR_TYPE_FSYNC_EVENT:
	{
		if(maxBufferSize < 2)
  40ec2e:	887b      	ldrh	r3, [r7, #2]
  40ec30:	2b01      	cmp	r3, #1
  40ec32:	f240 8140 	bls.w	40eeb6 <DynProtocol_encodeSensorEvent+0xc22>
			goto error_size;
		// delta_ts
		inv_dc_int16_to_little8((int16_t)vSensordata->data.u32[0], &outBuffer[idx]);
  40ec36:	697b      	ldr	r3, [r7, #20]
  40ec38:	689b      	ldr	r3, [r3, #8]
  40ec3a:	b218      	sxth	r0, r3
  40ec3c:	8bfb      	ldrh	r3, [r7, #30]
  40ec3e:	687a      	ldr	r2, [r7, #4]
  40ec40:	4413      	add	r3, r2
  40ec42:	4619      	mov	r1, r3
  40ec44:	4b64      	ldr	r3, [pc, #400]	; (40edd8 <DynProtocol_encodeSensorEvent+0xb44>)
  40ec46:	4798      	blx	r3
		idx += 2;
  40ec48:	8bfb      	ldrh	r3, [r7, #30]
  40ec4a:	3302      	adds	r3, #2
  40ec4c:	83fb      	strh	r3, [r7, #30]
		break;
  40ec4e:	e0fe      	b.n	40ee4e <DynProtocol_encodeSensorEvent+0xbba>
	}

	case DYN_PRO_SENSOR_TYPE_EIS:
	{
		if(maxBufferSize < 14)
  40ec50:	887b      	ldrh	r3, [r7, #2]
  40ec52:	2b0d      	cmp	r3, #13
  40ec54:	f240 8131 	bls.w	40eeba <DynProtocol_encodeSensorEvent+0xc26>
			goto error_size;
		// uncalibrated data
		idx += DynProtocol_encodeQxToQyVect16((int32_t*)&vSensordata->data.u32[0], 3, 16, self->precision.gyro, &outBuffer[idx]);
  40ec58:	697b      	ldr	r3, [r7, #20]
  40ec5a:	f103 0008 	add.w	r0, r3, #8
  40ec5e:	68fb      	ldr	r3, [r7, #12]
  40ec60:	f893 3295 	ldrb.w	r3, [r3, #661]	; 0x295
  40ec64:	4619      	mov	r1, r3
  40ec66:	8bfb      	ldrh	r3, [r7, #30]
  40ec68:	687a      	ldr	r2, [r7, #4]
  40ec6a:	4413      	add	r3, r2
  40ec6c:	9300      	str	r3, [sp, #0]
  40ec6e:	460b      	mov	r3, r1
  40ec70:	2210      	movs	r2, #16
  40ec72:	2103      	movs	r1, #3
  40ec74:	4c57      	ldr	r4, [pc, #348]	; (40edd4 <DynProtocol_encodeSensorEvent+0xb40>)
  40ec76:	47a0      	blx	r4
  40ec78:	4603      	mov	r3, r0
  40ec7a:	b29a      	uxth	r2, r3
  40ec7c:	8bfb      	ldrh	r3, [r7, #30]
  40ec7e:	4413      	add	r3, r2
  40ec80:	83fb      	strh	r3, [r7, #30]
		// bias
		idx += DynProtocol_encodeQxToQyVect16((int32_t*)&vSensordata->data.u32[3], 3, 16, self->precision.gyro, &outBuffer[idx]);
  40ec82:	697b      	ldr	r3, [r7, #20]
  40ec84:	f103 0014 	add.w	r0, r3, #20
  40ec88:	68fb      	ldr	r3, [r7, #12]
  40ec8a:	f893 3295 	ldrb.w	r3, [r3, #661]	; 0x295
  40ec8e:	4619      	mov	r1, r3
  40ec90:	8bfb      	ldrh	r3, [r7, #30]
  40ec92:	687a      	ldr	r2, [r7, #4]
  40ec94:	4413      	add	r3, r2
  40ec96:	9300      	str	r3, [sp, #0]
  40ec98:	460b      	mov	r3, r1
  40ec9a:	2210      	movs	r2, #16
  40ec9c:	2103      	movs	r1, #3
  40ec9e:	4c4d      	ldr	r4, [pc, #308]	; (40edd4 <DynProtocol_encodeSensorEvent+0xb40>)
  40eca0:	47a0      	blx	r4
  40eca2:	4603      	mov	r3, r0
  40eca4:	b29a      	uxth	r2, r3
  40eca6:	8bfb      	ldrh	r3, [r7, #30]
  40eca8:	4413      	add	r3, r2
  40ecaa:	83fb      	strh	r3, [r7, #30]
		// delta_ts
		inv_dc_int16_to_little8((int16_t)vSensordata->data.u32[6], &outBuffer[idx]);
  40ecac:	697b      	ldr	r3, [r7, #20]
  40ecae:	6a1b      	ldr	r3, [r3, #32]
  40ecb0:	b218      	sxth	r0, r3
  40ecb2:	8bfb      	ldrh	r3, [r7, #30]
  40ecb4:	687a      	ldr	r2, [r7, #4]
  40ecb6:	4413      	add	r3, r2
  40ecb8:	4619      	mov	r1, r3
  40ecba:	4b47      	ldr	r3, [pc, #284]	; (40edd8 <DynProtocol_encodeSensorEvent+0xb44>)
  40ecbc:	4798      	blx	r3
		idx += 2;
  40ecbe:	8bfb      	ldrh	r3, [r7, #30]
  40ecc0:	3302      	adds	r3, #2
  40ecc2:	83fb      	strh	r3, [r7, #30]
		break;
  40ecc4:	e0c3      	b.n	40ee4e <DynProtocol_encodeSensorEvent+0xbba>
	case DYN_PRO_SENSOR_TYPE_CUSTOM4:
	case DYN_PRO_SENSOR_TYPE_CUSTOM5:
	case DYN_PRO_SENSOR_TYPE_CUSTOM6:
	case DYN_PRO_SENSOR_TYPE_CUSTOM7:
	{
		if(maxBufferSize < 64)
  40ecc6:	887b      	ldrh	r3, [r7, #2]
  40ecc8:	2b3f      	cmp	r3, #63	; 0x3f
  40ecca:	f240 80f8 	bls.w	40eebe <DynProtocol_encodeSensorEvent+0xc2a>
			goto error_size;
		// meta data contains size of custom sensors, it can be checked in host
		outBuffer[idx++] = vSensordata->base.meta_data;
  40ecce:	8bfb      	ldrh	r3, [r7, #30]
  40ecd0:	1c5a      	adds	r2, r3, #1
  40ecd2:	83fa      	strh	r2, [r7, #30]
  40ecd4:	461a      	mov	r2, r3
  40ecd6:	687b      	ldr	r3, [r7, #4]
  40ecd8:	4413      	add	r3, r2
  40ecda:	697a      	ldr	r2, [r7, #20]
  40ecdc:	6852      	ldr	r2, [r2, #4]
  40ecde:	b2d2      	uxtb	r2, r2
  40ece0:	701a      	strb	r2, [r3, #0]
		// one byte less available in outBuffer
		maxBufferSize--;
  40ece2:	887b      	ldrh	r3, [r7, #2]
  40ece4:	3b01      	subs	r3, #1
  40ece6:	807b      	strh	r3, [r7, #2]
		// let's make sure that size to be copied is not bigger than size left in outBuffer
		if(vSensordata->base.meta_data > maxBufferSize)
  40ece8:	697b      	ldr	r3, [r7, #20]
  40ecea:	685a      	ldr	r2, [r3, #4]
  40ecec:	887b      	ldrh	r3, [r7, #2]
  40ecee:	429a      	cmp	r2, r3
  40ecf0:	f200 80e7 	bhi.w	40eec2 <DynProtocol_encodeSensorEvent+0xc2e>
			goto error_size;

		memcpy(&outBuffer[idx], vSensordata->data.u8, vSensordata->base.meta_data);
  40ecf4:	8bfb      	ldrh	r3, [r7, #30]
  40ecf6:	687a      	ldr	r2, [r7, #4]
  40ecf8:	18d0      	adds	r0, r2, r3
  40ecfa:	697b      	ldr	r3, [r7, #20]
  40ecfc:	f103 0108 	add.w	r1, r3, #8
  40ed00:	697b      	ldr	r3, [r7, #20]
  40ed02:	685b      	ldr	r3, [r3, #4]
  40ed04:	461a      	mov	r2, r3
  40ed06:	4b35      	ldr	r3, [pc, #212]	; (40eddc <DynProtocol_encodeSensorEvent+0xb48>)
  40ed08:	4798      	blx	r3
		//set hardly the payload size until payload has a fixed value for custom sensors
		idx += sizeof(vSensordata->data.u8);
  40ed0a:	8bfb      	ldrh	r3, [r7, #30]
  40ed0c:	3340      	adds	r3, #64	; 0x40
  40ed0e:	83fb      	strh	r3, [r7, #30]
		break;
  40ed10:	e09d      	b.n	40ee4e <DynProtocol_encodeSensorEvent+0xbba>
	}

	case DYN_PRO_SENSOR_TYPE_CUSTOM_PRESSURE:
	{
		if(maxBufferSize < 16)
  40ed12:	887b      	ldrh	r3, [r7, #2]
  40ed14:	2b0f      	cmp	r3, #15
  40ed16:	f240 80d6 	bls.w	40eec6 <DynProtocol_encodeSensorEvent+0xc32>
			goto error_size;

		for (i=0; i<4; i++) {
  40ed1a:	2300      	movs	r3, #0
  40ed1c:	83bb      	strh	r3, [r7, #28]
  40ed1e:	e011      	b.n	40ed44 <DynProtocol_encodeSensorEvent+0xab0>
			inv_dc_int32_to_little8(vSensordata->data.u32[i], &outBuffer[idx]); // raw pressure
  40ed20:	8bba      	ldrh	r2, [r7, #28]
  40ed22:	697b      	ldr	r3, [r7, #20]
  40ed24:	3202      	adds	r2, #2
  40ed26:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
  40ed2a:	4618      	mov	r0, r3
  40ed2c:	8bfb      	ldrh	r3, [r7, #30]
  40ed2e:	687a      	ldr	r2, [r7, #4]
  40ed30:	4413      	add	r3, r2
  40ed32:	4619      	mov	r1, r3
  40ed34:	4b26      	ldr	r3, [pc, #152]	; (40edd0 <DynProtocol_encodeSensorEvent+0xb3c>)
  40ed36:	4798      	blx	r3
			idx += 4;
  40ed38:	8bfb      	ldrh	r3, [r7, #30]
  40ed3a:	3304      	adds	r3, #4
  40ed3c:	83fb      	strh	r3, [r7, #30]
		for (i=0; i<4; i++) {
  40ed3e:	8bbb      	ldrh	r3, [r7, #28]
  40ed40:	3301      	adds	r3, #1
  40ed42:	83bb      	strh	r3, [r7, #28]
  40ed44:	8bbb      	ldrh	r3, [r7, #28]
  40ed46:	2b03      	cmp	r3, #3
  40ed48:	d9ea      	bls.n	40ed20 <DynProtocol_encodeSensorEvent+0xa8c>
		}
		break;
  40ed4a:	e080      	b.n	40ee4e <DynProtocol_encodeSensorEvent+0xbba>
	}

	case DYN_PRO_SENSOR_TYPE_HEART_RATE:
	{
		if(maxBufferSize < 4)
  40ed4c:	887b      	ldrh	r3, [r7, #2]
  40ed4e:	2b03      	cmp	r3, #3
  40ed50:	f240 80bb 	bls.w	40eeca <DynProtocol_encodeSensorEvent+0xc36>
			goto error_size;

		// ppm
		idx += DynProtocol_encodeQxToQyVect16((int32_t*)&vSensordata->data.u32[0], 1, 16, PROTOCOL_HRM_PRECISION, &outBuffer[idx]);
  40ed54:	697b      	ldr	r3, [r7, #20]
  40ed56:	f103 0008 	add.w	r0, r3, #8
  40ed5a:	8bfb      	ldrh	r3, [r7, #30]
  40ed5c:	687a      	ldr	r2, [r7, #4]
  40ed5e:	4413      	add	r3, r2
  40ed60:	9300      	str	r3, [sp, #0]
  40ed62:	2307      	movs	r3, #7
  40ed64:	2210      	movs	r2, #16
  40ed66:	2101      	movs	r1, #1
  40ed68:	4c1a      	ldr	r4, [pc, #104]	; (40edd4 <DynProtocol_encodeSensorEvent+0xb40>)
  40ed6a:	47a0      	blx	r4
  40ed6c:	4603      	mov	r3, r0
  40ed6e:	b29a      	uxth	r2, r3
  40ed70:	8bfb      	ldrh	r3, [r7, #30]
  40ed72:	4413      	add	r3, r2
  40ed74:	83fb      	strh	r3, [r7, #30]

		// confidence
		outBuffer[idx] = vSensordata->data.u8[4];
  40ed76:	8bfb      	ldrh	r3, [r7, #30]
  40ed78:	687a      	ldr	r2, [r7, #4]
  40ed7a:	4413      	add	r3, r2
  40ed7c:	697a      	ldr	r2, [r7, #20]
  40ed7e:	7b12      	ldrb	r2, [r2, #12]
  40ed80:	701a      	strb	r2, [r3, #0]
		idx++;
  40ed82:	8bfb      	ldrh	r3, [r7, #30]
  40ed84:	3301      	adds	r3, #1
  40ed86:	83fb      	strh	r3, [r7, #30]

		// sqi
		outBuffer[idx] = vSensordata->data.u8[5];
  40ed88:	8bfb      	ldrh	r3, [r7, #30]
  40ed8a:	687a      	ldr	r2, [r7, #4]
  40ed8c:	4413      	add	r3, r2
  40ed8e:	697a      	ldr	r2, [r7, #20]
  40ed90:	7b52      	ldrb	r2, [r2, #13]
  40ed92:	701a      	strb	r2, [r3, #0]
		idx++;
  40ed94:	8bfb      	ldrh	r3, [r7, #30]
  40ed96:	3301      	adds	r3, #1
  40ed98:	83fb      	strh	r3, [r7, #30]

		break;
  40ed9a:	e058      	b.n	40ee4e <DynProtocol_encodeSensorEvent+0xbba>
	}

	case DYN_PRO_SENSOR_TYPE_HRV:
	{
		if(maxBufferSize < 10)
  40ed9c:	887b      	ldrh	r3, [r7, #2]
  40ed9e:	2b09      	cmp	r3, #9
  40eda0:	f240 8095 	bls.w	40eece <DynProtocol_encodeSensorEvent+0xc3a>
			goto error_size;

		// RR_count
		outBuffer[idx] = vSensordata->data.u8[0];
  40eda4:	8bfb      	ldrh	r3, [r7, #30]
  40eda6:	687a      	ldr	r2, [r7, #4]
  40eda8:	4413      	add	r3, r2
  40edaa:	697a      	ldr	r2, [r7, #20]
  40edac:	7a12      	ldrb	r2, [r2, #8]
  40edae:	701a      	strb	r2, [r3, #0]
		idx += 1;
  40edb0:	8bfb      	ldrh	r3, [r7, #30]
  40edb2:	3301      	adds	r3, #1
  40edb4:	83fb      	strh	r3, [r7, #30]

		// paddingDummy
		outBuffer[idx] = vSensordata->data.u8[1];
  40edb6:	8bfb      	ldrh	r3, [r7, #30]
  40edb8:	687a      	ldr	r2, [r7, #4]
  40edba:	4413      	add	r3, r2
  40edbc:	697a      	ldr	r2, [r7, #20]
  40edbe:	7a52      	ldrb	r2, [r2, #9]
  40edc0:	701a      	strb	r2, [r3, #0]
		idx += 1;
  40edc2:	8bfb      	ldrh	r3, [r7, #30]
  40edc4:	3301      	adds	r3, #1
  40edc6:	83fb      	strh	r3, [r7, #30]

		// RR_interval
		for (i=0; i<4; i++) {
  40edc8:	2300      	movs	r3, #0
  40edca:	83bb      	strh	r3, [r7, #28]
  40edcc:	e01b      	b.n	40ee06 <DynProtocol_encodeSensorEvent+0xb72>
  40edce:	bf00      	nop
  40edd0:	0040f791 	.word	0x0040f791
  40edd4:	0040cd19 	.word	0x0040cd19
  40edd8:	0040f7d5 	.word	0x0040f7d5
  40eddc:	00414045 	.word	0x00414045
			inv_dc_int16_to_little8(vSensordata->data.u16[i + 1], &outBuffer[idx]);
  40ede0:	8bbb      	ldrh	r3, [r7, #28]
  40ede2:	1c5a      	adds	r2, r3, #1
  40ede4:	697b      	ldr	r3, [r7, #20]
  40ede6:	3204      	adds	r2, #4
  40ede8:	f833 3012 	ldrh.w	r3, [r3, r2, lsl #1]
  40edec:	b218      	sxth	r0, r3
  40edee:	8bfb      	ldrh	r3, [r7, #30]
  40edf0:	687a      	ldr	r2, [r7, #4]
  40edf2:	4413      	add	r3, r2
  40edf4:	4619      	mov	r1, r3
  40edf6:	4b3b      	ldr	r3, [pc, #236]	; (40eee4 <DynProtocol_encodeSensorEvent+0xc50>)
  40edf8:	4798      	blx	r3
			idx += 2;
  40edfa:	8bfb      	ldrh	r3, [r7, #30]
  40edfc:	3302      	adds	r3, #2
  40edfe:	83fb      	strh	r3, [r7, #30]
		for (i=0; i<4; i++) {
  40ee00:	8bbb      	ldrh	r3, [r7, #28]
  40ee02:	3301      	adds	r3, #1
  40ee04:	83bb      	strh	r3, [r7, #28]
  40ee06:	8bbb      	ldrh	r3, [r7, #28]
  40ee08:	2b03      	cmp	r3, #3
  40ee0a:	d9e9      	bls.n	40ede0 <DynProtocol_encodeSensorEvent+0xb4c>
		}

		break;
  40ee0c:	e01f      	b.n	40ee4e <DynProtocol_encodeSensorEvent+0xbba>
	}

	case DYN_PRO_SENSOR_TYPE_DATA_ENCRYPTION:
	{
		if(maxBufferSize < (7*4))
  40ee0e:	887b      	ldrh	r3, [r7, #2]
  40ee10:	2b1b      	cmp	r3, #27
  40ee12:	d95e      	bls.n	40eed2 <DynProtocol_encodeSensorEvent+0xc3e>
			goto error_size;
				
		for (i=0; i<7; i++) {
  40ee14:	2300      	movs	r3, #0
  40ee16:	83bb      	strh	r3, [r7, #28]
  40ee18:	e011      	b.n	40ee3e <DynProtocol_encodeSensorEvent+0xbaa>
			inv_dc_int32_to_little8(vSensordata->data.u32[i], &outBuffer[idx]);
  40ee1a:	8bba      	ldrh	r2, [r7, #28]
  40ee1c:	697b      	ldr	r3, [r7, #20]
  40ee1e:	3202      	adds	r2, #2
  40ee20:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
  40ee24:	4618      	mov	r0, r3
  40ee26:	8bfb      	ldrh	r3, [r7, #30]
  40ee28:	687a      	ldr	r2, [r7, #4]
  40ee2a:	4413      	add	r3, r2
  40ee2c:	4619      	mov	r1, r3
  40ee2e:	4b2e      	ldr	r3, [pc, #184]	; (40eee8 <DynProtocol_encodeSensorEvent+0xc54>)
  40ee30:	4798      	blx	r3
			idx += 4;
  40ee32:	8bfb      	ldrh	r3, [r7, #30]
  40ee34:	3304      	adds	r3, #4
  40ee36:	83fb      	strh	r3, [r7, #30]
		for (i=0; i<7; i++) {
  40ee38:	8bbb      	ldrh	r3, [r7, #28]
  40ee3a:	3301      	adds	r3, #1
  40ee3c:	83bb      	strh	r3, [r7, #28]
  40ee3e:	8bbb      	ldrh	r3, [r7, #28]
  40ee40:	2b06      	cmp	r3, #6
  40ee42:	d9ea      	bls.n	40ee1a <DynProtocol_encodeSensorEvent+0xb86>
		}

		break;
  40ee44:	e003      	b.n	40ee4e <DynProtocol_encodeSensorEvent+0xbba>
	}

	default:
		return -1;
  40ee46:	f04f 33ff 	mov.w	r3, #4294967295
  40ee4a:	e047      	b.n	40eedc <DynProtocol_encodeSensorEvent+0xc48>
		break;
  40ee4c:	bf00      	nop
	}

	return idx;
  40ee4e:	8bfb      	ldrh	r3, [r7, #30]
  40ee50:	e044      	b.n	40eedc <DynProtocol_encodeSensorEvent+0xc48>
		goto error_size;
  40ee52:	bf00      	nop
  40ee54:	e03e      	b.n	40eed4 <DynProtocol_encodeSensorEvent+0xc40>
			goto error_size;
  40ee56:	bf00      	nop
  40ee58:	e03c      	b.n	40eed4 <DynProtocol_encodeSensorEvent+0xc40>
			goto error_size;
  40ee5a:	bf00      	nop
  40ee5c:	e03a      	b.n	40eed4 <DynProtocol_encodeSensorEvent+0xc40>
			goto error_size;
  40ee5e:	bf00      	nop
  40ee60:	e038      	b.n	40eed4 <DynProtocol_encodeSensorEvent+0xc40>
			goto error_size;
  40ee62:	bf00      	nop
  40ee64:	e036      	b.n	40eed4 <DynProtocol_encodeSensorEvent+0xc40>
			goto error_size;
  40ee66:	bf00      	nop
  40ee68:	e034      	b.n	40eed4 <DynProtocol_encodeSensorEvent+0xc40>
			goto error_size;
  40ee6a:	bf00      	nop
  40ee6c:	e032      	b.n	40eed4 <DynProtocol_encodeSensorEvent+0xc40>
			goto error_size;
  40ee6e:	bf00      	nop
  40ee70:	e030      	b.n	40eed4 <DynProtocol_encodeSensorEvent+0xc40>
			goto error_size;
  40ee72:	bf00      	nop
  40ee74:	e02e      	b.n	40eed4 <DynProtocol_encodeSensorEvent+0xc40>
			goto error_size;
  40ee76:	bf00      	nop
  40ee78:	e02c      	b.n	40eed4 <DynProtocol_encodeSensorEvent+0xc40>
			goto error_size;
  40ee7a:	bf00      	nop
  40ee7c:	e02a      	b.n	40eed4 <DynProtocol_encodeSensorEvent+0xc40>
			goto error_size;
  40ee7e:	bf00      	nop
  40ee80:	e028      	b.n	40eed4 <DynProtocol_encodeSensorEvent+0xc40>
			goto error_size;
  40ee82:	bf00      	nop
  40ee84:	e026      	b.n	40eed4 <DynProtocol_encodeSensorEvent+0xc40>
			goto error_size;
  40ee86:	bf00      	nop
  40ee88:	e024      	b.n	40eed4 <DynProtocol_encodeSensorEvent+0xc40>
			goto error_size;
  40ee8a:	bf00      	nop
  40ee8c:	e022      	b.n	40eed4 <DynProtocol_encodeSensorEvent+0xc40>
			goto error_size;
  40ee8e:	bf00      	nop
  40ee90:	e020      	b.n	40eed4 <DynProtocol_encodeSensorEvent+0xc40>
			goto error_size;
  40ee92:	bf00      	nop
  40ee94:	e01e      	b.n	40eed4 <DynProtocol_encodeSensorEvent+0xc40>
			goto error_size;
  40ee96:	bf00      	nop
  40ee98:	e01c      	b.n	40eed4 <DynProtocol_encodeSensorEvent+0xc40>
			goto error_size;
  40ee9a:	bf00      	nop
  40ee9c:	e01a      	b.n	40eed4 <DynProtocol_encodeSensorEvent+0xc40>
			goto error_size;
  40ee9e:	bf00      	nop
  40eea0:	e018      	b.n	40eed4 <DynProtocol_encodeSensorEvent+0xc40>
			goto error_size;
  40eea2:	bf00      	nop
  40eea4:	e016      	b.n	40eed4 <DynProtocol_encodeSensorEvent+0xc40>
			goto error_size;
  40eea6:	bf00      	nop
  40eea8:	e014      	b.n	40eed4 <DynProtocol_encodeSensorEvent+0xc40>
			goto error_size;
  40eeaa:	bf00      	nop
  40eeac:	e012      	b.n	40eed4 <DynProtocol_encodeSensorEvent+0xc40>
			goto error_size;
  40eeae:	bf00      	nop
  40eeb0:	e010      	b.n	40eed4 <DynProtocol_encodeSensorEvent+0xc40>
			goto error_size;
  40eeb2:	bf00      	nop
  40eeb4:	e00e      	b.n	40eed4 <DynProtocol_encodeSensorEvent+0xc40>
			goto error_size;
  40eeb6:	bf00      	nop
  40eeb8:	e00c      	b.n	40eed4 <DynProtocol_encodeSensorEvent+0xc40>
			goto error_size;
  40eeba:	bf00      	nop
  40eebc:	e00a      	b.n	40eed4 <DynProtocol_encodeSensorEvent+0xc40>
			goto error_size;
  40eebe:	bf00      	nop
  40eec0:	e008      	b.n	40eed4 <DynProtocol_encodeSensorEvent+0xc40>
			goto error_size;
  40eec2:	bf00      	nop
  40eec4:	e006      	b.n	40eed4 <DynProtocol_encodeSensorEvent+0xc40>
			goto error_size;
  40eec6:	bf00      	nop
  40eec8:	e004      	b.n	40eed4 <DynProtocol_encodeSensorEvent+0xc40>
			goto error_size;
  40eeca:	bf00      	nop
  40eecc:	e002      	b.n	40eed4 <DynProtocol_encodeSensorEvent+0xc40>
			goto error_size;
  40eece:	bf00      	nop
  40eed0:	e000      	b.n	40eed4 <DynProtocol_encodeSensorEvent+0xc40>
			goto error_size;
  40eed2:	bf00      	nop

error_size:
	return maxBufferSize + idx + 1; /* +1 to indicate buffer is too small */
  40eed4:	887a      	ldrh	r2, [r7, #2]
  40eed6:	8bfb      	ldrh	r3, [r7, #30]
  40eed8:	4413      	add	r3, r2
  40eeda:	3301      	adds	r3, #1
}
  40eedc:	4618      	mov	r0, r3
  40eede:	3724      	adds	r7, #36	; 0x24
  40eee0:	46bd      	mov	sp, r7
  40eee2:	bd90      	pop	{r4, r7, pc}
  40eee4:	0040f7d5 	.word	0x0040f7d5
  40eee8:	0040f791 	.word	0x0040f791

0040eeec <DynProtocol_checkFrameSize>:


static int DynProtocol_checkFrameSize(DynProtocol_t * self)
{
  40eeec:	b590      	push	{r4, r7, lr}
  40eeee:	b083      	sub	sp, #12
  40eef0:	af00      	add	r7, sp, #0
  40eef2:	6078      	str	r0, [r7, #4]
	if(self->decode_state_machine.expected_size == UINT16_MAX) {
  40eef4:	687b      	ldr	r3, [r7, #4]
  40eef6:	8a1b      	ldrh	r3, [r3, #16]
  40eef8:	f64f 72ff 	movw	r2, #65535	; 0xffff
  40eefc:	4293      	cmp	r3, r2
  40eefe:	d106      	bne.n	40ef0e <DynProtocol_checkFrameSize+0x22>
		/* assume frame is unknown, return error */
		INV_MSG(INV_MSG_LEVEL_ERROR, "DynProtocol: Unknown frame");
  40ef00:	4913      	ldr	r1, [pc, #76]	; (40ef50 <DynProtocol_checkFrameSize+0x64>)
  40ef02:	2001      	movs	r0, #1
  40ef04:	4b13      	ldr	r3, [pc, #76]	; (40ef54 <DynProtocol_checkFrameSize+0x68>)
  40ef06:	4798      	blx	r3
		return INV_ERROR_SIZE;
  40ef08:	f06f 0304 	mvn.w	r3, #4
  40ef0c:	e01b      	b.n	40ef46 <DynProtocol_checkFrameSize+0x5a>
	 * expected_size is the payload expected size (not the total frame expected size).
	 * it should respect this condititon:
	 *  current_frame_size >= 1 byte (GID) + 1 byte (CID) + expected_size
	 * note : current_frame_size == UINT16_MAX means check on frame size disabled (default).
	 */
	if(self->decode_state_machine.current_frame_size != UINT16_MAX) {
  40ef0e:	687b      	ldr	r3, [r7, #4]
  40ef10:	895b      	ldrh	r3, [r3, #10]
  40ef12:	f64f 72ff 	movw	r2, #65535	; 0xffff
  40ef16:	4293      	cmp	r3, r2
  40ef18:	d014      	beq.n	40ef44 <DynProtocol_checkFrameSize+0x58>
		if(self->decode_state_machine.current_frame_size < (self->decode_state_machine.expected_size + 2)) {
  40ef1a:	687b      	ldr	r3, [r7, #4]
  40ef1c:	895b      	ldrh	r3, [r3, #10]
  40ef1e:	461a      	mov	r2, r3
  40ef20:	687b      	ldr	r3, [r7, #4]
  40ef22:	8a1b      	ldrh	r3, [r3, #16]
  40ef24:	3302      	adds	r3, #2
  40ef26:	429a      	cmp	r2, r3
  40ef28:	da0c      	bge.n	40ef44 <DynProtocol_checkFrameSize+0x58>
			INV_MSG(INV_MSG_LEVEL_ERROR, "DynProtocol: Frame size error. size=%dB (expected %dB)",
  40ef2a:	687b      	ldr	r3, [r7, #4]
  40ef2c:	895b      	ldrh	r3, [r3, #10]
  40ef2e:	461a      	mov	r2, r3
  40ef30:	687b      	ldr	r3, [r7, #4]
  40ef32:	8a1b      	ldrh	r3, [r3, #16]
  40ef34:	3302      	adds	r3, #2
  40ef36:	4908      	ldr	r1, [pc, #32]	; (40ef58 <DynProtocol_checkFrameSize+0x6c>)
  40ef38:	2001      	movs	r0, #1
  40ef3a:	4c06      	ldr	r4, [pc, #24]	; (40ef54 <DynProtocol_checkFrameSize+0x68>)
  40ef3c:	47a0      	blx	r4
				self->decode_state_machine.current_frame_size, self->decode_state_machine.expected_size + 2);
			return INV_ERROR_SIZE;
  40ef3e:	f06f 0304 	mvn.w	r3, #4
  40ef42:	e000      	b.n	40ef46 <DynProtocol_checkFrameSize+0x5a>
		}
	}

	return INV_ERROR_SUCCESS;
  40ef44:	2300      	movs	r3, #0
}
  40ef46:	4618      	mov	r0, r3
  40ef48:	370c      	adds	r7, #12
  40ef4a:	46bd      	mov	sp, r7
  40ef4c:	bd90      	pop	{r4, r7, pc}
  40ef4e:	bf00      	nop
  40ef50:	0041cac8 	.word	0x0041cac8
  40ef54:	0040fd19 	.word	0x0040fd19
  40ef58:	0041cae4 	.word	0x0041cae4

0040ef5c <DynProtocol_init>:

void DynProtocol_init(DynProtocol_t * self,
		DynProtocolEvent_cb event_cb, void * event_cb_cookie)
{
  40ef5c:	b580      	push	{r7, lr}
  40ef5e:	b084      	sub	sp, #16
  40ef60:	af00      	add	r7, sp, #0
  40ef62:	60f8      	str	r0, [r7, #12]
  40ef64:	60b9      	str	r1, [r7, #8]
  40ef66:	607a      	str	r2, [r7, #4]
	memset(self, 0, sizeof(*self));
  40ef68:	f44f 7226 	mov.w	r2, #664	; 0x298
  40ef6c:	2100      	movs	r1, #0
  40ef6e:	68f8      	ldr	r0, [r7, #12]
  40ef70:	4b0b      	ldr	r3, [pc, #44]	; (40efa0 <DynProtocol_init+0x44>)
  40ef72:	4798      	blx	r3

	self->event_cb        = event_cb;
  40ef74:	68fb      	ldr	r3, [r7, #12]
  40ef76:	68ba      	ldr	r2, [r7, #8]
  40ef78:	601a      	str	r2, [r3, #0]
	self->event_cb_cookie = event_cb_cookie;
  40ef7a:	68fb      	ldr	r3, [r7, #12]
  40ef7c:	687a      	ldr	r2, [r7, #4]
  40ef7e:	605a      	str	r2, [r3, #4]
	self->decode_state_machine.current_frame_size = UINT16_MAX;
  40ef80:	68fb      	ldr	r3, [r7, #12]
  40ef82:	f64f 72ff 	movw	r2, #65535	; 0xffff
  40ef86:	815a      	strh	r2, [r3, #10]
	self->precision.acc = PROTOCOL_ACCELEROMETER_PRECISION;
  40ef88:	68fb      	ldr	r3, [r7, #12]
  40ef8a:	220b      	movs	r2, #11
  40ef8c:	f883 2294 	strb.w	r2, [r3, #660]	; 0x294
	self->precision.gyro = PROTOCOL_GYROSCOPE_PRECISION;
  40ef90:	68fb      	ldr	r3, [r7, #12]
  40ef92:	2204      	movs	r2, #4
  40ef94:	f883 2295 	strb.w	r2, [r3, #661]	; 0x295
}
  40ef98:	bf00      	nop
  40ef9a:	3710      	adds	r7, #16
  40ef9c:	46bd      	mov	sp, r7
  40ef9e:	bd80      	pop	{r7, pc}
  40efa0:	00414241 	.word	0x00414241

0040efa4 <DynProtocol_processPktByte>:
	}
	return rc;
}

int DynProtocol_processPktByte(DynProtocol_t * self, uint8_t rcvByte)
{
  40efa4:	b580      	push	{r7, lr}
  40efa6:	b084      	sub	sp, #16
  40efa8:	af00      	add	r7, sp, #0
  40efaa:	6078      	str	r0, [r7, #4]
  40efac:	460b      	mov	r3, r1
  40efae:	70fb      	strb	r3, [r7, #3]
	switch(self->decode_state_machine.state) {
  40efb0:	687b      	ldr	r3, [r7, #4]
  40efb2:	7a1b      	ldrb	r3, [r3, #8]
  40efb4:	2b01      	cmp	r3, #1
  40efb6:	d021      	beq.n	40effc <DynProtocol_processPktByte+0x58>
  40efb8:	2b02      	cmp	r3, #2
  40efba:	d047      	beq.n	40f04c <DynProtocol_processPktByte+0xa8>
  40efbc:	2b00      	cmp	r3, #0
  40efbe:	f040 8085 	bne.w	40f0cc <DynProtocol_processPktByte+0x128>
	case PROTOCOL_STATE_GID:
	{
		self->decode_state_machine.event_type = (rcvByte & EVENT_TYPE_MASK);
  40efc2:	78fb      	ldrb	r3, [r7, #3]
  40efc4:	f023 033f 	bic.w	r3, r3, #63	; 0x3f
  40efc8:	b2da      	uxtb	r2, r3
  40efca:	687b      	ldr	r3, [r7, #4]
  40efcc:	731a      	strb	r2, [r3, #12]
		self->decode_state_machine.group_id   = (rcvByte & ~EVENT_TYPE_MASK);
  40efce:	78fb      	ldrb	r3, [r7, #3]
  40efd0:	f003 033f 	and.w	r3, r3, #63	; 0x3f
  40efd4:	b2da      	uxtb	r2, r3
  40efd6:	687b      	ldr	r3, [r7, #4]
  40efd8:	735a      	strb	r2, [r3, #13]
		self->decode_state_machine.state      = PROTOCOL_STATE_CID;
  40efda:	687b      	ldr	r3, [r7, #4]
  40efdc:	2201      	movs	r2, #1
  40efde:	721a      	strb	r2, [r3, #8]

		if(self->decode_state_machine.group_id != DYN_PROTOCOL_GROUP_ID) {
  40efe0:	687b      	ldr	r3, [r7, #4]
  40efe2:	7b5b      	ldrb	r3, [r3, #13]
  40efe4:	2b03      	cmp	r3, #3
  40efe6:	d06c      	beq.n	40f0c2 <DynProtocol_processPktByte+0x11e>
			self->decode_state_machine.state  = PROTOCOL_STATE_IDLE;
  40efe8:	687b      	ldr	r3, [r7, #4]
  40efea:	2200      	movs	r2, #0
  40efec:	721a      	strb	r2, [r3, #8]
			INV_MSG(INV_MSG_LEVEL_ERROR, "DynProtocol: Invalid group ID");
  40efee:	493a      	ldr	r1, [pc, #232]	; (40f0d8 <DynProtocol_processPktByte+0x134>)
  40eff0:	2001      	movs	r0, #1
  40eff2:	4b3a      	ldr	r3, [pc, #232]	; (40f0dc <DynProtocol_processPktByte+0x138>)
  40eff4:	4798      	blx	r3
			return -1;
  40eff6:	f04f 33ff 	mov.w	r3, #4294967295
  40effa:	e068      	b.n	40f0ce <DynProtocol_processPktByte+0x12a>

	case PROTOCOL_STATE_CID:
	{
		int rc;

		self->decode_state_machine.cmd_id     = rcvByte;
  40effc:	687b      	ldr	r3, [r7, #4]
  40effe:	78fa      	ldrb	r2, [r7, #3]
  40f000:	739a      	strb	r2, [r3, #14]
		self->decode_state_machine.state      = PROTOCOL_STATE_PAYLOAD;
  40f002:	687b      	ldr	r3, [r7, #4]
  40f004:	2202      	movs	r2, #2
  40f006:	721a      	strb	r2, [r3, #8]
		self->decode_state_machine.received_size = 0;
  40f008:	687b      	ldr	r3, [r7, #4]
  40f00a:	2200      	movs	r2, #0
  40f00c:	825a      	strh	r2, [r3, #18]
		self->decode_state_machine.expected_size = 0;
  40f00e:	687b      	ldr	r3, [r7, #4]
  40f010:	2200      	movs	r2, #0
  40f012:	821a      	strh	r2, [r3, #16]
		self->decode_state_machine.expected_size = DynProtocol_getPayload(self);
  40f014:	6878      	ldr	r0, [r7, #4]
  40f016:	4b32      	ldr	r3, [pc, #200]	; (40f0e0 <DynProtocol_processPktByte+0x13c>)
  40f018:	4798      	blx	r3
  40f01a:	4603      	mov	r3, r0
  40f01c:	b29a      	uxth	r2, r3
  40f01e:	687b      	ldr	r3, [r7, #4]
  40f020:	821a      	strh	r2, [r3, #16]

		if((rc = DynProtocol_checkFrameSize(self)) != INV_ERROR_SUCCESS) {
  40f022:	6878      	ldr	r0, [r7, #4]
  40f024:	4b2f      	ldr	r3, [pc, #188]	; (40f0e4 <DynProtocol_processPktByte+0x140>)
  40f026:	4798      	blx	r3
  40f028:	60f8      	str	r0, [r7, #12]
  40f02a:	68fb      	ldr	r3, [r7, #12]
  40f02c:	2b00      	cmp	r3, #0
  40f02e:	d004      	beq.n	40f03a <DynProtocol_processPktByte+0x96>
			self->decode_state_machine.state = PROTOCOL_STATE_IDLE;
  40f030:	687b      	ldr	r3, [r7, #4]
  40f032:	2200      	movs	r2, #0
  40f034:	721a      	strb	r2, [r3, #8]
			return rc;
  40f036:	68fb      	ldr	r3, [r7, #12]
  40f038:	e049      	b.n	40f0ce <DynProtocol_processPktByte+0x12a>
		}

		if(self->decode_state_machine.expected_size == 0) {
  40f03a:	687b      	ldr	r3, [r7, #4]
  40f03c:	8a1b      	ldrh	r3, [r3, #16]
  40f03e:	2b00      	cmp	r3, #0
  40f040:	d141      	bne.n	40f0c6 <DynProtocol_processPktByte+0x122>
			return DynProtocol_doProcess(self);
  40f042:	6878      	ldr	r0, [r7, #4]
  40f044:	4b28      	ldr	r3, [pc, #160]	; (40f0e8 <DynProtocol_processPktByte+0x144>)
  40f046:	4798      	blx	r3
  40f048:	4603      	mov	r3, r0
  40f04a:	e040      	b.n	40f0ce <DynProtocol_processPktByte+0x12a>

	case PROTOCOL_STATE_PAYLOAD:
	{
		int rc;

		if(self->decode_state_machine.received_size >= MAX_EXPECTED_PAYLOAD)
  40f04c:	687b      	ldr	r3, [r7, #4]
  40f04e:	8a5b      	ldrh	r3, [r3, #18]
  40f050:	f5b3 7f20 	cmp.w	r3, #640	; 0x280
  40f054:	d304      	bcc.n	40f060 <DynProtocol_processPktByte+0xbc>
			INV_MSG(INV_MSG_LEVEL_WARNING, "DynProtocol: internal buffer size full");
  40f056:	4925      	ldr	r1, [pc, #148]	; (40f0ec <DynProtocol_processPktByte+0x148>)
  40f058:	2002      	movs	r0, #2
  40f05a:	4b20      	ldr	r3, [pc, #128]	; (40f0dc <DynProtocol_processPktByte+0x138>)
  40f05c:	4798      	blx	r3
  40f05e:	e006      	b.n	40f06e <DynProtocol_processPktByte+0xca>
		else
			self->decode_state_machine.tmp_buffer[self->decode_state_machine.received_size] = rcvByte;
  40f060:	687b      	ldr	r3, [r7, #4]
  40f062:	8a5b      	ldrh	r3, [r3, #18]
  40f064:	461a      	mov	r2, r3
  40f066:	687b      	ldr	r3, [r7, #4]
  40f068:	4413      	add	r3, r2
  40f06a:	78fa      	ldrb	r2, [r7, #3]
  40f06c:	751a      	strb	r2, [r3, #20]

		self->decode_state_machine.received_size++;
  40f06e:	687b      	ldr	r3, [r7, #4]
  40f070:	8a5b      	ldrh	r3, [r3, #18]
  40f072:	3301      	adds	r3, #1
  40f074:	b29a      	uxth	r2, r3
  40f076:	687b      	ldr	r3, [r7, #4]
  40f078:	825a      	strh	r2, [r3, #18]
		if(self->decode_state_machine.received_size == self->decode_state_machine.expected_size)
  40f07a:	687b      	ldr	r3, [r7, #4]
  40f07c:	8a5a      	ldrh	r2, [r3, #18]
  40f07e:	687b      	ldr	r3, [r7, #4]
  40f080:	8a1b      	ldrh	r3, [r3, #16]
  40f082:	429a      	cmp	r2, r3
  40f084:	d106      	bne.n	40f094 <DynProtocol_processPktByte+0xf0>
			/* update expected payload, in case actual payload cannot be determined using only CID */
			self->decode_state_machine.expected_size = DynProtocol_getPayload(self);
  40f086:	6878      	ldr	r0, [r7, #4]
  40f088:	4b15      	ldr	r3, [pc, #84]	; (40f0e0 <DynProtocol_processPktByte+0x13c>)
  40f08a:	4798      	blx	r3
  40f08c:	4603      	mov	r3, r0
  40f08e:	b29a      	uxth	r2, r3
  40f090:	687b      	ldr	r3, [r7, #4]
  40f092:	821a      	strh	r2, [r3, #16]

		if((rc = DynProtocol_checkFrameSize(self)) != INV_ERROR_SUCCESS) {
  40f094:	6878      	ldr	r0, [r7, #4]
  40f096:	4b13      	ldr	r3, [pc, #76]	; (40f0e4 <DynProtocol_processPktByte+0x140>)
  40f098:	4798      	blx	r3
  40f09a:	60b8      	str	r0, [r7, #8]
  40f09c:	68bb      	ldr	r3, [r7, #8]
  40f09e:	2b00      	cmp	r3, #0
  40f0a0:	d004      	beq.n	40f0ac <DynProtocol_processPktByte+0x108>
			self->decode_state_machine.state = PROTOCOL_STATE_IDLE;
  40f0a2:	687b      	ldr	r3, [r7, #4]
  40f0a4:	2200      	movs	r2, #0
  40f0a6:	721a      	strb	r2, [r3, #8]
			return rc;
  40f0a8:	68bb      	ldr	r3, [r7, #8]
  40f0aa:	e010      	b.n	40f0ce <DynProtocol_processPktByte+0x12a>
		}

		if(self->decode_state_machine.received_size == self->decode_state_machine.expected_size)
  40f0ac:	687b      	ldr	r3, [r7, #4]
  40f0ae:	8a5a      	ldrh	r2, [r3, #18]
  40f0b0:	687b      	ldr	r3, [r7, #4]
  40f0b2:	8a1b      	ldrh	r3, [r3, #16]
  40f0b4:	429a      	cmp	r2, r3
  40f0b6:	d108      	bne.n	40f0ca <DynProtocol_processPktByte+0x126>
			return DynProtocol_doProcess(self);
  40f0b8:	6878      	ldr	r0, [r7, #4]
  40f0ba:	4b0b      	ldr	r3, [pc, #44]	; (40f0e8 <DynProtocol_processPktByte+0x144>)
  40f0bc:	4798      	blx	r3
  40f0be:	4603      	mov	r3, r0
  40f0c0:	e005      	b.n	40f0ce <DynProtocol_processPktByte+0x12a>
		break;
  40f0c2:	bf00      	nop
  40f0c4:	e002      	b.n	40f0cc <DynProtocol_processPktByte+0x128>
		break;
  40f0c6:	bf00      	nop
  40f0c8:	e000      	b.n	40f0cc <DynProtocol_processPktByte+0x128>

		break;
  40f0ca:	bf00      	nop
	}
	}

	return 0;
  40f0cc:	2300      	movs	r3, #0
}
  40f0ce:	4618      	mov	r0, r3
  40f0d0:	3710      	adds	r7, #16
  40f0d2:	46bd      	mov	sp, r7
  40f0d4:	bd80      	pop	{r7, pc}
  40f0d6:	bf00      	nop
  40f0d8:	0041cb1c 	.word	0x0041cb1c
  40f0dc:	0040fd19 	.word	0x0040fd19
  40f0e0:	0040cf05 	.word	0x0040cf05
  40f0e4:	0040eeed 	.word	0x0040eeed
  40f0e8:	0040e1d1 	.word	0x0040e1d1
  40f0ec:	0041cb3c 	.word	0x0041cb3c

0040f0f0 <DynProtocol_encodeResponse>:
}

int DynProtocol_encodeResponse(DynProtocol_t * self,
		enum DynProtocolEid eid, const DynProtocolEdata_t * edata,
		uint8_t * outBuffer, uint16_t maxBufferSize, uint16_t *outBufferSize)
{
  40f0f0:	b590      	push	{r4, r7, lr}
  40f0f2:	b089      	sub	sp, #36	; 0x24
  40f0f4:	af02      	add	r7, sp, #8
  40f0f6:	60f8      	str	r0, [r7, #12]
  40f0f8:	607a      	str	r2, [r7, #4]
  40f0fa:	603b      	str	r3, [r7, #0]
  40f0fc:	460b      	mov	r3, r1
  40f0fe:	72fb      	strb	r3, [r7, #11]
	int precision;
	uint16_t idx = 0;
  40f100:	2300      	movs	r3, #0
  40f102:	82fb      	strh	r3, [r7, #22]

	(void)self;

	*outBufferSize = 0;
  40f104:	6afb      	ldr	r3, [r7, #44]	; 0x2c
  40f106:	2200      	movs	r2, #0
  40f108:	801a      	strh	r2, [r3, #0]

	if(maxBufferSize < 2)
  40f10a:	8d3b      	ldrh	r3, [r7, #40]	; 0x28
  40f10c:	2b01      	cmp	r3, #1
  40f10e:	f240 8186 	bls.w	40f41e <DynProtocol_encodeResponse+0x32e>
		goto error_size;

	outBuffer[idx]  = EVENT_TYPE_RESP; // Set event type
  40f112:	8afb      	ldrh	r3, [r7, #22]
  40f114:	683a      	ldr	r2, [r7, #0]
  40f116:	4413      	add	r3, r2
  40f118:	2240      	movs	r2, #64	; 0x40
  40f11a:	701a      	strb	r2, [r3, #0]
	outBuffer[idx++] |= DYN_PROTOCOL_GROUP_ID & ~EVENT_TYPE_MASK; // Set group ID
  40f11c:	8afb      	ldrh	r3, [r7, #22]
  40f11e:	1c5a      	adds	r2, r3, #1
  40f120:	82fa      	strh	r2, [r7, #22]
  40f122:	4619      	mov	r1, r3
  40f124:	683a      	ldr	r2, [r7, #0]
  40f126:	440a      	add	r2, r1
  40f128:	4619      	mov	r1, r3
  40f12a:	683b      	ldr	r3, [r7, #0]
  40f12c:	440b      	add	r3, r1
  40f12e:	781b      	ldrb	r3, [r3, #0]
  40f130:	f043 0303 	orr.w	r3, r3, #3
  40f134:	b2db      	uxtb	r3, r3
  40f136:	7013      	strb	r3, [r2, #0]
	outBuffer[idx++] = (uint8_t)eid;
  40f138:	8afb      	ldrh	r3, [r7, #22]
  40f13a:	1c5a      	adds	r2, r3, #1
  40f13c:	82fa      	strh	r2, [r7, #22]
  40f13e:	461a      	mov	r2, r3
  40f140:	683b      	ldr	r3, [r7, #0]
  40f142:	4413      	add	r3, r2
  40f144:	7afa      	ldrb	r2, [r7, #11]
  40f146:	701a      	strb	r2, [r3, #0]

	switch(eid) {
  40f148:	7afb      	ldrb	r3, [r7, #11]
  40f14a:	2b27      	cmp	r3, #39	; 0x27
  40f14c:	f200 815d 	bhi.w	40f40a <DynProtocol_encodeResponse+0x31a>
  40f150:	a201      	add	r2, pc, #4	; (adr r2, 40f158 <DynProtocol_encodeResponse+0x68>)
  40f152:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
  40f156:	bf00      	nop
  40f158:	0040f1f9 	.word	0x0040f1f9
  40f15c:	0040f40b 	.word	0x0040f40b
  40f160:	0040f40b 	.word	0x0040f40b
  40f164:	0040f40b 	.word	0x0040f40b
  40f168:	0040f40b 	.word	0x0040f40b
  40f16c:	0040f40b 	.word	0x0040f40b
  40f170:	0040f40b 	.word	0x0040f40b
  40f174:	0040f40b 	.word	0x0040f40b
  40f178:	0040f40b 	.word	0x0040f40b
  40f17c:	0040f40b 	.word	0x0040f40b
  40f180:	0040f40b 	.word	0x0040f40b
  40f184:	0040f40b 	.word	0x0040f40b
  40f188:	0040f40b 	.word	0x0040f40b
  40f18c:	0040f40b 	.word	0x0040f40b
  40f190:	0040f40b 	.word	0x0040f40b
  40f194:	0040f40b 	.word	0x0040f40b
  40f198:	0040f22b 	.word	0x0040f22b
  40f19c:	0040f22b 	.word	0x0040f22b
  40f1a0:	0040f22b 	.word	0x0040f22b
  40f1a4:	0040f22b 	.word	0x0040f22b
  40f1a8:	0040f40b 	.word	0x0040f40b
  40f1ac:	0040f22b 	.word	0x0040f22b
  40f1b0:	0040f1f9 	.word	0x0040f1f9
  40f1b4:	0040f22b 	.word	0x0040f22b
  40f1b8:	0040f40b 	.word	0x0040f40b
  40f1bc:	0040f22b 	.word	0x0040f22b
  40f1c0:	0040f22b 	.word	0x0040f22b
  40f1c4:	0040f22b 	.word	0x0040f22b
  40f1c8:	0040f22b 	.word	0x0040f22b
  40f1cc:	0040f22b 	.word	0x0040f22b
  40f1d0:	0040f22b 	.word	0x0040f22b
  40f1d4:	0040f355 	.word	0x0040f355
  40f1d8:	0040f22b 	.word	0x0040f22b
  40f1dc:	0040f24d 	.word	0x0040f24d
  40f1e0:	0040f22b 	.word	0x0040f22b
  40f1e4:	0040f22b 	.word	0x0040f22b
  40f1e8:	0040f29b 	.word	0x0040f29b
  40f1ec:	0040f22b 	.word	0x0040f22b
  40f1f0:	0040f3cf 	.word	0x0040f3cf
  40f1f4:	0040f22b 	.word	0x0040f22b
	case DYN_PROTOCOL_EID_PROTOCOLVERSION:
	case DYN_PROTOCOL_EID_GET_FW_INFO:
	{
		if((maxBufferSize - idx) < 16)
  40f1f8:	8d3a      	ldrh	r2, [r7, #40]	; 0x28
  40f1fa:	8afb      	ldrh	r3, [r7, #22]
  40f1fc:	1ad3      	subs	r3, r2, r3
  40f1fe:	2b0f      	cmp	r3, #15
  40f200:	f340 810f 	ble.w	40f422 <DynProtocol_encodeResponse+0x332>
			goto error_size;
		memcpy(&outBuffer[idx], edata->d.response.version, 15);
  40f204:	8afb      	ldrh	r3, [r7, #22]
  40f206:	683a      	ldr	r2, [r7, #0]
  40f208:	18d0      	adds	r0, r2, r3
  40f20a:	687b      	ldr	r3, [r7, #4]
  40f20c:	3304      	adds	r3, #4
  40f20e:	220f      	movs	r2, #15
  40f210:	4619      	mov	r1, r3
  40f212:	4b8f      	ldr	r3, [pc, #572]	; (40f450 <DynProtocol_encodeResponse+0x360>)
  40f214:	4798      	blx	r3
		outBuffer[idx+15] = '\0';
  40f216:	8afb      	ldrh	r3, [r7, #22]
  40f218:	330f      	adds	r3, #15
  40f21a:	683a      	ldr	r2, [r7, #0]
  40f21c:	4413      	add	r3, r2
  40f21e:	2200      	movs	r2, #0
  40f220:	701a      	strb	r2, [r3, #0]
		idx += 16;
  40f222:	8afb      	ldrh	r3, [r7, #22]
  40f224:	3310      	adds	r3, #16
  40f226:	82fb      	strh	r3, [r7, #22]
		break;
  40f228:	e0ea      	b.n	40f400 <DynProtocol_encodeResponse+0x310>
	case DYN_PROTOCOL_EID_SET_SENSOR_CFG:
	case DYN_PROTOCOL_EID_SET_SENSOR_BIAS:
	case DYN_PROTOCOL_EID_WRITE_MEMS_REG:
	case DYN_PROTOCOL_EID_TRANSFER_BUFFER:
	{
		if((maxBufferSize - idx) < 1)
  40f22a:	8d3a      	ldrh	r2, [r7, #40]	; 0x28
  40f22c:	8afb      	ldrh	r3, [r7, #22]
  40f22e:	1ad3      	subs	r3, r2, r3
  40f230:	2b00      	cmp	r3, #0
  40f232:	f340 80f8 	ble.w	40f426 <DynProtocol_encodeResponse+0x336>
			goto error_size;
		outBuffer[idx++] = (uint8_t)edata->d.response.rc;
  40f236:	8afb      	ldrh	r3, [r7, #22]
  40f238:	1c5a      	adds	r2, r3, #1
  40f23a:	82fa      	strh	r2, [r7, #22]
  40f23c:	461a      	mov	r2, r3
  40f23e:	683b      	ldr	r3, [r7, #0]
  40f240:	4413      	add	r3, r2
  40f242:	687a      	ldr	r2, [r7, #4]
  40f244:	6852      	ldr	r2, [r2, #4]
  40f246:	b2d2      	uxtb	r2, r2
  40f248:	701a      	strb	r2, [r3, #0]
		break;
  40f24a:	e0d9      	b.n	40f400 <DynProtocol_encodeResponse+0x310>
	}

	case DYN_PROTOCOL_EID_GET_SENSOR_DATA:
	{
		if((maxBufferSize - idx) < (1+1+1+4+64)) // need room for rc+sensorstatus+sensorid+timestamp+data
  40f24c:	8d3a      	ldrh	r2, [r7, #40]	; 0x28
  40f24e:	8afb      	ldrh	r3, [r7, #22]
  40f250:	1ad3      	subs	r3, r2, r3
  40f252:	2b46      	cmp	r3, #70	; 0x46
  40f254:	f340 80e9 	ble.w	40f42a <DynProtocol_encodeResponse+0x33a>
			goto error_size;
		outBuffer[idx++] = edata->d.response.sensorData.rc;
  40f258:	8afb      	ldrh	r3, [r7, #22]
  40f25a:	1c5a      	adds	r2, r3, #1
  40f25c:	82fa      	strh	r2, [r7, #22]
  40f25e:	461a      	mov	r2, r3
  40f260:	683b      	ldr	r3, [r7, #0]
  40f262:	4413      	add	r3, r2
  40f264:	687a      	ldr	r2, [r7, #4]
  40f266:	6852      	ldr	r2, [r2, #4]
  40f268:	b2d2      	uxtb	r2, r2
  40f26a:	701a      	strb	r2, [r3, #0]
 		if(DynProtocol_encodeSensorEvent(self, edata, &outBuffer[idx], maxBufferSize - idx, DYN_PROTOCOL_ETYPE_RESP) == -1)
  40f26c:	8afb      	ldrh	r3, [r7, #22]
  40f26e:	683a      	ldr	r2, [r7, #0]
  40f270:	18d1      	adds	r1, r2, r3
  40f272:	8d3a      	ldrh	r2, [r7, #40]	; 0x28
  40f274:	8afb      	ldrh	r3, [r7, #22]
  40f276:	1ad3      	subs	r3, r2, r3
  40f278:	b29a      	uxth	r2, r3
  40f27a:	2301      	movs	r3, #1
  40f27c:	9300      	str	r3, [sp, #0]
  40f27e:	4613      	mov	r3, r2
  40f280:	460a      	mov	r2, r1
  40f282:	6879      	ldr	r1, [r7, #4]
  40f284:	68f8      	ldr	r0, [r7, #12]
  40f286:	4c73      	ldr	r4, [pc, #460]	; (40f454 <DynProtocol_encodeResponse+0x364>)
  40f288:	47a0      	blx	r4
  40f28a:	4603      	mov	r3, r0
  40f28c:	f1b3 3fff 	cmp.w	r3, #4294967295
  40f290:	f000 80bd 	beq.w	40f40e <DynProtocol_encodeResponse+0x31e>
			goto error_arg;

		// GET_SENSOR_DATA response frame size is fixed:
		//  EVT_TYPE + EVT_ID + RC + SENSOR_STATUS + SENSORID + TIMESTAMP[0-3] + MAX_SENSOR_EVENT_DATA_SIZE (arbitrary fixed to 64B)
		idx = 1+1+1+1+1+4+64;
  40f294:	2349      	movs	r3, #73	; 0x49
  40f296:	82fb      	strh	r3, [r7, #22]
		break;
  40f298:	e0b2      	b.n	40f400 <DynProtocol_encodeResponse+0x310>
	}

	case DYN_PROTOCOL_EID_GET_SENSOR_CFG:
	{
		if((maxBufferSize - idx) < 68)
  40f29a:	8d3a      	ldrh	r2, [r7, #40]	; 0x28
  40f29c:	8afb      	ldrh	r3, [r7, #22]
  40f29e:	1ad3      	subs	r3, r2, r3
  40f2a0:	2b43      	cmp	r3, #67	; 0x43
  40f2a2:	f340 80c4 	ble.w	40f42e <DynProtocol_encodeResponse+0x33e>
			goto error_size;
		outBuffer[idx++] = (uint8_t)edata->d.response.sensorcfg.rc;
  40f2a6:	8afb      	ldrh	r3, [r7, #22]
  40f2a8:	1c5a      	adds	r2, r3, #1
  40f2aa:	82fa      	strh	r2, [r7, #22]
  40f2ac:	461a      	mov	r2, r3
  40f2ae:	683b      	ldr	r3, [r7, #0]
  40f2b0:	4413      	add	r3, r2
  40f2b2:	687a      	ldr	r2, [r7, #4]
  40f2b4:	6852      	ldr	r2, [r2, #4]
  40f2b6:	b2d2      	uxtb	r2, r2
  40f2b8:	701a      	strb	r2, [r3, #0]
		outBuffer[idx++] = (uint8_t)edata->d.response.sensorcfg.cfg.base.type;
  40f2ba:	8afb      	ldrh	r3, [r7, #22]
  40f2bc:	1c5a      	adds	r2, r3, #1
  40f2be:	82fa      	strh	r2, [r7, #22]
  40f2c0:	461a      	mov	r2, r3
  40f2c2:	683b      	ldr	r3, [r7, #0]
  40f2c4:	4413      	add	r3, r2
  40f2c6:	687a      	ldr	r2, [r7, #4]
  40f2c8:	6892      	ldr	r2, [r2, #8]
  40f2ca:	b2d2      	uxtb	r2, r2
  40f2cc:	701a      	strb	r2, [r3, #0]
		outBuffer[idx++] = (uint8_t)edata->d.response.sensorcfg.cfg.base.size;
  40f2ce:	8afb      	ldrh	r3, [r7, #22]
  40f2d0:	1c5a      	adds	r2, r3, #1
  40f2d2:	82fa      	strh	r2, [r7, #22]
  40f2d4:	461a      	mov	r2, r3
  40f2d6:	683b      	ldr	r3, [r7, #0]
  40f2d8:	4413      	add	r3, r2
  40f2da:	687a      	ldr	r2, [r7, #4]
  40f2dc:	68d2      	ldr	r2, [r2, #12]
  40f2de:	b2d2      	uxtb	r2, r2
  40f2e0:	701a      	strb	r2, [r3, #0]
		switch (edata->d.response.sensorcfg.cfg.base.type) {
  40f2e2:	687b      	ldr	r3, [r7, #4]
  40f2e4:	689b      	ldr	r3, [r3, #8]
  40f2e6:	2b03      	cmp	r3, #3
  40f2e8:	d11d      	bne.n	40f326 <DynProtocol_encodeResponse+0x236>
		case VSENSOR_CONFIG_TYPE_OFFSET:
			outBuffer[idx++] = (uint8_t)edata->sensor_id;
  40f2ea:	8afb      	ldrh	r3, [r7, #22]
  40f2ec:	1c5a      	adds	r2, r3, #1
  40f2ee:	82fa      	strh	r2, [r7, #22]
  40f2f0:	461a      	mov	r2, r3
  40f2f2:	683b      	ldr	r3, [r7, #0]
  40f2f4:	4413      	add	r3, r2
  40f2f6:	687a      	ldr	r2, [r7, #4]
  40f2f8:	6812      	ldr	r2, [r2, #0]
  40f2fa:	b2d2      	uxtb	r2, r2
  40f2fc:	701a      	strb	r2, [r3, #0]
			precision = DynProtocol_getPrecision(self, edata->sensor_id);
  40f2fe:	687b      	ldr	r3, [r7, #4]
  40f300:	681b      	ldr	r3, [r3, #0]
  40f302:	4619      	mov	r1, r3
  40f304:	68f8      	ldr	r0, [r7, #12]
  40f306:	4b54      	ldr	r3, [pc, #336]	; (40f458 <DynProtocol_encodeResponse+0x368>)
  40f308:	4798      	blx	r3
  40f30a:	6138      	str	r0, [r7, #16]
			DynProtocol_encodeQxToQyVect16((int32_t*)&edata->d.response.sensorcfg.cfg.buffer[0], 3, 16, precision, &outBuffer[idx]);
  40f30c:	687b      	ldr	r3, [r7, #4]
  40f30e:	f103 0010 	add.w	r0, r3, #16
  40f312:	8afb      	ldrh	r3, [r7, #22]
  40f314:	683a      	ldr	r2, [r7, #0]
  40f316:	4413      	add	r3, r2
  40f318:	9300      	str	r3, [sp, #0]
  40f31a:	693b      	ldr	r3, [r7, #16]
  40f31c:	2210      	movs	r2, #16
  40f31e:	2103      	movs	r1, #3
  40f320:	4c4e      	ldr	r4, [pc, #312]	; (40f45c <DynProtocol_encodeResponse+0x36c>)
  40f322:	47a0      	blx	r4
			break;
  40f324:	e013      	b.n	40f34e <DynProtocol_encodeResponse+0x25e>
		default:
			// we don't know what is the value of cfg.size so let's make sure
			// there is enough room in outBuffer.
			if((uint32_t)(maxBufferSize - idx) < edata->d.response.sensorcfg.cfg.base.size)
  40f326:	8d3a      	ldrh	r2, [r7, #40]	; 0x28
  40f328:	8afb      	ldrh	r3, [r7, #22]
  40f32a:	1ad3      	subs	r3, r2, r3
  40f32c:	461a      	mov	r2, r3
  40f32e:	687b      	ldr	r3, [r7, #4]
  40f330:	68db      	ldr	r3, [r3, #12]
  40f332:	429a      	cmp	r2, r3
  40f334:	d37d      	bcc.n	40f432 <DynProtocol_encodeResponse+0x342>
				goto error_size;
			memcpy(&outBuffer[idx], edata->d.response.sensorcfg.cfg.buffer, edata->d.response.sensorcfg.cfg.base.size);
  40f336:	8afb      	ldrh	r3, [r7, #22]
  40f338:	683a      	ldr	r2, [r7, #0]
  40f33a:	18d0      	adds	r0, r2, r3
  40f33c:	687b      	ldr	r3, [r7, #4]
  40f33e:	f103 0110 	add.w	r1, r3, #16
  40f342:	687b      	ldr	r3, [r7, #4]
  40f344:	68db      	ldr	r3, [r3, #12]
  40f346:	461a      	mov	r2, r3
  40f348:	4b41      	ldr	r3, [pc, #260]	; (40f450 <DynProtocol_encodeResponse+0x360>)
  40f34a:	4798      	blx	r3
			break;
  40f34c:	bf00      	nop
		}
		idx = 68 + 2;
  40f34e:	2346      	movs	r3, #70	; 0x46
  40f350:	82fb      	strh	r3, [r7, #22]
		break;
  40f352:	e055      	b.n	40f400 <DynProtocol_encodeResponse+0x310>
	}

	case DYN_PROTOCOL_EID_GET_SENSOR_BIAS:
	{
		if ((maxBufferSize - idx) < 1 + 1 + 1 + (3 * 2))
  40f354:	8d3a      	ldrh	r2, [r7, #40]	; 0x28
  40f356:	8afb      	ldrh	r3, [r7, #22]
  40f358:	1ad3      	subs	r3, r2, r3
  40f35a:	2b08      	cmp	r3, #8
  40f35c:	dd6b      	ble.n	40f436 <DynProtocol_encodeResponse+0x346>
			goto error_size;
		outBuffer[idx++] = (uint8_t)edata->d.response.sensorcfg.rc;
  40f35e:	8afb      	ldrh	r3, [r7, #22]
  40f360:	1c5a      	adds	r2, r3, #1
  40f362:	82fa      	strh	r2, [r7, #22]
  40f364:	461a      	mov	r2, r3
  40f366:	683b      	ldr	r3, [r7, #0]
  40f368:	4413      	add	r3, r2
  40f36a:	687a      	ldr	r2, [r7, #4]
  40f36c:	6852      	ldr	r2, [r2, #4]
  40f36e:	b2d2      	uxtb	r2, r2
  40f370:	701a      	strb	r2, [r3, #0]
		outBuffer[idx++] = (uint8_t)edata->sensor_id;
  40f372:	8afb      	ldrh	r3, [r7, #22]
  40f374:	1c5a      	adds	r2, r3, #1
  40f376:	82fa      	strh	r2, [r7, #22]
  40f378:	461a      	mov	r2, r3
  40f37a:	683b      	ldr	r3, [r7, #0]
  40f37c:	4413      	add	r3, r2
  40f37e:	687a      	ldr	r2, [r7, #4]
  40f380:	6812      	ldr	r2, [r2, #0]
  40f382:	b2d2      	uxtb	r2, r2
  40f384:	701a      	strb	r2, [r3, #0]
		outBuffer[idx++] = (uint8_t)edata->d.response.sensorcfg.cfg.base.type;
  40f386:	8afb      	ldrh	r3, [r7, #22]
  40f388:	1c5a      	adds	r2, r3, #1
  40f38a:	82fa      	strh	r2, [r7, #22]
  40f38c:	461a      	mov	r2, r3
  40f38e:	683b      	ldr	r3, [r7, #0]
  40f390:	4413      	add	r3, r2
  40f392:	687a      	ldr	r2, [r7, #4]
  40f394:	6892      	ldr	r2, [r2, #8]
  40f396:	b2d2      	uxtb	r2, r2
  40f398:	701a      	strb	r2, [r3, #0]
		precision = DynProtocol_getPrecision(self, edata->sensor_id);
  40f39a:	687b      	ldr	r3, [r7, #4]
  40f39c:	681b      	ldr	r3, [r3, #0]
  40f39e:	4619      	mov	r1, r3
  40f3a0:	68f8      	ldr	r0, [r7, #12]
  40f3a2:	4b2d      	ldr	r3, [pc, #180]	; (40f458 <DynProtocol_encodeResponse+0x368>)
  40f3a4:	4798      	blx	r3
  40f3a6:	6138      	str	r0, [r7, #16]
		idx += DynProtocol_encodeQxToQyVect16(&((VSensorConfigOffset *)&edata->d.response.sensorcfg.cfg)->vect[0], 3, 16, precision, &outBuffer[idx]);
  40f3a8:	687b      	ldr	r3, [r7, #4]
  40f3aa:	3308      	adds	r3, #8
  40f3ac:	f103 0008 	add.w	r0, r3, #8
  40f3b0:	8afb      	ldrh	r3, [r7, #22]
  40f3b2:	683a      	ldr	r2, [r7, #0]
  40f3b4:	4413      	add	r3, r2
  40f3b6:	9300      	str	r3, [sp, #0]
  40f3b8:	693b      	ldr	r3, [r7, #16]
  40f3ba:	2210      	movs	r2, #16
  40f3bc:	2103      	movs	r1, #3
  40f3be:	4c27      	ldr	r4, [pc, #156]	; (40f45c <DynProtocol_encodeResponse+0x36c>)
  40f3c0:	47a0      	blx	r4
  40f3c2:	4603      	mov	r3, r0
  40f3c4:	b29a      	uxth	r2, r3
  40f3c6:	8afb      	ldrh	r3, [r7, #22]
  40f3c8:	4413      	add	r3, r2
  40f3ca:	82fb      	strh	r3, [r7, #22]
		break;
  40f3cc:	e018      	b.n	40f400 <DynProtocol_encodeResponse+0x310>
	}

	case DYN_PROTOCOL_EID_READ_MEMS_REG:
		if ((maxBufferSize - idx) < 1 + 1)
  40f3ce:	8d3a      	ldrh	r2, [r7, #40]	; 0x28
  40f3d0:	8afb      	ldrh	r3, [r7, #22]
  40f3d2:	1ad3      	subs	r3, r2, r3
  40f3d4:	2b01      	cmp	r3, #1
  40f3d6:	dd30      	ble.n	40f43a <DynProtocol_encodeResponse+0x34a>
			goto error_size;
		outBuffer[idx++] = (uint8_t)edata->d.response.memsReg.rc;
  40f3d8:	8afb      	ldrh	r3, [r7, #22]
  40f3da:	1c5a      	adds	r2, r3, #1
  40f3dc:	82fa      	strh	r2, [r7, #22]
  40f3de:	461a      	mov	r2, r3
  40f3e0:	683b      	ldr	r3, [r7, #0]
  40f3e2:	4413      	add	r3, r2
  40f3e4:	687a      	ldr	r2, [r7, #4]
  40f3e6:	6852      	ldr	r2, [r2, #4]
  40f3e8:	b2d2      	uxtb	r2, r2
  40f3ea:	701a      	strb	r2, [r3, #0]
		outBuffer[idx++] = (uint8_t)edata->d.response.memsReg.regValue;
  40f3ec:	8afb      	ldrh	r3, [r7, #22]
  40f3ee:	1c5a      	adds	r2, r3, #1
  40f3f0:	82fa      	strh	r2, [r7, #22]
  40f3f2:	461a      	mov	r2, r3
  40f3f4:	683b      	ldr	r3, [r7, #0]
  40f3f6:	4413      	add	r3, r2
  40f3f8:	687a      	ldr	r2, [r7, #4]
  40f3fa:	7a12      	ldrb	r2, [r2, #8]
  40f3fc:	701a      	strb	r2, [r3, #0]
		break;
  40f3fe:	bf00      	nop

	default:
		goto error_arg;
	}

	*outBufferSize = (idx);
  40f400:	6afb      	ldr	r3, [r7, #44]	; 0x2c
  40f402:	8afa      	ldrh	r2, [r7, #22]
  40f404:	801a      	strh	r2, [r3, #0]

	return 0;
  40f406:	2300      	movs	r3, #0
  40f408:	e01e      	b.n	40f448 <DynProtocol_encodeResponse+0x358>
		goto error_arg;
  40f40a:	bf00      	nop
  40f40c:	e000      	b.n	40f410 <DynProtocol_encodeResponse+0x320>
			goto error_arg;
  40f40e:	bf00      	nop

error_arg:
	INV_MSG(INV_MSG_LEVEL_ERROR, "DynProtocol: Unexpected argument for DynProtocol_encodeResponse()");
  40f410:	4913      	ldr	r1, [pc, #76]	; (40f460 <DynProtocol_encodeResponse+0x370>)
  40f412:	2001      	movs	r0, #1
  40f414:	4b13      	ldr	r3, [pc, #76]	; (40f464 <DynProtocol_encodeResponse+0x374>)
  40f416:	4798      	blx	r3
	return -1;
  40f418:	f04f 33ff 	mov.w	r3, #4294967295
  40f41c:	e014      	b.n	40f448 <DynProtocol_encodeResponse+0x358>
		goto error_size;
  40f41e:	bf00      	nop
  40f420:	e00c      	b.n	40f43c <DynProtocol_encodeResponse+0x34c>
			goto error_size;
  40f422:	bf00      	nop
  40f424:	e00a      	b.n	40f43c <DynProtocol_encodeResponse+0x34c>
			goto error_size;
  40f426:	bf00      	nop
  40f428:	e008      	b.n	40f43c <DynProtocol_encodeResponse+0x34c>
			goto error_size;
  40f42a:	bf00      	nop
  40f42c:	e006      	b.n	40f43c <DynProtocol_encodeResponse+0x34c>
			goto error_size;
  40f42e:	bf00      	nop
  40f430:	e004      	b.n	40f43c <DynProtocol_encodeResponse+0x34c>
				goto error_size;
  40f432:	bf00      	nop
  40f434:	e002      	b.n	40f43c <DynProtocol_encodeResponse+0x34c>
			goto error_size;
  40f436:	bf00      	nop
  40f438:	e000      	b.n	40f43c <DynProtocol_encodeResponse+0x34c>
			goto error_size;
  40f43a:	bf00      	nop

error_size:
	INV_MSG(INV_MSG_LEVEL_ERROR, "DynProtocol: output buffer size too small");
  40f43c:	490a      	ldr	r1, [pc, #40]	; (40f468 <DynProtocol_encodeResponse+0x378>)
  40f43e:	2001      	movs	r0, #1
  40f440:	4b08      	ldr	r3, [pc, #32]	; (40f464 <DynProtocol_encodeResponse+0x374>)
  40f442:	4798      	blx	r3
	return -1;
  40f444:	f04f 33ff 	mov.w	r3, #4294967295
}
  40f448:	4618      	mov	r0, r3
  40f44a:	371c      	adds	r7, #28
  40f44c:	46bd      	mov	sp, r7
  40f44e:	bd90      	pop	{r4, r7, pc}
  40f450:	00414045 	.word	0x00414045
  40f454:	0040e295 	.word	0x0040e295
  40f458:	0040cda5 	.word	0x0040cda5
  40f45c:	0040cd19 	.word	0x0040cd19
  40f460:	0041cbc8 	.word	0x0041cbc8
  40f464:	0040fd19 	.word	0x0040fd19
  40f468:	0041cb9c 	.word	0x0041cb9c

0040f46c <DynProtocol_encodeAsync>:

int DynProtocol_encodeAsync(DynProtocol_t * self,
		enum DynProtocolEid eid, const DynProtocolEdata_t * edata,
		uint8_t * outBuffer, uint16_t maxBufferSize, uint16_t *outBufferSize)
{
  40f46c:	b590      	push	{r4, r7, lr}
  40f46e:	b089      	sub	sp, #36	; 0x24
  40f470:	af02      	add	r7, sp, #8
  40f472:	60f8      	str	r0, [r7, #12]
  40f474:	607a      	str	r2, [r7, #4]
  40f476:	603b      	str	r3, [r7, #0]
  40f478:	460b      	mov	r3, r1
  40f47a:	72fb      	strb	r3, [r7, #11]
	uint16_t idx = 0;
  40f47c:	2300      	movs	r3, #0
  40f47e:	82fb      	strh	r3, [r7, #22]
	int len;

	(void)self;

	*outBufferSize = 0;
  40f480:	6afb      	ldr	r3, [r7, #44]	; 0x2c
  40f482:	2200      	movs	r2, #0
  40f484:	801a      	strh	r2, [r3, #0]

	if(maxBufferSize < 2)
  40f486:	8d3b      	ldrh	r3, [r7, #40]	; 0x28
  40f488:	2b01      	cmp	r3, #1
  40f48a:	d94b      	bls.n	40f524 <DynProtocol_encodeAsync+0xb8>
		goto error_size;

	outBuffer[idx]  = EVENT_TYPE_ASYNC; // Set event type
  40f48c:	8afb      	ldrh	r3, [r7, #22]
  40f48e:	683a      	ldr	r2, [r7, #0]
  40f490:	4413      	add	r3, r2
  40f492:	2280      	movs	r2, #128	; 0x80
  40f494:	701a      	strb	r2, [r3, #0]
	outBuffer[idx++] |= DYN_PROTOCOL_GROUP_ID & ~EVENT_TYPE_MASK; // Set group ID
  40f496:	8afb      	ldrh	r3, [r7, #22]
  40f498:	1c5a      	adds	r2, r3, #1
  40f49a:	82fa      	strh	r2, [r7, #22]
  40f49c:	4619      	mov	r1, r3
  40f49e:	683a      	ldr	r2, [r7, #0]
  40f4a0:	440a      	add	r2, r1
  40f4a2:	4619      	mov	r1, r3
  40f4a4:	683b      	ldr	r3, [r7, #0]
  40f4a6:	440b      	add	r3, r1
  40f4a8:	781b      	ldrb	r3, [r3, #0]
  40f4aa:	f043 0303 	orr.w	r3, r3, #3
  40f4ae:	b2db      	uxtb	r3, r3
  40f4b0:	7013      	strb	r3, [r2, #0]
	outBuffer[idx++] = (uint8_t)eid;
  40f4b2:	8afb      	ldrh	r3, [r7, #22]
  40f4b4:	1c5a      	adds	r2, r3, #1
  40f4b6:	82fa      	strh	r2, [r7, #22]
  40f4b8:	461a      	mov	r2, r3
  40f4ba:	683b      	ldr	r3, [r7, #0]
  40f4bc:	4413      	add	r3, r2
  40f4be:	7afa      	ldrb	r2, [r7, #11]
  40f4c0:	701a      	strb	r2, [r3, #0]

	switch(eid) {
  40f4c2:	7afb      	ldrb	r3, [r7, #11]
  40f4c4:	2b30      	cmp	r3, #48	; 0x30
  40f4c6:	d000      	beq.n	40f4ca <DynProtocol_encodeAsync+0x5e>
		idx += len;
		break;
	}

	default:
		goto error_arg;
  40f4c8:	e025      	b.n	40f516 <DynProtocol_encodeAsync+0xaa>
		len = DynProtocol_encodeSensorEvent(self, edata, &outBuffer[idx], maxBufferSize - idx, DYN_PROTOCOL_ETYPE_ASYNC);
  40f4ca:	8afb      	ldrh	r3, [r7, #22]
  40f4cc:	683a      	ldr	r2, [r7, #0]
  40f4ce:	18d1      	adds	r1, r2, r3
  40f4d0:	8d3a      	ldrh	r2, [r7, #40]	; 0x28
  40f4d2:	8afb      	ldrh	r3, [r7, #22]
  40f4d4:	1ad3      	subs	r3, r2, r3
  40f4d6:	b29a      	uxth	r2, r3
  40f4d8:	2302      	movs	r3, #2
  40f4da:	9300      	str	r3, [sp, #0]
  40f4dc:	4613      	mov	r3, r2
  40f4de:	460a      	mov	r2, r1
  40f4e0:	6879      	ldr	r1, [r7, #4]
  40f4e2:	68f8      	ldr	r0, [r7, #12]
  40f4e4:	4c16      	ldr	r4, [pc, #88]	; (40f540 <DynProtocol_encodeAsync+0xd4>)
  40f4e6:	47a0      	blx	r4
  40f4e8:	6138      	str	r0, [r7, #16]
		if(len == -1)
  40f4ea:	693b      	ldr	r3, [r7, #16]
  40f4ec:	f1b3 3fff 	cmp.w	r3, #4294967295
  40f4f0:	d010      	beq.n	40f514 <DynProtocol_encodeAsync+0xa8>
		else if(len > maxBufferSize - idx)
  40f4f2:	8d3a      	ldrh	r2, [r7, #40]	; 0x28
  40f4f4:	8afb      	ldrh	r3, [r7, #22]
  40f4f6:	1ad2      	subs	r2, r2, r3
  40f4f8:	693b      	ldr	r3, [r7, #16]
  40f4fa:	429a      	cmp	r2, r3
  40f4fc:	db14      	blt.n	40f528 <DynProtocol_encodeAsync+0xbc>
		idx += len;
  40f4fe:	693b      	ldr	r3, [r7, #16]
  40f500:	b29a      	uxth	r2, r3
  40f502:	8afb      	ldrh	r3, [r7, #22]
  40f504:	4413      	add	r3, r2
  40f506:	82fb      	strh	r3, [r7, #22]
		break;
  40f508:	bf00      	nop
	}

	*outBufferSize = (idx);
  40f50a:	6afb      	ldr	r3, [r7, #44]	; 0x2c
  40f50c:	8afa      	ldrh	r2, [r7, #22]
  40f50e:	801a      	strh	r2, [r3, #0]

	return 0;
  40f510:	2300      	movs	r3, #0
  40f512:	e010      	b.n	40f536 <DynProtocol_encodeAsync+0xca>
			goto error_arg;
  40f514:	bf00      	nop

error_arg:
	INV_MSG(INV_MSG_LEVEL_ERROR, "DynProtocol: Unexpected argument for encode_async()");
  40f516:	490b      	ldr	r1, [pc, #44]	; (40f544 <DynProtocol_encodeAsync+0xd8>)
  40f518:	2001      	movs	r0, #1
  40f51a:	4b0b      	ldr	r3, [pc, #44]	; (40f548 <DynProtocol_encodeAsync+0xdc>)
  40f51c:	4798      	blx	r3
	return -1;
  40f51e:	f04f 33ff 	mov.w	r3, #4294967295
  40f522:	e008      	b.n	40f536 <DynProtocol_encodeAsync+0xca>
		goto error_size;
  40f524:	bf00      	nop
  40f526:	e000      	b.n	40f52a <DynProtocol_encodeAsync+0xbe>
			goto error_size;
  40f528:	bf00      	nop

error_size:
	INV_MSG(INV_MSG_LEVEL_ERROR, "DynProtocol: output buffer size too small");
  40f52a:	4908      	ldr	r1, [pc, #32]	; (40f54c <DynProtocol_encodeAsync+0xe0>)
  40f52c:	2001      	movs	r0, #1
  40f52e:	4b06      	ldr	r3, [pc, #24]	; (40f548 <DynProtocol_encodeAsync+0xdc>)
  40f530:	4798      	blx	r3
	return -1;
  40f532:	f04f 33ff 	mov.w	r3, #4294967295
}
  40f536:	4618      	mov	r0, r3
  40f538:	371c      	adds	r7, #28
  40f53a:	46bd      	mov	sp, r7
  40f53c:	bd90      	pop	{r4, r7, pc}
  40f53e:	bf00      	nop
  40f540:	0040e295 	.word	0x0040e295
  40f544:	0041cc0c 	.word	0x0041cc0c
  40f548:	0040fd19 	.word	0x0040fd19
  40f54c:	0041cb9c 	.word	0x0041cb9c

0040f550 <DynProTransportUart_callEventCB>:
#define DYN_PRO_TRANSPORT_UART_OVERHEAD     4

static inline void DynProTransportUart_callEventCB(DynProTransportUart_t * self, 
		enum DynProTransportEvent event,
		union DynProTransportEventData data)
{
  40f550:	b580      	push	{r7, lr}
  40f552:	b084      	sub	sp, #16
  40f554:	af00      	add	r7, sp, #0
  40f556:	60f8      	str	r0, [r7, #12]
  40f558:	460b      	mov	r3, r1
  40f55a:	607a      	str	r2, [r7, #4]
  40f55c:	72fb      	strb	r3, [r7, #11]
	if(self->event_cb) {
  40f55e:	68fb      	ldr	r3, [r7, #12]
  40f560:	681b      	ldr	r3, [r3, #0]
  40f562:	2b00      	cmp	r3, #0
  40f564:	d006      	beq.n	40f574 <DynProTransportUart_callEventCB+0x24>
		self->event_cb(event, data, self->event_cb_cookie);
  40f566:	68fb      	ldr	r3, [r7, #12]
  40f568:	681b      	ldr	r3, [r3, #0]
  40f56a:	68fa      	ldr	r2, [r7, #12]
  40f56c:	6852      	ldr	r2, [r2, #4]
  40f56e:	7af8      	ldrb	r0, [r7, #11]
  40f570:	6879      	ldr	r1, [r7, #4]
  40f572:	4798      	blx	r3
	}
}
  40f574:	bf00      	nop
  40f576:	3710      	adds	r7, #16
  40f578:	46bd      	mov	sp, r7
  40f57a:	bd80      	pop	{r7, pc}

0040f57c <DynProTransportUart_init>:

void DynProTransportUart_init(DynProTransportUart_t * self,
		DynProTransportEvent_cb event_cb, void * cookie)
{
  40f57c:	b480      	push	{r7}
  40f57e:	b085      	sub	sp, #20
  40f580:	af00      	add	r7, sp, #0
  40f582:	60f8      	str	r0, [r7, #12]
  40f584:	60b9      	str	r1, [r7, #8]
  40f586:	607a      	str	r2, [r7, #4]
	self->event_cb        = event_cb;
  40f588:	68fb      	ldr	r3, [r7, #12]
  40f58a:	68ba      	ldr	r2, [r7, #8]
  40f58c:	601a      	str	r2, [r3, #0]
	self->event_cb_cookie = cookie;
  40f58e:	68fb      	ldr	r3, [r7, #12]
  40f590:	687a      	ldr	r2, [r7, #4]
  40f592:	605a      	str	r2, [r3, #4]
	self->rx_sm_state     = RECEIVER_STATE_IDLE;
  40f594:	68fb      	ldr	r3, [r7, #12]
  40f596:	2200      	movs	r2, #0
  40f598:	721a      	strb	r2, [r3, #8]
	self->use_tx_dma        = 0;
  40f59a:	68fb      	ldr	r3, [r7, #12]
  40f59c:	2200      	movs	r2, #0
  40f59e:	739a      	strb	r2, [r3, #14]
}
  40f5a0:	bf00      	nop
  40f5a2:	3714      	adds	r7, #20
  40f5a4:	46bd      	mov	sp, r7
  40f5a6:	f85d 7b04 	ldr.w	r7, [sp], #4
  40f5aa:	4770      	bx	lr

0040f5ac <DynProTransportUart_rxProcessByte>:
		return expected_size;
		
}

int DynProTransportUart_rxProcessByte(DynProTransportUart_t * self, uint8_t rcv_byte)
{
  40f5ac:	b580      	push	{r7, lr}
  40f5ae:	b084      	sub	sp, #16
  40f5b0:	af00      	add	r7, sp, #0
  40f5b2:	6078      	str	r0, [r7, #4]
  40f5b4:	460b      	mov	r3, r1
  40f5b6:	70fb      	strb	r3, [r7, #3]
	union DynProTransportEventData udata;

	switch(self->rx_sm_state) {
  40f5b8:	687b      	ldr	r3, [r7, #4]
  40f5ba:	7a1b      	ldrb	r3, [r3, #8]
  40f5bc:	2b04      	cmp	r3, #4
  40f5be:	f200 8087 	bhi.w	40f6d0 <DynProTransportUart_rxProcessByte+0x124>
  40f5c2:	a201      	add	r2, pc, #4	; (adr r2, 40f5c8 <DynProTransportUart_rxProcessByte+0x1c>)
  40f5c4:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
  40f5c8:	0040f5dd 	.word	0x0040f5dd
  40f5cc:	0040f613 	.word	0x0040f613
  40f5d0:	0040f649 	.word	0x0040f649
  40f5d4:	0040f659 	.word	0x0040f659
  40f5d8:	0040f68f 	.word	0x0040f68f
	case RECEIVER_STATE_IDLE:
		if(rcv_byte == SYNC_BYTE_0) {
  40f5dc:	78fb      	ldrb	r3, [r7, #3]
  40f5de:	2b55      	cmp	r3, #85	; 0x55
  40f5e0:	d103      	bne.n	40f5ea <DynProTransportUart_rxProcessByte+0x3e>
			self->rx_sm_state = RECEIVER_STATE_SYNC_1;
  40f5e2:	687b      	ldr	r3, [r7, #4]
  40f5e4:	2201      	movs	r2, #1
  40f5e6:	721a      	strb	r2, [r3, #8]
			self->rx_sm_state = RECEIVER_STATE_IDLE;
			udata.error = -1;
			DynProTransportUart_callEventCB(self, DYN_PRO_TRANSPORT_EVENT_ERROR, udata);
			return -1;
		}
		break;
  40f5e8:	e072      	b.n	40f6d0 <DynProTransportUart_rxProcessByte+0x124>
			INV_MSG(INV_MSG_LEVEL_VERBOSE, "DynProTransportUart: unexpected SYNC0 byte %x recevied", rcv_byte);
  40f5ea:	78fb      	ldrb	r3, [r7, #3]
  40f5ec:	461a      	mov	r2, r3
  40f5ee:	493b      	ldr	r1, [pc, #236]	; (40f6dc <DynProTransportUart_rxProcessByte+0x130>)
  40f5f0:	2004      	movs	r0, #4
  40f5f2:	4b3b      	ldr	r3, [pc, #236]	; (40f6e0 <DynProTransportUart_rxProcessByte+0x134>)
  40f5f4:	4798      	blx	r3
			self->rx_sm_state = RECEIVER_STATE_IDLE;
  40f5f6:	687b      	ldr	r3, [r7, #4]
  40f5f8:	2200      	movs	r2, #0
  40f5fa:	721a      	strb	r2, [r3, #8]
			udata.error = -1;
  40f5fc:	f04f 33ff 	mov.w	r3, #4294967295
  40f600:	60fb      	str	r3, [r7, #12]
			DynProTransportUart_callEventCB(self, DYN_PRO_TRANSPORT_EVENT_ERROR, udata);
  40f602:	68fa      	ldr	r2, [r7, #12]
  40f604:	2100      	movs	r1, #0
  40f606:	6878      	ldr	r0, [r7, #4]
  40f608:	4b36      	ldr	r3, [pc, #216]	; (40f6e4 <DynProTransportUart_rxProcessByte+0x138>)
  40f60a:	4798      	blx	r3
			return -1;
  40f60c:	f04f 33ff 	mov.w	r3, #4294967295
  40f610:	e05f      	b.n	40f6d2 <DynProTransportUart_rxProcessByte+0x126>

	case RECEIVER_STATE_SYNC_1:
		if(rcv_byte == SYNC_BYTE_1) {
  40f612:	78fb      	ldrb	r3, [r7, #3]
  40f614:	2baa      	cmp	r3, #170	; 0xaa
  40f616:	d103      	bne.n	40f620 <DynProTransportUart_rxProcessByte+0x74>
			self->rx_sm_state = RECEIVER_STATE_SIZE_BYTE_0;
  40f618:	687b      	ldr	r3, [r7, #4]
  40f61a:	2202      	movs	r2, #2
  40f61c:	721a      	strb	r2, [r3, #8]
			self->rx_sm_state = RECEIVER_STATE_IDLE;
			udata.error = -1;
			DynProTransportUart_callEventCB(self, DYN_PRO_TRANSPORT_EVENT_ERROR, udata);
			return -1;
		}
		break;
  40f61e:	e057      	b.n	40f6d0 <DynProTransportUart_rxProcessByte+0x124>
			INV_MSG(INV_MSG_LEVEL_VERBOSE, "DynProTransportUart: unexpected SYNC1 byte %x recevied", rcv_byte);
  40f620:	78fb      	ldrb	r3, [r7, #3]
  40f622:	461a      	mov	r2, r3
  40f624:	4930      	ldr	r1, [pc, #192]	; (40f6e8 <DynProTransportUart_rxProcessByte+0x13c>)
  40f626:	2004      	movs	r0, #4
  40f628:	4b2d      	ldr	r3, [pc, #180]	; (40f6e0 <DynProTransportUart_rxProcessByte+0x134>)
  40f62a:	4798      	blx	r3
			self->rx_sm_state = RECEIVER_STATE_IDLE;
  40f62c:	687b      	ldr	r3, [r7, #4]
  40f62e:	2200      	movs	r2, #0
  40f630:	721a      	strb	r2, [r3, #8]
			udata.error = -1;
  40f632:	f04f 33ff 	mov.w	r3, #4294967295
  40f636:	60fb      	str	r3, [r7, #12]
			DynProTransportUart_callEventCB(self, DYN_PRO_TRANSPORT_EVENT_ERROR, udata);
  40f638:	68fa      	ldr	r2, [r7, #12]
  40f63a:	2100      	movs	r1, #0
  40f63c:	6878      	ldr	r0, [r7, #4]
  40f63e:	4b29      	ldr	r3, [pc, #164]	; (40f6e4 <DynProTransportUart_rxProcessByte+0x138>)
  40f640:	4798      	blx	r3
			return -1;
  40f642:	f04f 33ff 	mov.w	r3, #4294967295
  40f646:	e044      	b.n	40f6d2 <DynProTransportUart_rxProcessByte+0x126>

	case RECEIVER_STATE_SIZE_BYTE_0:
		self->rx_expected_bytes = (uint16_t)rcv_byte;
  40f648:	78fb      	ldrb	r3, [r7, #3]
  40f64a:	b29a      	uxth	r2, r3
  40f64c:	687b      	ldr	r3, [r7, #4]
  40f64e:	815a      	strh	r2, [r3, #10]
		self->rx_sm_state = RECEIVER_STATE_SIZE_BYTE_1;
  40f650:	687b      	ldr	r3, [r7, #4]
  40f652:	2203      	movs	r2, #3
  40f654:	721a      	strb	r2, [r3, #8]
		break;
  40f656:	e03b      	b.n	40f6d0 <DynProTransportUart_rxProcessByte+0x124>

	case RECEIVER_STATE_SIZE_BYTE_1:
		self->rx_expected_bytes |= ((uint16_t)rcv_byte << 8U);
  40f658:	687b      	ldr	r3, [r7, #4]
  40f65a:	895b      	ldrh	r3, [r3, #10]
  40f65c:	b21a      	sxth	r2, r3
  40f65e:	78fb      	ldrb	r3, [r7, #3]
  40f660:	021b      	lsls	r3, r3, #8
  40f662:	b21b      	sxth	r3, r3
  40f664:	4313      	orrs	r3, r2
  40f666:	b21b      	sxth	r3, r3
  40f668:	b29a      	uxth	r2, r3
  40f66a:	687b      	ldr	r3, [r7, #4]
  40f66c:	815a      	strh	r2, [r3, #10]
		self->rx_received_bytes = 0;
  40f66e:	687b      	ldr	r3, [r7, #4]
  40f670:	2200      	movs	r2, #0
  40f672:	819a      	strh	r2, [r3, #12]
		self->rx_sm_state = RECEIVER_STATE_PACKET_DATA;
  40f674:	687b      	ldr	r3, [r7, #4]
  40f676:	2204      	movs	r2, #4
  40f678:	721a      	strb	r2, [r3, #8]
		udata.pkt_size = self->rx_expected_bytes;
  40f67a:	687b      	ldr	r3, [r7, #4]
  40f67c:	895b      	ldrh	r3, [r3, #10]
  40f67e:	81bb      	strh	r3, [r7, #12]
		DynProTransportUart_callEventCB(self, DYN_PRO_TRANSPORT_EVENT_PKT_SIZE, udata);
  40f680:	68fa      	ldr	r2, [r7, #12]
  40f682:	2101      	movs	r1, #1
  40f684:	6878      	ldr	r0, [r7, #4]
  40f686:	4b17      	ldr	r3, [pc, #92]	; (40f6e4 <DynProTransportUart_rxProcessByte+0x138>)
  40f688:	4798      	blx	r3
		return 1;
  40f68a:	2301      	movs	r3, #1
  40f68c:	e021      	b.n	40f6d2 <DynProTransportUart_rxProcessByte+0x126>

	case RECEIVER_STATE_PACKET_DATA:
		self->rx_received_bytes++;
  40f68e:	687b      	ldr	r3, [r7, #4]
  40f690:	899b      	ldrh	r3, [r3, #12]
  40f692:	3301      	adds	r3, #1
  40f694:	b29a      	uxth	r2, r3
  40f696:	687b      	ldr	r3, [r7, #4]
  40f698:	819a      	strh	r2, [r3, #12]
		udata.pkt_size = rcv_byte;
  40f69a:	78fb      	ldrb	r3, [r7, #3]
  40f69c:	b29b      	uxth	r3, r3
  40f69e:	81bb      	strh	r3, [r7, #12]
		DynProTransportUart_callEventCB(self, DYN_PRO_TRANSPORT_EVENT_PKT_BYTE, udata);
  40f6a0:	68fa      	ldr	r2, [r7, #12]
  40f6a2:	2102      	movs	r1, #2
  40f6a4:	6878      	ldr	r0, [r7, #4]
  40f6a6:	4b0f      	ldr	r3, [pc, #60]	; (40f6e4 <DynProTransportUart_rxProcessByte+0x138>)
  40f6a8:	4798      	blx	r3
		if(self->rx_received_bytes == self->rx_expected_bytes) {
  40f6aa:	687b      	ldr	r3, [r7, #4]
  40f6ac:	899a      	ldrh	r2, [r3, #12]
  40f6ae:	687b      	ldr	r3, [r7, #4]
  40f6b0:	895b      	ldrh	r3, [r3, #10]
  40f6b2:	429a      	cmp	r2, r3
  40f6b4:	d10a      	bne.n	40f6cc <DynProTransportUart_rxProcessByte+0x120>
			self->rx_sm_state = RECEIVER_STATE_IDLE;
  40f6b6:	687b      	ldr	r3, [r7, #4]
  40f6b8:	2200      	movs	r2, #0
  40f6ba:	721a      	strb	r2, [r3, #8]
			udata.pkt_size = self->rx_received_bytes;
  40f6bc:	687b      	ldr	r3, [r7, #4]
  40f6be:	899b      	ldrh	r3, [r3, #12]
  40f6c0:	81bb      	strh	r3, [r7, #12]
			DynProTransportUart_callEventCB(self, DYN_PRO_TRANSPORT_EVENT_PKT_END, udata);
  40f6c2:	68fa      	ldr	r2, [r7, #12]
  40f6c4:	2103      	movs	r1, #3
  40f6c6:	6878      	ldr	r0, [r7, #4]
  40f6c8:	4b06      	ldr	r3, [pc, #24]	; (40f6e4 <DynProTransportUart_rxProcessByte+0x138>)
  40f6ca:	4798      	blx	r3
		}
		return 1;
  40f6cc:	2301      	movs	r3, #1
  40f6ce:	e000      	b.n	40f6d2 <DynProTransportUart_rxProcessByte+0x126>
	}

	return 0;
  40f6d0:	2300      	movs	r3, #0
}
  40f6d2:	4618      	mov	r0, r3
  40f6d4:	3710      	adds	r7, #16
  40f6d6:	46bd      	mov	sp, r7
  40f6d8:	bd80      	pop	{r7, pc}
  40f6da:	bf00      	nop
  40f6dc:	0041cf74 	.word	0x0041cf74
  40f6e0:	0040fd19 	.word	0x0040fd19
  40f6e4:	0040f551 	.word	0x0040f551
  40f6e8:	0041cfac 	.word	0x0041cfac

0040f6ec <DynProTransportUart_tx>:
 *
 * @return      0 on sucess, negative value on error
 */
int DynProTransportUart_tx(DynProTransportUart_t * self,
	const uint8_t * buffer, uint16_t size)
{
  40f6ec:	b580      	push	{r7, lr}
  40f6ee:	b088      	sub	sp, #32
  40f6f0:	af00      	add	r7, sp, #0
  40f6f2:	60f8      	str	r0, [r7, #12]
  40f6f4:	60b9      	str	r1, [r7, #8]
  40f6f6:	4613      	mov	r3, r2
  40f6f8:	80fb      	strh	r3, [r7, #6]
	union DynProTransportEventData udata;
	const uint32_t total_bytes = DYN_PRO_TRANSPORT_UART_OVERHEAD + size;
  40f6fa:	88fb      	ldrh	r3, [r7, #6]
  40f6fc:	3304      	adds	r3, #4
  40f6fe:	61bb      	str	r3, [r7, #24]
	uint16_t i;

	udata.tx_start = total_bytes;
  40f700:	69bb      	ldr	r3, [r7, #24]
  40f702:	617b      	str	r3, [r7, #20]
	DynProTransportUart_callEventCB(self, DYN_PRO_TRANSPORT_EVENT_TX_START, udata);
  40f704:	697a      	ldr	r2, [r7, #20]
  40f706:	2104      	movs	r1, #4
  40f708:	68f8      	ldr	r0, [r7, #12]
  40f70a:	4b20      	ldr	r3, [pc, #128]	; (40f78c <DynProTransportUart_tx+0xa0>)
  40f70c:	4798      	blx	r3
	udata.tx_byte = SYNC_BYTE_0;
  40f70e:	2355      	movs	r3, #85	; 0x55
  40f710:	753b      	strb	r3, [r7, #20]
	DynProTransportUart_callEventCB(self, DYN_PRO_TRANSPORT_EVENT_TX_BYTE, udata);
  40f712:	697a      	ldr	r2, [r7, #20]
  40f714:	2105      	movs	r1, #5
  40f716:	68f8      	ldr	r0, [r7, #12]
  40f718:	4b1c      	ldr	r3, [pc, #112]	; (40f78c <DynProTransportUart_tx+0xa0>)
  40f71a:	4798      	blx	r3
	udata.tx_byte = SYNC_BYTE_1;
  40f71c:	23aa      	movs	r3, #170	; 0xaa
  40f71e:	753b      	strb	r3, [r7, #20]
	DynProTransportUart_callEventCB(self, DYN_PRO_TRANSPORT_EVENT_TX_BYTE, udata);
  40f720:	697a      	ldr	r2, [r7, #20]
  40f722:	2105      	movs	r1, #5
  40f724:	68f8      	ldr	r0, [r7, #12]
  40f726:	4b19      	ldr	r3, [pc, #100]	; (40f78c <DynProTransportUart_tx+0xa0>)
  40f728:	4798      	blx	r3
	udata.tx_byte = (size & 0x00FF);
  40f72a:	88fb      	ldrh	r3, [r7, #6]
  40f72c:	b2db      	uxtb	r3, r3
  40f72e:	753b      	strb	r3, [r7, #20]
	DynProTransportUart_callEventCB(self, DYN_PRO_TRANSPORT_EVENT_TX_BYTE, udata);
  40f730:	697a      	ldr	r2, [r7, #20]
  40f732:	2105      	movs	r1, #5
  40f734:	68f8      	ldr	r0, [r7, #12]
  40f736:	4b15      	ldr	r3, [pc, #84]	; (40f78c <DynProTransportUart_tx+0xa0>)
  40f738:	4798      	blx	r3
	udata.tx_byte = (size & 0xFF00) >> 8;
  40f73a:	88fb      	ldrh	r3, [r7, #6]
  40f73c:	0a1b      	lsrs	r3, r3, #8
  40f73e:	b29b      	uxth	r3, r3
  40f740:	b2db      	uxtb	r3, r3
  40f742:	753b      	strb	r3, [r7, #20]
	DynProTransportUart_callEventCB(self, DYN_PRO_TRANSPORT_EVENT_TX_BYTE, udata);
  40f744:	697a      	ldr	r2, [r7, #20]
  40f746:	2105      	movs	r1, #5
  40f748:	68f8      	ldr	r0, [r7, #12]
  40f74a:	4b10      	ldr	r3, [pc, #64]	; (40f78c <DynProTransportUart_tx+0xa0>)
  40f74c:	4798      	blx	r3

	for(i = 0; i < size; ++i) {
  40f74e:	2300      	movs	r3, #0
  40f750:	83fb      	strh	r3, [r7, #30]
  40f752:	e00c      	b.n	40f76e <DynProTransportUart_tx+0x82>
		udata.tx_byte = buffer[i];
  40f754:	8bfb      	ldrh	r3, [r7, #30]
  40f756:	68ba      	ldr	r2, [r7, #8]
  40f758:	4413      	add	r3, r2
  40f75a:	781b      	ldrb	r3, [r3, #0]
  40f75c:	753b      	strb	r3, [r7, #20]
		DynProTransportUart_callEventCB(self, DYN_PRO_TRANSPORT_EVENT_TX_BYTE, udata);
  40f75e:	697a      	ldr	r2, [r7, #20]
  40f760:	2105      	movs	r1, #5
  40f762:	68f8      	ldr	r0, [r7, #12]
  40f764:	4b09      	ldr	r3, [pc, #36]	; (40f78c <DynProTransportUart_tx+0xa0>)
  40f766:	4798      	blx	r3
	for(i = 0; i < size; ++i) {
  40f768:	8bfb      	ldrh	r3, [r7, #30]
  40f76a:	3301      	adds	r3, #1
  40f76c:	83fb      	strh	r3, [r7, #30]
  40f76e:	8bfa      	ldrh	r2, [r7, #30]
  40f770:	88fb      	ldrh	r3, [r7, #6]
  40f772:	429a      	cmp	r2, r3
  40f774:	d3ee      	bcc.n	40f754 <DynProTransportUart_tx+0x68>
	}

	DynProTransportUart_callEventCB(self, DYN_PRO_TRANSPORT_EVENT_TX_END, udata);
  40f776:	697a      	ldr	r2, [r7, #20]
  40f778:	2106      	movs	r1, #6
  40f77a:	68f8      	ldr	r0, [r7, #12]
  40f77c:	4b03      	ldr	r3, [pc, #12]	; (40f78c <DynProTransportUart_tx+0xa0>)
  40f77e:	4798      	blx	r3

	return 0;
  40f780:	2300      	movs	r3, #0
}
  40f782:	4618      	mov	r0, r3
  40f784:	3720      	adds	r7, #32
  40f786:	46bd      	mov	sp, r7
  40f788:	bd80      	pop	{r7, pc}
  40f78a:	bf00      	nop
  40f78c:	0040f551 	.word	0x0040f551

0040f790 <inv_dc_int32_to_little8>:
 */

#include "DataConverter.h"

uint8_t * inv_dc_int32_to_little8(int32_t x, uint8_t * little8)
{
  40f790:	b480      	push	{r7}
  40f792:	b083      	sub	sp, #12
  40f794:	af00      	add	r7, sp, #0
  40f796:	6078      	str	r0, [r7, #4]
  40f798:	6039      	str	r1, [r7, #0]
	little8[3] = (uint8_t)((x >> 24) & 0xff);
  40f79a:	683b      	ldr	r3, [r7, #0]
  40f79c:	3303      	adds	r3, #3
  40f79e:	687a      	ldr	r2, [r7, #4]
  40f7a0:	1612      	asrs	r2, r2, #24
  40f7a2:	b2d2      	uxtb	r2, r2
  40f7a4:	701a      	strb	r2, [r3, #0]
	little8[2] = (uint8_t)((x >> 16) & 0xff);
  40f7a6:	683b      	ldr	r3, [r7, #0]
  40f7a8:	3302      	adds	r3, #2
  40f7aa:	687a      	ldr	r2, [r7, #4]
  40f7ac:	1412      	asrs	r2, r2, #16
  40f7ae:	b2d2      	uxtb	r2, r2
  40f7b0:	701a      	strb	r2, [r3, #0]
	little8[1] = (uint8_t)((x >> 8) & 0xff);
  40f7b2:	683b      	ldr	r3, [r7, #0]
  40f7b4:	3301      	adds	r3, #1
  40f7b6:	687a      	ldr	r2, [r7, #4]
  40f7b8:	1212      	asrs	r2, r2, #8
  40f7ba:	b2d2      	uxtb	r2, r2
  40f7bc:	701a      	strb	r2, [r3, #0]
	little8[0] = (uint8_t)(x & 0xff);
  40f7be:	687b      	ldr	r3, [r7, #4]
  40f7c0:	b2da      	uxtb	r2, r3
  40f7c2:	683b      	ldr	r3, [r7, #0]
  40f7c4:	701a      	strb	r2, [r3, #0]

	return little8;
  40f7c6:	683b      	ldr	r3, [r7, #0]
}
  40f7c8:	4618      	mov	r0, r3
  40f7ca:	370c      	adds	r7, #12
  40f7cc:	46bd      	mov	sp, r7
  40f7ce:	f85d 7b04 	ldr.w	r7, [sp], #4
  40f7d2:	4770      	bx	lr

0040f7d4 <inv_dc_int16_to_little8>:

uint8_t * inv_dc_int16_to_little8(int16_t x, uint8_t * little8)
{
  40f7d4:	b480      	push	{r7}
  40f7d6:	b083      	sub	sp, #12
  40f7d8:	af00      	add	r7, sp, #0
  40f7da:	4603      	mov	r3, r0
  40f7dc:	6039      	str	r1, [r7, #0]
  40f7de:	80fb      	strh	r3, [r7, #6]
	little8[0] = (uint8_t)(x & 0xff);
  40f7e0:	88fb      	ldrh	r3, [r7, #6]
  40f7e2:	b2da      	uxtb	r2, r3
  40f7e4:	683b      	ldr	r3, [r7, #0]
  40f7e6:	701a      	strb	r2, [r3, #0]
	little8[1] = (uint8_t)((x >> 8) & 0xff);
  40f7e8:	683b      	ldr	r3, [r7, #0]
  40f7ea:	3301      	adds	r3, #1
  40f7ec:	f9b7 2006 	ldrsh.w	r2, [r7, #6]
  40f7f0:	1212      	asrs	r2, r2, #8
  40f7f2:	b212      	sxth	r2, r2
  40f7f4:	b2d2      	uxtb	r2, r2
  40f7f6:	701a      	strb	r2, [r3, #0]

	return little8;
  40f7f8:	683b      	ldr	r3, [r7, #0]
}
  40f7fa:	4618      	mov	r0, r3
  40f7fc:	370c      	adds	r7, #12
  40f7fe:	46bd      	mov	sp, r7
  40f800:	f85d 7b04 	ldr.w	r7, [sp], #4
  40f804:	4770      	bx	lr

0040f806 <inv_dc_little8_to_int32>:

	return big8;
}

int32_t inv_dc_little8_to_int32(const uint8_t * little8)
{
  40f806:	b480      	push	{r7}
  40f808:	b085      	sub	sp, #20
  40f80a:	af00      	add	r7, sp, #0
  40f80c:	6078      	str	r0, [r7, #4]
	int32_t x = 0;
  40f80e:	2300      	movs	r3, #0
  40f810:	60fb      	str	r3, [r7, #12]

	x |= ((int32_t)little8[3] << 24);
  40f812:	687b      	ldr	r3, [r7, #4]
  40f814:	3303      	adds	r3, #3
  40f816:	781b      	ldrb	r3, [r3, #0]
  40f818:	061b      	lsls	r3, r3, #24
  40f81a:	68fa      	ldr	r2, [r7, #12]
  40f81c:	4313      	orrs	r3, r2
  40f81e:	60fb      	str	r3, [r7, #12]
	x |= ((int32_t)little8[2] << 16);
  40f820:	687b      	ldr	r3, [r7, #4]
  40f822:	3302      	adds	r3, #2
  40f824:	781b      	ldrb	r3, [r3, #0]
  40f826:	041b      	lsls	r3, r3, #16
  40f828:	68fa      	ldr	r2, [r7, #12]
  40f82a:	4313      	orrs	r3, r2
  40f82c:	60fb      	str	r3, [r7, #12]
	x |= ((int32_t)little8[1] << 8);
  40f82e:	687b      	ldr	r3, [r7, #4]
  40f830:	3301      	adds	r3, #1
  40f832:	781b      	ldrb	r3, [r3, #0]
  40f834:	021b      	lsls	r3, r3, #8
  40f836:	68fa      	ldr	r2, [r7, #12]
  40f838:	4313      	orrs	r3, r2
  40f83a:	60fb      	str	r3, [r7, #12]
	x |= ((int32_t)little8[0]);
  40f83c:	687b      	ldr	r3, [r7, #4]
  40f83e:	781b      	ldrb	r3, [r3, #0]
  40f840:	461a      	mov	r2, r3
  40f842:	68fb      	ldr	r3, [r7, #12]
  40f844:	4313      	orrs	r3, r2
  40f846:	60fb      	str	r3, [r7, #12]

	return x;
  40f848:	68fb      	ldr	r3, [r7, #12]
}
  40f84a:	4618      	mov	r0, r3
  40f84c:	3714      	adds	r7, #20
  40f84e:	46bd      	mov	sp, r7
  40f850:	f85d 7b04 	ldr.w	r7, [sp], #4
  40f854:	4770      	bx	lr

0040f856 <inv_dc_le_to_int16>:

	return result;
}

int16_t inv_dc_le_to_int16(const uint8_t * little8)
{
  40f856:	b480      	push	{r7}
  40f858:	b085      	sub	sp, #20
  40f85a:	af00      	add	r7, sp, #0
  40f85c:	6078      	str	r0, [r7, #4]
	uint16_t x = 0;
  40f85e:	2300      	movs	r3, #0
  40f860:	81fb      	strh	r3, [r7, #14]

	x |= ((uint16_t)little8[0]);
  40f862:	687b      	ldr	r3, [r7, #4]
  40f864:	781b      	ldrb	r3, [r3, #0]
  40f866:	b29a      	uxth	r2, r3
  40f868:	89fb      	ldrh	r3, [r7, #14]
  40f86a:	4313      	orrs	r3, r2
  40f86c:	81fb      	strh	r3, [r7, #14]
	x |= ((uint16_t)little8[1] << 8);
  40f86e:	687b      	ldr	r3, [r7, #4]
  40f870:	3301      	adds	r3, #1
  40f872:	781b      	ldrb	r3, [r3, #0]
  40f874:	021b      	lsls	r3, r3, #8
  40f876:	b21a      	sxth	r2, r3
  40f878:	f9b7 300e 	ldrsh.w	r3, [r7, #14]
  40f87c:	4313      	orrs	r3, r2
  40f87e:	b21b      	sxth	r3, r3
  40f880:	81fb      	strh	r3, [r7, #14]

	return (int16_t)x;
  40f882:	f9b7 300e 	ldrsh.w	r3, [r7, #14]
}
  40f886:	4618      	mov	r0, r3
  40f888:	3714      	adds	r7, #20
  40f88a:	46bd      	mov	sp, r7
  40f88c:	f85d 7b04 	ldr.w	r7, [sp], #4
  40f890:	4770      	bx	lr

0040f892 <inv_dc_float_to_sfix32>:
		out[i] = (float)in[i] / (1 << qx);
	}
}

void inv_dc_float_to_sfix32(const float * in, uint32_t len, uint8_t qx, int32_t * out)
{
  40f892:	b480      	push	{r7}
  40f894:	b087      	sub	sp, #28
  40f896:	af00      	add	r7, sp, #0
  40f898:	60f8      	str	r0, [r7, #12]
  40f89a:	60b9      	str	r1, [r7, #8]
  40f89c:	603b      	str	r3, [r7, #0]
  40f89e:	4613      	mov	r3, r2
  40f8a0:	71fb      	strb	r3, [r7, #7]
	uint8_t i;

	for(i = 0; i < len; ++i) {
  40f8a2:	2300      	movs	r3, #0
  40f8a4:	75fb      	strb	r3, [r7, #23]
  40f8a6:	e02d      	b.n	40f904 <inv_dc_float_to_sfix32+0x72>
		out[i] = (int32_t)((in[i] * (1 << qx)) + ((in[i] >= 0) - 0.5f));
  40f8a8:	7dfb      	ldrb	r3, [r7, #23]
  40f8aa:	009b      	lsls	r3, r3, #2
  40f8ac:	683a      	ldr	r2, [r7, #0]
  40f8ae:	4413      	add	r3, r2
  40f8b0:	7dfa      	ldrb	r2, [r7, #23]
  40f8b2:	0092      	lsls	r2, r2, #2
  40f8b4:	68f9      	ldr	r1, [r7, #12]
  40f8b6:	440a      	add	r2, r1
  40f8b8:	ed92 7a00 	vldr	s14, [r2]
  40f8bc:	79fa      	ldrb	r2, [r7, #7]
  40f8be:	2101      	movs	r1, #1
  40f8c0:	fa01 f202 	lsl.w	r2, r1, r2
  40f8c4:	ee07 2a90 	vmov	s15, r2
  40f8c8:	eef8 7ae7 	vcvt.f32.s32	s15, s15
  40f8cc:	ee27 7a27 	vmul.f32	s14, s14, s15
  40f8d0:	7dfa      	ldrb	r2, [r7, #23]
  40f8d2:	0092      	lsls	r2, r2, #2
  40f8d4:	68f9      	ldr	r1, [r7, #12]
  40f8d6:	440a      	add	r2, r1
  40f8d8:	edd2 7a00 	vldr	s15, [r2]
  40f8dc:	eef5 7ac0 	vcmpe.f32	s15, #0.0
  40f8e0:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
  40f8e4:	db02      	blt.n	40f8ec <inv_dc_float_to_sfix32+0x5a>
  40f8e6:	eef6 7a00 	vmov.f32	s15, #96	; 0x3f000000  0.5
  40f8ea:	e001      	b.n	40f8f0 <inv_dc_float_to_sfix32+0x5e>
  40f8ec:	eefe 7a00 	vmov.f32	s15, #224	; 0xbf000000 -0.5
  40f8f0:	ee77 7a27 	vadd.f32	s15, s14, s15
  40f8f4:	eefd 7ae7 	vcvt.s32.f32	s15, s15
  40f8f8:	ee17 2a90 	vmov	r2, s15
  40f8fc:	601a      	str	r2, [r3, #0]
	for(i = 0; i < len; ++i) {
  40f8fe:	7dfb      	ldrb	r3, [r7, #23]
  40f900:	3301      	adds	r3, #1
  40f902:	75fb      	strb	r3, [r7, #23]
  40f904:	7dfa      	ldrb	r2, [r7, #23]
  40f906:	68bb      	ldr	r3, [r7, #8]
  40f908:	429a      	cmp	r2, r3
  40f90a:	d3cd      	bcc.n	40f8a8 <inv_dc_float_to_sfix32+0x16>
	}
}
  40f90c:	bf00      	nop
  40f90e:	371c      	adds	r7, #28
  40f910:	46bd      	mov	sp, r7
  40f912:	f85d 7b04 	ldr.w	r7, [sp], #4
  40f916:	4770      	bx	lr

0040f918 <inv_error_str>:
 */

#include "ErrorHelper.h"

const char * inv_error_str(int error)
{
  40f918:	b480      	push	{r7}
  40f91a:	b083      	sub	sp, #12
  40f91c:	af00      	add	r7, sp, #0
  40f91e:	6078      	str	r0, [r7, #4]
	switch(error) {
  40f920:	687b      	ldr	r3, [r7, #4]
  40f922:	3311      	adds	r3, #17
  40f924:	2b11      	cmp	r3, #17
  40f926:	d849      	bhi.n	40f9bc <inv_error_str+0xa4>
  40f928:	a201      	add	r2, pc, #4	; (adr r2, 40f930 <inv_error_str+0x18>)
  40f92a:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
  40f92e:	bf00      	nop
  40f930:	0040f9b9 	.word	0x0040f9b9
  40f934:	0040f9b5 	.word	0x0040f9b5
  40f938:	0040f9b1 	.word	0x0040f9b1
  40f93c:	0040f9ad 	.word	0x0040f9ad
  40f940:	0040f9a9 	.word	0x0040f9a9
  40f944:	0040f9a5 	.word	0x0040f9a5
  40f948:	0040f9a1 	.word	0x0040f9a1
  40f94c:	0040f99d 	.word	0x0040f99d
  40f950:	0040f999 	.word	0x0040f999
  40f954:	0040f9bd 	.word	0x0040f9bd
  40f958:	0040f995 	.word	0x0040f995
  40f95c:	0040f991 	.word	0x0040f991
  40f960:	0040f98d 	.word	0x0040f98d
  40f964:	0040f989 	.word	0x0040f989
  40f968:	0040f985 	.word	0x0040f985
  40f96c:	0040f981 	.word	0x0040f981
  40f970:	0040f97d 	.word	0x0040f97d
  40f974:	0040f979 	.word	0x0040f979
	case INV_ERROR_SUCCESS:      return "Success";
  40f978:	4b14      	ldr	r3, [pc, #80]	; (40f9cc <inv_error_str+0xb4>)
  40f97a:	e020      	b.n	40f9be <inv_error_str+0xa6>
	case INV_ERROR:              return "Unspecified error";
  40f97c:	4b14      	ldr	r3, [pc, #80]	; (40f9d0 <inv_error_str+0xb8>)
  40f97e:	e01e      	b.n	40f9be <inv_error_str+0xa6>
	case INV_ERROR_NIMPL:        return "Not implemented";
  40f980:	4b14      	ldr	r3, [pc, #80]	; (40f9d4 <inv_error_str+0xbc>)
  40f982:	e01c      	b.n	40f9be <inv_error_str+0xa6>
	case INV_ERROR_TRANSPORT:    return "Transport error";
  40f984:	4b14      	ldr	r3, [pc, #80]	; (40f9d8 <inv_error_str+0xc0>)
  40f986:	e01a      	b.n	40f9be <inv_error_str+0xa6>
	case INV_ERROR_TIMEOUT:      return "Timeout, action did not complete in time";
  40f988:	4b14      	ldr	r3, [pc, #80]	; (40f9dc <inv_error_str+0xc4>)
  40f98a:	e018      	b.n	40f9be <inv_error_str+0xa6>
	case INV_ERROR_SIZE:         return "Wrong size error";
  40f98c:	4b14      	ldr	r3, [pc, #80]	; (40f9e0 <inv_error_str+0xc8>)
  40f98e:	e016      	b.n	40f9be <inv_error_str+0xa6>
	case INV_ERROR_OS:           return "Operating system failure";
  40f990:	4b14      	ldr	r3, [pc, #80]	; (40f9e4 <inv_error_str+0xcc>)
  40f992:	e014      	b.n	40f9be <inv_error_str+0xa6>
	case INV_ERROR_IO:           return "Input/Output error";
  40f994:	4b14      	ldr	r3, [pc, #80]	; (40f9e8 <inv_error_str+0xd0>)
  40f996:	e012      	b.n	40f9be <inv_error_str+0xa6>
	case INV_ERROR_MEM: 		 return "Bad allocation";
  40f998:	4b14      	ldr	r3, [pc, #80]	; (40f9ec <inv_error_str+0xd4>)
  40f99a:	e010      	b.n	40f9be <inv_error_str+0xa6>
	case INV_ERROR_HW:           return "Hardware error";
  40f99c:	4b14      	ldr	r3, [pc, #80]	; (40f9f0 <inv_error_str+0xd8>)
  40f99e:	e00e      	b.n	40f9be <inv_error_str+0xa6>
	case INV_ERROR_BAD_ARG:      return "Invalid arguments";
  40f9a0:	4b14      	ldr	r3, [pc, #80]	; (40f9f4 <inv_error_str+0xdc>)
  40f9a2:	e00c      	b.n	40f9be <inv_error_str+0xa6>
	case INV_ERROR_UNEXPECTED:   return "Unexpected error";
  40f9a4:	4b14      	ldr	r3, [pc, #80]	; (40f9f8 <inv_error_str+0xe0>)
  40f9a6:	e00a      	b.n	40f9be <inv_error_str+0xa6>
	case INV_ERROR_FILE:         return "Invalid file format";
  40f9a8:	4b14      	ldr	r3, [pc, #80]	; (40f9fc <inv_error_str+0xe4>)
  40f9aa:	e008      	b.n	40f9be <inv_error_str+0xa6>
	case INV_ERROR_PATH:         return "Invalid file path";
  40f9ac:	4b14      	ldr	r3, [pc, #80]	; (40fa00 <inv_error_str+0xe8>)
  40f9ae:	e006      	b.n	40f9be <inv_error_str+0xa6>
	case INV_ERROR_IMAGE_TYPE:   return "Unknown image type";
  40f9b0:	4b14      	ldr	r3, [pc, #80]	; (40fa04 <inv_error_str+0xec>)
  40f9b2:	e004      	b.n	40f9be <inv_error_str+0xa6>
	case INV_ERROR_WATCHDOG:     return "Watchdog error";
  40f9b4:	4b14      	ldr	r3, [pc, #80]	; (40fa08 <inv_error_str+0xf0>)
  40f9b6:	e002      	b.n	40f9be <inv_error_str+0xa6>
	case INV_ERROR_FIFO_OVERFLOW: return "FIFO overflow error";
  40f9b8:	4b14      	ldr	r3, [pc, #80]	; (40fa0c <inv_error_str+0xf4>)
  40f9ba:	e000      	b.n	40f9be <inv_error_str+0xa6>
	default:                     return "Unknown error";
  40f9bc:	4b14      	ldr	r3, [pc, #80]	; (40fa10 <inv_error_str+0xf8>)
	}
  40f9be:	4618      	mov	r0, r3
  40f9c0:	370c      	adds	r7, #12
  40f9c2:	46bd      	mov	sp, r7
  40f9c4:	f85d 7b04 	ldr.w	r7, [sp], #4
  40f9c8:	4770      	bx	lr
  40f9ca:	bf00      	nop
  40f9cc:	0041cfe4 	.word	0x0041cfe4
  40f9d0:	0041cfec 	.word	0x0041cfec
  40f9d4:	0041d000 	.word	0x0041d000
  40f9d8:	0041d010 	.word	0x0041d010
  40f9dc:	0041d020 	.word	0x0041d020
  40f9e0:	0041d04c 	.word	0x0041d04c
  40f9e4:	0041d060 	.word	0x0041d060
  40f9e8:	0041d07c 	.word	0x0041d07c
  40f9ec:	0041d090 	.word	0x0041d090
  40f9f0:	0041d0a0 	.word	0x0041d0a0
  40f9f4:	0041d0b0 	.word	0x0041d0b0
  40f9f8:	0041d0c4 	.word	0x0041d0c4
  40f9fc:	0041d0d8 	.word	0x0041d0d8
  40fa00:	0041d0ec 	.word	0x0041d0ec
  40fa04:	0041d100 	.word	0x0041d100
  40fa08:	0041d114 	.word	0x0041d114
  40fa0c:	0041d124 	.word	0x0041d124
  40fa10:	0041d138 	.word	0x0041d138

0040fa14 <InvScheduler_insertTask>:

#include "InvScheduler.h"

static void InvScheduler_insertTask(InvScheduler * scheduler,
		InvSchedulerTask *task)
{
  40fa14:	b480      	push	{r7}
  40fa16:	b083      	sub	sp, #12
  40fa18:	af00      	add	r7, sp, #0
  40fa1a:	6078      	str	r0, [r7, #4]
  40fa1c:	6039      	str	r1, [r7, #0]
	if(scheduler->queue == 0) {
  40fa1e:	687b      	ldr	r3, [r7, #4]
  40fa20:	685b      	ldr	r3, [r3, #4]
  40fa22:	2b00      	cmp	r3, #0
  40fa24:	d109      	bne.n	40fa3a <InvScheduler_insertTask+0x26>
		task->prev = task;
  40fa26:	683b      	ldr	r3, [r7, #0]
  40fa28:	683a      	ldr	r2, [r7, #0]
  40fa2a:	621a      	str	r2, [r3, #32]
		task->next = 0;
  40fa2c:	683b      	ldr	r3, [r7, #0]
  40fa2e:	2200      	movs	r2, #0
  40fa30:	61da      	str	r2, [r3, #28]
		scheduler->queue = task;
  40fa32:	687b      	ldr	r3, [r7, #4]
  40fa34:	683a      	ldr	r2, [r7, #0]
  40fa36:	605a      	str	r2, [r3, #4]
		task->prev = scheduler->queue->prev;
		task->next = 0;
		scheduler->queue->prev->next = task;
		scheduler->queue->prev       = task;
	}
}
  40fa38:	e010      	b.n	40fa5c <InvScheduler_insertTask+0x48>
		task->prev = scheduler->queue->prev;
  40fa3a:	687b      	ldr	r3, [r7, #4]
  40fa3c:	685b      	ldr	r3, [r3, #4]
  40fa3e:	6a1a      	ldr	r2, [r3, #32]
  40fa40:	683b      	ldr	r3, [r7, #0]
  40fa42:	621a      	str	r2, [r3, #32]
		task->next = 0;
  40fa44:	683b      	ldr	r3, [r7, #0]
  40fa46:	2200      	movs	r2, #0
  40fa48:	61da      	str	r2, [r3, #28]
		scheduler->queue->prev->next = task;
  40fa4a:	687b      	ldr	r3, [r7, #4]
  40fa4c:	685b      	ldr	r3, [r3, #4]
  40fa4e:	6a1b      	ldr	r3, [r3, #32]
  40fa50:	683a      	ldr	r2, [r7, #0]
  40fa52:	61da      	str	r2, [r3, #28]
		scheduler->queue->prev       = task;
  40fa54:	687b      	ldr	r3, [r7, #4]
  40fa56:	685b      	ldr	r3, [r3, #4]
  40fa58:	683a      	ldr	r2, [r7, #0]
  40fa5a:	621a      	str	r2, [r3, #32]
}
  40fa5c:	bf00      	nop
  40fa5e:	370c      	adds	r7, #12
  40fa60:	46bd      	mov	sp, r7
  40fa62:	f85d 7b04 	ldr.w	r7, [sp], #4
  40fa66:	4770      	bx	lr

0040fa68 <InvScheduler_removeTask>:

static inline void InvScheduler_removeTask(InvScheduler * scheduler,
		InvSchedulerTask *task)
{
  40fa68:	b480      	push	{r7}
  40fa6a:	b083      	sub	sp, #12
  40fa6c:	af00      	add	r7, sp, #0
  40fa6e:	6078      	str	r0, [r7, #4]
  40fa70:	6039      	str	r1, [r7, #0]
	if(scheduler->queue == task) {
  40fa72:	687b      	ldr	r3, [r7, #4]
  40fa74:	685a      	ldr	r2, [r3, #4]
  40fa76:	683b      	ldr	r3, [r7, #0]
  40fa78:	429a      	cmp	r2, r3
  40fa7a:	d104      	bne.n	40fa86 <InvScheduler_removeTask+0x1e>
		scheduler->queue = task->next;
  40fa7c:	683b      	ldr	r3, [r7, #0]
  40fa7e:	69da      	ldr	r2, [r3, #28]
  40fa80:	687b      	ldr	r3, [r7, #4]
  40fa82:	605a      	str	r2, [r3, #4]
  40fa84:	e00f      	b.n	40faa6 <InvScheduler_removeTask+0x3e>
	} else {
		if(scheduler->queue->prev == task)
  40fa86:	687b      	ldr	r3, [r7, #4]
  40fa88:	685b      	ldr	r3, [r3, #4]
  40fa8a:	6a1a      	ldr	r2, [r3, #32]
  40fa8c:	683b      	ldr	r3, [r7, #0]
  40fa8e:	429a      	cmp	r2, r3
  40fa90:	d104      	bne.n	40fa9c <InvScheduler_removeTask+0x34>
			scheduler->queue->prev = task->prev;
  40fa92:	687b      	ldr	r3, [r7, #4]
  40fa94:	685b      	ldr	r3, [r3, #4]
  40fa96:	683a      	ldr	r2, [r7, #0]
  40fa98:	6a12      	ldr	r2, [r2, #32]
  40fa9a:	621a      	str	r2, [r3, #32]
		task->prev->next = task->next;
  40fa9c:	683b      	ldr	r3, [r7, #0]
  40fa9e:	6a1b      	ldr	r3, [r3, #32]
  40faa0:	683a      	ldr	r2, [r7, #0]
  40faa2:	69d2      	ldr	r2, [r2, #28]
  40faa4:	61da      	str	r2, [r3, #28]
	}
	if(task->next)
  40faa6:	683b      	ldr	r3, [r7, #0]
  40faa8:	69db      	ldr	r3, [r3, #28]
  40faaa:	2b00      	cmp	r3, #0
  40faac:	d004      	beq.n	40fab8 <InvScheduler_removeTask+0x50>
		task->next->prev = task->prev;
  40faae:	683b      	ldr	r3, [r7, #0]
  40fab0:	69db      	ldr	r3, [r3, #28]
  40fab2:	683a      	ldr	r2, [r7, #0]
  40fab4:	6a12      	ldr	r2, [r2, #32]
  40fab6:	621a      	str	r2, [r3, #32]
}
  40fab8:	bf00      	nop
  40faba:	370c      	adds	r7, #12
  40fabc:	46bd      	mov	sp, r7
  40fabe:	f85d 7b04 	ldr.w	r7, [sp], #4
  40fac2:	4770      	bx	lr

0040fac4 <InvScheduler_getTaskToSchedule>:

static InvSchedulerTask * InvScheduler_getTaskToSchedule(InvScheduler * scheduler,
		uint32_t now)
{
  40fac4:	b480      	push	{r7}
  40fac6:	b089      	sub	sp, #36	; 0x24
  40fac8:	af00      	add	r7, sp, #0
  40faca:	6078      	str	r0, [r7, #4]
  40facc:	6039      	str	r1, [r7, #0]
	InvSchedulerTask * cur  = scheduler->queue;
  40face:	687b      	ldr	r3, [r7, #4]
  40fad0:	685b      	ldr	r3, [r3, #4]
  40fad2:	61fb      	str	r3, [r7, #28]
	InvSchedulerTask * task = 0;
  40fad4:	2300      	movs	r3, #0
  40fad6:	61bb      	str	r3, [r7, #24]
	uint32_t           max_diff = 0;
  40fad8:	2300      	movs	r3, #0
  40fada:	617b      	str	r3, [r7, #20]

	while(cur) {
  40fadc:	e043      	b.n	40fb66 <InvScheduler_getTaskToSchedule+0xa2>
		const uint32_t timeout = (cur->delay != 0) ? cur->delay : cur->period;
  40fade:	69fb      	ldr	r3, [r7, #28]
  40fae0:	695b      	ldr	r3, [r3, #20]
  40fae2:	2b00      	cmp	r3, #0
  40fae4:	d002      	beq.n	40faec <InvScheduler_getTaskToSchedule+0x28>
  40fae6:	69fb      	ldr	r3, [r7, #28]
  40fae8:	695b      	ldr	r3, [r3, #20]
  40faea:	e001      	b.n	40faf0 <InvScheduler_getTaskToSchedule+0x2c>
  40faec:	69fb      	ldr	r3, [r7, #28]
  40faee:	691b      	ldr	r3, [r3, #16]
  40faf0:	613b      	str	r3, [r7, #16]
		uint32_t elpased;

		/* initalize task states after it was started */
		if(cur->state == INVSCHEDULER_TASK_STATE_STARTED) {
  40faf2:	69fb      	ldr	r3, [r7, #28]
  40faf4:	7a5b      	ldrb	r3, [r3, #9]
  40faf6:	2b01      	cmp	r3, #1
  40faf8:	d110      	bne.n	40fb1c <InvScheduler_getTaskToSchedule+0x58>
			cur->state    = INVSCHEDULER_TASK_STATE_READY;
  40fafa:	69fb      	ldr	r3, [r7, #28]
  40fafc:	2202      	movs	r2, #2
  40fafe:	725a      	strb	r2, [r3, #9]
			cur->lasttime = now;
  40fb00:	69fb      	ldr	r3, [r7, #28]
  40fb02:	683a      	ldr	r2, [r7, #0]
  40fb04:	60da      	str	r2, [r3, #12]

			if(cur->delay == 0) {
  40fb06:	69fb      	ldr	r3, [r7, #28]
  40fb08:	695b      	ldr	r3, [r3, #20]
  40fb0a:	2b00      	cmp	r3, #0
  40fb0c:	d106      	bne.n	40fb1c <InvScheduler_getTaskToSchedule+0x58>
				cur->lasttime -= cur->period; /* ensure task is run ASAP */
  40fb0e:	69fb      	ldr	r3, [r7, #28]
  40fb10:	68da      	ldr	r2, [r3, #12]
  40fb12:	69fb      	ldr	r3, [r7, #28]
  40fb14:	691b      	ldr	r3, [r3, #16]
  40fb16:	1ad2      	subs	r2, r2, r3
  40fb18:	69fb      	ldr	r3, [r7, #28]
  40fb1a:	60da      	str	r2, [r3, #12]
			}
		}

		elpased = (now - cur->lasttime);
  40fb1c:	69fb      	ldr	r3, [r7, #28]
  40fb1e:	68db      	ldr	r3, [r3, #12]
  40fb20:	683a      	ldr	r2, [r7, #0]
  40fb22:	1ad3      	subs	r3, r2, r3
  40fb24:	60fb      	str	r3, [r7, #12]

		/* check timeout against elpased time */
		if(elpased >= timeout) {
  40fb26:	68fa      	ldr	r2, [r7, #12]
  40fb28:	693b      	ldr	r3, [r7, #16]
  40fb2a:	429a      	cmp	r2, r3
  40fb2c:	d318      	bcc.n	40fb60 <InvScheduler_getTaskToSchedule+0x9c>
			const uint32_t diff = (elpased - timeout);
  40fb2e:	68fa      	ldr	r2, [r7, #12]
  40fb30:	693b      	ldr	r3, [r7, #16]
  40fb32:	1ad3      	subs	r3, r2, r3
  40fb34:	60bb      	str	r3, [r7, #8]

			if(task == 0 || diff > max_diff ||
  40fb36:	69bb      	ldr	r3, [r7, #24]
  40fb38:	2b00      	cmp	r3, #0
  40fb3a:	d00d      	beq.n	40fb58 <InvScheduler_getTaskToSchedule+0x94>
  40fb3c:	68ba      	ldr	r2, [r7, #8]
  40fb3e:	697b      	ldr	r3, [r7, #20]
  40fb40:	429a      	cmp	r2, r3
  40fb42:	d809      	bhi.n	40fb58 <InvScheduler_getTaskToSchedule+0x94>
  40fb44:	68ba      	ldr	r2, [r7, #8]
  40fb46:	697b      	ldr	r3, [r7, #20]
  40fb48:	429a      	cmp	r2, r3
  40fb4a:	d109      	bne.n	40fb60 <InvScheduler_getTaskToSchedule+0x9c>
					(diff == max_diff && cur->priority > task->priority)) {
  40fb4c:	69fb      	ldr	r3, [r7, #28]
  40fb4e:	7a1a      	ldrb	r2, [r3, #8]
  40fb50:	69bb      	ldr	r3, [r7, #24]
  40fb52:	7a1b      	ldrb	r3, [r3, #8]
  40fb54:	429a      	cmp	r2, r3
  40fb56:	d903      	bls.n	40fb60 <InvScheduler_getTaskToSchedule+0x9c>
				task = cur;
  40fb58:	69fb      	ldr	r3, [r7, #28]
  40fb5a:	61bb      	str	r3, [r7, #24]
				max_diff = diff;
  40fb5c:	68bb      	ldr	r3, [r7, #8]
  40fb5e:	617b      	str	r3, [r7, #20]
			}
		}

		cur = cur->next;
  40fb60:	69fb      	ldr	r3, [r7, #28]
  40fb62:	69db      	ldr	r3, [r3, #28]
  40fb64:	61fb      	str	r3, [r7, #28]
	while(cur) {
  40fb66:	69fb      	ldr	r3, [r7, #28]
  40fb68:	2b00      	cmp	r3, #0
  40fb6a:	d1b8      	bne.n	40fade <InvScheduler_getTaskToSchedule+0x1a>
	}

	return task;
  40fb6c:	69bb      	ldr	r3, [r7, #24]
}
  40fb6e:	4618      	mov	r0, r3
  40fb70:	3724      	adds	r7, #36	; 0x24
  40fb72:	46bd      	mov	sp, r7
  40fb74:	f85d 7b04 	ldr.w	r7, [sp], #4
  40fb78:	4770      	bx	lr
	...

0040fb7c <InvScheduler_dispatchOneTask>:

	return UINT32_MAX;
}

int InvScheduler_dispatchOneTask(InvScheduler *scheduler)
{
  40fb7c:	b580      	push	{r7, lr}
  40fb7e:	b086      	sub	sp, #24
  40fb80:	af00      	add	r7, sp, #0
  40fb82:	6078      	str	r0, [r7, #4]
	int run = 0;
  40fb84:	2300      	movs	r3, #0
  40fb86:	617b      	str	r3, [r7, #20]
	const uint32_t now = scheduler->currentTime;
  40fb88:	687b      	ldr	r3, [r7, #4]
  40fb8a:	681b      	ldr	r3, [r3, #0]
  40fb8c:	613b      	str	r3, [r7, #16]
	InvSchedulerTask * task;

	InvScheduler_lock(scheduler->contextLock);

	task = InvScheduler_getTaskToSchedule(scheduler, now);
  40fb8e:	6939      	ldr	r1, [r7, #16]
  40fb90:	6878      	ldr	r0, [r7, #4]
  40fb92:	4b15      	ldr	r3, [pc, #84]	; (40fbe8 <InvScheduler_dispatchOneTask+0x6c>)
  40fb94:	4798      	blx	r3
  40fb96:	60f8      	str	r0, [r7, #12]

	if(task) {
  40fb98:	68fb      	ldr	r3, [r7, #12]
  40fb9a:	2b00      	cmp	r3, #0
  40fb9c:	d01f      	beq.n	40fbde <InvScheduler_dispatchOneTask+0x62>
		/* update lastime and task state */
		task->delay    = 0; /* clear delay */
  40fb9e:	68fb      	ldr	r3, [r7, #12]
  40fba0:	2200      	movs	r2, #0
  40fba2:	615a      	str	r2, [r3, #20]
		task->lasttime = now;
  40fba4:	68fb      	ldr	r3, [r7, #12]
  40fba6:	693a      	ldr	r2, [r7, #16]
  40fba8:	60da      	str	r2, [r3, #12]
		task->state    = INVSCHEDULER_TASK_STATE_RUNNING;
  40fbaa:	68fb      	ldr	r3, [r7, #12]
  40fbac:	2203      	movs	r2, #3
  40fbae:	725a      	strb	r2, [r3, #9]

		InvScheduler_removeTask(scheduler, task);
  40fbb0:	68f9      	ldr	r1, [r7, #12]
  40fbb2:	6878      	ldr	r0, [r7, #4]
  40fbb4:	4b0d      	ldr	r3, [pc, #52]	; (40fbec <InvScheduler_dispatchOneTask+0x70>)
  40fbb6:	4798      	blx	r3

		InvScheduler_unlock(scheduler->contextLock);
		InvScheduler_onTaskEnterHook(task, scheduler->currentTime);
		task->func(task->arg); /* execute the task */
  40fbb8:	68fb      	ldr	r3, [r7, #12]
  40fbba:	681b      	ldr	r3, [r3, #0]
  40fbbc:	68fa      	ldr	r2, [r7, #12]
  40fbbe:	6852      	ldr	r2, [r2, #4]
  40fbc0:	4610      	mov	r0, r2
  40fbc2:	4798      	blx	r3
		InvScheduler_onTaskExitHook(task, scheduler->currentTime);
		InvScheduler_lock(scheduler->contextLock);

		/* schedule task for next period */
		if(task->state == INVSCHEDULER_TASK_STATE_RUNNING) {
  40fbc4:	68fb      	ldr	r3, [r7, #12]
  40fbc6:	7a5b      	ldrb	r3, [r3, #9]
  40fbc8:	2b03      	cmp	r3, #3
  40fbca:	d106      	bne.n	40fbda <InvScheduler_dispatchOneTask+0x5e>
			task->state = INVSCHEDULER_TASK_STATE_READY;
  40fbcc:	68fb      	ldr	r3, [r7, #12]
  40fbce:	2202      	movs	r2, #2
  40fbd0:	725a      	strb	r2, [r3, #9]
			InvScheduler_insertTask(scheduler, task);
  40fbd2:	68f9      	ldr	r1, [r7, #12]
  40fbd4:	6878      	ldr	r0, [r7, #4]
  40fbd6:	4b06      	ldr	r3, [pc, #24]	; (40fbf0 <InvScheduler_dispatchOneTask+0x74>)
  40fbd8:	4798      	blx	r3
		}

		run = 1;
  40fbda:	2301      	movs	r3, #1
  40fbdc:	617b      	str	r3, [r7, #20]
	}

	InvScheduler_unlock(scheduler->contextLock);

	return run;
  40fbde:	697b      	ldr	r3, [r7, #20]
}
  40fbe0:	4618      	mov	r0, r3
  40fbe2:	3718      	adds	r7, #24
  40fbe4:	46bd      	mov	sp, r7
  40fbe6:	bd80      	pop	{r7, pc}
  40fbe8:	0040fac5 	.word	0x0040fac5
  40fbec:	0040fa69 	.word	0x0040fa69
  40fbf0:	0040fa15 	.word	0x0040fa15

0040fbf4 <InvScheduler_dispatchTasks>:

int InvScheduler_dispatchTasks(InvScheduler *scheduler)
{
  40fbf4:	b580      	push	{r7, lr}
  40fbf6:	b084      	sub	sp, #16
  40fbf8:	af00      	add	r7, sp, #0
  40fbfa:	6078      	str	r0, [r7, #4]
	int count = 0;
  40fbfc:	2300      	movs	r3, #0
  40fbfe:	60fb      	str	r3, [r7, #12]

	while(InvScheduler_dispatchOneTask(scheduler))
  40fc00:	e002      	b.n	40fc08 <InvScheduler_dispatchTasks+0x14>
		++count;
  40fc02:	68fb      	ldr	r3, [r7, #12]
  40fc04:	3301      	adds	r3, #1
  40fc06:	60fb      	str	r3, [r7, #12]
	while(InvScheduler_dispatchOneTask(scheduler))
  40fc08:	6878      	ldr	r0, [r7, #4]
  40fc0a:	4b05      	ldr	r3, [pc, #20]	; (40fc20 <InvScheduler_dispatchTasks+0x2c>)
  40fc0c:	4798      	blx	r3
  40fc0e:	4603      	mov	r3, r0
  40fc10:	2b00      	cmp	r3, #0
  40fc12:	d1f6      	bne.n	40fc02 <InvScheduler_dispatchTasks+0xe>

	return count;
  40fc14:	68fb      	ldr	r3, [r7, #12]
}
  40fc16:	4618      	mov	r0, r3
  40fc18:	3710      	adds	r7, #16
  40fc1a:	46bd      	mov	sp, r7
  40fc1c:	bd80      	pop	{r7, pc}
  40fc1e:	bf00      	nop
  40fc20:	0040fb7d 	.word	0x0040fb7d

0040fc24 <InvScheduler_initTaskDo>:

void InvScheduler_initTaskDo(InvScheduler *scheduler, InvSchedulerTask *task,
		void (*func)(void *), void *arg, uint8_t prio, uint32_t period)
{
  40fc24:	b480      	push	{r7}
  40fc26:	b085      	sub	sp, #20
  40fc28:	af00      	add	r7, sp, #0
  40fc2a:	60f8      	str	r0, [r7, #12]
  40fc2c:	60b9      	str	r1, [r7, #8]
  40fc2e:	607a      	str	r2, [r7, #4]
  40fc30:	603b      	str	r3, [r7, #0]
	task->scheduler = scheduler;
  40fc32:	68bb      	ldr	r3, [r7, #8]
  40fc34:	68fa      	ldr	r2, [r7, #12]
  40fc36:	619a      	str	r2, [r3, #24]
	task->func 		= func;
  40fc38:	68bb      	ldr	r3, [r7, #8]
  40fc3a:	687a      	ldr	r2, [r7, #4]
  40fc3c:	601a      	str	r2, [r3, #0]
	task->arg 		= arg;
  40fc3e:	68bb      	ldr	r3, [r7, #8]
  40fc40:	683a      	ldr	r2, [r7, #0]
  40fc42:	605a      	str	r2, [r3, #4]
	task->priority 	= prio;
  40fc44:	68bb      	ldr	r3, [r7, #8]
  40fc46:	7e3a      	ldrb	r2, [r7, #24]
  40fc48:	721a      	strb	r2, [r3, #8]
	task->period 	= period;
  40fc4a:	68bb      	ldr	r3, [r7, #8]
  40fc4c:	69fa      	ldr	r2, [r7, #28]
  40fc4e:	611a      	str	r2, [r3, #16]
	task->state		= INVSCHEDULER_TASK_STATE_STOP;
  40fc50:	68bb      	ldr	r3, [r7, #8]
  40fc52:	2200      	movs	r2, #0
  40fc54:	725a      	strb	r2, [r3, #9]
#ifdef INVSCHEDULER_TASK_NAME
	task->name 		= "";
#endif
}
  40fc56:	bf00      	nop
  40fc58:	3714      	adds	r7, #20
  40fc5a:	46bd      	mov	sp, r7
  40fc5c:	f85d 7b04 	ldr.w	r7, [sp], #4
  40fc60:	4770      	bx	lr
	...

0040fc64 <InvScheduler_startTaskU>:

void InvScheduler_startTaskU(InvSchedulerTask *task, uint32_t delay)
{
  40fc64:	b580      	push	{r7, lr}
  40fc66:	b082      	sub	sp, #8
  40fc68:	af00      	add	r7, sp, #0
  40fc6a:	6078      	str	r0, [r7, #4]
  40fc6c:	6039      	str	r1, [r7, #0]
	if(task->state == INVSCHEDULER_TASK_STATE_STARTED ||
  40fc6e:	687b      	ldr	r3, [r7, #4]
  40fc70:	7a5b      	ldrb	r3, [r3, #9]
  40fc72:	2b01      	cmp	r3, #1
  40fc74:	d003      	beq.n	40fc7e <InvScheduler_startTaskU+0x1a>
			task->state == INVSCHEDULER_TASK_STATE_READY) {
  40fc76:	687b      	ldr	r3, [r7, #4]
  40fc78:	7a5b      	ldrb	r3, [r3, #9]
	if(task->state == INVSCHEDULER_TASK_STATE_STARTED ||
  40fc7a:	2b02      	cmp	r3, #2
  40fc7c:	d105      	bne.n	40fc8a <InvScheduler_startTaskU+0x26>
		InvScheduler_removeTask(task->scheduler, task);
  40fc7e:	687b      	ldr	r3, [r7, #4]
  40fc80:	699b      	ldr	r3, [r3, #24]
  40fc82:	6879      	ldr	r1, [r7, #4]
  40fc84:	4618      	mov	r0, r3
  40fc86:	4b09      	ldr	r3, [pc, #36]	; (40fcac <InvScheduler_startTaskU+0x48>)
  40fc88:	4798      	blx	r3
	}
	InvScheduler_insertTask(task->scheduler, task);
  40fc8a:	687b      	ldr	r3, [r7, #4]
  40fc8c:	699b      	ldr	r3, [r3, #24]
  40fc8e:	6879      	ldr	r1, [r7, #4]
  40fc90:	4618      	mov	r0, r3
  40fc92:	4b07      	ldr	r3, [pc, #28]	; (40fcb0 <InvScheduler_startTaskU+0x4c>)
  40fc94:	4798      	blx	r3
	task->delay = delay;
  40fc96:	687b      	ldr	r3, [r7, #4]
  40fc98:	683a      	ldr	r2, [r7, #0]
  40fc9a:	615a      	str	r2, [r3, #20]
	task->state = INVSCHEDULER_TASK_STATE_STARTED;
  40fc9c:	687b      	ldr	r3, [r7, #4]
  40fc9e:	2201      	movs	r2, #1
  40fca0:	725a      	strb	r2, [r3, #9]
}
  40fca2:	bf00      	nop
  40fca4:	3708      	adds	r7, #8
  40fca6:	46bd      	mov	sp, r7
  40fca8:	bd80      	pop	{r7, pc}
  40fcaa:	bf00      	nop
  40fcac:	0040fa69 	.word	0x0040fa69
  40fcb0:	0040fa15 	.word	0x0040fa15

0040fcb4 <InvScheduler_startTask>:

void InvScheduler_startTask(InvSchedulerTask *task, uint32_t delay)
{
  40fcb4:	b580      	push	{r7, lr}
  40fcb6:	b082      	sub	sp, #8
  40fcb8:	af00      	add	r7, sp, #0
  40fcba:	6078      	str	r0, [r7, #4]
  40fcbc:	6039      	str	r1, [r7, #0]
	InvScheduler_lock(task->scheduler->contextLock);
	InvScheduler_startTaskU(task, delay);
  40fcbe:	6839      	ldr	r1, [r7, #0]
  40fcc0:	6878      	ldr	r0, [r7, #4]
  40fcc2:	4b03      	ldr	r3, [pc, #12]	; (40fcd0 <InvScheduler_startTask+0x1c>)
  40fcc4:	4798      	blx	r3
	InvScheduler_unlock(task->scheduler->contextLock);
}
  40fcc6:	bf00      	nop
  40fcc8:	3708      	adds	r7, #8
  40fcca:	46bd      	mov	sp, r7
  40fccc:	bd80      	pop	{r7, pc}
  40fcce:	bf00      	nop
  40fcd0:	0040fc65 	.word	0x0040fc65

0040fcd4 <inv_msg_setup>:
{
	(void)level, (void)str, (void)ap;
}

void inv_msg_setup(int level, inv_msg_printer_t printer)
{
  40fcd4:	b480      	push	{r7}
  40fcd6:	b083      	sub	sp, #12
  40fcd8:	af00      	add	r7, sp, #0
  40fcda:	6078      	str	r0, [r7, #4]
  40fcdc:	6039      	str	r1, [r7, #0]
	msg_level   = level;
  40fcde:	4a0c      	ldr	r2, [pc, #48]	; (40fd10 <inv_msg_setup+0x3c>)
  40fce0:	687b      	ldr	r3, [r7, #4]
  40fce2:	6013      	str	r3, [r2, #0]
	if (level < INV_MSG_LEVEL_OFF)
  40fce4:	687b      	ldr	r3, [r7, #4]
  40fce6:	2b00      	cmp	r3, #0
  40fce8:	da03      	bge.n	40fcf2 <inv_msg_setup+0x1e>
		msg_level = INV_MSG_LEVEL_OFF;
  40fcea:	4b09      	ldr	r3, [pc, #36]	; (40fd10 <inv_msg_setup+0x3c>)
  40fcec:	2200      	movs	r2, #0
  40fcee:	601a      	str	r2, [r3, #0]
  40fcf0:	e005      	b.n	40fcfe <inv_msg_setup+0x2a>
	else if (level > INV_MSG_LEVEL_MAX)
  40fcf2:	687b      	ldr	r3, [r7, #4]
  40fcf4:	2b06      	cmp	r3, #6
  40fcf6:	dd02      	ble.n	40fcfe <inv_msg_setup+0x2a>
		msg_level = INV_MSG_LEVEL_MAX;
  40fcf8:	4b05      	ldr	r3, [pc, #20]	; (40fd10 <inv_msg_setup+0x3c>)
  40fcfa:	2206      	movs	r2, #6
  40fcfc:	601a      	str	r2, [r3, #0]
	msg_printer = printer;
  40fcfe:	4a05      	ldr	r2, [pc, #20]	; (40fd14 <inv_msg_setup+0x40>)
  40fd00:	683b      	ldr	r3, [r7, #0]
  40fd02:	6013      	str	r3, [r2, #0]
}
  40fd04:	bf00      	nop
  40fd06:	370c      	adds	r7, #12
  40fd08:	46bd      	mov	sp, r7
  40fd0a:	f85d 7b04 	ldr.w	r7, [sp], #4
  40fd0e:	4770      	bx	lr
  40fd10:	20001840 	.word	0x20001840
  40fd14:	20001844 	.word	0x20001844

0040fd18 <inv_msg>:

void inv_msg(int level, const char * str, ...)
{
  40fd18:	b40e      	push	{r1, r2, r3}
  40fd1a:	b580      	push	{r7, lr}
  40fd1c:	b085      	sub	sp, #20
  40fd1e:	af00      	add	r7, sp, #0
  40fd20:	6078      	str	r0, [r7, #4]
	if(level && level <= msg_level && msg_printer) {
  40fd22:	687b      	ldr	r3, [r7, #4]
  40fd24:	2b00      	cmp	r3, #0
  40fd26:	d011      	beq.n	40fd4c <inv_msg+0x34>
  40fd28:	4b0c      	ldr	r3, [pc, #48]	; (40fd5c <inv_msg+0x44>)
  40fd2a:	681b      	ldr	r3, [r3, #0]
  40fd2c:	687a      	ldr	r2, [r7, #4]
  40fd2e:	429a      	cmp	r2, r3
  40fd30:	dc0c      	bgt.n	40fd4c <inv_msg+0x34>
  40fd32:	4b0b      	ldr	r3, [pc, #44]	; (40fd60 <inv_msg+0x48>)
  40fd34:	681b      	ldr	r3, [r3, #0]
  40fd36:	2b00      	cmp	r3, #0
  40fd38:	d008      	beq.n	40fd4c <inv_msg+0x34>
		va_list ap;
		va_start(ap, str);
  40fd3a:	f107 0320 	add.w	r3, r7, #32
  40fd3e:	60fb      	str	r3, [r7, #12]
		msg_printer(level, str, ap);
  40fd40:	4b07      	ldr	r3, [pc, #28]	; (40fd60 <inv_msg+0x48>)
  40fd42:	681b      	ldr	r3, [r3, #0]
  40fd44:	68fa      	ldr	r2, [r7, #12]
  40fd46:	69f9      	ldr	r1, [r7, #28]
  40fd48:	6878      	ldr	r0, [r7, #4]
  40fd4a:	4798      	blx	r3
		va_end(ap);
	}
}
  40fd4c:	bf00      	nop
  40fd4e:	3714      	adds	r7, #20
  40fd50:	46bd      	mov	sp, r7
  40fd52:	e8bd 4080 	ldmia.w	sp!, {r7, lr}
  40fd56:	b003      	add	sp, #12
  40fd58:	4770      	bx	lr
  40fd5a:	bf00      	nop
  40fd5c:	20001840 	.word	0x20001840
  40fd60:	20001844 	.word	0x20001844

0040fd64 <RingByteBuffer_init>:

#include "RingByteBuffer.h"

void RingByteBuffer_init(RingByteBuffer *self, uint8_t *pBuffer,
                         uint16_t sizeBuffer)
{
  40fd64:	b580      	push	{r7, lr}
  40fd66:	b084      	sub	sp, #16
  40fd68:	af00      	add	r7, sp, #0
  40fd6a:	60f8      	str	r0, [r7, #12]
  40fd6c:	60b9      	str	r1, [r7, #8]
  40fd6e:	4613      	mov	r3, r2
  40fd70:	80fb      	strh	r3, [r7, #6]
	ASSERT(self);
	ASSERT(pBuffer);

	self->buffer 	= pBuffer;
  40fd72:	68fb      	ldr	r3, [r7, #12]
  40fd74:	68ba      	ldr	r2, [r7, #8]
  40fd76:	601a      	str	r2, [r3, #0]
	self->size 		= sizeBuffer;
  40fd78:	68fb      	ldr	r3, [r7, #12]
  40fd7a:	88fa      	ldrh	r2, [r7, #6]
  40fd7c:	809a      	strh	r2, [r3, #4]

	RingByteBuffer_clear(self);
  40fd7e:	68f8      	ldr	r0, [r7, #12]
  40fd80:	4b02      	ldr	r3, [pc, #8]	; (40fd8c <RingByteBuffer_init+0x28>)
  40fd82:	4798      	blx	r3
}
  40fd84:	bf00      	nop
  40fd86:	3710      	adds	r7, #16
  40fd88:	46bd      	mov	sp, r7
  40fd8a:	bd80      	pop	{r7, pc}
  40fd8c:	0040fd91 	.word	0x0040fd91

0040fd90 <RingByteBuffer_clear>:

void RingByteBuffer_clear(RingByteBuffer *self)
{
  40fd90:	b480      	push	{r7}
  40fd92:	b083      	sub	sp, #12
  40fd94:	af00      	add	r7, sp, #0
  40fd96:	6078      	str	r0, [r7, #4]
	ASSERT(self);

	self->start		= 0;
  40fd98:	687b      	ldr	r3, [r7, #4]
  40fd9a:	2200      	movs	r2, #0
  40fd9c:	80da      	strh	r2, [r3, #6]
	self->end		= 0;
  40fd9e:	687b      	ldr	r3, [r7, #4]
  40fda0:	2200      	movs	r2, #0
  40fda2:	811a      	strh	r2, [r3, #8]
	self->msbStart	= 0;
  40fda4:	687b      	ldr	r3, [r7, #4]
  40fda6:	2200      	movs	r2, #0
  40fda8:	729a      	strb	r2, [r3, #10]
	self->msbEnd	= 0;
  40fdaa:	687b      	ldr	r3, [r7, #4]
  40fdac:	2200      	movs	r2, #0
  40fdae:	72da      	strb	r2, [r3, #11]
}
  40fdb0:	bf00      	nop
  40fdb2:	370c      	adds	r7, #12
  40fdb4:	46bd      	mov	sp, r7
  40fdb6:	f85d 7b04 	ldr.w	r7, [sp], #4
  40fdba:	4770      	bx	lr

0040fdbc <RingByteBuffer_pushByte>:
		return 0;
	}
}

void RingByteBuffer_pushByte(RingByteBuffer *self, uint8_t byte)
{
  40fdbc:	b480      	push	{r7}
  40fdbe:	b083      	sub	sp, #12
  40fdc0:	af00      	add	r7, sp, #0
  40fdc2:	6078      	str	r0, [r7, #4]
  40fdc4:	460b      	mov	r3, r1
  40fdc6:	70fb      	strb	r3, [r7, #3]
	ASSERT(self);

	self->buffer[self->end] = byte;
  40fdc8:	687b      	ldr	r3, [r7, #4]
  40fdca:	681b      	ldr	r3, [r3, #0]
  40fdcc:	687a      	ldr	r2, [r7, #4]
  40fdce:	8912      	ldrh	r2, [r2, #8]
  40fdd0:	4413      	add	r3, r2
  40fdd2:	78fa      	ldrb	r2, [r7, #3]
  40fdd4:	701a      	strb	r2, [r3, #0]

	if (++self->end == self->size) {
  40fdd6:	687b      	ldr	r3, [r7, #4]
  40fdd8:	891b      	ldrh	r3, [r3, #8]
  40fdda:	3301      	adds	r3, #1
  40fddc:	b29a      	uxth	r2, r3
  40fdde:	687b      	ldr	r3, [r7, #4]
  40fde0:	811a      	strh	r2, [r3, #8]
  40fde2:	687b      	ldr	r3, [r7, #4]
  40fde4:	891a      	ldrh	r2, [r3, #8]
  40fde6:	687b      	ldr	r3, [r7, #4]
  40fde8:	889b      	ldrh	r3, [r3, #4]
  40fdea:	429a      	cmp	r2, r3
  40fdec:	d109      	bne.n	40fe02 <RingByteBuffer_pushByte+0x46>
		self->msbEnd ^= 1;
  40fdee:	687b      	ldr	r3, [r7, #4]
  40fdf0:	7adb      	ldrb	r3, [r3, #11]
  40fdf2:	f083 0301 	eor.w	r3, r3, #1
  40fdf6:	b2da      	uxtb	r2, r3
  40fdf8:	687b      	ldr	r3, [r7, #4]
  40fdfa:	72da      	strb	r2, [r3, #11]
		self->end 	  = 0;
  40fdfc:	687b      	ldr	r3, [r7, #4]
  40fdfe:	2200      	movs	r2, #0
  40fe00:	811a      	strh	r2, [r3, #8]
	}
}
  40fe02:	bf00      	nop
  40fe04:	370c      	adds	r7, #12
  40fe06:	46bd      	mov	sp, r7
  40fe08:	f85d 7b04 	ldr.w	r7, [sp], #4
  40fe0c:	4770      	bx	lr

0040fe0e <RingByteBuffer_popByte>:

uint8_t RingByteBuffer_popByte(RingByteBuffer *self)
{
  40fe0e:	b480      	push	{r7}
  40fe10:	b085      	sub	sp, #20
  40fe12:	af00      	add	r7, sp, #0
  40fe14:	6078      	str	r0, [r7, #4]
	uint8_t byte;

	ASSERT(self);

	byte = self->buffer[self->start];
  40fe16:	687b      	ldr	r3, [r7, #4]
  40fe18:	681b      	ldr	r3, [r3, #0]
  40fe1a:	687a      	ldr	r2, [r7, #4]
  40fe1c:	88d2      	ldrh	r2, [r2, #6]
  40fe1e:	4413      	add	r3, r2
  40fe20:	781b      	ldrb	r3, [r3, #0]
  40fe22:	73fb      	strb	r3, [r7, #15]

	if (++self->start == self->size) {
  40fe24:	687b      	ldr	r3, [r7, #4]
  40fe26:	88db      	ldrh	r3, [r3, #6]
  40fe28:	3301      	adds	r3, #1
  40fe2a:	b29a      	uxth	r2, r3
  40fe2c:	687b      	ldr	r3, [r7, #4]
  40fe2e:	80da      	strh	r2, [r3, #6]
  40fe30:	687b      	ldr	r3, [r7, #4]
  40fe32:	88da      	ldrh	r2, [r3, #6]
  40fe34:	687b      	ldr	r3, [r7, #4]
  40fe36:	889b      	ldrh	r3, [r3, #4]
  40fe38:	429a      	cmp	r2, r3
  40fe3a:	d109      	bne.n	40fe50 <RingByteBuffer_popByte+0x42>
		self->msbStart ^= 1;
  40fe3c:	687b      	ldr	r3, [r7, #4]
  40fe3e:	7a9b      	ldrb	r3, [r3, #10]
  40fe40:	f083 0301 	eor.w	r3, r3, #1
  40fe44:	b2da      	uxtb	r2, r3
  40fe46:	687b      	ldr	r3, [r7, #4]
  40fe48:	729a      	strb	r2, [r3, #10]
		self->start     = 0;
  40fe4a:	687b      	ldr	r3, [r7, #4]
  40fe4c:	2200      	movs	r2, #0
  40fe4e:	80da      	strh	r2, [r3, #6]
	}

	return byte;
  40fe50:	7bfb      	ldrb	r3, [r7, #15]
}
  40fe52:	4618      	mov	r0, r3
  40fe54:	3714      	adds	r7, #20
  40fe56:	46bd      	mov	sp, r7
  40fe58:	f85d 7b04 	ldr.w	r7, [sp], #4
  40fe5c:	4770      	bx	lr

0040fe5e <inv_icm20948_augmented_init>:
		newOdr = MIN(s->sOriWuOdrMs,newOdr); \
	if	(inv_icm20948_ctrl_androidSensor_enabled	(s, ANDROID_SENSOR_WAKEUP_ROTATION_VECTOR)) \
		newOdr = MIN(s->sRvWuOdrMs,newOdr);

int inv_icm20948_augmented_init(struct inv_icm20948 * s)
{
  40fe5e:	b480      	push	{r7}
  40fe60:	b083      	sub	sp, #12
  40fe62:	af00      	add	r7, sp, #0
  40fe64:	6078      	str	r0, [r7, #4]
	// ODR expected for gravity-based sensors
	s->sGravityOdrMs = 0xFFFF;
  40fe66:	687b      	ldr	r3, [r7, #4]
  40fe68:	f64f 72ff 	movw	r2, #65535	; 0xffff
  40fe6c:	f8a3 24de 	strh.w	r2, [r3, #1246]	; 0x4de
	s->sGrvOdrMs = 0xFFFF;
  40fe70:	687b      	ldr	r3, [r7, #4]
  40fe72:	f64f 72ff 	movw	r2, #65535	; 0xffff
  40fe76:	f8a3 24e0 	strh.w	r2, [r3, #1248]	; 0x4e0
	s->sLinAccOdrMs = 0xFFFF;
  40fe7a:	687b      	ldr	r3, [r7, #4]
  40fe7c:	f64f 72ff 	movw	r2, #65535	; 0xffff
  40fe80:	f8a3 24e2 	strh.w	r2, [r3, #1250]	; 0x4e2
	s->sGravityWuOdrMs = 0xFFFF;
  40fe84:	687b      	ldr	r3, [r7, #4]
  40fe86:	f64f 72ff 	movw	r2, #65535	; 0xffff
  40fe8a:	f8a3 24e4 	strh.w	r2, [r3, #1252]	; 0x4e4
	s->sGrvWuOdrMs = 0xFFFF;
  40fe8e:	687b      	ldr	r3, [r7, #4]
  40fe90:	f64f 72ff 	movw	r2, #65535	; 0xffff
  40fe94:	f8a3 24e6 	strh.w	r2, [r3, #1254]	; 0x4e6
	s->sLinAccWuOdrMs = 0xFFFF;
  40fe98:	687b      	ldr	r3, [r7, #4]
  40fe9a:	f64f 72ff 	movw	r2, #65535	; 0xffff
  40fe9e:	f8a3 24e8 	strh.w	r2, [r3, #1256]	; 0x4e8
	// ODR expected for rotation vector-based sensors
	s->sRvOdrMs = 0xFFFF;
  40fea2:	687b      	ldr	r3, [r7, #4]
  40fea4:	f64f 72ff 	movw	r2, #65535	; 0xffff
  40fea8:	f8a3 24ea 	strh.w	r2, [r3, #1258]	; 0x4ea
	s->sOriOdrMs = 0xFFFF;
  40feac:	687b      	ldr	r3, [r7, #4]
  40feae:	f64f 72ff 	movw	r2, #65535	; 0xffff
  40feb2:	f8a3 24ec 	strh.w	r2, [r3, #1260]	; 0x4ec
	s->sRvWuOdrMs = 0xFFFF;
  40feb6:	687b      	ldr	r3, [r7, #4]
  40feb8:	f64f 72ff 	movw	r2, #65535	; 0xffff
  40febc:	f8a3 24ee 	strh.w	r2, [r3, #1262]	; 0x4ee
	s->sOriWuOdrMs = 0xFFFF;
  40fec0:	687b      	ldr	r3, [r7, #4]
  40fec2:	f64f 72ff 	movw	r2, #65535	; 0xffff
  40fec6:	f8a3 24f0 	strh.w	r2, [r3, #1264]	; 0x4f0
	
	return 0;
  40feca:	2300      	movs	r3, #0
}
  40fecc:	4618      	mov	r0, r3
  40fece:	370c      	adds	r7, #12
  40fed0:	46bd      	mov	sp, r7
  40fed2:	f85d 7b04 	ldr.w	r7, [sp], #4
  40fed6:	4770      	bx	lr

0040fed8 <inv_icm20948_augmented_sensors_get_gravity>:

int inv_icm20948_augmented_sensors_get_gravity(struct inv_icm20948 * s, long gravity[3], const long quat6axis_3e[3])
{
  40fed8:	b5b0      	push	{r4, r5, r7, lr}
  40feda:	b08c      	sub	sp, #48	; 0x30
  40fedc:	af00      	add	r7, sp, #0
  40fede:	60f8      	str	r0, [r7, #12]
  40fee0:	60b9      	str	r1, [r7, #8]
  40fee2:	607a      	str	r2, [r7, #4]
	long quat6axis_4e[4];
	long quat6axis_4e_body_to_world[4];

	if(!gravity) return -1;
  40fee4:	68bb      	ldr	r3, [r7, #8]
  40fee6:	2b00      	cmp	r3, #0
  40fee8:	d102      	bne.n	40fef0 <inv_icm20948_augmented_sensors_get_gravity+0x18>
  40feea:	f04f 33ff 	mov.w	r3, #4294967295
  40feee:	e054      	b.n	40ff9a <inv_icm20948_augmented_sensors_get_gravity+0xc2>
	if(!quat6axis_3e) return -1;
  40fef0:	687b      	ldr	r3, [r7, #4]
  40fef2:	2b00      	cmp	r3, #0
  40fef4:	d102      	bne.n	40fefc <inv_icm20948_augmented_sensors_get_gravity+0x24>
  40fef6:	f04f 33ff 	mov.w	r3, #4294967295
  40fefa:	e04e      	b.n	40ff9a <inv_icm20948_augmented_sensors_get_gravity+0xc2>

	// compute w element
	inv_icm20948_convert_compute_scalar_part_fxp(quat6axis_3e, quat6axis_4e);
  40fefc:	f107 0320 	add.w	r3, r7, #32
  40ff00:	4619      	mov	r1, r3
  40ff02:	6878      	ldr	r0, [r7, #4]
  40ff04:	4b27      	ldr	r3, [pc, #156]	; (40ffa4 <inv_icm20948_augmented_sensors_get_gravity+0xcc>)
  40ff06:	4798      	blx	r3
	// apply mounting matrix
	inv_icm20948_q_mult_q_qi(quat6axis_4e, s->s_quat_chip_to_body, quat6axis_4e_body_to_world);
  40ff08:	68fb      	ldr	r3, [r7, #12]
  40ff0a:	f103 01a8 	add.w	r1, r3, #168	; 0xa8
  40ff0e:	f107 0210 	add.w	r2, r7, #16
  40ff12:	f107 0320 	add.w	r3, r7, #32
  40ff16:	4618      	mov	r0, r3
  40ff18:	4b23      	ldr	r3, [pc, #140]	; (40ffa8 <inv_icm20948_augmented_sensors_get_gravity+0xd0>)
  40ff1a:	4798      	blx	r3

	gravity[0] = ( 2 * inv_icm20948_convert_mult_qfix_fxp(quat6axis_4e_body_to_world[1], quat6axis_4e_body_to_world[3], 30) - 
  40ff1c:	697b      	ldr	r3, [r7, #20]
  40ff1e:	69f9      	ldr	r1, [r7, #28]
  40ff20:	221e      	movs	r2, #30
  40ff22:	4618      	mov	r0, r3
  40ff24:	4b21      	ldr	r3, [pc, #132]	; (40ffac <inv_icm20948_augmented_sensors_get_gravity+0xd4>)
  40ff26:	4798      	blx	r3
  40ff28:	4604      	mov	r4, r0
	               2 * inv_icm20948_convert_mult_qfix_fxp(quat6axis_4e_body_to_world[0], quat6axis_4e_body_to_world[2], 30) ) >> (30 - 16);
  40ff2a:	693b      	ldr	r3, [r7, #16]
  40ff2c:	69b9      	ldr	r1, [r7, #24]
  40ff2e:	221e      	movs	r2, #30
  40ff30:	4618      	mov	r0, r3
  40ff32:	4b1e      	ldr	r3, [pc, #120]	; (40ffac <inv_icm20948_augmented_sensors_get_gravity+0xd4>)
  40ff34:	4798      	blx	r3
  40ff36:	4603      	mov	r3, r0
	gravity[0] = ( 2 * inv_icm20948_convert_mult_qfix_fxp(quat6axis_4e_body_to_world[1], quat6axis_4e_body_to_world[3], 30) - 
  40ff38:	1ae3      	subs	r3, r4, r3
  40ff3a:	005b      	lsls	r3, r3, #1
	               2 * inv_icm20948_convert_mult_qfix_fxp(quat6axis_4e_body_to_world[0], quat6axis_4e_body_to_world[2], 30) ) >> (30 - 16);
  40ff3c:	139a      	asrs	r2, r3, #14
	gravity[0] = ( 2 * inv_icm20948_convert_mult_qfix_fxp(quat6axis_4e_body_to_world[1], quat6axis_4e_body_to_world[3], 30) - 
  40ff3e:	68bb      	ldr	r3, [r7, #8]
  40ff40:	601a      	str	r2, [r3, #0]
	gravity[1] = ( 2 * inv_icm20948_convert_mult_qfix_fxp(quat6axis_4e_body_to_world[2], quat6axis_4e_body_to_world[3], 30) + 
  40ff42:	68bb      	ldr	r3, [r7, #8]
  40ff44:	1d1c      	adds	r4, r3, #4
  40ff46:	69bb      	ldr	r3, [r7, #24]
  40ff48:	69f9      	ldr	r1, [r7, #28]
  40ff4a:	221e      	movs	r2, #30
  40ff4c:	4618      	mov	r0, r3
  40ff4e:	4b17      	ldr	r3, [pc, #92]	; (40ffac <inv_icm20948_augmented_sensors_get_gravity+0xd4>)
  40ff50:	4798      	blx	r3
  40ff52:	4605      	mov	r5, r0
	               2 * inv_icm20948_convert_mult_qfix_fxp(quat6axis_4e_body_to_world[0], quat6axis_4e_body_to_world[1], 30) ) >> (30 - 16);
  40ff54:	693b      	ldr	r3, [r7, #16]
  40ff56:	6979      	ldr	r1, [r7, #20]
  40ff58:	221e      	movs	r2, #30
  40ff5a:	4618      	mov	r0, r3
  40ff5c:	4b13      	ldr	r3, [pc, #76]	; (40ffac <inv_icm20948_augmented_sensors_get_gravity+0xd4>)
  40ff5e:	4798      	blx	r3
  40ff60:	4603      	mov	r3, r0
	gravity[1] = ( 2 * inv_icm20948_convert_mult_qfix_fxp(quat6axis_4e_body_to_world[2], quat6axis_4e_body_to_world[3], 30) + 
  40ff62:	442b      	add	r3, r5
  40ff64:	005b      	lsls	r3, r3, #1
	               2 * inv_icm20948_convert_mult_qfix_fxp(quat6axis_4e_body_to_world[0], quat6axis_4e_body_to_world[1], 30) ) >> (30 - 16);
  40ff66:	139b      	asrs	r3, r3, #14
	gravity[1] = ( 2 * inv_icm20948_convert_mult_qfix_fxp(quat6axis_4e_body_to_world[2], quat6axis_4e_body_to_world[3], 30) + 
  40ff68:	6023      	str	r3, [r4, #0]
	gravity[2] = ( (1 << 30) - 2 * inv_icm20948_convert_mult_qfix_fxp(quat6axis_4e_body_to_world[1], quat6axis_4e_body_to_world[1], 30) - 
  40ff6a:	68bb      	ldr	r3, [r7, #8]
  40ff6c:	f103 0408 	add.w	r4, r3, #8
  40ff70:	697b      	ldr	r3, [r7, #20]
  40ff72:	6979      	ldr	r1, [r7, #20]
  40ff74:	221e      	movs	r2, #30
  40ff76:	4618      	mov	r0, r3
  40ff78:	4b0c      	ldr	r3, [pc, #48]	; (40ffac <inv_icm20948_augmented_sensors_get_gravity+0xd4>)
  40ff7a:	4798      	blx	r3
  40ff7c:	4603      	mov	r3, r0
  40ff7e:	f1c3 5500 	rsb	r5, r3, #536870912	; 0x20000000
	                2 * inv_icm20948_convert_mult_qfix_fxp(quat6axis_4e_body_to_world[2], quat6axis_4e_body_to_world[2], 30) ) >> (30 - 16);
  40ff82:	69bb      	ldr	r3, [r7, #24]
  40ff84:	69b9      	ldr	r1, [r7, #24]
  40ff86:	221e      	movs	r2, #30
  40ff88:	4618      	mov	r0, r3
  40ff8a:	4b08      	ldr	r3, [pc, #32]	; (40ffac <inv_icm20948_augmented_sensors_get_gravity+0xd4>)
  40ff8c:	4798      	blx	r3
  40ff8e:	4603      	mov	r3, r0
	gravity[2] = ( (1 << 30) - 2 * inv_icm20948_convert_mult_qfix_fxp(quat6axis_4e_body_to_world[1], quat6axis_4e_body_to_world[1], 30) - 
  40ff90:	1aeb      	subs	r3, r5, r3
  40ff92:	005b      	lsls	r3, r3, #1
	                2 * inv_icm20948_convert_mult_qfix_fxp(quat6axis_4e_body_to_world[2], quat6axis_4e_body_to_world[2], 30) ) >> (30 - 16);
  40ff94:	139b      	asrs	r3, r3, #14
	gravity[2] = ( (1 << 30) - 2 * inv_icm20948_convert_mult_qfix_fxp(quat6axis_4e_body_to_world[1], quat6axis_4e_body_to_world[1], 30) - 
  40ff96:	6023      	str	r3, [r4, #0]

	return MPU_SUCCESS;
  40ff98:	2300      	movs	r3, #0
}
  40ff9a:	4618      	mov	r0, r3
  40ff9c:	3730      	adds	r7, #48	; 0x30
  40ff9e:	46bd      	mov	sp, r7
  40ffa0:	bdb0      	pop	{r4, r5, r7, pc}
  40ffa2:	bf00      	nop
  40ffa4:	00406d35 	.word	0x00406d35
  40ffa8:	00406765 	.word	0x00406765
  40ffac:	00407589 	.word	0x00407589

0040ffb0 <inv_icm20948_augmented_sensors_get_linearacceleration>:

int inv_icm20948_augmented_sensors_get_linearacceleration(long linacc[3], const long gravity[3], const long accel[3])
{
  40ffb0:	b480      	push	{r7}
  40ffb2:	b085      	sub	sp, #20
  40ffb4:	af00      	add	r7, sp, #0
  40ffb6:	60f8      	str	r0, [r7, #12]
  40ffb8:	60b9      	str	r1, [r7, #8]
  40ffba:	607a      	str	r2, [r7, #4]
    if(!linacc) return -1;
  40ffbc:	68fb      	ldr	r3, [r7, #12]
  40ffbe:	2b00      	cmp	r3, #0
  40ffc0:	d102      	bne.n	40ffc8 <inv_icm20948_augmented_sensors_get_linearacceleration+0x18>
  40ffc2:	f04f 33ff 	mov.w	r3, #4294967295
  40ffc6:	e027      	b.n	410018 <inv_icm20948_augmented_sensors_get_linearacceleration+0x68>
    if(!gravity) return -1;
  40ffc8:	68bb      	ldr	r3, [r7, #8]
  40ffca:	2b00      	cmp	r3, #0
  40ffcc:	d102      	bne.n	40ffd4 <inv_icm20948_augmented_sensors_get_linearacceleration+0x24>
  40ffce:	f04f 33ff 	mov.w	r3, #4294967295
  40ffd2:	e021      	b.n	410018 <inv_icm20948_augmented_sensors_get_linearacceleration+0x68>
    if(!accel) return -1;
  40ffd4:	687b      	ldr	r3, [r7, #4]
  40ffd6:	2b00      	cmp	r3, #0
  40ffd8:	d102      	bne.n	40ffe0 <inv_icm20948_augmented_sensors_get_linearacceleration+0x30>
  40ffda:	f04f 33ff 	mov.w	r3, #4294967295
  40ffde:	e01b      	b.n	410018 <inv_icm20948_augmented_sensors_get_linearacceleration+0x68>
    
    linacc[0] = accel[0] - gravity[0];
  40ffe0:	687b      	ldr	r3, [r7, #4]
  40ffe2:	681a      	ldr	r2, [r3, #0]
  40ffe4:	68bb      	ldr	r3, [r7, #8]
  40ffe6:	681b      	ldr	r3, [r3, #0]
  40ffe8:	1ad2      	subs	r2, r2, r3
  40ffea:	68fb      	ldr	r3, [r7, #12]
  40ffec:	601a      	str	r2, [r3, #0]
    linacc[1] = accel[1] - gravity[1];
  40ffee:	68fb      	ldr	r3, [r7, #12]
  40fff0:	3304      	adds	r3, #4
  40fff2:	687a      	ldr	r2, [r7, #4]
  40fff4:	3204      	adds	r2, #4
  40fff6:	6811      	ldr	r1, [r2, #0]
  40fff8:	68ba      	ldr	r2, [r7, #8]
  40fffa:	3204      	adds	r2, #4
  40fffc:	6812      	ldr	r2, [r2, #0]
  40fffe:	1a8a      	subs	r2, r1, r2
  410000:	601a      	str	r2, [r3, #0]
    linacc[2] = accel[2] - gravity[2];
  410002:	68fb      	ldr	r3, [r7, #12]
  410004:	3308      	adds	r3, #8
  410006:	687a      	ldr	r2, [r7, #4]
  410008:	3208      	adds	r2, #8
  41000a:	6811      	ldr	r1, [r2, #0]
  41000c:	68ba      	ldr	r2, [r7, #8]
  41000e:	3208      	adds	r2, #8
  410010:	6812      	ldr	r2, [r2, #0]
  410012:	1a8a      	subs	r2, r1, r2
  410014:	601a      	str	r2, [r3, #0]
                    
    return MPU_SUCCESS;
  410016:	2300      	movs	r3, #0
}
  410018:	4618      	mov	r0, r3
  41001a:	3714      	adds	r7, #20
  41001c:	46bd      	mov	sp, r7
  41001e:	f85d 7b04 	ldr.w	r7, [sp], #4
  410022:	4770      	bx	lr

00410024 <inv_icm20948_augmented_sensors_get_orientation>:


int inv_icm20948_augmented_sensors_get_orientation(long orientation[3], const long quat9axis_3e[4])
{
  410024:	b590      	push	{r4, r7, lr}
  410026:	b093      	sub	sp, #76	; 0x4c
  410028:	af00      	add	r7, sp, #0
  41002a:	6078      	str	r0, [r7, #4]
  41002c:	6039      	str	r1, [r7, #0]
    long lQuat9axis4e[4];
	long lMatrixQ30[9];       
	long lMatrixQ30Square; 
	long lRad2degQ16 = 0x394BB8; // (float)(180.0 / 3.14159265358979) in Q16
  41002e:	4b43      	ldr	r3, [pc, #268]	; (41013c <inv_icm20948_augmented_sensors_get_orientation+0x118>)
  410030:	647b      	str	r3, [r7, #68]	; 0x44
    
    if(!orientation) return -1;
  410032:	687b      	ldr	r3, [r7, #4]
  410034:	2b00      	cmp	r3, #0
  410036:	d102      	bne.n	41003e <inv_icm20948_augmented_sensors_get_orientation+0x1a>
  410038:	f04f 33ff 	mov.w	r3, #4294967295
  41003c:	e07a      	b.n	410134 <inv_icm20948_augmented_sensors_get_orientation+0x110>
    if(!quat9axis_3e) return -1;
  41003e:	683b      	ldr	r3, [r7, #0]
  410040:	2b00      	cmp	r3, #0
  410042:	d102      	bne.n	41004a <inv_icm20948_augmented_sensors_get_orientation+0x26>
  410044:	f04f 33ff 	mov.w	r3, #4294967295
  410048:	e074      	b.n	410134 <inv_icm20948_augmented_sensors_get_orientation+0x110>
    
    // compute w element
	inv_icm20948_convert_compute_scalar_part_fxp(quat9axis_3e, lQuat9axis4e);
  41004a:	f107 0330 	add.w	r3, r7, #48	; 0x30
  41004e:	4619      	mov	r1, r3
  410050:	6838      	ldr	r0, [r7, #0]
  410052:	4b3b      	ldr	r3, [pc, #236]	; (410140 <inv_icm20948_augmented_sensors_get_orientation+0x11c>)
  410054:	4798      	blx	r3
    
	// quaternion to a rotation matrix, q30 to q30
	inv_icm20948_convert_quat_to_col_major_matrix_fxp((const long *)lQuat9axis4e, (long *)lMatrixQ30);
  410056:	f107 020c 	add.w	r2, r7, #12
  41005a:	f107 0330 	add.w	r3, r7, #48	; 0x30
  41005e:	4611      	mov	r1, r2
  410060:	4618      	mov	r0, r3
  410062:	4b38      	ldr	r3, [pc, #224]	; (410144 <inv_icm20948_augmented_sensors_get_orientation+0x120>)
  410064:	4798      	blx	r3

	// compute orientation in q16
	// orientationFlt[0] = atan2f(-matrixFlt[1][0], matrixFlt[0][0]) * rad2deg;
	orientation[0] = inv_icm20948_math_atan2_q15_fxp(-lMatrixQ30[3] >> 15, lMatrixQ30[0] >> 15) << 1;
  410066:	69bb      	ldr	r3, [r7, #24]
  410068:	425b      	negs	r3, r3
  41006a:	13da      	asrs	r2, r3, #15
  41006c:	68fb      	ldr	r3, [r7, #12]
  41006e:	13db      	asrs	r3, r3, #15
  410070:	4619      	mov	r1, r3
  410072:	4610      	mov	r0, r2
  410074:	4b34      	ldr	r3, [pc, #208]	; (410148 <inv_icm20948_augmented_sensors_get_orientation+0x124>)
  410076:	4798      	blx	r3
  410078:	4603      	mov	r3, r0
  41007a:	005a      	lsls	r2, r3, #1
  41007c:	687b      	ldr	r3, [r7, #4]
  41007e:	601a      	str	r2, [r3, #0]
	orientation[0] = inv_icm20948_convert_mult_qfix_fxp(orientation[0], lRad2degQ16, 16);
  410080:	687b      	ldr	r3, [r7, #4]
  410082:	681b      	ldr	r3, [r3, #0]
  410084:	2210      	movs	r2, #16
  410086:	6c79      	ldr	r1, [r7, #68]	; 0x44
  410088:	4618      	mov	r0, r3
  41008a:	4b30      	ldr	r3, [pc, #192]	; (41014c <inv_icm20948_augmented_sensors_get_orientation+0x128>)
  41008c:	4798      	blx	r3
  41008e:	4602      	mov	r2, r0
  410090:	687b      	ldr	r3, [r7, #4]
  410092:	601a      	str	r2, [r3, #0]

	// orientationFlt[1] = atan2f(-matrixFlt[2][1], matrixFlt[2][2]) * rad2deg;
	orientation[1] = inv_icm20948_math_atan2_q15_fxp(-lMatrixQ30[7] >> 15, lMatrixQ30[8] >> 15) << 1;
  410094:	687b      	ldr	r3, [r7, #4]
  410096:	1d1c      	adds	r4, r3, #4
  410098:	6abb      	ldr	r3, [r7, #40]	; 0x28
  41009a:	425b      	negs	r3, r3
  41009c:	13da      	asrs	r2, r3, #15
  41009e:	6afb      	ldr	r3, [r7, #44]	; 0x2c
  4100a0:	13db      	asrs	r3, r3, #15
  4100a2:	4619      	mov	r1, r3
  4100a4:	4610      	mov	r0, r2
  4100a6:	4b28      	ldr	r3, [pc, #160]	; (410148 <inv_icm20948_augmented_sensors_get_orientation+0x124>)
  4100a8:	4798      	blx	r3
  4100aa:	4603      	mov	r3, r0
  4100ac:	005b      	lsls	r3, r3, #1
  4100ae:	6023      	str	r3, [r4, #0]
	orientation[1] = inv_icm20948_convert_mult_qfix_fxp(orientation[1], lRad2degQ16, 16);
  4100b0:	687b      	ldr	r3, [r7, #4]
  4100b2:	1d1c      	adds	r4, r3, #4
  4100b4:	687b      	ldr	r3, [r7, #4]
  4100b6:	3304      	adds	r3, #4
  4100b8:	681b      	ldr	r3, [r3, #0]
  4100ba:	2210      	movs	r2, #16
  4100bc:	6c79      	ldr	r1, [r7, #68]	; 0x44
  4100be:	4618      	mov	r0, r3
  4100c0:	4b22      	ldr	r3, [pc, #136]	; (41014c <inv_icm20948_augmented_sensors_get_orientation+0x128>)
  4100c2:	4798      	blx	r3
  4100c4:	4603      	mov	r3, r0
  4100c6:	6023      	str	r3, [r4, #0]

	// orientationFlt[2] = asinf ( matrixFlt[2][0]) * rad2deg;
	// asin(x) = atan (x/sqrt(1-x))
	// atan2(y,x) = atan(y/x)
	// asin(x) = atan2(x, sqrt(1-x))
	lMatrixQ30Square = inv_icm20948_convert_mult_qfix_fxp(lMatrixQ30[6], lMatrixQ30[6], 30); // x
  4100c8:	6a7b      	ldr	r3, [r7, #36]	; 0x24
  4100ca:	6a79      	ldr	r1, [r7, #36]	; 0x24
  4100cc:	221e      	movs	r2, #30
  4100ce:	4618      	mov	r0, r3
  4100d0:	4b1e      	ldr	r3, [pc, #120]	; (41014c <inv_icm20948_augmented_sensors_get_orientation+0x128>)
  4100d2:	4798      	blx	r3
  4100d4:	6438      	str	r0, [r7, #64]	; 0x40
	lMatrixQ30Square = (1UL << 30) - lMatrixQ30Square; // 1-x
  4100d6:	6c3b      	ldr	r3, [r7, #64]	; 0x40
  4100d8:	f1c3 4380 	rsb	r3, r3, #1073741824	; 0x40000000
  4100dc:	643b      	str	r3, [r7, #64]	; 0x40
	lMatrixQ30Square = inv_icm20948_convert_fast_sqrt_fxp(lMatrixQ30Square); // sqrt(1-x)
  4100de:	6c38      	ldr	r0, [r7, #64]	; 0x40
  4100e0:	4b1b      	ldr	r3, [pc, #108]	; (410150 <inv_icm20948_augmented_sensors_get_orientation+0x12c>)
  4100e2:	4798      	blx	r3
  4100e4:	6438      	str	r0, [r7, #64]	; 0x40
	orientation[2] = inv_icm20948_math_atan2_q15_fxp(lMatrixQ30[6] >> 15,  lMatrixQ30Square >> 15) << 1; // atan2(x, sqrt(1-x))
  4100e6:	687b      	ldr	r3, [r7, #4]
  4100e8:	f103 0408 	add.w	r4, r3, #8
  4100ec:	6a7b      	ldr	r3, [r7, #36]	; 0x24
  4100ee:	13da      	asrs	r2, r3, #15
  4100f0:	6c3b      	ldr	r3, [r7, #64]	; 0x40
  4100f2:	13db      	asrs	r3, r3, #15
  4100f4:	4619      	mov	r1, r3
  4100f6:	4610      	mov	r0, r2
  4100f8:	4b13      	ldr	r3, [pc, #76]	; (410148 <inv_icm20948_augmented_sensors_get_orientation+0x124>)
  4100fa:	4798      	blx	r3
  4100fc:	4603      	mov	r3, r0
  4100fe:	005b      	lsls	r3, r3, #1
  410100:	6023      	str	r3, [r4, #0]
	orientation[2] = inv_icm20948_convert_mult_qfix_fxp(orientation[2], lRad2degQ16, 16); // * rad2deg
  410102:	687b      	ldr	r3, [r7, #4]
  410104:	f103 0408 	add.w	r4, r3, #8
  410108:	687b      	ldr	r3, [r7, #4]
  41010a:	3308      	adds	r3, #8
  41010c:	681b      	ldr	r3, [r3, #0]
  41010e:	2210      	movs	r2, #16
  410110:	6c79      	ldr	r1, [r7, #68]	; 0x44
  410112:	4618      	mov	r0, r3
  410114:	4b0d      	ldr	r3, [pc, #52]	; (41014c <inv_icm20948_augmented_sensors_get_orientation+0x128>)
  410116:	4798      	blx	r3
  410118:	4603      	mov	r3, r0
  41011a:	6023      	str	r3, [r4, #0]

	if (orientation[0] < 0)
  41011c:	687b      	ldr	r3, [r7, #4]
  41011e:	681b      	ldr	r3, [r3, #0]
  410120:	2b00      	cmp	r3, #0
  410122:	da06      	bge.n	410132 <inv_icm20948_augmented_sensors_get_orientation+0x10e>
		orientation[0] += 360UL << 16;
  410124:	687b      	ldr	r3, [r7, #4]
  410126:	681b      	ldr	r3, [r3, #0]
  410128:	f103 73b4 	add.w	r3, r3, #23592960	; 0x1680000
  41012c:	461a      	mov	r2, r3
  41012e:	687b      	ldr	r3, [r7, #4]
  410130:	601a      	str	r2, [r3, #0]

    return MPU_SUCCESS;
  410132:	2300      	movs	r3, #0
}
  410134:	4618      	mov	r0, r3
  410136:	374c      	adds	r7, #76	; 0x4c
  410138:	46bd      	mov	sp, r7
  41013a:	bd90      	pop	{r4, r7, pc}
  41013c:	00394bb8 	.word	0x00394bb8
  410140:	00406d35 	.word	0x00406d35
  410144:	0040763d 	.word	0x0040763d
  410148:	00407a09 	.word	0x00407a09
  41014c:	00407589 	.word	0x00407589
  410150:	00406dc9 	.word	0x00406dc9

00410154 <inv_icm20948_augmented_sensors_set_odr>:

unsigned short inv_icm20948_augmented_sensors_set_odr(struct inv_icm20948 * s, unsigned char androidSensor, unsigned short delayInMs)
{
  410154:	b580      	push	{r7, lr}
  410156:	b082      	sub	sp, #8
  410158:	af00      	add	r7, sp, #0
  41015a:	6078      	str	r0, [r7, #4]
  41015c:	460b      	mov	r3, r1
  41015e:	70fb      	strb	r3, [r7, #3]
  410160:	4613      	mov	r3, r2
  410162:	803b      	strh	r3, [r7, #0]
	switch(androidSensor)
  410164:	78fb      	ldrb	r3, [r7, #3]
  410166:	3b03      	subs	r3, #3
  410168:	2b20      	cmp	r3, #32
  41016a:	f200 8207 	bhi.w	41057c <inv_icm20948_augmented_sensors_set_odr+0x428>
  41016e:	a201      	add	r2, pc, #4	; (adr r2, 410174 <inv_icm20948_augmented_sensors_set_odr+0x20>)
  410170:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
  410174:	0041032b 	.word	0x0041032b
  410178:	0041057d 	.word	0x0041057d
  41017c:	0041057d 	.word	0x0041057d
  410180:	0041057d 	.word	0x0041057d
  410184:	0041057d 	.word	0x0041057d
  410188:	0041057d 	.word	0x0041057d
  41018c:	004101f9 	.word	0x004101f9
  410190:	004102c5 	.word	0x004102c5
  410194:	00410373 	.word	0x00410373
  410198:	0041057d 	.word	0x0041057d
  41019c:	0041057d 	.word	0x0041057d
  4101a0:	0041057d 	.word	0x0041057d
  4101a4:	0041025f 	.word	0x0041025f
  4101a8:	0041057d 	.word	0x0041057d
  4101ac:	0041057d 	.word	0x0041057d
  4101b0:	0041057d 	.word	0x0041057d
  4101b4:	0041057d 	.word	0x0041057d
  4101b8:	0041057d 	.word	0x0041057d
  4101bc:	0041057d 	.word	0x0041057d
  4101c0:	0041057d 	.word	0x0041057d
  4101c4:	0041057d 	.word	0x0041057d
  4101c8:	0041057d 	.word	0x0041057d
  4101cc:	004104f1 	.word	0x004104f1
  4101d0:	0041057d 	.word	0x0041057d
  4101d4:	0041057d 	.word	0x0041057d
  4101d8:	0041057d 	.word	0x0041057d
  4101dc:	004103bb 	.word	0x004103bb
  4101e0:	0041048d 	.word	0x0041048d
  4101e4:	00410537 	.word	0x00410537
  4101e8:	0041057d 	.word	0x0041057d
  4101ec:	0041057d 	.word	0x0041057d
  4101f0:	0041057d 	.word	0x0041057d
  4101f4:	00410421 	.word	0x00410421
	{
		case ANDROID_SENSOR_GRAVITY:
			s->sGravityOdrMs = delayInMs;
  4101f8:	687b      	ldr	r3, [r7, #4]
  4101fa:	883a      	ldrh	r2, [r7, #0]
  4101fc:	f8a3 24de 	strh.w	r2, [r3, #1246]	; 0x4de
			AUGMENTED_SENSOR_GET_6QUAT_MIN_ODR(s, delayInMs);
  410200:	2109      	movs	r1, #9
  410202:	6878      	ldr	r0, [r7, #4]
  410204:	4ba0      	ldr	r3, [pc, #640]	; (410488 <inv_icm20948_augmented_sensors_set_odr+0x334>)
  410206:	4798      	blx	r3
  410208:	4603      	mov	r3, r0
  41020a:	2b00      	cmp	r3, #0
  41020c:	d007      	beq.n	41021e <inv_icm20948_augmented_sensors_set_odr+0xca>
  41020e:	687b      	ldr	r3, [r7, #4]
  410210:	f8b3 24de 	ldrh.w	r2, [r3, #1246]	; 0x4de
  410214:	883b      	ldrh	r3, [r7, #0]
  410216:	4293      	cmp	r3, r2
  410218:	bf28      	it	cs
  41021a:	4613      	movcs	r3, r2
  41021c:	803b      	strh	r3, [r7, #0]
  41021e:	210f      	movs	r1, #15
  410220:	6878      	ldr	r0, [r7, #4]
  410222:	4b99      	ldr	r3, [pc, #612]	; (410488 <inv_icm20948_augmented_sensors_set_odr+0x334>)
  410224:	4798      	blx	r3
  410226:	4603      	mov	r3, r0
  410228:	2b00      	cmp	r3, #0
  41022a:	d007      	beq.n	41023c <inv_icm20948_augmented_sensors_set_odr+0xe8>
  41022c:	687b      	ldr	r3, [r7, #4]
  41022e:	f8b3 24e0 	ldrh.w	r2, [r3, #1248]	; 0x4e0
  410232:	883b      	ldrh	r3, [r7, #0]
  410234:	4293      	cmp	r3, r2
  410236:	bf28      	it	cs
  410238:	4613      	movcs	r3, r2
  41023a:	803b      	strh	r3, [r7, #0]
  41023c:	210a      	movs	r1, #10
  41023e:	6878      	ldr	r0, [r7, #4]
  410240:	4b91      	ldr	r3, [pc, #580]	; (410488 <inv_icm20948_augmented_sensors_set_odr+0x334>)
  410242:	4798      	blx	r3
  410244:	4603      	mov	r3, r0
  410246:	2b00      	cmp	r3, #0
  410248:	f000 819a 	beq.w	410580 <inv_icm20948_augmented_sensors_set_odr+0x42c>
  41024c:	687b      	ldr	r3, [r7, #4]
  41024e:	f8b3 24e2 	ldrh.w	r2, [r3, #1250]	; 0x4e2
  410252:	883b      	ldrh	r3, [r7, #0]
  410254:	4293      	cmp	r3, r2
  410256:	bf28      	it	cs
  410258:	4613      	movcs	r3, r2
  41025a:	803b      	strh	r3, [r7, #0]
			break;
  41025c:	e190      	b.n	410580 <inv_icm20948_augmented_sensors_set_odr+0x42c>
        case ANDROID_SENSOR_GAME_ROTATION_VECTOR:
			s->sGrvOdrMs = delayInMs;
  41025e:	687b      	ldr	r3, [r7, #4]
  410260:	883a      	ldrh	r2, [r7, #0]
  410262:	f8a3 24e0 	strh.w	r2, [r3, #1248]	; 0x4e0
			AUGMENTED_SENSOR_GET_6QUAT_MIN_ODR(s, delayInMs);
  410266:	2109      	movs	r1, #9
  410268:	6878      	ldr	r0, [r7, #4]
  41026a:	4b87      	ldr	r3, [pc, #540]	; (410488 <inv_icm20948_augmented_sensors_set_odr+0x334>)
  41026c:	4798      	blx	r3
  41026e:	4603      	mov	r3, r0
  410270:	2b00      	cmp	r3, #0
  410272:	d007      	beq.n	410284 <inv_icm20948_augmented_sensors_set_odr+0x130>
  410274:	687b      	ldr	r3, [r7, #4]
  410276:	f8b3 24de 	ldrh.w	r2, [r3, #1246]	; 0x4de
  41027a:	883b      	ldrh	r3, [r7, #0]
  41027c:	4293      	cmp	r3, r2
  41027e:	bf28      	it	cs
  410280:	4613      	movcs	r3, r2
  410282:	803b      	strh	r3, [r7, #0]
  410284:	210f      	movs	r1, #15
  410286:	6878      	ldr	r0, [r7, #4]
  410288:	4b7f      	ldr	r3, [pc, #508]	; (410488 <inv_icm20948_augmented_sensors_set_odr+0x334>)
  41028a:	4798      	blx	r3
  41028c:	4603      	mov	r3, r0
  41028e:	2b00      	cmp	r3, #0
  410290:	d007      	beq.n	4102a2 <inv_icm20948_augmented_sensors_set_odr+0x14e>
  410292:	687b      	ldr	r3, [r7, #4]
  410294:	f8b3 24e0 	ldrh.w	r2, [r3, #1248]	; 0x4e0
  410298:	883b      	ldrh	r3, [r7, #0]
  41029a:	4293      	cmp	r3, r2
  41029c:	bf28      	it	cs
  41029e:	4613      	movcs	r3, r2
  4102a0:	803b      	strh	r3, [r7, #0]
  4102a2:	210a      	movs	r1, #10
  4102a4:	6878      	ldr	r0, [r7, #4]
  4102a6:	4b78      	ldr	r3, [pc, #480]	; (410488 <inv_icm20948_augmented_sensors_set_odr+0x334>)
  4102a8:	4798      	blx	r3
  4102aa:	4603      	mov	r3, r0
  4102ac:	2b00      	cmp	r3, #0
  4102ae:	f000 8169 	beq.w	410584 <inv_icm20948_augmented_sensors_set_odr+0x430>
  4102b2:	687b      	ldr	r3, [r7, #4]
  4102b4:	f8b3 24e2 	ldrh.w	r2, [r3, #1250]	; 0x4e2
  4102b8:	883b      	ldrh	r3, [r7, #0]
  4102ba:	4293      	cmp	r3, r2
  4102bc:	bf28      	it	cs
  4102be:	4613      	movcs	r3, r2
  4102c0:	803b      	strh	r3, [r7, #0]
			break;
  4102c2:	e15f      	b.n	410584 <inv_icm20948_augmented_sensors_set_odr+0x430>
        case ANDROID_SENSOR_LINEAR_ACCELERATION:
			s->sLinAccOdrMs = delayInMs;
  4102c4:	687b      	ldr	r3, [r7, #4]
  4102c6:	883a      	ldrh	r2, [r7, #0]
  4102c8:	f8a3 24e2 	strh.w	r2, [r3, #1250]	; 0x4e2
			AUGMENTED_SENSOR_GET_6QUAT_MIN_ODR(s, delayInMs);
  4102cc:	2109      	movs	r1, #9
  4102ce:	6878      	ldr	r0, [r7, #4]
  4102d0:	4b6d      	ldr	r3, [pc, #436]	; (410488 <inv_icm20948_augmented_sensors_set_odr+0x334>)
  4102d2:	4798      	blx	r3
  4102d4:	4603      	mov	r3, r0
  4102d6:	2b00      	cmp	r3, #0
  4102d8:	d007      	beq.n	4102ea <inv_icm20948_augmented_sensors_set_odr+0x196>
  4102da:	687b      	ldr	r3, [r7, #4]
  4102dc:	f8b3 24de 	ldrh.w	r2, [r3, #1246]	; 0x4de
  4102e0:	883b      	ldrh	r3, [r7, #0]
  4102e2:	4293      	cmp	r3, r2
  4102e4:	bf28      	it	cs
  4102e6:	4613      	movcs	r3, r2
  4102e8:	803b      	strh	r3, [r7, #0]
  4102ea:	210f      	movs	r1, #15
  4102ec:	6878      	ldr	r0, [r7, #4]
  4102ee:	4b66      	ldr	r3, [pc, #408]	; (410488 <inv_icm20948_augmented_sensors_set_odr+0x334>)
  4102f0:	4798      	blx	r3
  4102f2:	4603      	mov	r3, r0
  4102f4:	2b00      	cmp	r3, #0
  4102f6:	d007      	beq.n	410308 <inv_icm20948_augmented_sensors_set_odr+0x1b4>
  4102f8:	687b      	ldr	r3, [r7, #4]
  4102fa:	f8b3 24e0 	ldrh.w	r2, [r3, #1248]	; 0x4e0
  4102fe:	883b      	ldrh	r3, [r7, #0]
  410300:	4293      	cmp	r3, r2
  410302:	bf28      	it	cs
  410304:	4613      	movcs	r3, r2
  410306:	803b      	strh	r3, [r7, #0]
  410308:	210a      	movs	r1, #10
  41030a:	6878      	ldr	r0, [r7, #4]
  41030c:	4b5e      	ldr	r3, [pc, #376]	; (410488 <inv_icm20948_augmented_sensors_set_odr+0x334>)
  41030e:	4798      	blx	r3
  410310:	4603      	mov	r3, r0
  410312:	2b00      	cmp	r3, #0
  410314:	f000 8138 	beq.w	410588 <inv_icm20948_augmented_sensors_set_odr+0x434>
  410318:	687b      	ldr	r3, [r7, #4]
  41031a:	f8b3 24e2 	ldrh.w	r2, [r3, #1250]	; 0x4e2
  41031e:	883b      	ldrh	r3, [r7, #0]
  410320:	4293      	cmp	r3, r2
  410322:	bf28      	it	cs
  410324:	4613      	movcs	r3, r2
  410326:	803b      	strh	r3, [r7, #0]
			break;
  410328:	e12e      	b.n	410588 <inv_icm20948_augmented_sensors_set_odr+0x434>
        case ANDROID_SENSOR_ORIENTATION:
			s->sOriOdrMs = delayInMs;
  41032a:	687b      	ldr	r3, [r7, #4]
  41032c:	883a      	ldrh	r2, [r7, #0]
  41032e:	f8a3 24ec 	strh.w	r2, [r3, #1260]	; 0x4ec
			AUGMENTED_SENSOR_GET_9QUAT_MIN_ODR(s, delayInMs);
  410332:	2103      	movs	r1, #3
  410334:	6878      	ldr	r0, [r7, #4]
  410336:	4b54      	ldr	r3, [pc, #336]	; (410488 <inv_icm20948_augmented_sensors_set_odr+0x334>)
  410338:	4798      	blx	r3
  41033a:	4603      	mov	r3, r0
  41033c:	2b00      	cmp	r3, #0
  41033e:	d007      	beq.n	410350 <inv_icm20948_augmented_sensors_set_odr+0x1fc>
  410340:	687b      	ldr	r3, [r7, #4]
  410342:	f8b3 24ec 	ldrh.w	r2, [r3, #1260]	; 0x4ec
  410346:	883b      	ldrh	r3, [r7, #0]
  410348:	4293      	cmp	r3, r2
  41034a:	bf28      	it	cs
  41034c:	4613      	movcs	r3, r2
  41034e:	803b      	strh	r3, [r7, #0]
  410350:	210b      	movs	r1, #11
  410352:	6878      	ldr	r0, [r7, #4]
  410354:	4b4c      	ldr	r3, [pc, #304]	; (410488 <inv_icm20948_augmented_sensors_set_odr+0x334>)
  410356:	4798      	blx	r3
  410358:	4603      	mov	r3, r0
  41035a:	2b00      	cmp	r3, #0
  41035c:	f000 8116 	beq.w	41058c <inv_icm20948_augmented_sensors_set_odr+0x438>
  410360:	687b      	ldr	r3, [r7, #4]
  410362:	f8b3 24ea 	ldrh.w	r2, [r3, #1258]	; 0x4ea
  410366:	883b      	ldrh	r3, [r7, #0]
  410368:	4293      	cmp	r3, r2
  41036a:	bf28      	it	cs
  41036c:	4613      	movcs	r3, r2
  41036e:	803b      	strh	r3, [r7, #0]
			break;
  410370:	e10c      	b.n	41058c <inv_icm20948_augmented_sensors_set_odr+0x438>
        case ANDROID_SENSOR_ROTATION_VECTOR:
			s->sRvOdrMs = delayInMs;
  410372:	687b      	ldr	r3, [r7, #4]
  410374:	883a      	ldrh	r2, [r7, #0]
  410376:	f8a3 24ea 	strh.w	r2, [r3, #1258]	; 0x4ea
			AUGMENTED_SENSOR_GET_9QUAT_MIN_ODR(s, delayInMs);
  41037a:	2103      	movs	r1, #3
  41037c:	6878      	ldr	r0, [r7, #4]
  41037e:	4b42      	ldr	r3, [pc, #264]	; (410488 <inv_icm20948_augmented_sensors_set_odr+0x334>)
  410380:	4798      	blx	r3
  410382:	4603      	mov	r3, r0
  410384:	2b00      	cmp	r3, #0
  410386:	d007      	beq.n	410398 <inv_icm20948_augmented_sensors_set_odr+0x244>
  410388:	687b      	ldr	r3, [r7, #4]
  41038a:	f8b3 24ec 	ldrh.w	r2, [r3, #1260]	; 0x4ec
  41038e:	883b      	ldrh	r3, [r7, #0]
  410390:	4293      	cmp	r3, r2
  410392:	bf28      	it	cs
  410394:	4613      	movcs	r3, r2
  410396:	803b      	strh	r3, [r7, #0]
  410398:	210b      	movs	r1, #11
  41039a:	6878      	ldr	r0, [r7, #4]
  41039c:	4b3a      	ldr	r3, [pc, #232]	; (410488 <inv_icm20948_augmented_sensors_set_odr+0x334>)
  41039e:	4798      	blx	r3
  4103a0:	4603      	mov	r3, r0
  4103a2:	2b00      	cmp	r3, #0
  4103a4:	f000 80f4 	beq.w	410590 <inv_icm20948_augmented_sensors_set_odr+0x43c>
  4103a8:	687b      	ldr	r3, [r7, #4]
  4103aa:	f8b3 24ea 	ldrh.w	r2, [r3, #1258]	; 0x4ea
  4103ae:	883b      	ldrh	r3, [r7, #0]
  4103b0:	4293      	cmp	r3, r2
  4103b2:	bf28      	it	cs
  4103b4:	4613      	movcs	r3, r2
  4103b6:	803b      	strh	r3, [r7, #0]
			break;
  4103b8:	e0ea      	b.n	410590 <inv_icm20948_augmented_sensors_set_odr+0x43c>
		case ANDROID_SENSOR_WAKEUP_GRAVITY:
			s->sGravityWuOdrMs = delayInMs;
  4103ba:	687b      	ldr	r3, [r7, #4]
  4103bc:	883a      	ldrh	r2, [r7, #0]
  4103be:	f8a3 24e4 	strh.w	r2, [r3, #1252]	; 0x4e4
			AUGMENTED_SENSOR_GET_6QUATWU_MIN_ODR(s, delayInMs);
  4103c2:	211d      	movs	r1, #29
  4103c4:	6878      	ldr	r0, [r7, #4]
  4103c6:	4b30      	ldr	r3, [pc, #192]	; (410488 <inv_icm20948_augmented_sensors_set_odr+0x334>)
  4103c8:	4798      	blx	r3
  4103ca:	4603      	mov	r3, r0
  4103cc:	2b00      	cmp	r3, #0
  4103ce:	d007      	beq.n	4103e0 <inv_icm20948_augmented_sensors_set_odr+0x28c>
  4103d0:	687b      	ldr	r3, [r7, #4]
  4103d2:	f8b3 24e4 	ldrh.w	r2, [r3, #1252]	; 0x4e4
  4103d6:	883b      	ldrh	r3, [r7, #0]
  4103d8:	4293      	cmp	r3, r2
  4103da:	bf28      	it	cs
  4103dc:	4613      	movcs	r3, r2
  4103de:	803b      	strh	r3, [r7, #0]
  4103e0:	2123      	movs	r1, #35	; 0x23
  4103e2:	6878      	ldr	r0, [r7, #4]
  4103e4:	4b28      	ldr	r3, [pc, #160]	; (410488 <inv_icm20948_augmented_sensors_set_odr+0x334>)
  4103e6:	4798      	blx	r3
  4103e8:	4603      	mov	r3, r0
  4103ea:	2b00      	cmp	r3, #0
  4103ec:	d007      	beq.n	4103fe <inv_icm20948_augmented_sensors_set_odr+0x2aa>
  4103ee:	687b      	ldr	r3, [r7, #4]
  4103f0:	f8b3 24e6 	ldrh.w	r2, [r3, #1254]	; 0x4e6
  4103f4:	883b      	ldrh	r3, [r7, #0]
  4103f6:	4293      	cmp	r3, r2
  4103f8:	bf28      	it	cs
  4103fa:	4613      	movcs	r3, r2
  4103fc:	803b      	strh	r3, [r7, #0]
  4103fe:	211e      	movs	r1, #30
  410400:	6878      	ldr	r0, [r7, #4]
  410402:	4b21      	ldr	r3, [pc, #132]	; (410488 <inv_icm20948_augmented_sensors_set_odr+0x334>)
  410404:	4798      	blx	r3
  410406:	4603      	mov	r3, r0
  410408:	2b00      	cmp	r3, #0
  41040a:	f000 80c3 	beq.w	410594 <inv_icm20948_augmented_sensors_set_odr+0x440>
  41040e:	687b      	ldr	r3, [r7, #4]
  410410:	f8b3 24e8 	ldrh.w	r2, [r3, #1256]	; 0x4e8
  410414:	883b      	ldrh	r3, [r7, #0]
  410416:	4293      	cmp	r3, r2
  410418:	bf28      	it	cs
  41041a:	4613      	movcs	r3, r2
  41041c:	803b      	strh	r3, [r7, #0]
			break;
  41041e:	e0b9      	b.n	410594 <inv_icm20948_augmented_sensors_set_odr+0x440>
        case ANDROID_SENSOR_WAKEUP_GAME_ROTATION_VECTOR:
			s->sGrvWuOdrMs = delayInMs;
  410420:	687b      	ldr	r3, [r7, #4]
  410422:	883a      	ldrh	r2, [r7, #0]
  410424:	f8a3 24e6 	strh.w	r2, [r3, #1254]	; 0x4e6
			AUGMENTED_SENSOR_GET_6QUATWU_MIN_ODR(s, delayInMs);
  410428:	211d      	movs	r1, #29
  41042a:	6878      	ldr	r0, [r7, #4]
  41042c:	4b16      	ldr	r3, [pc, #88]	; (410488 <inv_icm20948_augmented_sensors_set_odr+0x334>)
  41042e:	4798      	blx	r3
  410430:	4603      	mov	r3, r0
  410432:	2b00      	cmp	r3, #0
  410434:	d007      	beq.n	410446 <inv_icm20948_augmented_sensors_set_odr+0x2f2>
  410436:	687b      	ldr	r3, [r7, #4]
  410438:	f8b3 24e4 	ldrh.w	r2, [r3, #1252]	; 0x4e4
  41043c:	883b      	ldrh	r3, [r7, #0]
  41043e:	4293      	cmp	r3, r2
  410440:	bf28      	it	cs
  410442:	4613      	movcs	r3, r2
  410444:	803b      	strh	r3, [r7, #0]
  410446:	2123      	movs	r1, #35	; 0x23
  410448:	6878      	ldr	r0, [r7, #4]
  41044a:	4b0f      	ldr	r3, [pc, #60]	; (410488 <inv_icm20948_augmented_sensors_set_odr+0x334>)
  41044c:	4798      	blx	r3
  41044e:	4603      	mov	r3, r0
  410450:	2b00      	cmp	r3, #0
  410452:	d007      	beq.n	410464 <inv_icm20948_augmented_sensors_set_odr+0x310>
  410454:	687b      	ldr	r3, [r7, #4]
  410456:	f8b3 24e6 	ldrh.w	r2, [r3, #1254]	; 0x4e6
  41045a:	883b      	ldrh	r3, [r7, #0]
  41045c:	4293      	cmp	r3, r2
  41045e:	bf28      	it	cs
  410460:	4613      	movcs	r3, r2
  410462:	803b      	strh	r3, [r7, #0]
  410464:	211e      	movs	r1, #30
  410466:	6878      	ldr	r0, [r7, #4]
  410468:	4b07      	ldr	r3, [pc, #28]	; (410488 <inv_icm20948_augmented_sensors_set_odr+0x334>)
  41046a:	4798      	blx	r3
  41046c:	4603      	mov	r3, r0
  41046e:	2b00      	cmp	r3, #0
  410470:	f000 8092 	beq.w	410598 <inv_icm20948_augmented_sensors_set_odr+0x444>
  410474:	687b      	ldr	r3, [r7, #4]
  410476:	f8b3 24e8 	ldrh.w	r2, [r3, #1256]	; 0x4e8
  41047a:	883b      	ldrh	r3, [r7, #0]
  41047c:	4293      	cmp	r3, r2
  41047e:	bf28      	it	cs
  410480:	4613      	movcs	r3, r2
  410482:	803b      	strh	r3, [r7, #0]
			break;
  410484:	e088      	b.n	410598 <inv_icm20948_augmented_sensors_set_odr+0x444>
  410486:	bf00      	nop
  410488:	004107b9 	.word	0x004107b9
        case ANDROID_SENSOR_WAKEUP_LINEAR_ACCELERATION:
			s->sLinAccWuOdrMs = delayInMs;
  41048c:	687b      	ldr	r3, [r7, #4]
  41048e:	883a      	ldrh	r2, [r7, #0]
  410490:	f8a3 24e8 	strh.w	r2, [r3, #1256]	; 0x4e8
			AUGMENTED_SENSOR_GET_6QUATWU_MIN_ODR(s, delayInMs);
  410494:	211d      	movs	r1, #29
  410496:	6878      	ldr	r0, [r7, #4]
  410498:	4b45      	ldr	r3, [pc, #276]	; (4105b0 <inv_icm20948_augmented_sensors_set_odr+0x45c>)
  41049a:	4798      	blx	r3
  41049c:	4603      	mov	r3, r0
  41049e:	2b00      	cmp	r3, #0
  4104a0:	d007      	beq.n	4104b2 <inv_icm20948_augmented_sensors_set_odr+0x35e>
  4104a2:	687b      	ldr	r3, [r7, #4]
  4104a4:	f8b3 24e4 	ldrh.w	r2, [r3, #1252]	; 0x4e4
  4104a8:	883b      	ldrh	r3, [r7, #0]
  4104aa:	4293      	cmp	r3, r2
  4104ac:	bf28      	it	cs
  4104ae:	4613      	movcs	r3, r2
  4104b0:	803b      	strh	r3, [r7, #0]
  4104b2:	2123      	movs	r1, #35	; 0x23
  4104b4:	6878      	ldr	r0, [r7, #4]
  4104b6:	4b3e      	ldr	r3, [pc, #248]	; (4105b0 <inv_icm20948_augmented_sensors_set_odr+0x45c>)
  4104b8:	4798      	blx	r3
  4104ba:	4603      	mov	r3, r0
  4104bc:	2b00      	cmp	r3, #0
  4104be:	d007      	beq.n	4104d0 <inv_icm20948_augmented_sensors_set_odr+0x37c>
  4104c0:	687b      	ldr	r3, [r7, #4]
  4104c2:	f8b3 24e6 	ldrh.w	r2, [r3, #1254]	; 0x4e6
  4104c6:	883b      	ldrh	r3, [r7, #0]
  4104c8:	4293      	cmp	r3, r2
  4104ca:	bf28      	it	cs
  4104cc:	4613      	movcs	r3, r2
  4104ce:	803b      	strh	r3, [r7, #0]
  4104d0:	211e      	movs	r1, #30
  4104d2:	6878      	ldr	r0, [r7, #4]
  4104d4:	4b36      	ldr	r3, [pc, #216]	; (4105b0 <inv_icm20948_augmented_sensors_set_odr+0x45c>)
  4104d6:	4798      	blx	r3
  4104d8:	4603      	mov	r3, r0
  4104da:	2b00      	cmp	r3, #0
  4104dc:	d05e      	beq.n	41059c <inv_icm20948_augmented_sensors_set_odr+0x448>
  4104de:	687b      	ldr	r3, [r7, #4]
  4104e0:	f8b3 24e8 	ldrh.w	r2, [r3, #1256]	; 0x4e8
  4104e4:	883b      	ldrh	r3, [r7, #0]
  4104e6:	4293      	cmp	r3, r2
  4104e8:	bf28      	it	cs
  4104ea:	4613      	movcs	r3, r2
  4104ec:	803b      	strh	r3, [r7, #0]
			break;
  4104ee:	e055      	b.n	41059c <inv_icm20948_augmented_sensors_set_odr+0x448>
        case ANDROID_SENSOR_WAKEUP_ORIENTATION:
			s->sOriWuOdrMs = delayInMs;
  4104f0:	687b      	ldr	r3, [r7, #4]
  4104f2:	883a      	ldrh	r2, [r7, #0]
  4104f4:	f8a3 24f0 	strh.w	r2, [r3, #1264]	; 0x4f0
			AUGMENTED_SENSOR_GET_9QUATWU_MIN_ODR(s, delayInMs);
  4104f8:	2119      	movs	r1, #25
  4104fa:	6878      	ldr	r0, [r7, #4]
  4104fc:	4b2c      	ldr	r3, [pc, #176]	; (4105b0 <inv_icm20948_augmented_sensors_set_odr+0x45c>)
  4104fe:	4798      	blx	r3
  410500:	4603      	mov	r3, r0
  410502:	2b00      	cmp	r3, #0
  410504:	d007      	beq.n	410516 <inv_icm20948_augmented_sensors_set_odr+0x3c2>
  410506:	687b      	ldr	r3, [r7, #4]
  410508:	f8b3 24f0 	ldrh.w	r2, [r3, #1264]	; 0x4f0
  41050c:	883b      	ldrh	r3, [r7, #0]
  41050e:	4293      	cmp	r3, r2
  410510:	bf28      	it	cs
  410512:	4613      	movcs	r3, r2
  410514:	803b      	strh	r3, [r7, #0]
  410516:	211f      	movs	r1, #31
  410518:	6878      	ldr	r0, [r7, #4]
  41051a:	4b25      	ldr	r3, [pc, #148]	; (4105b0 <inv_icm20948_augmented_sensors_set_odr+0x45c>)
  41051c:	4798      	blx	r3
  41051e:	4603      	mov	r3, r0
  410520:	2b00      	cmp	r3, #0
  410522:	d03d      	beq.n	4105a0 <inv_icm20948_augmented_sensors_set_odr+0x44c>
  410524:	687b      	ldr	r3, [r7, #4]
  410526:	f8b3 24ee 	ldrh.w	r2, [r3, #1262]	; 0x4ee
  41052a:	883b      	ldrh	r3, [r7, #0]
  41052c:	4293      	cmp	r3, r2
  41052e:	bf28      	it	cs
  410530:	4613      	movcs	r3, r2
  410532:	803b      	strh	r3, [r7, #0]
			break;
  410534:	e034      	b.n	4105a0 <inv_icm20948_augmented_sensors_set_odr+0x44c>
        case ANDROID_SENSOR_WAKEUP_ROTATION_VECTOR:
			s->sRvWuOdrMs = delayInMs;
  410536:	687b      	ldr	r3, [r7, #4]
  410538:	883a      	ldrh	r2, [r7, #0]
  41053a:	f8a3 24ee 	strh.w	r2, [r3, #1262]	; 0x4ee
			AUGMENTED_SENSOR_GET_9QUATWU_MIN_ODR(s, delayInMs);
  41053e:	2119      	movs	r1, #25
  410540:	6878      	ldr	r0, [r7, #4]
  410542:	4b1b      	ldr	r3, [pc, #108]	; (4105b0 <inv_icm20948_augmented_sensors_set_odr+0x45c>)
  410544:	4798      	blx	r3
  410546:	4603      	mov	r3, r0
  410548:	2b00      	cmp	r3, #0
  41054a:	d007      	beq.n	41055c <inv_icm20948_augmented_sensors_set_odr+0x408>
  41054c:	687b      	ldr	r3, [r7, #4]
  41054e:	f8b3 24f0 	ldrh.w	r2, [r3, #1264]	; 0x4f0
  410552:	883b      	ldrh	r3, [r7, #0]
  410554:	4293      	cmp	r3, r2
  410556:	bf28      	it	cs
  410558:	4613      	movcs	r3, r2
  41055a:	803b      	strh	r3, [r7, #0]
  41055c:	211f      	movs	r1, #31
  41055e:	6878      	ldr	r0, [r7, #4]
  410560:	4b13      	ldr	r3, [pc, #76]	; (4105b0 <inv_icm20948_augmented_sensors_set_odr+0x45c>)
  410562:	4798      	blx	r3
  410564:	4603      	mov	r3, r0
  410566:	2b00      	cmp	r3, #0
  410568:	d01c      	beq.n	4105a4 <inv_icm20948_augmented_sensors_set_odr+0x450>
  41056a:	687b      	ldr	r3, [r7, #4]
  41056c:	f8b3 24ee 	ldrh.w	r2, [r3, #1262]	; 0x4ee
  410570:	883b      	ldrh	r3, [r7, #0]
  410572:	4293      	cmp	r3, r2
  410574:	bf28      	it	cs
  410576:	4613      	movcs	r3, r2
  410578:	803b      	strh	r3, [r7, #0]
			break;
  41057a:	e013      	b.n	4105a4 <inv_icm20948_augmented_sensors_set_odr+0x450>
		default :
			break;
  41057c:	bf00      	nop
  41057e:	e012      	b.n	4105a6 <inv_icm20948_augmented_sensors_set_odr+0x452>
			break;
  410580:	bf00      	nop
  410582:	e010      	b.n	4105a6 <inv_icm20948_augmented_sensors_set_odr+0x452>
			break;
  410584:	bf00      	nop
  410586:	e00e      	b.n	4105a6 <inv_icm20948_augmented_sensors_set_odr+0x452>
			break;
  410588:	bf00      	nop
  41058a:	e00c      	b.n	4105a6 <inv_icm20948_augmented_sensors_set_odr+0x452>
			break;
  41058c:	bf00      	nop
  41058e:	e00a      	b.n	4105a6 <inv_icm20948_augmented_sensors_set_odr+0x452>
			break;
  410590:	bf00      	nop
  410592:	e008      	b.n	4105a6 <inv_icm20948_augmented_sensors_set_odr+0x452>
			break;
  410594:	bf00      	nop
  410596:	e006      	b.n	4105a6 <inv_icm20948_augmented_sensors_set_odr+0x452>
			break;
  410598:	bf00      	nop
  41059a:	e004      	b.n	4105a6 <inv_icm20948_augmented_sensors_set_odr+0x452>
			break;
  41059c:	bf00      	nop
  41059e:	e002      	b.n	4105a6 <inv_icm20948_augmented_sensors_set_odr+0x452>
			break;
  4105a0:	bf00      	nop
  4105a2:	e000      	b.n	4105a6 <inv_icm20948_augmented_sensors_set_odr+0x452>
			break;
  4105a4:	bf00      	nop
	}

	return delayInMs;
  4105a6:	883b      	ldrh	r3, [r7, #0]
}
  4105a8:	4618      	mov	r0, r3
  4105aa:	3708      	adds	r7, #8
  4105ac:	46bd      	mov	sp, r7
  4105ae:	bd80      	pop	{r7, pc}
  4105b0:	004107b9 	.word	0x004107b9

004105b4 <inv_icm20948_augmented_sensors_update_odr>:


void inv_icm20948_augmented_sensors_update_odr(struct inv_icm20948 * s, unsigned char androidSensor, unsigned short * updatedDelayPtr)
{
  4105b4:	b580      	push	{r7, lr}
  4105b6:	b086      	sub	sp, #24
  4105b8:	af00      	add	r7, sp, #0
  4105ba:	60f8      	str	r0, [r7, #12]
  4105bc:	460b      	mov	r3, r1
  4105be:	607a      	str	r2, [r7, #4]
  4105c0:	72fb      	strb	r3, [r7, #11]
	unsigned short lDelayInMs = 0xFFFF; // max value of uint16_t, so that we can get min value of all enabled sensors
  4105c2:	f64f 73ff 	movw	r3, #65535	; 0xffff
  4105c6:	82fb      	strh	r3, [r7, #22]
	switch(androidSensor)
  4105c8:	7afb      	ldrb	r3, [r7, #11]
  4105ca:	3b03      	subs	r3, #3
  4105cc:	2b20      	cmp	r3, #32
  4105ce:	f200 80eb 	bhi.w	4107a8 <inv_icm20948_augmented_sensors_update_odr+0x1f4>
  4105d2:	a201      	add	r2, pc, #4	; (adr r2, 4105d8 <inv_icm20948_augmented_sensors_update_odr+0x24>)
  4105d4:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
  4105d8:	00410721 	.word	0x00410721
  4105dc:	004107a9 	.word	0x004107a9
  4105e0:	004107a9 	.word	0x004107a9
  4105e4:	004107a9 	.word	0x004107a9
  4105e8:	004107a9 	.word	0x004107a9
  4105ec:	004107a9 	.word	0x004107a9
  4105f0:	0041065d 	.word	0x0041065d
  4105f4:	0041065d 	.word	0x0041065d
  4105f8:	00410721 	.word	0x00410721
  4105fc:	004107a9 	.word	0x004107a9
  410600:	004107a9 	.word	0x004107a9
  410604:	004107a9 	.word	0x004107a9
  410608:	0041065d 	.word	0x0041065d
  41060c:	004107a9 	.word	0x004107a9
  410610:	004107a9 	.word	0x004107a9
  410614:	004107a9 	.word	0x004107a9
  410618:	004107a9 	.word	0x004107a9
  41061c:	004107a9 	.word	0x004107a9
  410620:	004107a9 	.word	0x004107a9
  410624:	004107a9 	.word	0x004107a9
  410628:	004107a9 	.word	0x004107a9
  41062c:	004107a9 	.word	0x004107a9
  410630:	00410765 	.word	0x00410765
  410634:	004107a9 	.word	0x004107a9
  410638:	004107a9 	.word	0x004107a9
  41063c:	004107a9 	.word	0x004107a9
  410640:	004106bf 	.word	0x004106bf
  410644:	004106bf 	.word	0x004106bf
  410648:	00410765 	.word	0x00410765
  41064c:	004107a9 	.word	0x004107a9
  410650:	004107a9 	.word	0x004107a9
  410654:	004107a9 	.word	0x004107a9
  410658:	004106bf 	.word	0x004106bf
	{
		case ANDROID_SENSOR_GRAVITY:
        case ANDROID_SENSOR_GAME_ROTATION_VECTOR:
        case ANDROID_SENSOR_LINEAR_ACCELERATION:
			AUGMENTED_SENSOR_GET_6QUAT_MIN_ODR(s, lDelayInMs);
  41065c:	2109      	movs	r1, #9
  41065e:	68f8      	ldr	r0, [r7, #12]
  410660:	4b54      	ldr	r3, [pc, #336]	; (4107b4 <inv_icm20948_augmented_sensors_update_odr+0x200>)
  410662:	4798      	blx	r3
  410664:	4603      	mov	r3, r0
  410666:	2b00      	cmp	r3, #0
  410668:	d007      	beq.n	41067a <inv_icm20948_augmented_sensors_update_odr+0xc6>
  41066a:	68fb      	ldr	r3, [r7, #12]
  41066c:	f8b3 24de 	ldrh.w	r2, [r3, #1246]	; 0x4de
  410670:	8afb      	ldrh	r3, [r7, #22]
  410672:	4293      	cmp	r3, r2
  410674:	bf28      	it	cs
  410676:	4613      	movcs	r3, r2
  410678:	82fb      	strh	r3, [r7, #22]
  41067a:	210f      	movs	r1, #15
  41067c:	68f8      	ldr	r0, [r7, #12]
  41067e:	4b4d      	ldr	r3, [pc, #308]	; (4107b4 <inv_icm20948_augmented_sensors_update_odr+0x200>)
  410680:	4798      	blx	r3
  410682:	4603      	mov	r3, r0
  410684:	2b00      	cmp	r3, #0
  410686:	d007      	beq.n	410698 <inv_icm20948_augmented_sensors_update_odr+0xe4>
  410688:	68fb      	ldr	r3, [r7, #12]
  41068a:	f8b3 24e0 	ldrh.w	r2, [r3, #1248]	; 0x4e0
  41068e:	8afb      	ldrh	r3, [r7, #22]
  410690:	4293      	cmp	r3, r2
  410692:	bf28      	it	cs
  410694:	4613      	movcs	r3, r2
  410696:	82fb      	strh	r3, [r7, #22]
  410698:	210a      	movs	r1, #10
  41069a:	68f8      	ldr	r0, [r7, #12]
  41069c:	4b45      	ldr	r3, [pc, #276]	; (4107b4 <inv_icm20948_augmented_sensors_update_odr+0x200>)
  41069e:	4798      	blx	r3
  4106a0:	4603      	mov	r3, r0
  4106a2:	2b00      	cmp	r3, #0
  4106a4:	d007      	beq.n	4106b6 <inv_icm20948_augmented_sensors_update_odr+0x102>
  4106a6:	68fb      	ldr	r3, [r7, #12]
  4106a8:	f8b3 24e2 	ldrh.w	r2, [r3, #1250]	; 0x4e2
  4106ac:	8afb      	ldrh	r3, [r7, #22]
  4106ae:	4293      	cmp	r3, r2
  4106b0:	bf28      	it	cs
  4106b2:	4613      	movcs	r3, r2
  4106b4:	82fb      	strh	r3, [r7, #22]
			*updatedDelayPtr = lDelayInMs;
  4106b6:	687b      	ldr	r3, [r7, #4]
  4106b8:	8afa      	ldrh	r2, [r7, #22]
  4106ba:	801a      	strh	r2, [r3, #0]
			break;
  4106bc:	e075      	b.n	4107aa <inv_icm20948_augmented_sensors_update_odr+0x1f6>
		case ANDROID_SENSOR_WAKEUP_GRAVITY:
        case ANDROID_SENSOR_WAKEUP_GAME_ROTATION_VECTOR:
        case ANDROID_SENSOR_WAKEUP_LINEAR_ACCELERATION:
			AUGMENTED_SENSOR_GET_6QUATWU_MIN_ODR(s, lDelayInMs);
  4106be:	211d      	movs	r1, #29
  4106c0:	68f8      	ldr	r0, [r7, #12]
  4106c2:	4b3c      	ldr	r3, [pc, #240]	; (4107b4 <inv_icm20948_augmented_sensors_update_odr+0x200>)
  4106c4:	4798      	blx	r3
  4106c6:	4603      	mov	r3, r0
  4106c8:	2b00      	cmp	r3, #0
  4106ca:	d007      	beq.n	4106dc <inv_icm20948_augmented_sensors_update_odr+0x128>
  4106cc:	68fb      	ldr	r3, [r7, #12]
  4106ce:	f8b3 24e4 	ldrh.w	r2, [r3, #1252]	; 0x4e4
  4106d2:	8afb      	ldrh	r3, [r7, #22]
  4106d4:	4293      	cmp	r3, r2
  4106d6:	bf28      	it	cs
  4106d8:	4613      	movcs	r3, r2
  4106da:	82fb      	strh	r3, [r7, #22]
  4106dc:	2123      	movs	r1, #35	; 0x23
  4106de:	68f8      	ldr	r0, [r7, #12]
  4106e0:	4b34      	ldr	r3, [pc, #208]	; (4107b4 <inv_icm20948_augmented_sensors_update_odr+0x200>)
  4106e2:	4798      	blx	r3
  4106e4:	4603      	mov	r3, r0
  4106e6:	2b00      	cmp	r3, #0
  4106e8:	d007      	beq.n	4106fa <inv_icm20948_augmented_sensors_update_odr+0x146>
  4106ea:	68fb      	ldr	r3, [r7, #12]
  4106ec:	f8b3 24e6 	ldrh.w	r2, [r3, #1254]	; 0x4e6
  4106f0:	8afb      	ldrh	r3, [r7, #22]
  4106f2:	4293      	cmp	r3, r2
  4106f4:	bf28      	it	cs
  4106f6:	4613      	movcs	r3, r2
  4106f8:	82fb      	strh	r3, [r7, #22]
  4106fa:	211e      	movs	r1, #30
  4106fc:	68f8      	ldr	r0, [r7, #12]
  4106fe:	4b2d      	ldr	r3, [pc, #180]	; (4107b4 <inv_icm20948_augmented_sensors_update_odr+0x200>)
  410700:	4798      	blx	r3
  410702:	4603      	mov	r3, r0
  410704:	2b00      	cmp	r3, #0
  410706:	d007      	beq.n	410718 <inv_icm20948_augmented_sensors_update_odr+0x164>
  410708:	68fb      	ldr	r3, [r7, #12]
  41070a:	f8b3 24e8 	ldrh.w	r2, [r3, #1256]	; 0x4e8
  41070e:	8afb      	ldrh	r3, [r7, #22]
  410710:	4293      	cmp	r3, r2
  410712:	bf28      	it	cs
  410714:	4613      	movcs	r3, r2
  410716:	82fb      	strh	r3, [r7, #22]
			*updatedDelayPtr = lDelayInMs;
  410718:	687b      	ldr	r3, [r7, #4]
  41071a:	8afa      	ldrh	r2, [r7, #22]
  41071c:	801a      	strh	r2, [r3, #0]
			break;
  41071e:	e044      	b.n	4107aa <inv_icm20948_augmented_sensors_update_odr+0x1f6>
		case ANDROID_SENSOR_ORIENTATION:
        case ANDROID_SENSOR_ROTATION_VECTOR:
			AUGMENTED_SENSOR_GET_9QUAT_MIN_ODR(s, lDelayInMs);
  410720:	2103      	movs	r1, #3
  410722:	68f8      	ldr	r0, [r7, #12]
  410724:	4b23      	ldr	r3, [pc, #140]	; (4107b4 <inv_icm20948_augmented_sensors_update_odr+0x200>)
  410726:	4798      	blx	r3
  410728:	4603      	mov	r3, r0
  41072a:	2b00      	cmp	r3, #0
  41072c:	d007      	beq.n	41073e <inv_icm20948_augmented_sensors_update_odr+0x18a>
  41072e:	68fb      	ldr	r3, [r7, #12]
  410730:	f8b3 24ec 	ldrh.w	r2, [r3, #1260]	; 0x4ec
  410734:	8afb      	ldrh	r3, [r7, #22]
  410736:	4293      	cmp	r3, r2
  410738:	bf28      	it	cs
  41073a:	4613      	movcs	r3, r2
  41073c:	82fb      	strh	r3, [r7, #22]
  41073e:	210b      	movs	r1, #11
  410740:	68f8      	ldr	r0, [r7, #12]
  410742:	4b1c      	ldr	r3, [pc, #112]	; (4107b4 <inv_icm20948_augmented_sensors_update_odr+0x200>)
  410744:	4798      	blx	r3
  410746:	4603      	mov	r3, r0
  410748:	2b00      	cmp	r3, #0
  41074a:	d007      	beq.n	41075c <inv_icm20948_augmented_sensors_update_odr+0x1a8>
  41074c:	68fb      	ldr	r3, [r7, #12]
  41074e:	f8b3 24ea 	ldrh.w	r2, [r3, #1258]	; 0x4ea
  410752:	8afb      	ldrh	r3, [r7, #22]
  410754:	4293      	cmp	r3, r2
  410756:	bf28      	it	cs
  410758:	4613      	movcs	r3, r2
  41075a:	82fb      	strh	r3, [r7, #22]
			*updatedDelayPtr = lDelayInMs;
  41075c:	687b      	ldr	r3, [r7, #4]
  41075e:	8afa      	ldrh	r2, [r7, #22]
  410760:	801a      	strh	r2, [r3, #0]
			break;
  410762:	e022      	b.n	4107aa <inv_icm20948_augmented_sensors_update_odr+0x1f6>
		case ANDROID_SENSOR_WAKEUP_ORIENTATION:
        case ANDROID_SENSOR_WAKEUP_ROTATION_VECTOR:
			AUGMENTED_SENSOR_GET_9QUATWU_MIN_ODR(s, lDelayInMs);
  410764:	2119      	movs	r1, #25
  410766:	68f8      	ldr	r0, [r7, #12]
  410768:	4b12      	ldr	r3, [pc, #72]	; (4107b4 <inv_icm20948_augmented_sensors_update_odr+0x200>)
  41076a:	4798      	blx	r3
  41076c:	4603      	mov	r3, r0
  41076e:	2b00      	cmp	r3, #0
  410770:	d007      	beq.n	410782 <inv_icm20948_augmented_sensors_update_odr+0x1ce>
  410772:	68fb      	ldr	r3, [r7, #12]
  410774:	f8b3 24f0 	ldrh.w	r2, [r3, #1264]	; 0x4f0
  410778:	8afb      	ldrh	r3, [r7, #22]
  41077a:	4293      	cmp	r3, r2
  41077c:	bf28      	it	cs
  41077e:	4613      	movcs	r3, r2
  410780:	82fb      	strh	r3, [r7, #22]
  410782:	211f      	movs	r1, #31
  410784:	68f8      	ldr	r0, [r7, #12]
  410786:	4b0b      	ldr	r3, [pc, #44]	; (4107b4 <inv_icm20948_augmented_sensors_update_odr+0x200>)
  410788:	4798      	blx	r3
  41078a:	4603      	mov	r3, r0
  41078c:	2b00      	cmp	r3, #0
  41078e:	d007      	beq.n	4107a0 <inv_icm20948_augmented_sensors_update_odr+0x1ec>
  410790:	68fb      	ldr	r3, [r7, #12]
  410792:	f8b3 24ee 	ldrh.w	r2, [r3, #1262]	; 0x4ee
  410796:	8afb      	ldrh	r3, [r7, #22]
  410798:	4293      	cmp	r3, r2
  41079a:	bf28      	it	cs
  41079c:	4613      	movcs	r3, r2
  41079e:	82fb      	strh	r3, [r7, #22]
			*updatedDelayPtr = lDelayInMs;
  4107a0:	687b      	ldr	r3, [r7, #4]
  4107a2:	8afa      	ldrh	r2, [r7, #22]
  4107a4:	801a      	strh	r2, [r3, #0]
			break;
  4107a6:	e000      	b.n	4107aa <inv_icm20948_augmented_sensors_update_odr+0x1f6>
		default :
			break;
  4107a8:	bf00      	nop
	}

}
  4107aa:	bf00      	nop
  4107ac:	3718      	adds	r7, #24
  4107ae:	46bd      	mov	sp, r7
  4107b0:	bd80      	pop	{r7, pc}
  4107b2:	bf00      	nop
  4107b4:	004107b9 	.word	0x004107b9

004107b8 <inv_icm20948_ctrl_androidSensor_enabled>:
static int inv_set_hw_smplrt_dmp_odrs(struct inv_icm20948 * s);
static void inv_reGenerate_sensorControl(struct inv_icm20948 * s, const short *sen_num_2_ctrl, unsigned short *sensor_control, uint8_t header2_count);
static short get_multiple_56_rate(unsigned short delayInMs);

unsigned long inv_icm20948_ctrl_androidSensor_enabled(struct inv_icm20948 * s, unsigned char androidSensor)
{
  4107b8:	b480      	push	{r7}
  4107ba:	b083      	sub	sp, #12
  4107bc:	af00      	add	r7, sp, #0
  4107be:	6078      	str	r0, [r7, #4]
  4107c0:	460b      	mov	r3, r1
  4107c2:	70fb      	strb	r3, [r7, #3]
	return s->inv_androidSensorsOn_mask[(androidSensor>>5)] & (1L << (androidSensor&0x1F));
  4107c4:	78fb      	ldrb	r3, [r7, #3]
  4107c6:	095b      	lsrs	r3, r3, #5
  4107c8:	b2db      	uxtb	r3, r3
  4107ca:	461a      	mov	r2, r3
  4107cc:	687b      	ldr	r3, [r7, #4]
  4107ce:	3258      	adds	r2, #88	; 0x58
  4107d0:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
  4107d4:	78fa      	ldrb	r2, [r7, #3]
  4107d6:	f002 021f 	and.w	r2, r2, #31
  4107da:	2101      	movs	r1, #1
  4107dc:	fa01 f202 	lsl.w	r2, r1, r2
  4107e0:	4013      	ands	r3, r2
}
  4107e2:	4618      	mov	r0, r3
  4107e4:	370c      	adds	r7, #12
  4107e6:	46bd      	mov	sp, r7
  4107e8:	f85d 7b04 	ldr.w	r7, [sp], #4
  4107ec:	4770      	bx	lr
	...

004107f0 <MinDelayGenActual>:
}	MinDelayGenElementT;

#define MinDelayGen(s, list) MinDelayGenActual(s, list, sizeof(list) / sizeof (MinDelayGenElementT))

static unsigned short MinDelayGenActual(struct inv_icm20948 *s, const MinDelayGenElementT *element, unsigned long elementQuan)
{
  4107f0:	b580      	push	{r7, lr}
  4107f2:	b086      	sub	sp, #24
  4107f4:	af00      	add	r7, sp, #0
  4107f6:	60f8      	str	r0, [r7, #12]
  4107f8:	60b9      	str	r1, [r7, #8]
  4107fa:	607a      	str	r2, [r7, #4]
	unsigned short minDelay = (unsigned short) -1;
  4107fc:	f64f 73ff 	movw	r3, #65535	; 0xffff
  410800:	82fb      	strh	r3, [r7, #22]

	while(elementQuan--) {
  410802:	e019      	b.n	410838 <MinDelayGenActual+0x48>
		if (inv_icm20948_ctrl_androidSensor_enabled(s, element->AndroidSensor)) {
  410804:	68bb      	ldr	r3, [r7, #8]
  410806:	781b      	ldrb	r3, [r3, #0]
  410808:	4619      	mov	r1, r3
  41080a:	68f8      	ldr	r0, [r7, #12]
  41080c:	4b0f      	ldr	r3, [pc, #60]	; (41084c <MinDelayGenActual+0x5c>)
  41080e:	4798      	blx	r3
  410810:	4603      	mov	r3, r0
  410812:	2b00      	cmp	r3, #0
  410814:	d00d      	beq.n	410832 <MinDelayGenActual+0x42>
			unsigned short odrDelay = s->inv_dmp_odr_delays[element->InvSensor];
  410816:	68bb      	ldr	r3, [r7, #8]
  410818:	785b      	ldrb	r3, [r3, #1]
  41081a:	68fa      	ldr	r2, [r7, #12]
  41081c:	3380      	adds	r3, #128	; 0x80
  41081e:	005b      	lsls	r3, r3, #1
  410820:	4413      	add	r3, r2
  410822:	88db      	ldrh	r3, [r3, #6]
  410824:	82bb      	strh	r3, [r7, #20]

			if (minDelay > odrDelay)
  410826:	8afa      	ldrh	r2, [r7, #22]
  410828:	8abb      	ldrh	r3, [r7, #20]
  41082a:	429a      	cmp	r2, r3
  41082c:	d901      	bls.n	410832 <MinDelayGenActual+0x42>
					minDelay = odrDelay;
  41082e:	8abb      	ldrh	r3, [r7, #20]
  410830:	82fb      	strh	r3, [r7, #22]
		}
		element++;
  410832:	68bb      	ldr	r3, [r7, #8]
  410834:	3302      	adds	r3, #2
  410836:	60bb      	str	r3, [r7, #8]
	while(elementQuan--) {
  410838:	687b      	ldr	r3, [r7, #4]
  41083a:	1e5a      	subs	r2, r3, #1
  41083c:	607a      	str	r2, [r7, #4]
  41083e:	2b00      	cmp	r3, #0
  410840:	d1e0      	bne.n	410804 <MinDelayGenActual+0x14>
	} // end while elements to process

	return	minDelay;
  410842:	8afb      	ldrh	r3, [r7, #22]
}
  410844:	4618      	mov	r0, r3
  410846:	3718      	adds	r7, #24
  410848:	46bd      	mov	sp, r7
  41084a:	bd80      	pop	{r7, pc}
  41084c:	004107b9 	.word	0x004107b9

00410850 <DividerRateSet>:

static int DividerRateSet(struct inv_icm20948 *s, unsigned short minDelay, unsigned short hwSampleRateDivider, enum INV_SENSORS InvSensor)
{
  410850:	b580      	push	{r7, lr}
  410852:	b086      	sub	sp, #24
  410854:	af00      	add	r7, sp, #0
  410856:	60f8      	str	r0, [r7, #12]
  410858:	4608      	mov	r0, r1
  41085a:	4611      	mov	r1, r2
  41085c:	461a      	mov	r2, r3
  41085e:	4603      	mov	r3, r0
  410860:	817b      	strh	r3, [r7, #10]
  410862:	460b      	mov	r3, r1
  410864:	813b      	strh	r3, [r7, #8]
  410866:	4613      	mov	r3, r2
  410868:	71fb      	strb	r3, [r7, #7]
	int result = 0;
  41086a:	2300      	movs	r3, #0
  41086c:	617b      	str	r3, [r7, #20]
	
	if (minDelay != 0xFFFF) {
  41086e:	897b      	ldrh	r3, [r7, #10]
  410870:	f64f 72ff 	movw	r2, #65535	; 0xffff
  410874:	4293      	cmp	r3, r2
  410876:	d025      	beq.n	4108c4 <DividerRateSet+0x74>
		unsigned short dmpOdrDivider = (minDelay * 1125L) / (hwSampleRateDivider * 1000L); // a divider from (1125Hz/hw_smplrt_divider).
  410878:	897b      	ldrh	r3, [r7, #10]
  41087a:	f240 4265 	movw	r2, #1125	; 0x465
  41087e:	fb02 f203 	mul.w	r2, r2, r3
  410882:	893b      	ldrh	r3, [r7, #8]
  410884:	f44f 717a 	mov.w	r1, #1000	; 0x3e8
  410888:	fb01 f303 	mul.w	r3, r1, r3
  41088c:	fb92 f3f3 	sdiv	r3, r2, r3
  410890:	827b      	strh	r3, [r7, #18]

		s->inv_dmp_odr_dividers[InvSensor] = hwSampleRateDivider * dmpOdrDivider;
  410892:	79fb      	ldrb	r3, [r7, #7]
  410894:	8939      	ldrh	r1, [r7, #8]
  410896:	8a7a      	ldrh	r2, [r7, #18]
  410898:	fb11 f202 	smulbb	r2, r1, r2
  41089c:	b291      	uxth	r1, r2
  41089e:	68fa      	ldr	r2, [r7, #12]
  4108a0:	335c      	adds	r3, #92	; 0x5c
  4108a2:	005b      	lsls	r3, r3, #1
  4108a4:	4413      	add	r3, r2
  4108a6:	460a      	mov	r2, r1
  4108a8:	809a      	strh	r2, [r3, #4]
		result |= dmp_icm20948_set_sensor_rate(s, InvSensor, (dmpOdrDivider - 1));
  4108aa:	79f9      	ldrb	r1, [r7, #7]
  4108ac:	8a7b      	ldrh	r3, [r7, #18]
  4108ae:	3b01      	subs	r3, #1
  4108b0:	b29b      	uxth	r3, r3
  4108b2:	b21b      	sxth	r3, r3
  4108b4:	461a      	mov	r2, r3
  4108b6:	68f8      	ldr	r0, [r7, #12]
  4108b8:	4b05      	ldr	r3, [pc, #20]	; (4108d0 <DividerRateSet+0x80>)
  4108ba:	4798      	blx	r3
  4108bc:	4602      	mov	r2, r0
  4108be:	697b      	ldr	r3, [r7, #20]
  4108c0:	4313      	orrs	r3, r2
  4108c2:	617b      	str	r3, [r7, #20]
	}
	
	return result;
  4108c4:	697b      	ldr	r3, [r7, #20]
}
  4108c6:	4618      	mov	r0, r3
  4108c8:	3718      	adds	r7, #24
  4108ca:	46bd      	mov	sp, r7
  4108cc:	bd80      	pop	{r7, pc}
  4108ce:	bf00      	nop
  4108d0:	00407e55 	.word	0x00407e55

004108d4 <SampleRateDividerGet>:

static unsigned short SampleRateDividerGet(unsigned short minDelay)
{
  4108d4:	b480      	push	{r7}
  4108d6:	b085      	sub	sp, #20
  4108d8:	af00      	add	r7, sp, #0
  4108da:	4603      	mov	r3, r0
  4108dc:	80fb      	strh	r3, [r7, #6]
	unsigned short delay = min(INV_ODR_MIN_DELAY, minDelay); // because of GYRO_SMPLRT_DIV which relies on 8 bits, we can't have ODR value higher than 200ms
  4108de:	88fb      	ldrh	r3, [r7, #6]
  4108e0:	2bc8      	cmp	r3, #200	; 0xc8
  4108e2:	bf28      	it	cs
  4108e4:	23c8      	movcs	r3, #200	; 0xc8
  4108e6:	81fb      	strh	r3, [r7, #14]
	return delay * 1125L / 1000L; // a divider from 1125Hz.
  4108e8:	89fb      	ldrh	r3, [r7, #14]
  4108ea:	f240 4265 	movw	r2, #1125	; 0x465
  4108ee:	fb02 f303 	mul.w	r3, r2, r3
  4108f2:	4a06      	ldr	r2, [pc, #24]	; (41090c <SampleRateDividerGet+0x38>)
  4108f4:	fb82 1203 	smull	r1, r2, r2, r3
  4108f8:	1192      	asrs	r2, r2, #6
  4108fa:	17db      	asrs	r3, r3, #31
  4108fc:	1ad3      	subs	r3, r2, r3
  4108fe:	b29b      	uxth	r3, r3
}
  410900:	4618      	mov	r0, r3
  410902:	3714      	adds	r7, #20
  410904:	46bd      	mov	sp, r7
  410906:	f85d 7b04 	ldr.w	r7, [sp], #4
  41090a:	4770      	bx	lr
  41090c:	10624dd3 	.word	0x10624dd3

00410910 <getMinDlyAccel>:

/** @brief Get minimum ODR to be applied to accel engine based on all accel-based enabled sensors.
* @return ODR in ms we expect to be applied to accel engine
*/
static unsigned short getMinDlyAccel(struct inv_icm20948 *s)
{
  410910:	b5b0      	push	{r4, r5, r7, lr}
  410912:	b08e      	sub	sp, #56	; 0x38
  410914:	af00      	add	r7, sp, #0
  410916:	6078      	str	r0, [r7, #4]
	const MinDelayGenElementT MinDelayGenAccelList[] ={
  410918:	4b54      	ldr	r3, [pc, #336]	; (410a6c <getMinDlyAccel+0x15c>)
  41091a:	f107 040c 	add.w	r4, r7, #12
  41091e:	461d      	mov	r5, r3
  410920:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
  410922:	c40f      	stmia	r4!, {r0, r1, r2, r3}
  410924:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
  410926:	c40f      	stmia	r4!, {r0, r1, r2, r3}
  410928:	e895 0007 	ldmia.w	r5, {r0, r1, r2}
  41092c:	c403      	stmia	r4!, {r0, r1}
  41092e:	8022      	strh	r2, [r4, #0]
		{ANDROID_SENSOR_ROTATION_VECTOR,                    INV_SENSOR_NINEQ_accel          },
		{ANDROID_SENSOR_WAKEUP_ORIENTATION,                 INV_SENSOR_WAKEUP_NINEQ_accel   },
		{ANDROID_SENSOR_WAKEUP_ROTATION_VECTOR,             INV_SENSOR_WAKEUP_NINEQ_accel   }
	};

	unsigned short lMinOdr = MinDelayGen(s, MinDelayGenAccelList);
  410930:	f107 030c 	add.w	r3, r7, #12
  410934:	2215      	movs	r2, #21
  410936:	4619      	mov	r1, r3
  410938:	6878      	ldr	r0, [r7, #4]
  41093a:	4b4d      	ldr	r3, [pc, #308]	; (410a70 <getMinDlyAccel+0x160>)
  41093c:	4798      	blx	r3
  41093e:	4603      	mov	r3, r0
  410940:	86fb      	strh	r3, [r7, #54]	; 0x36

	if(inv_icm20948_ctrl_androidSensor_enabled(s, ANDROID_SENSOR_ACCELEROMETER))
  410942:	2101      	movs	r1, #1
  410944:	6878      	ldr	r0, [r7, #4]
  410946:	4b4b      	ldr	r3, [pc, #300]	; (410a74 <getMinDlyAccel+0x164>)
  410948:	4798      	blx	r3
  41094a:	4603      	mov	r3, r0
  41094c:	2b00      	cmp	r3, #0
  41094e:	d01b      	beq.n	410988 <getMinDlyAccel+0x78>
		if(inv_icm20948_ctrl_androidSensor_enabled(s, ANDROID_SENSOR_RAW_ACCELEROMETER))
  410950:	212a      	movs	r1, #42	; 0x2a
  410952:	6878      	ldr	r0, [r7, #4]
  410954:	4b47      	ldr	r3, [pc, #284]	; (410a74 <getMinDlyAccel+0x164>)
  410956:	4798      	blx	r3
  410958:	4603      	mov	r3, r0
  41095a:	2b00      	cmp	r3, #0
  41095c:	d00d      	beq.n	41097a <getMinDlyAccel+0x6a>
			s->inv_dmp_odr_delays[INV_SENSOR_ACCEL] = min(s->odr_acc_ms,s->odr_racc_ms);
  41095e:	687b      	ldr	r3, [r7, #4]
  410960:	f8b3 2248 	ldrh.w	r2, [r3, #584]	; 0x248
  410964:	687b      	ldr	r3, [r7, #4]
  410966:	f8b3 3246 	ldrh.w	r3, [r3, #582]	; 0x246
  41096a:	4293      	cmp	r3, r2
  41096c:	bf28      	it	cs
  41096e:	4613      	movcs	r3, r2
  410970:	b29a      	uxth	r2, r3
  410972:	687b      	ldr	r3, [r7, #4]
  410974:	f8a3 2106 	strh.w	r2, [r3, #262]	; 0x106
  410978:	e013      	b.n	4109a2 <getMinDlyAccel+0x92>
		else
			s->inv_dmp_odr_delays[INV_SENSOR_ACCEL] = s->odr_acc_ms;
  41097a:	687b      	ldr	r3, [r7, #4]
  41097c:	f8b3 2246 	ldrh.w	r2, [r3, #582]	; 0x246
  410980:	687b      	ldr	r3, [r7, #4]
  410982:	f8a3 2106 	strh.w	r2, [r3, #262]	; 0x106
  410986:	e00c      	b.n	4109a2 <getMinDlyAccel+0x92>
	else
		if(inv_icm20948_ctrl_androidSensor_enabled(s, ANDROID_SENSOR_RAW_ACCELEROMETER))
  410988:	212a      	movs	r1, #42	; 0x2a
  41098a:	6878      	ldr	r0, [r7, #4]
  41098c:	4b39      	ldr	r3, [pc, #228]	; (410a74 <getMinDlyAccel+0x164>)
  41098e:	4798      	blx	r3
  410990:	4603      	mov	r3, r0
  410992:	2b00      	cmp	r3, #0
  410994:	d005      	beq.n	4109a2 <getMinDlyAccel+0x92>
			s->inv_dmp_odr_delays[INV_SENSOR_ACCEL] = s->odr_racc_ms;
  410996:	687b      	ldr	r3, [r7, #4]
  410998:	f8b3 2248 	ldrh.w	r2, [r3, #584]	; 0x248
  41099c:	687b      	ldr	r3, [r7, #4]
  41099e:	f8a3 2106 	strh.w	r2, [r3, #262]	; 0x106

	if (s->bac_status != 0)
  4109a2:	687b      	ldr	r3, [r7, #4]
  4109a4:	f8b3 3154 	ldrh.w	r3, [r3, #340]	; 0x154
  4109a8:	2b00      	cmp	r3, #0
  4109aa:	d007      	beq.n	4109bc <getMinDlyAccel+0xac>
		lMinOdr = min(lMinOdr, s->inv_dmp_odr_delays[INV_SENSOR_ACTIVITY_CLASSIFIER]);
  4109ac:	687b      	ldr	r3, [r7, #4]
  4109ae:	f8b3 2120 	ldrh.w	r2, [r3, #288]	; 0x120
  4109b2:	8efb      	ldrh	r3, [r7, #54]	; 0x36
  4109b4:	4293      	cmp	r3, r2
  4109b6:	bf28      	it	cs
  4109b8:	4613      	movcs	r3, r2
  4109ba:	86fb      	strh	r3, [r7, #54]	; 0x36
	if (s->flip_pickup_status != 0)
  4109bc:	687b      	ldr	r3, [r7, #4]
  4109be:	f8b3 3158 	ldrh.w	r3, [r3, #344]	; 0x158
  4109c2:	2b00      	cmp	r3, #0
  4109c4:	d007      	beq.n	4109d6 <getMinDlyAccel+0xc6>
		lMinOdr = min(lMinOdr, s->inv_dmp_odr_delays[INV_SENSOR_FLIP_PICKUP]);
  4109c6:	687b      	ldr	r3, [r7, #4]
  4109c8:	f8b3 2122 	ldrh.w	r2, [r3, #290]	; 0x122
  4109cc:	8efb      	ldrh	r3, [r7, #54]	; 0x36
  4109ce:	4293      	cmp	r3, r2
  4109d0:	bf28      	it	cs
  4109d2:	4613      	movcs	r3, r2
  4109d4:	86fb      	strh	r3, [r7, #54]	; 0x36
	if (s->b2s_status != 0)
  4109d6:	687b      	ldr	r3, [r7, #4]
  4109d8:	f8b3 3156 	ldrh.w	r3, [r3, #342]	; 0x156
  4109dc:	2b00      	cmp	r3, #0
  4109de:	d007      	beq.n	4109f0 <getMinDlyAccel+0xe0>
		lMinOdr = min(lMinOdr, s->inv_dmp_odr_delays[INV_SENSOR_BRING_TO_SEE]);
  4109e0:	687b      	ldr	r3, [r7, #4]
  4109e2:	f8b3 2124 	ldrh.w	r2, [r3, #292]	; 0x124
  4109e6:	8efb      	ldrh	r3, [r7, #54]	; 0x36
  4109e8:	4293      	cmp	r3, r2
  4109ea:	bf28      	it	cs
  4109ec:	4613      	movcs	r3, r2
  4109ee:	86fb      	strh	r3, [r7, #54]	; 0x36
	
	/** To have correct algorithm performance and quick convergence of GMRV, it is advised to set accelerometer to 225Hz.
	    In case power consumption is to be improved at the expense of performance, this setup should be commented out */
	if (   inv_icm20948_ctrl_androidSensor_enabled(s, ANDROID_SENSOR_WAKEUP_GEOMAGNETIC_ROTATION_VECTOR) 
  4109f0:	2127      	movs	r1, #39	; 0x27
  4109f2:	6878      	ldr	r0, [r7, #4]
  4109f4:	4b1f      	ldr	r3, [pc, #124]	; (410a74 <getMinDlyAccel+0x164>)
  4109f6:	4798      	blx	r3
  4109f8:	4603      	mov	r3, r0
  4109fa:	2b00      	cmp	r3, #0
  4109fc:	d106      	bne.n	410a0c <getMinDlyAccel+0xfc>
		|| inv_icm20948_ctrl_androidSensor_enabled(s, ANDROID_SENSOR_GEOMAGNETIC_ROTATION_VECTOR) )
  4109fe:	2114      	movs	r1, #20
  410a00:	6878      	ldr	r0, [r7, #4]
  410a02:	4b1c      	ldr	r3, [pc, #112]	; (410a74 <getMinDlyAccel+0x164>)
  410a04:	4798      	blx	r3
  410a06:	4603      	mov	r3, r0
  410a08:	2b00      	cmp	r3, #0
  410a0a:	d004      	beq.n	410a16 <getMinDlyAccel+0x106>
		lMinOdr = min(lMinOdr, 5);
  410a0c:	8efb      	ldrh	r3, [r7, #54]	; 0x36
  410a0e:	2b05      	cmp	r3, #5
  410a10:	bf28      	it	cs
  410a12:	2305      	movcs	r3, #5
  410a14:	86fb      	strh	r3, [r7, #54]	; 0x36

	/** To have correct algorithm performance and quick convergence of RV, it is advised to set accelerometer to 225Hz.
	    In case power consumption is to be improved at the expense of performance, this setup should be commented out */
	if (   inv_icm20948_ctrl_androidSensor_enabled(s, ANDROID_SENSOR_WAKEUP_ROTATION_VECTOR) 
  410a16:	211f      	movs	r1, #31
  410a18:	6878      	ldr	r0, [r7, #4]
  410a1a:	4b16      	ldr	r3, [pc, #88]	; (410a74 <getMinDlyAccel+0x164>)
  410a1c:	4798      	blx	r3
  410a1e:	4603      	mov	r3, r0
  410a20:	2b00      	cmp	r3, #0
  410a22:	d106      	bne.n	410a32 <getMinDlyAccel+0x122>
		|| inv_icm20948_ctrl_androidSensor_enabled(s, ANDROID_SENSOR_ROTATION_VECTOR) )
  410a24:	210b      	movs	r1, #11
  410a26:	6878      	ldr	r0, [r7, #4]
  410a28:	4b12      	ldr	r3, [pc, #72]	; (410a74 <getMinDlyAccel+0x164>)
  410a2a:	4798      	blx	r3
  410a2c:	4603      	mov	r3, r0
  410a2e:	2b00      	cmp	r3, #0
  410a30:	d004      	beq.n	410a3c <getMinDlyAccel+0x12c>
		lMinOdr = min(lMinOdr, 5);
  410a32:	8efb      	ldrh	r3, [r7, #54]	; 0x36
  410a34:	2b05      	cmp	r3, #5
  410a36:	bf28      	it	cs
  410a38:	2305      	movcs	r3, #5
  410a3a:	86fb      	strh	r3, [r7, #54]	; 0x36
	
	/** To have correct algorithm performance and quick convergence of GRV, it is advised to set accelerometer to 225Hz.
	    In case power consumption is to be improved at the expense of performance, this setup should be commented out */
	if (   inv_icm20948_ctrl_androidSensor_enabled(s, ANDROID_SENSOR_WAKEUP_GAME_ROTATION_VECTOR) 
  410a3c:	2123      	movs	r1, #35	; 0x23
  410a3e:	6878      	ldr	r0, [r7, #4]
  410a40:	4b0c      	ldr	r3, [pc, #48]	; (410a74 <getMinDlyAccel+0x164>)
  410a42:	4798      	blx	r3
  410a44:	4603      	mov	r3, r0
  410a46:	2b00      	cmp	r3, #0
  410a48:	d106      	bne.n	410a58 <getMinDlyAccel+0x148>
		|| inv_icm20948_ctrl_androidSensor_enabled(s, ANDROID_SENSOR_GAME_ROTATION_VECTOR) )
  410a4a:	210f      	movs	r1, #15
  410a4c:	6878      	ldr	r0, [r7, #4]
  410a4e:	4b09      	ldr	r3, [pc, #36]	; (410a74 <getMinDlyAccel+0x164>)
  410a50:	4798      	blx	r3
  410a52:	4603      	mov	r3, r0
  410a54:	2b00      	cmp	r3, #0
  410a56:	d004      	beq.n	410a62 <getMinDlyAccel+0x152>
		lMinOdr = min(lMinOdr, 5);
  410a58:	8efb      	ldrh	r3, [r7, #54]	; 0x36
  410a5a:	2b05      	cmp	r3, #5
  410a5c:	bf28      	it	cs
  410a5e:	2305      	movcs	r3, #5
  410a60:	86fb      	strh	r3, [r7, #54]	; 0x36

	return lMinOdr;
  410a62:	8efb      	ldrh	r3, [r7, #54]	; 0x36
}
  410a64:	4618      	mov	r0, r3
  410a66:	3738      	adds	r7, #56	; 0x38
  410a68:	46bd      	mov	sp, r7
  410a6a:	bdb0      	pop	{r4, r5, r7, pc}
  410a6c:	0041d148 	.word	0x0041d148
  410a70:	004107f1 	.word	0x004107f1
  410a74:	004107b9 	.word	0x004107b9

00410a78 <getMinDlyGyro>:

/** @brief Get minimum ODR to be applied to gyro engine based on all gyro-based enabled sensors.
* @return ODR in ms we expect to be applied to gyro engine
*/
static unsigned short getMinDlyGyro(struct inv_icm20948 *s)
{
  410a78:	b5b0      	push	{r4, r5, r7, lr}
  410a7a:	b08a      	sub	sp, #40	; 0x28
  410a7c:	af00      	add	r7, sp, #0
  410a7e:	6078      	str	r0, [r7, #4]
	const MinDelayGenElementT MinDelayGenGyroList[] = {
  410a80:	4b36      	ldr	r3, [pc, #216]	; (410b5c <getMinDlyGyro+0xe4>)
  410a82:	f107 0408 	add.w	r4, r7, #8
  410a86:	461d      	mov	r5, r3
  410a88:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
  410a8a:	c40f      	stmia	r4!, {r0, r1, r2, r3}
  410a8c:	e895 000f 	ldmia.w	r5, {r0, r1, r2, r3}
  410a90:	c407      	stmia	r4!, {r0, r1, r2}
  410a92:	8023      	strh	r3, [r4, #0]
		{ANDROID_SENSOR_ROTATION_VECTOR,               INV_SENSOR_NINEQ             },
		{ANDROID_SENSOR_WAKEUP_ORIENTATION,            INV_SENSOR_WAKEUP_NINEQ      },
		{ANDROID_SENSOR_WAKEUP_ROTATION_VECTOR,        INV_SENSOR_WAKEUP_NINEQ      }
	};

	unsigned short lMinOdr = MinDelayGen(s, MinDelayGenGyroList);
  410a94:	f107 0308 	add.w	r3, r7, #8
  410a98:	220f      	movs	r2, #15
  410a9a:	4619      	mov	r1, r3
  410a9c:	6878      	ldr	r0, [r7, #4]
  410a9e:	4b30      	ldr	r3, [pc, #192]	; (410b60 <getMinDlyGyro+0xe8>)
  410aa0:	4798      	blx	r3
  410aa2:	4603      	mov	r3, r0
  410aa4:	84fb      	strh	r3, [r7, #38]	; 0x26

	if(inv_icm20948_ctrl_androidSensor_enabled(s, ANDROID_SENSOR_GYROSCOPE_UNCALIBRATED))
  410aa6:	2110      	movs	r1, #16
  410aa8:	6878      	ldr	r0, [r7, #4]
  410aaa:	4b2e      	ldr	r3, [pc, #184]	; (410b64 <getMinDlyGyro+0xec>)
  410aac:	4798      	blx	r3
  410aae:	4603      	mov	r3, r0
  410ab0:	2b00      	cmp	r3, #0
  410ab2:	d01b      	beq.n	410aec <getMinDlyGyro+0x74>
		if(inv_icm20948_ctrl_androidSensor_enabled(s, ANDROID_SENSOR_RAW_GYROSCOPE))
  410ab4:	212b      	movs	r1, #43	; 0x2b
  410ab6:	6878      	ldr	r0, [r7, #4]
  410ab8:	4b2a      	ldr	r3, [pc, #168]	; (410b64 <getMinDlyGyro+0xec>)
  410aba:	4798      	blx	r3
  410abc:	4603      	mov	r3, r0
  410abe:	2b00      	cmp	r3, #0
  410ac0:	d00d      	beq.n	410ade <getMinDlyGyro+0x66>
			s->inv_dmp_odr_delays[INV_SENSOR_GYRO] = min(s->odr_gyr_ms,s->odr_rgyr_ms);
  410ac2:	687b      	ldr	r3, [r7, #4]
  410ac4:	f8b3 224c 	ldrh.w	r2, [r3, #588]	; 0x24c
  410ac8:	687b      	ldr	r3, [r7, #4]
  410aca:	f8b3 324a 	ldrh.w	r3, [r3, #586]	; 0x24a
  410ace:	4293      	cmp	r3, r2
  410ad0:	bf28      	it	cs
  410ad2:	4613      	movcs	r3, r2
  410ad4:	b29a      	uxth	r2, r3
  410ad6:	687b      	ldr	r3, [r7, #4]
  410ad8:	f8a3 2108 	strh.w	r2, [r3, #264]	; 0x108
  410adc:	e013      	b.n	410b06 <getMinDlyGyro+0x8e>
		else
			s->inv_dmp_odr_delays[INV_SENSOR_GYRO] = s->odr_gyr_ms;
  410ade:	687b      	ldr	r3, [r7, #4]
  410ae0:	f8b3 224a 	ldrh.w	r2, [r3, #586]	; 0x24a
  410ae4:	687b      	ldr	r3, [r7, #4]
  410ae6:	f8a3 2108 	strh.w	r2, [r3, #264]	; 0x108
  410aea:	e00c      	b.n	410b06 <getMinDlyGyro+0x8e>
	else
		if(inv_icm20948_ctrl_androidSensor_enabled(s, ANDROID_SENSOR_RAW_GYROSCOPE))
  410aec:	212b      	movs	r1, #43	; 0x2b
  410aee:	6878      	ldr	r0, [r7, #4]
  410af0:	4b1c      	ldr	r3, [pc, #112]	; (410b64 <getMinDlyGyro+0xec>)
  410af2:	4798      	blx	r3
  410af4:	4603      	mov	r3, r0
  410af6:	2b00      	cmp	r3, #0
  410af8:	d005      	beq.n	410b06 <getMinDlyGyro+0x8e>
			s->inv_dmp_odr_delays[INV_SENSOR_GYRO] = s->odr_rgyr_ms;
  410afa:	687b      	ldr	r3, [r7, #4]
  410afc:	f8b3 224c 	ldrh.w	r2, [r3, #588]	; 0x24c
  410b00:	687b      	ldr	r3, [r7, #4]
  410b02:	f8a3 2108 	strh.w	r2, [r3, #264]	; 0x108

	/** To have correct algorithm performance and quick convergence of RV, it is advised to set gyro to 225Hz.
	    In case power consumption is to be improved at the expense of performance, this setup should be commented out */
	if (   inv_icm20948_ctrl_androidSensor_enabled(s, ANDROID_SENSOR_WAKEUP_ROTATION_VECTOR) 
  410b06:	211f      	movs	r1, #31
  410b08:	6878      	ldr	r0, [r7, #4]
  410b0a:	4b16      	ldr	r3, [pc, #88]	; (410b64 <getMinDlyGyro+0xec>)
  410b0c:	4798      	blx	r3
  410b0e:	4603      	mov	r3, r0
  410b10:	2b00      	cmp	r3, #0
  410b12:	d106      	bne.n	410b22 <getMinDlyGyro+0xaa>
		|| inv_icm20948_ctrl_androidSensor_enabled(s, ANDROID_SENSOR_ROTATION_VECTOR) )
  410b14:	210b      	movs	r1, #11
  410b16:	6878      	ldr	r0, [r7, #4]
  410b18:	4b12      	ldr	r3, [pc, #72]	; (410b64 <getMinDlyGyro+0xec>)
  410b1a:	4798      	blx	r3
  410b1c:	4603      	mov	r3, r0
  410b1e:	2b00      	cmp	r3, #0
  410b20:	d004      	beq.n	410b2c <getMinDlyGyro+0xb4>
		lMinOdr	= min(lMinOdr, 5);
  410b22:	8cfb      	ldrh	r3, [r7, #38]	; 0x26
  410b24:	2b05      	cmp	r3, #5
  410b26:	bf28      	it	cs
  410b28:	2305      	movcs	r3, #5
  410b2a:	84fb      	strh	r3, [r7, #38]	; 0x26
				
	/** To have correct algorithm performance and quick convergence of GRV, it is advised to set gyro to 225Hz.
	    In case power consumption is to be improved at the expense of performance, this setup should be commented out */
	if (   inv_icm20948_ctrl_androidSensor_enabled(s, ANDROID_SENSOR_WAKEUP_GAME_ROTATION_VECTOR) 
  410b2c:	2123      	movs	r1, #35	; 0x23
  410b2e:	6878      	ldr	r0, [r7, #4]
  410b30:	4b0c      	ldr	r3, [pc, #48]	; (410b64 <getMinDlyGyro+0xec>)
  410b32:	4798      	blx	r3
  410b34:	4603      	mov	r3, r0
  410b36:	2b00      	cmp	r3, #0
  410b38:	d106      	bne.n	410b48 <getMinDlyGyro+0xd0>
		|| inv_icm20948_ctrl_androidSensor_enabled(s, ANDROID_SENSOR_GAME_ROTATION_VECTOR) )
  410b3a:	210f      	movs	r1, #15
  410b3c:	6878      	ldr	r0, [r7, #4]
  410b3e:	4b09      	ldr	r3, [pc, #36]	; (410b64 <getMinDlyGyro+0xec>)
  410b40:	4798      	blx	r3
  410b42:	4603      	mov	r3, r0
  410b44:	2b00      	cmp	r3, #0
  410b46:	d004      	beq.n	410b52 <getMinDlyGyro+0xda>
		lMinOdr	= min(lMinOdr, 5);
  410b48:	8cfb      	ldrh	r3, [r7, #38]	; 0x26
  410b4a:	2b05      	cmp	r3, #5
  410b4c:	bf28      	it	cs
  410b4e:	2305      	movcs	r3, #5
  410b50:	84fb      	strh	r3, [r7, #38]	; 0x26

	return lMinOdr;
  410b52:	8cfb      	ldrh	r3, [r7, #38]	; 0x26
}
  410b54:	4618      	mov	r0, r3
  410b56:	3728      	adds	r7, #40	; 0x28
  410b58:	46bd      	mov	sp, r7
  410b5a:	bdb0      	pop	{r4, r5, r7, pc}
  410b5c:	0041d174 	.word	0x0041d174
  410b60:	004107f1 	.word	0x004107f1
  410b64:	004107b9 	.word	0x004107b9

00410b68 <getMinDlyCompass>:

/** @brief Get minimum ODR to be applied to compass engine based on all compass-based enabled sensors.
* @return ODR in ms we expect to be applied to compass engine
*/
static unsigned short getMinDlyCompass(struct inv_icm20948 *s)
{
  410b68:	b5b0      	push	{r4, r5, r7, lr}
  410b6a:	b088      	sub	sp, #32
  410b6c:	af00      	add	r7, sp, #0
  410b6e:	6078      	str	r0, [r7, #4]
	const MinDelayGenElementT MinDelayGenCpassList[] = {
  410b70:	4b1d      	ldr	r3, [pc, #116]	; (410be8 <getMinDlyCompass+0x80>)
  410b72:	f107 0408 	add.w	r4, r7, #8
  410b76:	461d      	mov	r5, r3
  410b78:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
  410b7a:	c40f      	stmia	r4!, {r0, r1, r2, r3}
  410b7c:	682b      	ldr	r3, [r5, #0]
  410b7e:	6023      	str	r3, [r4, #0]
		{ANDROID_SENSOR_WAKEUP_GEOMAGNETIC_ROTATION_VECTOR, INV_SENSOR_WAKEUP_GEOMAG_cpass  },
		{ANDROID_SENSOR_WAKEUP_ORIENTATION,                 INV_SENSOR_WAKEUP_NINEQ_cpass   },
		{ANDROID_SENSOR_WAKEUP_ROTATION_VECTOR,             INV_SENSOR_WAKEUP_NINEQ_cpass   }
	};

	unsigned short lMinOdr = MinDelayGen(s, MinDelayGenCpassList);
  410b80:	f107 0308 	add.w	r3, r7, #8
  410b84:	220a      	movs	r2, #10
  410b86:	4619      	mov	r1, r3
  410b88:	6878      	ldr	r0, [r7, #4]
  410b8a:	4b18      	ldr	r3, [pc, #96]	; (410bec <getMinDlyCompass+0x84>)
  410b8c:	4798      	blx	r3
  410b8e:	4603      	mov	r3, r0
  410b90:	83fb      	strh	r3, [r7, #30]

	/** To have correct algorithm performance and quick convergence of GMRV, it is advised to set compass to 70Hz.
	    In case power consumption is to be improved at the expense of performance, this setup should be commented out */
	if (   inv_icm20948_ctrl_androidSensor_enabled(s, ANDROID_SENSOR_WAKEUP_GEOMAGNETIC_ROTATION_VECTOR) 
  410b92:	2127      	movs	r1, #39	; 0x27
  410b94:	6878      	ldr	r0, [r7, #4]
  410b96:	4b16      	ldr	r3, [pc, #88]	; (410bf0 <getMinDlyCompass+0x88>)
  410b98:	4798      	blx	r3
  410b9a:	4603      	mov	r3, r0
  410b9c:	2b00      	cmp	r3, #0
  410b9e:	d106      	bne.n	410bae <getMinDlyCompass+0x46>
		|| inv_icm20948_ctrl_androidSensor_enabled(s, ANDROID_SENSOR_GEOMAGNETIC_ROTATION_VECTOR) )
  410ba0:	2114      	movs	r1, #20
  410ba2:	6878      	ldr	r0, [r7, #4]
  410ba4:	4b12      	ldr	r3, [pc, #72]	; (410bf0 <getMinDlyCompass+0x88>)
  410ba6:	4798      	blx	r3
  410ba8:	4603      	mov	r3, r0
  410baa:	2b00      	cmp	r3, #0
  410bac:	d004      	beq.n	410bb8 <getMinDlyCompass+0x50>
		lMinOdr= min(lMinOdr, 15);
  410bae:	8bfb      	ldrh	r3, [r7, #30]
  410bb0:	2b0f      	cmp	r3, #15
  410bb2:	bf28      	it	cs
  410bb4:	230f      	movcs	r3, #15
  410bb6:	83fb      	strh	r3, [r7, #30]
	/** To have correct algorithm performance and quick convergence of RV, it is advised to set compass to 35Hz.
	    In case power consumption is to be improved at the expense of performance, this setup should be commented out */
	if (   inv_icm20948_ctrl_androidSensor_enabled(s, ANDROID_SENSOR_WAKEUP_ROTATION_VECTOR) 
  410bb8:	211f      	movs	r1, #31
  410bba:	6878      	ldr	r0, [r7, #4]
  410bbc:	4b0c      	ldr	r3, [pc, #48]	; (410bf0 <getMinDlyCompass+0x88>)
  410bbe:	4798      	blx	r3
  410bc0:	4603      	mov	r3, r0
  410bc2:	2b00      	cmp	r3, #0
  410bc4:	d106      	bne.n	410bd4 <getMinDlyCompass+0x6c>
		|| inv_icm20948_ctrl_androidSensor_enabled(s, ANDROID_SENSOR_ROTATION_VECTOR) )
  410bc6:	210b      	movs	r1, #11
  410bc8:	6878      	ldr	r0, [r7, #4]
  410bca:	4b09      	ldr	r3, [pc, #36]	; (410bf0 <getMinDlyCompass+0x88>)
  410bcc:	4798      	blx	r3
  410bce:	4603      	mov	r3, r0
  410bd0:	2b00      	cmp	r3, #0
  410bd2:	d004      	beq.n	410bde <getMinDlyCompass+0x76>
		lMinOdr = min(lMinOdr, 28);
  410bd4:	8bfb      	ldrh	r3, [r7, #30]
  410bd6:	2b1c      	cmp	r3, #28
  410bd8:	bf28      	it	cs
  410bda:	231c      	movcs	r3, #28
  410bdc:	83fb      	strh	r3, [r7, #30]

	return lMinOdr;
  410bde:	8bfb      	ldrh	r3, [r7, #30]
}
  410be0:	4618      	mov	r0, r3
  410be2:	3720      	adds	r7, #32
  410be4:	46bd      	mov	sp, r7
  410be6:	bdb0      	pop	{r4, r5, r7, pc}
  410be8:	0041d194 	.word	0x0041d194
  410bec:	004107f1 	.word	0x004107f1
  410bf0:	004107b9 	.word	0x004107b9

00410bf4 <inv_icm20948_base_control_init>:

int inv_icm20948_base_control_init(struct inv_icm20948 * s)
{
  410bf4:	b580      	push	{r7, lr}
  410bf6:	b084      	sub	sp, #16
  410bf8:	af00      	add	r7, sp, #0
  410bfa:	6078      	str	r0, [r7, #4]
	int result = 0;
  410bfc:	2300      	movs	r3, #0
  410bfe:	60bb      	str	r3, [r7, #8]
	unsigned int i;

	memset(s->inv_dmp_odr_dividers, 0, sizeof(s->inv_dmp_odr_dividers));
  410c00:	687b      	ldr	r3, [r7, #4]
  410c02:	33bc      	adds	r3, #188	; 0xbc
  410c04:	224a      	movs	r2, #74	; 0x4a
  410c06:	2100      	movs	r1, #0
  410c08:	4618      	mov	r0, r3
  410c0a:	4b65      	ldr	r3, [pc, #404]	; (410da0 <inv_icm20948_base_control_init+0x1ac>)
  410c0c:	4798      	blx	r3
	
	for(i = 0; i < (sizeof(s->inv_dmp_odr_delays)/sizeof(unsigned short)); i++) {
  410c0e:	2300      	movs	r3, #0
  410c10:	60fb      	str	r3, [r7, #12]
  410c12:	e02b      	b.n	410c6c <inv_icm20948_base_control_init+0x78>
		if((i == INV_SENSOR_ACTIVITY_CLASSIFIER) ||
  410c14:	68fb      	ldr	r3, [r7, #12]
  410c16:	2b0d      	cmp	r3, #13
  410c18:	d00b      	beq.n	410c32 <inv_icm20948_base_control_init+0x3e>
  410c1a:	68fb      	ldr	r3, [r7, #12]
  410c1c:	2b0c      	cmp	r3, #12
  410c1e:	d008      	beq.n	410c32 <inv_icm20948_base_control_init+0x3e>
		   (i == INV_SENSOR_STEP_COUNTER) ||
  410c20:	68fb      	ldr	r3, [r7, #12]
  410c22:	2b1f      	cmp	r3, #31
  410c24:	d005      	beq.n	410c32 <inv_icm20948_base_control_init+0x3e>
		   (i == INV_SENSOR_WAKEUP_STEP_COUNTER) ||
  410c26:	68fb      	ldr	r3, [r7, #12]
  410c28:	2b20      	cmp	r3, #32
  410c2a:	d002      	beq.n	410c32 <inv_icm20948_base_control_init+0x3e>
		   (i == INV_SENSOR_WAKEUP_TILT_DETECTOR) ||
  410c2c:	68fb      	ldr	r3, [r7, #12]
  410c2e:	2b0e      	cmp	r3, #14
  410c30:	d107      	bne.n	410c42 <inv_icm20948_base_control_init+0x4e>
		   (i == INV_SENSOR_FLIP_PICKUP) )
			s->inv_dmp_odr_delays[i] = INV_ODR_DEFAULT_BAC;
  410c32:	687a      	ldr	r2, [r7, #4]
  410c34:	68fb      	ldr	r3, [r7, #12]
  410c36:	3380      	adds	r3, #128	; 0x80
  410c38:	005b      	lsls	r3, r3, #1
  410c3a:	4413      	add	r3, r2
  410c3c:	2212      	movs	r2, #18
  410c3e:	80da      	strh	r2, [r3, #6]
  410c40:	e011      	b.n	410c66 <inv_icm20948_base_control_init+0x72>
		else if(i == INV_SENSOR_BRING_TO_SEE)
  410c42:	68fb      	ldr	r3, [r7, #12]
  410c44:	2b0f      	cmp	r3, #15
  410c46:	d107      	bne.n	410c58 <inv_icm20948_base_control_init+0x64>
			s->inv_dmp_odr_delays[i] = INV_ODR_DEFAULT_B2S;
  410c48:	687a      	ldr	r2, [r7, #4]
  410c4a:	68fb      	ldr	r3, [r7, #12]
  410c4c:	3380      	adds	r3, #128	; 0x80
  410c4e:	005b      	lsls	r3, r3, #1
  410c50:	4413      	add	r3, r2
  410c52:	2212      	movs	r2, #18
  410c54:	80da      	strh	r2, [r3, #6]
  410c56:	e006      	b.n	410c66 <inv_icm20948_base_control_init+0x72>
		else
			s->inv_dmp_odr_delays[i] = INV_ODR_MIN_DELAY;
  410c58:	687a      	ldr	r2, [r7, #4]
  410c5a:	68fb      	ldr	r3, [r7, #12]
  410c5c:	3380      	adds	r3, #128	; 0x80
  410c5e:	005b      	lsls	r3, r3, #1
  410c60:	4413      	add	r3, r2
  410c62:	22c8      	movs	r2, #200	; 0xc8
  410c64:	80da      	strh	r2, [r3, #6]
	for(i = 0; i < (sizeof(s->inv_dmp_odr_delays)/sizeof(unsigned short)); i++) {
  410c66:	68fb      	ldr	r3, [r7, #12]
  410c68:	3301      	adds	r3, #1
  410c6a:	60fb      	str	r3, [r7, #12]
  410c6c:	68fb      	ldr	r3, [r7, #12]
  410c6e:	2b24      	cmp	r3, #36	; 0x24
  410c70:	d9d0      	bls.n	410c14 <inv_icm20948_base_control_init+0x20>
	}
	for(i = 0; i < (sizeof(s->inv_androidSensorsOdr_boundaries)/sizeof(s->inv_androidSensorsOdr_boundaries[0])); i++) {
  410c72:	2300      	movs	r3, #0
  410c74:	60fb      	str	r3, [r7, #12]
  410c76:	e057      	b.n	410d28 <inv_icm20948_base_control_init+0x134>
		if ((i == ANDROID_SENSOR_MAGNETIC_FIELD_UNCALIBRATED) || (i == ANDROID_SENSOR_GEOMAGNETIC_FIELD) ||
  410c78:	68fb      	ldr	r3, [r7, #12]
  410c7a:	2b0e      	cmp	r3, #14
  410c7c:	d008      	beq.n	410c90 <inv_icm20948_base_control_init+0x9c>
  410c7e:	68fb      	ldr	r3, [r7, #12]
  410c80:	2b02      	cmp	r3, #2
  410c82:	d005      	beq.n	410c90 <inv_icm20948_base_control_init+0x9c>
  410c84:	68fb      	ldr	r3, [r7, #12]
  410c86:	2b22      	cmp	r3, #34	; 0x22
  410c88:	d002      	beq.n	410c90 <inv_icm20948_base_control_init+0x9c>
		    (i == ANDROID_SENSOR_WAKEUP_MAGNETIC_FIELD_UNCALIBRATED) || (i == ANDROID_SENSOR_WAKEUP_MAGNETIC_FIELD)) {
  410c8a:	68fb      	ldr	r3, [r7, #12]
  410c8c:	2b18      	cmp	r3, #24
  410c8e:	d10e      	bne.n	410cae <inv_icm20948_base_control_init+0xba>
			s->inv_androidSensorsOdr_boundaries[i][0] = INV_MIN_ODR_CPASS;
  410c90:	687b      	ldr	r3, [r7, #4]
  410c92:	68fa      	ldr	r2, [r7, #12]
  410c94:	325a      	adds	r2, #90	; 0x5a
  410c96:	210e      	movs	r1, #14
  410c98:	f823 1022 	strh.w	r1, [r3, r2, lsl #2]
			s->inv_androidSensorsOdr_boundaries[i][1] = INV_MAX_ODR_CPASS;
  410c9c:	687a      	ldr	r2, [r7, #4]
  410c9e:	68fb      	ldr	r3, [r7, #12]
  410ca0:	009b      	lsls	r3, r3, #2
  410ca2:	4413      	add	r3, r2
  410ca4:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
  410ca8:	f8a3 216a 	strh.w	r2, [r3, #362]	; 0x16a
  410cac:	e039      	b.n	410d22 <inv_icm20948_base_control_init+0x12e>
		} else if ((i == ANDROID_SENSOR_GAME_ROTATION_VECTOR) || (i == ANDROID_SENSOR_WAKEUP_GAME_ROTATION_VECTOR) ||
  410cae:	68fb      	ldr	r3, [r7, #12]
  410cb0:	2b0f      	cmp	r3, #15
  410cb2:	d01a      	beq.n	410cea <inv_icm20948_base_control_init+0xf6>
  410cb4:	68fb      	ldr	r3, [r7, #12]
  410cb6:	2b23      	cmp	r3, #35	; 0x23
  410cb8:	d017      	beq.n	410cea <inv_icm20948_base_control_init+0xf6>
  410cba:	68fb      	ldr	r3, [r7, #12]
  410cbc:	2b09      	cmp	r3, #9
  410cbe:	d014      	beq.n	410cea <inv_icm20948_base_control_init+0xf6>
		           (i == ANDROID_SENSOR_GRAVITY) || (i == ANDROID_SENSOR_WAKEUP_GRAVITY) ||
  410cc0:	68fb      	ldr	r3, [r7, #12]
  410cc2:	2b1d      	cmp	r3, #29
  410cc4:	d011      	beq.n	410cea <inv_icm20948_base_control_init+0xf6>
  410cc6:	68fb      	ldr	r3, [r7, #12]
  410cc8:	2b0a      	cmp	r3, #10
  410cca:	d00e      	beq.n	410cea <inv_icm20948_base_control_init+0xf6>
		           (i == ANDROID_SENSOR_LINEAR_ACCELERATION) || (i == ANDROID_SENSOR_WAKEUP_LINEAR_ACCELERATION) ||
  410ccc:	68fb      	ldr	r3, [r7, #12]
  410cce:	2b1e      	cmp	r3, #30
  410cd0:	d00b      	beq.n	410cea <inv_icm20948_base_control_init+0xf6>
  410cd2:	68fb      	ldr	r3, [r7, #12]
  410cd4:	2b0b      	cmp	r3, #11
  410cd6:	d008      	beq.n	410cea <inv_icm20948_base_control_init+0xf6>
		           (i == ANDROID_SENSOR_ROTATION_VECTOR) || (i == ANDROID_SENSOR_WAKEUP_ROTATION_VECTOR) ||
  410cd8:	68fb      	ldr	r3, [r7, #12]
  410cda:	2b1f      	cmp	r3, #31
  410cdc:	d005      	beq.n	410cea <inv_icm20948_base_control_init+0xf6>
  410cde:	68fb      	ldr	r3, [r7, #12]
  410ce0:	2b03      	cmp	r3, #3
  410ce2:	d002      	beq.n	410cea <inv_icm20948_base_control_init+0xf6>
		           (i == ANDROID_SENSOR_ORIENTATION) || (i == ANDROID_SENSOR_WAKEUP_ORIENTATION)) {
  410ce4:	68fb      	ldr	r3, [r7, #12]
  410ce6:	2b19      	cmp	r3, #25
  410ce8:	d10d      	bne.n	410d06 <inv_icm20948_base_control_init+0x112>
			s->inv_androidSensorsOdr_boundaries[i][0] = INV_MIN_ODR_GRV;
  410cea:	687b      	ldr	r3, [r7, #4]
  410cec:	68fa      	ldr	r2, [r7, #12]
  410cee:	325a      	adds	r2, #90	; 0x5a
  410cf0:	2105      	movs	r1, #5
  410cf2:	f823 1022 	strh.w	r1, [r3, r2, lsl #2]
			s->inv_androidSensorsOdr_boundaries[i][1] = INV_MAX_ODR_GRV;
  410cf6:	687a      	ldr	r2, [r7, #4]
  410cf8:	68fb      	ldr	r3, [r7, #12]
  410cfa:	009b      	lsls	r3, r3, #2
  410cfc:	4413      	add	r3, r2
  410cfe:	2214      	movs	r2, #20
  410d00:	f8a3 216a 	strh.w	r2, [r3, #362]	; 0x16a
  410d04:	e00d      	b.n	410d22 <inv_icm20948_base_control_init+0x12e>
		} else {
			s->inv_androidSensorsOdr_boundaries[i][0] = INV_MIN_ODR;
  410d06:	687b      	ldr	r3, [r7, #4]
  410d08:	68fa      	ldr	r2, [r7, #12]
  410d0a:	325a      	adds	r2, #90	; 0x5a
  410d0c:	2105      	movs	r1, #5
  410d0e:	f823 1022 	strh.w	r1, [r3, r2, lsl #2]
			s->inv_androidSensorsOdr_boundaries[i][1] = INV_MAX_ODR;
  410d12:	687a      	ldr	r2, [r7, #4]
  410d14:	68fb      	ldr	r3, [r7, #12]
  410d16:	009b      	lsls	r3, r3, #2
  410d18:	4413      	add	r3, r2
  410d1a:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
  410d1e:	f8a3 216a 	strh.w	r2, [r3, #362]	; 0x16a
	for(i = 0; i < (sizeof(s->inv_androidSensorsOdr_boundaries)/sizeof(s->inv_androidSensorsOdr_boundaries[0])); i++) {
  410d22:	68fb      	ldr	r3, [r7, #12]
  410d24:	3301      	adds	r3, #1
  410d26:	60fb      	str	r3, [r7, #12]
  410d28:	68fb      	ldr	r3, [r7, #12]
  410d2a:	2b32      	cmp	r3, #50	; 0x32
  410d2c:	d9a4      	bls.n	410c78 <inv_icm20948_base_control_init+0x84>
		}
	}
	s->lLastHwSmplrtDividerAcc = 0;
  410d2e:	687b      	ldr	r3, [r7, #4]
  410d30:	2200      	movs	r2, #0
  410d32:	f8a3 2236 	strh.w	r2, [r3, #566]	; 0x236
	s->lLastHwSmplrtDividerGyr = 0;
  410d36:	687b      	ldr	r3, [r7, #4]
  410d38:	2200      	movs	r2, #0
  410d3a:	f8a3 2238 	strh.w	r2, [r3, #568]	; 0x238
	s->sBatchMode              = 0;
  410d3e:	687b      	ldr	r3, [r7, #4]
  410d40:	2200      	movs	r2, #0
  410d42:	f883 223a 	strb.w	r2, [r3, #570]	; 0x23a
	s->header2_count           = 0;
  410d46:	687b      	ldr	r3, [r7, #4]
  410d48:	2200      	movs	r2, #0
  410d4a:	f883 223b 	strb.w	r2, [r3, #571]	; 0x23b
	s->mems_put_to_sleep       = 1;
  410d4e:	687b      	ldr	r3, [r7, #4]
  410d50:	2201      	movs	r2, #1
  410d52:	f883 223c 	strb.w	r2, [r3, #572]	; 0x23c
	s->smd_status              = 0;
  410d56:	687b      	ldr	r3, [r7, #4]
  410d58:	2200      	movs	r2, #0
  410d5a:	f8a3 223e 	strh.w	r2, [r3, #574]	; 0x23e
	s->ped_int_status          = 0;
  410d5e:	687b      	ldr	r3, [r7, #4]
  410d60:	2200      	movs	r2, #0
  410d62:	f8a3 2240 	strh.w	r2, [r3, #576]	; 0x240
	s->b2s_status              = 0;
  410d66:	687b      	ldr	r3, [r7, #4]
  410d68:	2200      	movs	r2, #0
  410d6a:	f8a3 2156 	strh.w	r2, [r3, #342]	; 0x156
	s->bac_request             = 0;
  410d6e:	687b      	ldr	r3, [r7, #4]
  410d70:	2200      	movs	r2, #0
  410d72:	f8a3 2242 	strh.w	r2, [r3, #578]	; 0x242
	s->odr_acc_ms = INV_ODR_MIN_DELAY;
  410d76:	687b      	ldr	r3, [r7, #4]
  410d78:	22c8      	movs	r2, #200	; 0xc8
  410d7a:	f8a3 2246 	strh.w	r2, [r3, #582]	; 0x246
	//s->odr_acc_wom_ms = INV_ODR_MIN_DELAY;
	s->odr_racc_ms = INV_ODR_MIN_DELAY;
  410d7e:	687b      	ldr	r3, [r7, #4]
  410d80:	22c8      	movs	r2, #200	; 0xc8
  410d82:	f8a3 2248 	strh.w	r2, [r3, #584]	; 0x248
	s->odr_gyr_ms = INV_ODR_MIN_DELAY;
  410d86:	687b      	ldr	r3, [r7, #4]
  410d88:	22c8      	movs	r2, #200	; 0xc8
  410d8a:	f8a3 224a 	strh.w	r2, [r3, #586]	; 0x24a
	s->odr_rgyr_ms = INV_ODR_MIN_DELAY;
  410d8e:	687b      	ldr	r3, [r7, #4]
  410d90:	22c8      	movs	r2, #200	; 0xc8
  410d92:	f8a3 224c 	strh.w	r2, [r3, #588]	; 0x24c

	return result;
  410d96:	68bb      	ldr	r3, [r7, #8]
}
  410d98:	4618      	mov	r0, r3
  410d9a:	3710      	adds	r7, #16
  410d9c:	46bd      	mov	sp, r7
  410d9e:	bd80      	pop	{r7, pc}
  410da0:	00414241 	.word	0x00414241

00410da4 <inv_set_hw_smplrt_dmp_odrs>:

static int inv_set_hw_smplrt_dmp_odrs(struct inv_icm20948 * s)
{
  410da4:	b590      	push	{r4, r7, lr}
  410da6:	b09d      	sub	sp, #116	; 0x74
  410da8:	af00      	add	r7, sp, #0
  410daa:	6078      	str	r0, [r7, #4]
	int result = 0;
  410dac:	2300      	movs	r3, #0
  410dae:	66fb      	str	r3, [r7, #108]	; 0x6c
	unsigned short minDly, minDly_accel, minDly_gyro;
	unsigned short minDly_cpass;
	unsigned short minDly_pressure;
	unsigned short hw_smplrt_divider = 0;
  410db0:	2300      	movs	r3, #0
  410db2:	f8a7 3062 	strh.w	r3, [r7, #98]	; 0x62
	
	const MinDelayGenElementT MinDelayGenPressureList[] = {
  410db6:	4b45      	ldr	r3, [pc, #276]	; (410ecc <inv_set_hw_smplrt_dmp_odrs+0x128>)
  410db8:	681b      	ldr	r3, [r3, #0]
  410dba:	65bb      	str	r3, [r7, #88]	; 0x58
		{ANDROID_SENSOR_PRESSURE,                           INV_SENSOR_PRESSURE             },
		{ANDROID_SENSOR_WAKEUP_PRESSURE,                    INV_SENSOR_WAKEUP_PRESSURE      }
	};
	const MinDelayGenElementT MinDelayGenAccel2List[] = {
  410dbc:	4a44      	ldr	r2, [pc, #272]	; (410ed0 <inv_set_hw_smplrt_dmp_odrs+0x12c>)
  410dbe:	f107 034c 	add.w	r3, r7, #76	; 0x4c
  410dc2:	ca07      	ldmia	r2, {r0, r1, r2}
  410dc4:	c303      	stmia	r3!, {r0, r1}
  410dc6:	801a      	strh	r2, [r3, #0]
		{ANDROID_SENSOR_WAKEUP_ACCELEROMETER,               INV_SENSOR_WAKEUP_ACCEL         },
		{ANDROID_SENSOR_RAW_ACCELEROMETER,                  INV_SENSOR_ACCEL                },
		{ANDROID_SENSOR_LINEAR_ACCELERATION,                INV_SENSOR_SIXQ_accel           },
		{ANDROID_SENSOR_WAKEUP_LINEAR_ACCELERATION,         INV_SENSOR_WAKEUP_SIXQ_accel    }
	};
	const MinDelayGenElementT MinDelayGenAccel3List[] = {
  410dc8:	4b42      	ldr	r3, [pc, #264]	; (410ed4 <inv_set_hw_smplrt_dmp_odrs+0x130>)
  410dca:	681b      	ldr	r3, [r3, #0]
  410dcc:	64bb      	str	r3, [r7, #72]	; 0x48
		{ANDROID_SENSOR_GEOMAGNETIC_ROTATION_VECTOR,        INV_SENSOR_GEOMAG               },
		{ANDROID_SENSOR_WAKEUP_GEOMAGNETIC_ROTATION_VECTOR, INV_SENSOR_WAKEUP_GEOMAG        }
	};
	const MinDelayGenElementT MinDelayGenAccel4List[] = {
  410dce:	4a42      	ldr	r2, [pc, #264]	; (410ed8 <inv_set_hw_smplrt_dmp_odrs+0x134>)
  410dd0:	f107 033c 	add.w	r3, r7, #60	; 0x3c
  410dd4:	ca07      	ldmia	r2, {r0, r1, r2}
  410dd6:	c303      	stmia	r3!, {r0, r1}
  410dd8:	801a      	strh	r2, [r3, #0]
		{ANDROID_SENSOR_STEP_COUNTER,                       INV_SENSOR_STEP_COUNTER         },
		{ANDROID_SENSOR_WAKEUP_STEP_DETECTOR,               INV_SENSOR_WAKEUP_STEP_COUNTER  },
		{ANDROID_SENSOR_WAKEUP_STEP_COUNTER,                INV_SENSOR_WAKEUP_STEP_COUNTER  },
		{ANDROID_SENSOR_WAKEUP_SIGNIFICANT_MOTION,          INV_SENSOR_WAKEUP_STEP_COUNTER  }
	};
	const MinDelayGenElementT MinDelayGenGyro2List[] = {
  410dda:	4a40      	ldr	r2, [pc, #256]	; (410edc <inv_set_hw_smplrt_dmp_odrs+0x138>)
  410ddc:	f107 0330 	add.w	r3, r7, #48	; 0x30
  410de0:	ca07      	ldmia	r2, {r0, r1, r2}
  410de2:	c303      	stmia	r3!, {r0, r1}
  410de4:	801a      	strh	r2, [r3, #0]
		{ANDROID_SENSOR_WAKEUP_GYROSCOPE_UNCALIBRATED,      INV_SENSOR_WAKEUP_GYRO          },
		{ANDROID_SENSOR_GYROSCOPE,                          INV_SENSOR_CALIB_GYRO           },
		{ANDROID_SENSOR_RAW_GYROSCOPE,                      INV_SENSOR_GYRO           },
		{ANDROID_SENSOR_WAKEUP_GYROSCOPE,                   INV_SENSOR_WAKEUP_CALIB_GYRO    }
	};
	const MinDelayGenElementT MinDelayGenGyro3List[] = {
  410de6:	4b3e      	ldr	r3, [pc, #248]	; (410ee0 <inv_set_hw_smplrt_dmp_odrs+0x13c>)
  410de8:	681b      	ldr	r3, [r3, #0]
  410dea:	62fb      	str	r3, [r7, #44]	; 0x2c
		{ANDROID_SENSOR_GYROSCOPE,                          INV_SENSOR_CALIB_GYRO           },
		{ANDROID_SENSOR_WAKEUP_GYROSCOPE,                   INV_SENSOR_WAKEUP_CALIB_GYRO    }
	};
	const MinDelayGenElementT MinDelayGenGyro4List[] = {
  410dec:	4a3d      	ldr	r2, [pc, #244]	; (410ee4 <inv_set_hw_smplrt_dmp_odrs+0x140>)
  410dee:	f107 0320 	add.w	r3, r7, #32
  410df2:	ca07      	ldmia	r2, {r0, r1, r2}
  410df4:	e883 0007 	stmia.w	r3, {r0, r1, r2}
		{ANDROID_SENSOR_LINEAR_ACCELERATION,                INV_SENSOR_SIXQ                 },
		{ANDROID_SENSOR_WAKEUP_GRAVITY,                     INV_SENSOR_WAKEUP_SIXQ          },
		{ANDROID_SENSOR_WAKEUP_GAME_ROTATION_VECTOR,        INV_SENSOR_WAKEUP_SIXQ          },
		{ANDROID_SENSOR_WAKEUP_LINEAR_ACCELERATION,         INV_SENSOR_WAKEUP_SIXQ          }
	};
	const MinDelayGenElementT MinDelayGenGyro5List[] = {
  410df8:	4a3b      	ldr	r2, [pc, #236]	; (410ee8 <inv_set_hw_smplrt_dmp_odrs+0x144>)
  410dfa:	f107 0318 	add.w	r3, r7, #24
  410dfe:	e892 0003 	ldmia.w	r2, {r0, r1}
  410e02:	e883 0003 	stmia.w	r3, {r0, r1}
		{ANDROID_SENSOR_ORIENTATION,                        INV_SENSOR_NINEQ                },
		{ANDROID_SENSOR_ROTATION_VECTOR,                    INV_SENSOR_NINEQ                },
		{ANDROID_SENSOR_WAKEUP_ORIENTATION,                 INV_SENSOR_WAKEUP_NINEQ         },
		{ANDROID_SENSOR_WAKEUP_ROTATION_VECTOR,             INV_SENSOR_WAKEUP_NINEQ         }
	};
	const MinDelayGenElementT MinDelayGenCpass2List[] = {
  410e06:	4b39      	ldr	r3, [pc, #228]	; (410eec <inv_set_hw_smplrt_dmp_odrs+0x148>)
  410e08:	681b      	ldr	r3, [r3, #0]
  410e0a:	617b      	str	r3, [r7, #20]
		{ANDROID_SENSOR_MAGNETIC_FIELD_UNCALIBRATED,        INV_SENSOR_COMPASS              },
		{ANDROID_SENSOR_WAKEUP_MAGNETIC_FIELD_UNCALIBRATED,	INV_SENSOR_WAKEUP_COMPASS       }
	};
	const MinDelayGenElementT MinDelayGenCpass3List[] = {
  410e0c:	4b38      	ldr	r3, [pc, #224]	; (410ef0 <inv_set_hw_smplrt_dmp_odrs+0x14c>)
  410e0e:	681b      	ldr	r3, [r3, #0]
  410e10:	613b      	str	r3, [r7, #16]
		{ANDROID_SENSOR_GEOMAGNETIC_FIELD,                  INV_SENSOR_CALIB_COMPASS        },
		{ANDROID_SENSOR_WAKEUP_MAGNETIC_FIELD,              INV_SENSOR_WAKEUP_CALIB_COMPASS }
	};
	const MinDelayGenElementT MinDelayGenPressure2List[] = {
  410e12:	4b2e      	ldr	r3, [pc, #184]	; (410ecc <inv_set_hw_smplrt_dmp_odrs+0x128>)
  410e14:	681b      	ldr	r3, [r3, #0]
  410e16:	60fb      	str	r3, [r7, #12]
		{ANDROID_SENSOR_PRESSURE,                           INV_SENSOR_PRESSURE             },
		{ANDROID_SENSOR_WAKEUP_PRESSURE,                    INV_SENSOR_WAKEUP_PRESSURE      }
	};
	
	// Engine ACCEL Based
	minDly_accel = getMinDlyAccel(s);
  410e18:	6878      	ldr	r0, [r7, #4]
  410e1a:	4b36      	ldr	r3, [pc, #216]	; (410ef4 <inv_set_hw_smplrt_dmp_odrs+0x150>)
  410e1c:	4798      	blx	r3
  410e1e:	4603      	mov	r3, r0
  410e20:	f8a7 306a 	strh.w	r3, [r7, #106]	; 0x6a

	// Engine Gyro Based
	minDly_gyro  = getMinDlyGyro(s);
  410e24:	6878      	ldr	r0, [r7, #4]
  410e26:	4b34      	ldr	r3, [pc, #208]	; (410ef8 <inv_set_hw_smplrt_dmp_odrs+0x154>)
  410e28:	4798      	blx	r3
  410e2a:	4603      	mov	r3, r0
  410e2c:	f8a7 3068 	strh.w	r3, [r7, #104]	; 0x68

	// Engine Cpass Based	
	minDly_cpass = getMinDlyCompass(s);
  410e30:	6878      	ldr	r0, [r7, #4]
  410e32:	4b32      	ldr	r3, [pc, #200]	; (410efc <inv_set_hw_smplrt_dmp_odrs+0x158>)
  410e34:	4798      	blx	r3
  410e36:	4603      	mov	r3, r0
  410e38:	f8a7 3066 	strh.w	r3, [r7, #102]	; 0x66

	// Engine Pressure Based	
	minDly_pressure	=	MinDelayGen	(s, MinDelayGenPressureList);
  410e3c:	f107 0358 	add.w	r3, r7, #88	; 0x58
  410e40:	2202      	movs	r2, #2
  410e42:	4619      	mov	r1, r3
  410e44:	6878      	ldr	r0, [r7, #4]
  410e46:	4b2e      	ldr	r3, [pc, #184]	; (410f00 <inv_set_hw_smplrt_dmp_odrs+0x15c>)
  410e48:	4798      	blx	r3
  410e4a:	4603      	mov	r3, r0
  410e4c:	f8a7 3064 	strh.w	r3, [r7, #100]	; 0x64

	// get min delay of all enabled sensors of all sensor engine groups
	minDly = min(minDly_gyro, minDly_accel);
  410e50:	f8b7 206a 	ldrh.w	r2, [r7, #106]	; 0x6a
  410e54:	f8b7 3068 	ldrh.w	r3, [r7, #104]	; 0x68
  410e58:	4293      	cmp	r3, r2
  410e5a:	bf28      	it	cs
  410e5c:	4613      	movcs	r3, r2
  410e5e:	f8a7 3060 	strh.w	r3, [r7, #96]	; 0x60
	minDly = min(minDly, minDly_cpass);
  410e62:	f8b7 2066 	ldrh.w	r2, [r7, #102]	; 0x66
  410e66:	f8b7 3060 	ldrh.w	r3, [r7, #96]	; 0x60
  410e6a:	4293      	cmp	r3, r2
  410e6c:	bf28      	it	cs
  410e6e:	4613      	movcs	r3, r2
  410e70:	f8a7 3060 	strh.w	r3, [r7, #96]	; 0x60
	minDly = min(minDly, minDly_pressure);
  410e74:	f8b7 2064 	ldrh.w	r2, [r7, #100]	; 0x64
  410e78:	f8b7 3060 	ldrh.w	r3, [r7, #96]	; 0x60
  410e7c:	4293      	cmp	r3, r2
  410e7e:	bf28      	it	cs
  410e80:	4613      	movcs	r3, r2
  410e82:	f8a7 3060 	strh.w	r3, [r7, #96]	; 0x60
	
	// switch between low power and low noise at 500Hz boundary
	if (minDly != 0xFFFF) {
  410e86:	f8b7 3060 	ldrh.w	r3, [r7, #96]	; 0x60
  410e8a:	f64f 72ff 	movw	r2, #65535	; 0xffff
  410e8e:	4293      	cmp	r3, r2
  410e90:	d03c      	beq.n	410f0c <inv_set_hw_smplrt_dmp_odrs+0x168>
		// above 500Hz boundary, force LN mode
		if (minDly==1) {
  410e92:	f8b7 3060 	ldrh.w	r3, [r7, #96]	; 0x60
  410e96:	2b01      	cmp	r3, #1
  410e98:	d10b      	bne.n	410eb2 <inv_set_hw_smplrt_dmp_odrs+0x10e>
			if (s->base_state.chip_lp_ln_mode == CHIP_LOW_POWER_ICM20948) {
  410e9a:	687b      	ldr	r3, [r7, #4]
  410e9c:	7e5b      	ldrb	r3, [r3, #25]
  410e9e:	2b01      	cmp	r3, #1
  410ea0:	d140      	bne.n	410f24 <inv_set_hw_smplrt_dmp_odrs+0x180>
				s->go_back_lp_when_odr_low = 1;
  410ea2:	687b      	ldr	r3, [r7, #4]
  410ea4:	2201      	movs	r2, #1
  410ea6:	f883 2244 	strb.w	r2, [r3, #580]	; 0x244
				inv_icm20948_enter_low_noise_mode(s);
  410eaa:	6878      	ldr	r0, [r7, #4]
  410eac:	4b15      	ldr	r3, [pc, #84]	; (410f04 <inv_set_hw_smplrt_dmp_odrs+0x160>)
  410eae:	4798      	blx	r3
  410eb0:	e038      	b.n	410f24 <inv_set_hw_smplrt_dmp_odrs+0x180>
			}
		} else { // below 500 Hz boundary, go back to originally requested mode
			if (s->go_back_lp_when_odr_low) {
  410eb2:	687b      	ldr	r3, [r7, #4]
  410eb4:	f893 3244 	ldrb.w	r3, [r3, #580]	; 0x244
  410eb8:	2b00      	cmp	r3, #0
  410eba:	d033      	beq.n	410f24 <inv_set_hw_smplrt_dmp_odrs+0x180>
				s->go_back_lp_when_odr_low = 0;
  410ebc:	687b      	ldr	r3, [r7, #4]
  410ebe:	2200      	movs	r2, #0
  410ec0:	f883 2244 	strb.w	r2, [r3, #580]	; 0x244
				inv_icm20948_enter_duty_cycle_mode(s);
  410ec4:	6878      	ldr	r0, [r7, #4]
  410ec6:	4b10      	ldr	r3, [pc, #64]	; (410f08 <inv_set_hw_smplrt_dmp_odrs+0x164>)
  410ec8:	4798      	blx	r3
  410eca:	e02b      	b.n	410f24 <inv_set_hw_smplrt_dmp_odrs+0x180>
  410ecc:	0041d1a8 	.word	0x0041d1a8
  410ed0:	0041d1ac 	.word	0x0041d1ac
  410ed4:	0041d1b8 	.word	0x0041d1b8
  410ed8:	0041d1bc 	.word	0x0041d1bc
  410edc:	0041d1c8 	.word	0x0041d1c8
  410ee0:	0041d1d4 	.word	0x0041d1d4
  410ee4:	0041d1d8 	.word	0x0041d1d8
  410ee8:	0041d1e4 	.word	0x0041d1e4
  410eec:	0041d1ec 	.word	0x0041d1ec
  410ef0:	0041d1f0 	.word	0x0041d1f0
  410ef4:	00410911 	.word	0x00410911
  410ef8:	00410a79 	.word	0x00410a79
  410efc:	00410b69 	.word	0x00410b69
  410f00:	004107f1 	.word	0x004107f1
  410f04:	00405add 	.word	0x00405add
  410f08:	00405aad 	.word	0x00405aad
			}	
		}
	} else // all sensors are turned OFF, force originally requested mode
	{
		if (s->go_back_lp_when_odr_low) {
  410f0c:	687b      	ldr	r3, [r7, #4]
  410f0e:	f893 3244 	ldrb.w	r3, [r3, #580]	; 0x244
  410f12:	2b00      	cmp	r3, #0
  410f14:	d006      	beq.n	410f24 <inv_set_hw_smplrt_dmp_odrs+0x180>
			s->go_back_lp_when_odr_low = 0;
  410f16:	687b      	ldr	r3, [r7, #4]
  410f18:	2200      	movs	r2, #0
  410f1a:	f883 2244 	strb.w	r2, [r3, #580]	; 0x244
			inv_icm20948_enter_duty_cycle_mode(s);
  410f1e:	6878      	ldr	r0, [r7, #4]
  410f20:	4bbf      	ldr	r3, [pc, #764]	; (411220 <inv_set_hw_smplrt_dmp_odrs+0x47c>)
  410f22:	4798      	blx	r3
		}
	}
	
	if (minDly_accel != 0xFFFF)    minDly_accel = minDly;
  410f24:	f8b7 306a 	ldrh.w	r3, [r7, #106]	; 0x6a
  410f28:	f64f 72ff 	movw	r2, #65535	; 0xffff
  410f2c:	4293      	cmp	r3, r2
  410f2e:	d003      	beq.n	410f38 <inv_set_hw_smplrt_dmp_odrs+0x194>
  410f30:	f8b7 3060 	ldrh.w	r3, [r7, #96]	; 0x60
  410f34:	f8a7 306a 	strh.w	r3, [r7, #106]	; 0x6a
	if (minDly_gyro  != 0xFFFF)    minDly_gyro  = minDly;
  410f38:	f8b7 3068 	ldrh.w	r3, [r7, #104]	; 0x68
  410f3c:	f64f 72ff 	movw	r2, #65535	; 0xffff
  410f40:	4293      	cmp	r3, r2
  410f42:	d003      	beq.n	410f4c <inv_set_hw_smplrt_dmp_odrs+0x1a8>
  410f44:	f8b7 3060 	ldrh.w	r3, [r7, #96]	; 0x60
  410f48:	f8a7 3068 	strh.w	r3, [r7, #104]	; 0x68
	if (minDly_cpass != 0xFFFF)    minDly_cpass = minDly;
  410f4c:	f8b7 3066 	ldrh.w	r3, [r7, #102]	; 0x66
  410f50:	f64f 72ff 	movw	r2, #65535	; 0xffff
  410f54:	4293      	cmp	r3, r2
  410f56:	d003      	beq.n	410f60 <inv_set_hw_smplrt_dmp_odrs+0x1bc>
  410f58:	f8b7 3060 	ldrh.w	r3, [r7, #96]	; 0x60
  410f5c:	f8a7 3066 	strh.w	r3, [r7, #102]	; 0x66
	if (minDly_pressure != 0xFFFF) minDly_pressure = minDly;
  410f60:	f8b7 3064 	ldrh.w	r3, [r7, #100]	; 0x64
  410f64:	f64f 72ff 	movw	r2, #65535	; 0xffff
  410f68:	4293      	cmp	r3, r2
  410f6a:	d003      	beq.n	410f74 <inv_set_hw_smplrt_dmp_odrs+0x1d0>
  410f6c:	f8b7 3060 	ldrh.w	r3, [r7, #96]	; 0x60
  410f70:	f8a7 3064 	strh.w	r3, [r7, #100]	; 0x64

	if (s->bac_request != 0) {
  410f74:	687b      	ldr	r3, [r7, #4]
  410f76:	f8b3 3242 	ldrh.w	r3, [r3, #578]	; 0x242
  410f7a:	2b00      	cmp	r3, #0
  410f7c:	d035      	beq.n	410fea <inv_set_hw_smplrt_dmp_odrs+0x246>
		unsigned short lBACMinDly = min(INV_ODR_DEFAULT_BAC, minDly_accel);
  410f7e:	f8b7 306a 	ldrh.w	r3, [r7, #106]	; 0x6a
  410f82:	2b12      	cmp	r3, #18
  410f84:	bf28      	it	cs
  410f86:	2312      	movcs	r3, #18
  410f88:	f8a7 305e 	strh.w	r3, [r7, #94]	; 0x5e
		// estimate closest decimator value to have 56Hz multiple and apply it
		lBACMinDly = 1000/(get_multiple_56_rate(lBACMinDly));
  410f8c:	f8b7 305e 	ldrh.w	r3, [r7, #94]	; 0x5e
  410f90:	4618      	mov	r0, r3
  410f92:	4ba4      	ldr	r3, [pc, #656]	; (411224 <inv_set_hw_smplrt_dmp_odrs+0x480>)
  410f94:	4798      	blx	r3
  410f96:	4603      	mov	r3, r0
  410f98:	461a      	mov	r2, r3
  410f9a:	f44f 737a 	mov.w	r3, #1000	; 0x3e8
  410f9e:	fb93 f3f2 	sdiv	r3, r3, r2
  410fa2:	f8a7 305e 	strh.w	r3, [r7, #94]	; 0x5e
		dmp_icm20948_set_bac_rate(s, get_multiple_56_rate(lBACMinDly));
  410fa6:	f8b7 305e 	ldrh.w	r3, [r7, #94]	; 0x5e
  410faa:	4618      	mov	r0, r3
  410fac:	4b9d      	ldr	r3, [pc, #628]	; (411224 <inv_set_hw_smplrt_dmp_odrs+0x480>)
  410fae:	4798      	blx	r3
  410fb0:	4603      	mov	r3, r0
  410fb2:	4619      	mov	r1, r3
  410fb4:	6878      	ldr	r0, [r7, #4]
  410fb6:	4b9c      	ldr	r3, [pc, #624]	; (411228 <inv_set_hw_smplrt_dmp_odrs+0x484>)
  410fb8:	4798      	blx	r3
		minDly_accel = lBACMinDly;
  410fba:	f8b7 305e 	ldrh.w	r3, [r7, #94]	; 0x5e
  410fbe:	f8a7 306a 	strh.w	r3, [r7, #106]	; 0x6a
		hw_smplrt_divider = SampleRateDividerGet(minDly_accel);
  410fc2:	f8b7 306a 	ldrh.w	r3, [r7, #106]	; 0x6a
  410fc6:	4618      	mov	r0, r3
  410fc8:	4b98      	ldr	r3, [pc, #608]	; (41122c <inv_set_hw_smplrt_dmp_odrs+0x488>)
  410fca:	4798      	blx	r3
  410fcc:	4603      	mov	r3, r0
  410fce:	f8a7 3062 	strh.w	r3, [r7, #98]	; 0x62
		result |= DividerRateSet(s, lBACMinDly, hw_smplrt_divider, INV_SENSOR_ACTIVITY_CLASSIFIER);
  410fd2:	f8b7 2062 	ldrh.w	r2, [r7, #98]	; 0x62
  410fd6:	f8b7 105e 	ldrh.w	r1, [r7, #94]	; 0x5e
  410fda:	230d      	movs	r3, #13
  410fdc:	6878      	ldr	r0, [r7, #4]
  410fde:	4c94      	ldr	r4, [pc, #592]	; (411230 <inv_set_hw_smplrt_dmp_odrs+0x48c>)
  410fe0:	47a0      	blx	r4
  410fe2:	4602      	mov	r2, r0
  410fe4:	6efb      	ldr	r3, [r7, #108]	; 0x6c
  410fe6:	4313      	orrs	r3, r2
  410fe8:	66fb      	str	r3, [r7, #108]	; 0x6c
	}
	if (s->b2s_status != 0) {
  410fea:	687b      	ldr	r3, [r7, #4]
  410fec:	f8b3 3156 	ldrh.w	r3, [r3, #342]	; 0x156
  410ff0:	2b00      	cmp	r3, #0
  410ff2:	d035      	beq.n	411060 <inv_set_hw_smplrt_dmp_odrs+0x2bc>
		unsigned short lB2SMinDly = min(INV_ODR_DEFAULT_B2S, minDly_accel);
  410ff4:	f8b7 306a 	ldrh.w	r3, [r7, #106]	; 0x6a
  410ff8:	2b12      	cmp	r3, #18
  410ffa:	bf28      	it	cs
  410ffc:	2312      	movcs	r3, #18
  410ffe:	f8a7 305c 	strh.w	r3, [r7, #92]	; 0x5c
		lB2SMinDly = 1000/(get_multiple_56_rate(lB2SMinDly));
  411002:	f8b7 305c 	ldrh.w	r3, [r7, #92]	; 0x5c
  411006:	4618      	mov	r0, r3
  411008:	4b86      	ldr	r3, [pc, #536]	; (411224 <inv_set_hw_smplrt_dmp_odrs+0x480>)
  41100a:	4798      	blx	r3
  41100c:	4603      	mov	r3, r0
  41100e:	461a      	mov	r2, r3
  411010:	f44f 737a 	mov.w	r3, #1000	; 0x3e8
  411014:	fb93 f3f2 	sdiv	r3, r3, r2
  411018:	f8a7 305c 	strh.w	r3, [r7, #92]	; 0x5c
		dmp_icm20948_set_b2s_rate(s, get_multiple_56_rate(lB2SMinDly));
  41101c:	f8b7 305c 	ldrh.w	r3, [r7, #92]	; 0x5c
  411020:	4618      	mov	r0, r3
  411022:	4b80      	ldr	r3, [pc, #512]	; (411224 <inv_set_hw_smplrt_dmp_odrs+0x480>)
  411024:	4798      	blx	r3
  411026:	4603      	mov	r3, r0
  411028:	4619      	mov	r1, r3
  41102a:	6878      	ldr	r0, [r7, #4]
  41102c:	4b81      	ldr	r3, [pc, #516]	; (411234 <inv_set_hw_smplrt_dmp_odrs+0x490>)
  41102e:	4798      	blx	r3
		minDly_accel = lB2SMinDly;
  411030:	f8b7 305c 	ldrh.w	r3, [r7, #92]	; 0x5c
  411034:	f8a7 306a 	strh.w	r3, [r7, #106]	; 0x6a
		hw_smplrt_divider = SampleRateDividerGet(minDly_accel);
  411038:	f8b7 306a 	ldrh.w	r3, [r7, #106]	; 0x6a
  41103c:	4618      	mov	r0, r3
  41103e:	4b7b      	ldr	r3, [pc, #492]	; (41122c <inv_set_hw_smplrt_dmp_odrs+0x488>)
  411040:	4798      	blx	r3
  411042:	4603      	mov	r3, r0
  411044:	f8a7 3062 	strh.w	r3, [r7, #98]	; 0x62
		result |= DividerRateSet(s, lB2SMinDly, hw_smplrt_divider, INV_SENSOR_BRING_TO_SEE);
  411048:	f8b7 2062 	ldrh.w	r2, [r7, #98]	; 0x62
  41104c:	f8b7 105c 	ldrh.w	r1, [r7, #92]	; 0x5c
  411050:	230f      	movs	r3, #15
  411052:	6878      	ldr	r0, [r7, #4]
  411054:	4c76      	ldr	r4, [pc, #472]	; (411230 <inv_set_hw_smplrt_dmp_odrs+0x48c>)
  411056:	47a0      	blx	r4
  411058:	4602      	mov	r2, r0
  41105a:	6efb      	ldr	r3, [r7, #108]	; 0x6c
  41105c:	4313      	orrs	r3, r2
  41105e:	66fb      	str	r3, [r7, #108]	; 0x6c
	}

	// set odrs for each enabled sensors

	// Engine ACCEL Based
	if (minDly_accel != 0xFFFF)	{ // 0xFFFF -- none accel based sensor enable
  411060:	f8b7 306a 	ldrh.w	r3, [r7, #106]	; 0x6a
  411064:	f64f 72ff 	movw	r2, #65535	; 0xffff
  411068:	4293      	cmp	r3, r2
  41106a:	d06d      	beq.n	411148 <inv_set_hw_smplrt_dmp_odrs+0x3a4>
		hw_smplrt_divider = SampleRateDividerGet(minDly_accel);
  41106c:	f8b7 306a 	ldrh.w	r3, [r7, #106]	; 0x6a
  411070:	4618      	mov	r0, r3
  411072:	4b6e      	ldr	r3, [pc, #440]	; (41122c <inv_set_hw_smplrt_dmp_odrs+0x488>)
  411074:	4798      	blx	r3
  411076:	4603      	mov	r3, r0
  411078:	f8a7 3062 	strh.w	r3, [r7, #98]	; 0x62

		if (hw_smplrt_divider != s->lLastHwSmplrtDividerAcc) {
  41107c:	687b      	ldr	r3, [r7, #4]
  41107e:	f8b3 3236 	ldrh.w	r3, [r3, #566]	; 0x236
  411082:	f8b7 2062 	ldrh.w	r2, [r7, #98]	; 0x62
  411086:	429a      	cmp	r2, r3
  411088:	d025      	beq.n	4110d6 <inv_set_hw_smplrt_dmp_odrs+0x332>
			
			result |= inv_icm20948_ctrl_set_accel_quaternion_gain(s, hw_smplrt_divider);
  41108a:	f8b7 3062 	ldrh.w	r3, [r7, #98]	; 0x62
  41108e:	4619      	mov	r1, r3
  411090:	6878      	ldr	r0, [r7, #4]
  411092:	4b69      	ldr	r3, [pc, #420]	; (411238 <inv_set_hw_smplrt_dmp_odrs+0x494>)
  411094:	4798      	blx	r3
  411096:	4602      	mov	r2, r0
  411098:	6efb      	ldr	r3, [r7, #108]	; 0x6c
  41109a:	4313      	orrs	r3, r2
  41109c:	66fb      	str	r3, [r7, #108]	; 0x6c
			result |= inv_icm20948_ctrl_set_accel_cal_params(s, hw_smplrt_divider);
  41109e:	f8b7 3062 	ldrh.w	r3, [r7, #98]	; 0x62
  4110a2:	4619      	mov	r1, r3
  4110a4:	6878      	ldr	r0, [r7, #4]
  4110a6:	4b65      	ldr	r3, [pc, #404]	; (41123c <inv_set_hw_smplrt_dmp_odrs+0x498>)
  4110a8:	4798      	blx	r3
  4110aa:	4602      	mov	r2, r0
  4110ac:	6efb      	ldr	r3, [r7, #108]	; 0x6c
  4110ae:	4313      	orrs	r3, r2
  4110b0:	66fb      	str	r3, [r7, #108]	; 0x6c
			result |= inv_icm20948_set_accel_divider(s, hw_smplrt_divider - 1);
  4110b2:	f8b7 3062 	ldrh.w	r3, [r7, #98]	; 0x62
  4110b6:	3b01      	subs	r3, #1
  4110b8:	b29b      	uxth	r3, r3
  4110ba:	b21b      	sxth	r3, r3
  4110bc:	4619      	mov	r1, r3
  4110be:	6878      	ldr	r0, [r7, #4]
  4110c0:	4b5f      	ldr	r3, [pc, #380]	; (411240 <inv_set_hw_smplrt_dmp_odrs+0x49c>)
  4110c2:	4798      	blx	r3
  4110c4:	4602      	mov	r2, r0
  4110c6:	6efb      	ldr	r3, [r7, #108]	; 0x6c
  4110c8:	4313      	orrs	r3, r2
  4110ca:	66fb      	str	r3, [r7, #108]	; 0x6c
			s->lLastHwSmplrtDividerAcc = hw_smplrt_divider;
  4110cc:	687b      	ldr	r3, [r7, #4]
  4110ce:	f8b7 2062 	ldrh.w	r2, [r7, #98]	; 0x62
  4110d2:	f8a3 2236 	strh.w	r2, [r3, #566]	; 0x236
		}

		result |= DividerRateSet(s, MinDelayGen(s, MinDelayGenAccel2List), hw_smplrt_divider, INV_SENSOR_ACCEL);
  4110d6:	f107 034c 	add.w	r3, r7, #76	; 0x4c
  4110da:	2205      	movs	r2, #5
  4110dc:	4619      	mov	r1, r3
  4110de:	6878      	ldr	r0, [r7, #4]
  4110e0:	4b58      	ldr	r3, [pc, #352]	; (411244 <inv_set_hw_smplrt_dmp_odrs+0x4a0>)
  4110e2:	4798      	blx	r3
  4110e4:	4603      	mov	r3, r0
  4110e6:	4619      	mov	r1, r3
  4110e8:	f8b7 2062 	ldrh.w	r2, [r7, #98]	; 0x62
  4110ec:	2300      	movs	r3, #0
  4110ee:	6878      	ldr	r0, [r7, #4]
  4110f0:	4c4f      	ldr	r4, [pc, #316]	; (411230 <inv_set_hw_smplrt_dmp_odrs+0x48c>)
  4110f2:	47a0      	blx	r4
  4110f4:	4602      	mov	r2, r0
  4110f6:	6efb      	ldr	r3, [r7, #108]	; 0x6c
  4110f8:	4313      	orrs	r3, r2
  4110fa:	66fb      	str	r3, [r7, #108]	; 0x6c
		result |= DividerRateSet(s, MinDelayGen(s, MinDelayGenAccel3List), hw_smplrt_divider, INV_SENSOR_GEOMAG);
  4110fc:	f107 0348 	add.w	r3, r7, #72	; 0x48
  411100:	2202      	movs	r2, #2
  411102:	4619      	mov	r1, r3
  411104:	6878      	ldr	r0, [r7, #4]
  411106:	4b4f      	ldr	r3, [pc, #316]	; (411244 <inv_set_hw_smplrt_dmp_odrs+0x4a0>)
  411108:	4798      	blx	r3
  41110a:	4603      	mov	r3, r0
  41110c:	4619      	mov	r1, r3
  41110e:	f8b7 2062 	ldrh.w	r2, [r7, #98]	; 0x62
  411112:	2307      	movs	r3, #7
  411114:	6878      	ldr	r0, [r7, #4]
  411116:	4c46      	ldr	r4, [pc, #280]	; (411230 <inv_set_hw_smplrt_dmp_odrs+0x48c>)
  411118:	47a0      	blx	r4
  41111a:	4602      	mov	r2, r0
  41111c:	6efb      	ldr	r3, [r7, #108]	; 0x6c
  41111e:	4313      	orrs	r3, r2
  411120:	66fb      	str	r3, [r7, #108]	; 0x6c
		result |= DividerRateSet(s, MinDelayGen(s, MinDelayGenAccel4List), hw_smplrt_divider, INV_SENSOR_STEP_COUNTER);
  411122:	f107 033c 	add.w	r3, r7, #60	; 0x3c
  411126:	2205      	movs	r2, #5
  411128:	4619      	mov	r1, r3
  41112a:	6878      	ldr	r0, [r7, #4]
  41112c:	4b45      	ldr	r3, [pc, #276]	; (411244 <inv_set_hw_smplrt_dmp_odrs+0x4a0>)
  41112e:	4798      	blx	r3
  411130:	4603      	mov	r3, r0
  411132:	4619      	mov	r1, r3
  411134:	f8b7 2062 	ldrh.w	r2, [r7, #98]	; 0x62
  411138:	230c      	movs	r3, #12
  41113a:	6878      	ldr	r0, [r7, #4]
  41113c:	4c3c      	ldr	r4, [pc, #240]	; (411230 <inv_set_hw_smplrt_dmp_odrs+0x48c>)
  41113e:	47a0      	blx	r4
  411140:	4602      	mov	r2, r0
  411142:	6efb      	ldr	r3, [r7, #108]	; 0x6c
  411144:	4313      	orrs	r3, r2
  411146:	66fb      	str	r3, [r7, #108]	; 0x6c
		
	}

	// Engine Gyro Based
	if (minDly_gyro != 0xFFFF) { // 0xFFFF -- none gyro based sensor enable
  411148:	f8b7 3068 	ldrh.w	r3, [r7, #104]	; 0x68
  41114c:	f64f 72ff 	movw	r2, #65535	; 0xffff
  411150:	4293      	cmp	r3, r2
  411152:	f000 8085 	beq.w	411260 <inv_set_hw_smplrt_dmp_odrs+0x4bc>
		hw_smplrt_divider = SampleRateDividerGet(minDly_gyro);
  411156:	f8b7 3068 	ldrh.w	r3, [r7, #104]	; 0x68
  41115a:	4618      	mov	r0, r3
  41115c:	4b33      	ldr	r3, [pc, #204]	; (41122c <inv_set_hw_smplrt_dmp_odrs+0x488>)
  41115e:	4798      	blx	r3
  411160:	4603      	mov	r3, r0
  411162:	f8a7 3062 	strh.w	r3, [r7, #98]	; 0x62

		if (hw_smplrt_divider != s->lLastHwSmplrtDividerGyr) {
  411166:	687b      	ldr	r3, [r7, #4]
  411168:	f8b3 3238 	ldrh.w	r3, [r3, #568]	; 0x238
  41116c:	f8b7 2062 	ldrh.w	r2, [r7, #98]	; 0x62
  411170:	429a      	cmp	r2, r3
  411172:	d011      	beq.n	411198 <inv_set_hw_smplrt_dmp_odrs+0x3f4>
			result |= inv_icm20948_set_gyro_divider(s, (unsigned char)(hw_smplrt_divider - 1));
  411174:	f8b7 3062 	ldrh.w	r3, [r7, #98]	; 0x62
  411178:	b2db      	uxtb	r3, r3
  41117a:	3b01      	subs	r3, #1
  41117c:	b2db      	uxtb	r3, r3
  41117e:	4619      	mov	r1, r3
  411180:	6878      	ldr	r0, [r7, #4]
  411182:	4b31      	ldr	r3, [pc, #196]	; (411248 <inv_set_hw_smplrt_dmp_odrs+0x4a4>)
  411184:	4798      	blx	r3
  411186:	4602      	mov	r2, r0
  411188:	6efb      	ldr	r3, [r7, #108]	; 0x6c
  41118a:	4313      	orrs	r3, r2
  41118c:	66fb      	str	r3, [r7, #108]	; 0x6c
			s->lLastHwSmplrtDividerGyr = hw_smplrt_divider;
  41118e:	687b      	ldr	r3, [r7, #4]
  411190:	f8b7 2062 	ldrh.w	r2, [r7, #98]	; 0x62
  411194:	f8a3 2238 	strh.w	r2, [r3, #568]	; 0x238
		}

		result |= DividerRateSet(s, MinDelayGen(s, MinDelayGenGyro2List), hw_smplrt_divider, INV_SENSOR_GYRO);
  411198:	f107 0330 	add.w	r3, r7, #48	; 0x30
  41119c:	2205      	movs	r2, #5
  41119e:	4619      	mov	r1, r3
  4111a0:	6878      	ldr	r0, [r7, #4]
  4111a2:	4b28      	ldr	r3, [pc, #160]	; (411244 <inv_set_hw_smplrt_dmp_odrs+0x4a0>)
  4111a4:	4798      	blx	r3
  4111a6:	4603      	mov	r3, r0
  4111a8:	4619      	mov	r1, r3
  4111aa:	f8b7 2062 	ldrh.w	r2, [r7, #98]	; 0x62
  4111ae:	2301      	movs	r3, #1
  4111b0:	6878      	ldr	r0, [r7, #4]
  4111b2:	4c1f      	ldr	r4, [pc, #124]	; (411230 <inv_set_hw_smplrt_dmp_odrs+0x48c>)
  4111b4:	47a0      	blx	r4
  4111b6:	4602      	mov	r2, r0
  4111b8:	6efb      	ldr	r3, [r7, #108]	; 0x6c
  4111ba:	4313      	orrs	r3, r2
  4111bc:	66fb      	str	r3, [r7, #108]	; 0x6c
		result |= DividerRateSet(s, MinDelayGen(s, MinDelayGenGyro3List), hw_smplrt_divider, INV_SENSOR_CALIB_GYRO);
  4111be:	f107 032c 	add.w	r3, r7, #44	; 0x2c
  4111c2:	2202      	movs	r2, #2
  4111c4:	4619      	mov	r1, r3
  4111c6:	6878      	ldr	r0, [r7, #4]
  4111c8:	4b1e      	ldr	r3, [pc, #120]	; (411244 <inv_set_hw_smplrt_dmp_odrs+0x4a0>)
  4111ca:	4798      	blx	r3
  4111cc:	4603      	mov	r3, r0
  4111ce:	4619      	mov	r1, r3
  4111d0:	f8b7 2062 	ldrh.w	r2, [r7, #98]	; 0x62
  4111d4:	230a      	movs	r3, #10
  4111d6:	6878      	ldr	r0, [r7, #4]
  4111d8:	4c15      	ldr	r4, [pc, #84]	; (411230 <inv_set_hw_smplrt_dmp_odrs+0x48c>)
  4111da:	47a0      	blx	r4
  4111dc:	4602      	mov	r2, r0
  4111de:	6efb      	ldr	r3, [r7, #108]	; 0x6c
  4111e0:	4313      	orrs	r3, r2
  4111e2:	66fb      	str	r3, [r7, #108]	; 0x6c
		result |= DividerRateSet(s, MinDelayGen(s, MinDelayGenGyro4List), hw_smplrt_divider, INV_SENSOR_SIXQ);
  4111e4:	f107 0320 	add.w	r3, r7, #32
  4111e8:	2206      	movs	r2, #6
  4111ea:	4619      	mov	r1, r3
  4111ec:	6878      	ldr	r0, [r7, #4]
  4111ee:	4b15      	ldr	r3, [pc, #84]	; (411244 <inv_set_hw_smplrt_dmp_odrs+0x4a0>)
  4111f0:	4798      	blx	r3
  4111f2:	4603      	mov	r3, r0
  4111f4:	4619      	mov	r1, r3
  4111f6:	f8b7 2062 	ldrh.w	r2, [r7, #98]	; 0x62
  4111fa:	2305      	movs	r3, #5
  4111fc:	6878      	ldr	r0, [r7, #4]
  4111fe:	4c0c      	ldr	r4, [pc, #48]	; (411230 <inv_set_hw_smplrt_dmp_odrs+0x48c>)
  411200:	47a0      	blx	r4
  411202:	4602      	mov	r2, r0
  411204:	6efb      	ldr	r3, [r7, #108]	; 0x6c
  411206:	4313      	orrs	r3, r2
  411208:	66fb      	str	r3, [r7, #108]	; 0x6c
		result |= DividerRateSet(s, MinDelayGen(s, MinDelayGenGyro5List), hw_smplrt_divider, INV_SENSOR_NINEQ);
  41120a:	f107 0318 	add.w	r3, r7, #24
  41120e:	2204      	movs	r2, #4
  411210:	4619      	mov	r1, r3
  411212:	6878      	ldr	r0, [r7, #4]
  411214:	4b0b      	ldr	r3, [pc, #44]	; (411244 <inv_set_hw_smplrt_dmp_odrs+0x4a0>)
  411216:	4798      	blx	r3
  411218:	4603      	mov	r3, r0
  41121a:	4619      	mov	r1, r3
  41121c:	e016      	b.n	41124c <inv_set_hw_smplrt_dmp_odrs+0x4a8>
  41121e:	bf00      	nop
  411220:	00405aad 	.word	0x00405aad
  411224:	00411381 	.word	0x00411381
  411228:	0040856d 	.word	0x0040856d
  41122c:	004108d5 	.word	0x004108d5
  411230:	00410851 	.word	0x00410851
  411234:	00408601 	.word	0x00408601
  411238:	00412325 	.word	0x00412325
  41123c:	004123cd 	.word	0x004123cd
  411240:	00405f0d 	.word	0x00405f0d
  411244:	004107f1 	.word	0x004107f1
  411248:	00405e8d 	.word	0x00405e8d
  41124c:	f8b7 2062 	ldrh.w	r2, [r7, #98]	; 0x62
  411250:	2306      	movs	r3, #6
  411252:	6878      	ldr	r0, [r7, #4]
  411254:	4c46      	ldr	r4, [pc, #280]	; (411370 <inv_set_hw_smplrt_dmp_odrs+0x5cc>)
  411256:	47a0      	blx	r4
  411258:	4602      	mov	r2, r0
  41125a:	6efb      	ldr	r3, [r7, #108]	; 0x6c
  41125c:	4313      	orrs	r3, r2
  41125e:	66fb      	str	r3, [r7, #108]	; 0x6c
	}

	// Engine Cpass and Pressure Based	
	if ((minDly_cpass != 0xFFFF) || (minDly_pressure != 0xFFFF)) {
  411260:	f8b7 3066 	ldrh.w	r3, [r7, #102]	; 0x66
  411264:	f64f 72ff 	movw	r2, #65535	; 0xffff
  411268:	4293      	cmp	r3, r2
  41126a:	d105      	bne.n	411278 <inv_set_hw_smplrt_dmp_odrs+0x4d4>
  41126c:	f8b7 3064 	ldrh.w	r3, [r7, #100]	; 0x64
  411270:	f64f 72ff 	movw	r2, #65535	; 0xffff
  411274:	4293      	cmp	r3, r2
  411276:	d075      	beq.n	411364 <inv_set_hw_smplrt_dmp_odrs+0x5c0>
		unsigned int lI2cEffectiveDivider = 0;
  411278:	2300      	movs	r3, #0
  41127a:	60bb      	str	r3, [r7, #8]

		// if compass or pressure are alone, compute 1st stage divider, otherwise it will be taken from accel or gyro
		if ( (minDly_accel == 0xFFFF) && (minDly_gyro == 0xFFFF) )
  41127c:	f8b7 306a 	ldrh.w	r3, [r7, #106]	; 0x6a
  411280:	f64f 72ff 	movw	r2, #65535	; 0xffff
  411284:	4293      	cmp	r3, r2
  411286:	d10d      	bne.n	4112a4 <inv_set_hw_smplrt_dmp_odrs+0x500>
  411288:	f8b7 3068 	ldrh.w	r3, [r7, #104]	; 0x68
  41128c:	f64f 72ff 	movw	r2, #65535	; 0xffff
  411290:	4293      	cmp	r3, r2
  411292:	d107      	bne.n	4112a4 <inv_set_hw_smplrt_dmp_odrs+0x500>
			hw_smplrt_divider = SampleRateDividerGet(minDly);
  411294:	f8b7 3060 	ldrh.w	r3, [r7, #96]	; 0x60
  411298:	4618      	mov	r0, r3
  41129a:	4b36      	ldr	r3, [pc, #216]	; (411374 <inv_set_hw_smplrt_dmp_odrs+0x5d0>)
  41129c:	4798      	blx	r3
  41129e:	4603      	mov	r3, r0
  4112a0:	f8a7 3062 	strh.w	r3, [r7, #98]	; 0x62

		// Apply compass or pressure ODR to I2C and get effective ODR
		// so that 2nd level of divider can take into account real frequency we can expect
		// to determine its divider value
		result |= inv_icm20948_secondary_set_odr(s, hw_smplrt_divider, &lI2cEffectiveDivider);
  4112a4:	f8b7 3062 	ldrh.w	r3, [r7, #98]	; 0x62
  4112a8:	f107 0208 	add.w	r2, r7, #8
  4112ac:	4619      	mov	r1, r3
  4112ae:	6878      	ldr	r0, [r7, #4]
  4112b0:	4b31      	ldr	r3, [pc, #196]	; (411378 <inv_set_hw_smplrt_dmp_odrs+0x5d4>)
  4112b2:	4798      	blx	r3
  4112b4:	4602      	mov	r2, r0
  4112b6:	6efb      	ldr	r3, [r7, #108]	; 0x6c
  4112b8:	4313      	orrs	r3, r2
  4112ba:	66fb      	str	r3, [r7, #108]	; 0x6c

		// if compass or pressure are alone, recompute 1st stage divider based on configured divider for I2C
		// otherwise divider is taken from accel or gyro, so there is no need to recompute effective divider value
		// based on the divider we just applied
		if ( (minDly_accel == 0xFFFF) && (minDly_gyro == 0xFFFF) )
  4112bc:	f8b7 306a 	ldrh.w	r3, [r7, #106]	; 0x6a
  4112c0:	f64f 72ff 	movw	r2, #65535	; 0xffff
  4112c4:	4293      	cmp	r3, r2
  4112c6:	d108      	bne.n	4112da <inv_set_hw_smplrt_dmp_odrs+0x536>
  4112c8:	f8b7 3068 	ldrh.w	r3, [r7, #104]	; 0x68
  4112cc:	f64f 72ff 	movw	r2, #65535	; 0xffff
  4112d0:	4293      	cmp	r3, r2
  4112d2:	d102      	bne.n	4112da <inv_set_hw_smplrt_dmp_odrs+0x536>
			hw_smplrt_divider = lI2cEffectiveDivider;
  4112d4:	68bb      	ldr	r3, [r7, #8]
  4112d6:	f8a7 3062 	strh.w	r3, [r7, #98]	; 0x62

		if (minDly_cpass != 0xFFFF) {
  4112da:	f8b7 3066 	ldrh.w	r3, [r7, #102]	; 0x66
  4112de:	f64f 72ff 	movw	r2, #65535	; 0xffff
  4112e2:	4293      	cmp	r3, r2
  4112e4:	d025      	beq.n	411332 <inv_set_hw_smplrt_dmp_odrs+0x58e>
			result |= DividerRateSet(s, MinDelayGen(s, MinDelayGenCpass2List), hw_smplrt_divider, INV_SENSOR_COMPASS);
  4112e6:	f107 0314 	add.w	r3, r7, #20
  4112ea:	2202      	movs	r2, #2
  4112ec:	4619      	mov	r1, r3
  4112ee:	6878      	ldr	r0, [r7, #4]
  4112f0:	4b22      	ldr	r3, [pc, #136]	; (41137c <inv_set_hw_smplrt_dmp_odrs+0x5d8>)
  4112f2:	4798      	blx	r3
  4112f4:	4603      	mov	r3, r0
  4112f6:	4619      	mov	r1, r3
  4112f8:	f8b7 2062 	ldrh.w	r2, [r7, #98]	; 0x62
  4112fc:	2303      	movs	r3, #3
  4112fe:	6878      	ldr	r0, [r7, #4]
  411300:	4c1b      	ldr	r4, [pc, #108]	; (411370 <inv_set_hw_smplrt_dmp_odrs+0x5cc>)
  411302:	47a0      	blx	r4
  411304:	4602      	mov	r2, r0
  411306:	6efb      	ldr	r3, [r7, #108]	; 0x6c
  411308:	4313      	orrs	r3, r2
  41130a:	66fb      	str	r3, [r7, #108]	; 0x6c
			result |= DividerRateSet(s, MinDelayGen(s, MinDelayGenCpass3List), hw_smplrt_divider, INV_SENSOR_CALIB_COMPASS);
  41130c:	f107 0310 	add.w	r3, r7, #16
  411310:	2202      	movs	r2, #2
  411312:	4619      	mov	r1, r3
  411314:	6878      	ldr	r0, [r7, #4]
  411316:	4b19      	ldr	r3, [pc, #100]	; (41137c <inv_set_hw_smplrt_dmp_odrs+0x5d8>)
  411318:	4798      	blx	r3
  41131a:	4603      	mov	r3, r0
  41131c:	4619      	mov	r1, r3
  41131e:	f8b7 2062 	ldrh.w	r2, [r7, #98]	; 0x62
  411322:	230b      	movs	r3, #11
  411324:	6878      	ldr	r0, [r7, #4]
  411326:	4c12      	ldr	r4, [pc, #72]	; (411370 <inv_set_hw_smplrt_dmp_odrs+0x5cc>)
  411328:	47a0      	blx	r4
  41132a:	4602      	mov	r2, r0
  41132c:	6efb      	ldr	r3, [r7, #108]	; 0x6c
  41132e:	4313      	orrs	r3, r2
  411330:	66fb      	str	r3, [r7, #108]	; 0x6c
		}

		if (minDly_pressure != 0xFFFF)
  411332:	f8b7 3064 	ldrh.w	r3, [r7, #100]	; 0x64
  411336:	f64f 72ff 	movw	r2, #65535	; 0xffff
  41133a:	4293      	cmp	r3, r2
  41133c:	d012      	beq.n	411364 <inv_set_hw_smplrt_dmp_odrs+0x5c0>
			result |= DividerRateSet(s, MinDelayGen(s, MinDelayGenPressure2List), hw_smplrt_divider, INV_SENSOR_PRESSURE);
  41133e:	f107 030c 	add.w	r3, r7, #12
  411342:	2202      	movs	r2, #2
  411344:	4619      	mov	r1, r3
  411346:	6878      	ldr	r0, [r7, #4]
  411348:	4b0c      	ldr	r3, [pc, #48]	; (41137c <inv_set_hw_smplrt_dmp_odrs+0x5d8>)
  41134a:	4798      	blx	r3
  41134c:	4603      	mov	r3, r0
  41134e:	4619      	mov	r1, r3
  411350:	f8b7 2062 	ldrh.w	r2, [r7, #98]	; 0x62
  411354:	2309      	movs	r3, #9
  411356:	6878      	ldr	r0, [r7, #4]
  411358:	4c05      	ldr	r4, [pc, #20]	; (411370 <inv_set_hw_smplrt_dmp_odrs+0x5cc>)
  41135a:	47a0      	blx	r4
  41135c:	4602      	mov	r2, r0
  41135e:	6efb      	ldr	r3, [r7, #108]	; 0x6c
  411360:	4313      	orrs	r3, r2
  411362:	66fb      	str	r3, [r7, #108]	; 0x6c
	}

	return result;
  411364:	6efb      	ldr	r3, [r7, #108]	; 0x6c
}
  411366:	4618      	mov	r0, r3
  411368:	3774      	adds	r7, #116	; 0x74
  41136a:	46bd      	mov	sp, r7
  41136c:	bd90      	pop	{r4, r7, pc}
  41136e:	bf00      	nop
  411370:	00410851 	.word	0x00410851
  411374:	004108d5 	.word	0x004108d5
  411378:	004056ed 	.word	0x004056ed
  41137c:	004107f1 	.word	0x004107f1

00411380 <get_multiple_56_rate>:

static short get_multiple_56_rate(unsigned short delayInMs)
{
  411380:	b480      	push	{r7}
  411382:	b085      	sub	sp, #20
  411384:	af00      	add	r7, sp, #0
  411386:	4603      	mov	r3, r0
  411388:	80fb      	strh	r3, [r7, #6]
	short lfreq = 0;
  41138a:	2300      	movs	r3, #0
  41138c:	81fb      	strh	r3, [r7, #14]

	// > 1KHz
	if( delayInMs < 2 ){
  41138e:	88fb      	ldrh	r3, [r7, #6]
  411390:	2b01      	cmp	r3, #1
  411392:	d803      	bhi.n	41139c <get_multiple_56_rate+0x1c>
	lfreq = DMP_ALGO_FREQ_900;
  411394:	f44f 7361 	mov.w	r3, #900	; 0x384
  411398:	81fb      	strh	r3, [r7, #14]
  41139a:	e020      	b.n	4113de <get_multiple_56_rate+0x5e>
	}
	// 225Hz - 500Hz
	else if(( delayInMs >= 2 ) && ( delayInMs < 4 )){
  41139c:	88fb      	ldrh	r3, [r7, #6]
  41139e:	2b01      	cmp	r3, #1
  4113a0:	d906      	bls.n	4113b0 <get_multiple_56_rate+0x30>
  4113a2:	88fb      	ldrh	r3, [r7, #6]
  4113a4:	2b03      	cmp	r3, #3
  4113a6:	d803      	bhi.n	4113b0 <get_multiple_56_rate+0x30>
	lfreq = DMP_ALGO_FREQ_450;
  4113a8:	f44f 73e1 	mov.w	r3, #450	; 0x1c2
  4113ac:	81fb      	strh	r3, [r7, #14]
  4113ae:	e016      	b.n	4113de <get_multiple_56_rate+0x5e>
	}
	// 112Hz - 225Hz
	else if(( delayInMs >= 4 ) && ( delayInMs < 8 )){
  4113b0:	88fb      	ldrh	r3, [r7, #6]
  4113b2:	2b03      	cmp	r3, #3
  4113b4:	d905      	bls.n	4113c2 <get_multiple_56_rate+0x42>
  4113b6:	88fb      	ldrh	r3, [r7, #6]
  4113b8:	2b07      	cmp	r3, #7
  4113ba:	d802      	bhi.n	4113c2 <get_multiple_56_rate+0x42>
	lfreq = DMP_ALGO_FREQ_225;
  4113bc:	23e1      	movs	r3, #225	; 0xe1
  4113be:	81fb      	strh	r3, [r7, #14]
  4113c0:	e00d      	b.n	4113de <get_multiple_56_rate+0x5e>
	}
	// 56Hz - 112Hz
	else if(( delayInMs >= 8 ) && ( delayInMs < 17 )){
  4113c2:	88fb      	ldrh	r3, [r7, #6]
  4113c4:	2b07      	cmp	r3, #7
  4113c6:	d905      	bls.n	4113d4 <get_multiple_56_rate+0x54>
  4113c8:	88fb      	ldrh	r3, [r7, #6]
  4113ca:	2b10      	cmp	r3, #16
  4113cc:	d802      	bhi.n	4113d4 <get_multiple_56_rate+0x54>
	lfreq = DMP_ALGO_FREQ_112;
  4113ce:	2370      	movs	r3, #112	; 0x70
  4113d0:	81fb      	strh	r3, [r7, #14]
  4113d2:	e004      	b.n	4113de <get_multiple_56_rate+0x5e>
	}
	// < 56Hz
	else if(delayInMs >= 17){
  4113d4:	88fb      	ldrh	r3, [r7, #6]
  4113d6:	2b10      	cmp	r3, #16
  4113d8:	d901      	bls.n	4113de <get_multiple_56_rate+0x5e>
	lfreq = DMP_ALGO_FREQ_56;
  4113da:	2338      	movs	r3, #56	; 0x38
  4113dc:	81fb      	strh	r3, [r7, #14]
	}
	
	return lfreq;
  4113de:	f9b7 300e 	ldrsh.w	r3, [r7, #14]
}
  4113e2:	4618      	mov	r0, r3
  4113e4:	3714      	adds	r7, #20
  4113e6:	46bd      	mov	sp, r7
  4113e8:	f85d 7b04 	ldr.w	r7, [sp], #4
  4113ec:	4770      	bx	lr
	...

004113f0 <inv_icm20948_set_odr>:

int inv_icm20948_set_odr(struct inv_icm20948 * s, unsigned char androidSensor, unsigned short delayInMs)
{
  4113f0:	b590      	push	{r4, r7, lr}
  4113f2:	b085      	sub	sp, #20
  4113f4:	af00      	add	r7, sp, #0
  4113f6:	6078      	str	r0, [r7, #4]
  4113f8:	460b      	mov	r3, r1
  4113fa:	70fb      	strb	r3, [r7, #3]
  4113fc:	4613      	mov	r3, r2
  4113fe:	803b      	strh	r3, [r7, #0]
	int result;

	if(sensor_needs_compass(androidSensor))
  411400:	78fb      	ldrb	r3, [r7, #3]
  411402:	4618      	mov	r0, r3
  411404:	4bb4      	ldr	r3, [pc, #720]	; (4116d8 <inv_icm20948_set_odr+0x2e8>)
  411406:	4798      	blx	r3
  411408:	4603      	mov	r3, r0
  41140a:	2b00      	cmp	r3, #0
  41140c:	d008      	beq.n	411420 <inv_icm20948_set_odr+0x30>
		if(!inv_icm20948_get_compass_availability(s))
  41140e:	6878      	ldr	r0, [r7, #4]
  411410:	4bb2      	ldr	r3, [pc, #712]	; (4116dc <inv_icm20948_set_odr+0x2ec>)
  411412:	4798      	blx	r3
  411414:	4603      	mov	r3, r0
  411416:	2b00      	cmp	r3, #0
  411418:	d102      	bne.n	411420 <inv_icm20948_set_odr+0x30>
			return -1;
  41141a:	f04f 33ff 	mov.w	r3, #4294967295
  41141e:	e1e3      	b.n	4117e8 <inv_icm20948_set_odr+0x3f8>
	
	//check if sensor is bac algo dependant
	if(sensor_needs_bac_algo(androidSensor)) {
  411420:	78fb      	ldrb	r3, [r7, #3]
  411422:	4618      	mov	r0, r3
  411424:	4bae      	ldr	r3, [pc, #696]	; (4116e0 <inv_icm20948_set_odr+0x2f0>)
  411426:	4798      	blx	r3
  411428:	4603      	mov	r3, r0
  41142a:	2b00      	cmp	r3, #0
  41142c:	d001      	beq.n	411432 <inv_icm20948_set_odr+0x42>
		// set odr for sensors using BAC (1/56)
		delayInMs = INV_ODR_DEFAULT_BAC;
  41142e:	2312      	movs	r3, #18
  411430:	803b      	strh	r3, [r7, #0]
	}
	
	inv_icm20948_prevent_lpen_control(s);
  411432:	6878      	ldr	r0, [r7, #4]
  411434:	4bab      	ldr	r3, [pc, #684]	; (4116e4 <inv_icm20948_set_odr+0x2f4>)
  411436:	4798      	blx	r3

	// check that requested ODR is within the allowed limits
	if (delayInMs < s->inv_androidSensorsOdr_boundaries[androidSensor][0]) delayInMs = s->inv_androidSensorsOdr_boundaries[androidSensor][0];
  411438:	78fa      	ldrb	r2, [r7, #3]
  41143a:	687b      	ldr	r3, [r7, #4]
  41143c:	325a      	adds	r2, #90	; 0x5a
  41143e:	f833 3022 	ldrh.w	r3, [r3, r2, lsl #2]
  411442:	883a      	ldrh	r2, [r7, #0]
  411444:	429a      	cmp	r2, r3
  411446:	d205      	bcs.n	411454 <inv_icm20948_set_odr+0x64>
  411448:	78fa      	ldrb	r2, [r7, #3]
  41144a:	687b      	ldr	r3, [r7, #4]
  41144c:	325a      	adds	r2, #90	; 0x5a
  41144e:	f833 3022 	ldrh.w	r3, [r3, r2, lsl #2]
  411452:	803b      	strh	r3, [r7, #0]
	if (delayInMs > s->inv_androidSensorsOdr_boundaries[androidSensor][1]) delayInMs = s->inv_androidSensorsOdr_boundaries[androidSensor][1];
  411454:	78fb      	ldrb	r3, [r7, #3]
  411456:	687a      	ldr	r2, [r7, #4]
  411458:	009b      	lsls	r3, r3, #2
  41145a:	4413      	add	r3, r2
  41145c:	f8b3 316a 	ldrh.w	r3, [r3, #362]	; 0x16a
  411460:	883a      	ldrh	r2, [r7, #0]
  411462:	429a      	cmp	r2, r3
  411464:	d906      	bls.n	411474 <inv_icm20948_set_odr+0x84>
  411466:	78fb      	ldrb	r3, [r7, #3]
  411468:	687a      	ldr	r2, [r7, #4]
  41146a:	009b      	lsls	r3, r3, #2
  41146c:	4413      	add	r3, r2
  41146e:	f8b3 316a 	ldrh.w	r3, [r3, #362]	; 0x16a
  411472:	803b      	strh	r3, [r7, #0]
	switch (androidSensor) {
  411474:	78fb      	ldrb	r3, [r7, #3]
  411476:	2b30      	cmp	r3, #48	; 0x30
  411478:	f200 819b 	bhi.w	4117b2 <inv_icm20948_set_odr+0x3c2>
  41147c:	a201      	add	r2, pc, #4	; (adr r2, 411484 <inv_icm20948_set_odr+0x94>)
  41147e:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
  411482:	bf00      	nop
  411484:	004117b3 	.word	0x004117b3
  411488:	00411549 	.word	0x00411549
  41148c:	004116af 	.word	0x004116af
  411490:	0041167b 	.word	0x0041167b
  411494:	0041164f 	.word	0x0041164f
  411498:	004116b9 	.word	0x004116b9
  41149c:	00411795 	.word	0x00411795
  4114a0:	004117b3 	.word	0x004117b3
  4114a4:	0041178b 	.word	0x0041178b
  4114a8:	00411659 	.word	0x00411659
  4114ac:	00411659 	.word	0x00411659
  4114b0:	0041167b 	.word	0x0041167b
  4114b4:	004117b3 	.word	0x004117b3
  4114b8:	004117b3 	.word	0x004117b3
  4114bc:	004116a5 	.word	0x004116a5
  4114c0:	00411659 	.word	0x00411659
  4114c4:	004115df 	.word	0x004115df
  4114c8:	004116cd 	.word	0x004116cd
  4114cc:	004115b9 	.word	0x004115b9
  4114d0:	004115b9 	.word	0x004115b9
  4114d4:	004115c3 	.word	0x004115c3
  4114d8:	004117b3 	.word	0x004117b3
  4114dc:	004116b9 	.word	0x004116b9
  4114e0:	004116c3 	.word	0x004116c3
  4114e4:	00411781 	.word	0x00411781
  4114e8:	0041174d 	.word	0x0041174d
  4114ec:	00411721 	.word	0x00411721
  4114f0:	0041178b 	.word	0x0041178b
  4114f4:	0041179f 	.word	0x0041179f
  4114f8:	0041172b 	.word	0x0041172b
  4114fc:	0041172b 	.word	0x0041172b
  411500:	0041174d 	.word	0x0041174d
  411504:	004117b3 	.word	0x004117b3
  411508:	004117b3 	.word	0x004117b3
  41150c:	00411777 	.word	0x00411777
  411510:	0041172b 	.word	0x0041172b
  411514:	00411717 	.word	0x00411717
  411518:	004116cd 	.word	0x004116cd
  41151c:	004116cd 	.word	0x004116cd
  411520:	004116f1 	.word	0x004116f1
  411524:	004117b3 	.word	0x004117b3
  411528:	00411703 	.word	0x00411703
  41152c:	00411581 	.word	0x00411581
  411530:	00411617 	.word	0x00411617
  411534:	004117b3 	.word	0x004117b3
  411538:	0041170d 	.word	0x0041170d
  41153c:	004117a9 	.word	0x004117a9
  411540:	004115d5 	.word	0x004115d5
  411544:	004117b3 	.word	0x004117b3
		case ANDROID_SENSOR_ACCELEROMETER:
			if(inv_icm20948_ctrl_androidSensor_enabled(s, ANDROID_SENSOR_RAW_ACCELEROMETER))
  411548:	212a      	movs	r1, #42	; 0x2a
  41154a:	6878      	ldr	r0, [r7, #4]
  41154c:	4b66      	ldr	r3, [pc, #408]	; (4116e8 <inv_icm20948_set_odr+0x2f8>)
  41154e:	4798      	blx	r3
  411550:	4603      	mov	r3, r0
  411552:	2b00      	cmp	r3, #0
  411554:	d00b      	beq.n	41156e <inv_icm20948_set_odr+0x17e>
				s->inv_dmp_odr_delays[INV_SENSOR_ACCEL] = min(delayInMs,s->odr_racc_ms);
  411556:	687b      	ldr	r3, [r7, #4]
  411558:	f8b3 2248 	ldrh.w	r2, [r3, #584]	; 0x248
  41155c:	883b      	ldrh	r3, [r7, #0]
  41155e:	4293      	cmp	r3, r2
  411560:	bf28      	it	cs
  411562:	4613      	movcs	r3, r2
  411564:	b29a      	uxth	r2, r3
  411566:	687b      	ldr	r3, [r7, #4]
  411568:	f8a3 2106 	strh.w	r2, [r3, #262]	; 0x106
  41156c:	e003      	b.n	411576 <inv_icm20948_set_odr+0x186>
			else
				s->inv_dmp_odr_delays[INV_SENSOR_ACCEL] = delayInMs;
  41156e:	687b      	ldr	r3, [r7, #4]
  411570:	883a      	ldrh	r2, [r7, #0]
  411572:	f8a3 2106 	strh.w	r2, [r3, #262]	; 0x106
			s->odr_acc_ms = delayInMs;
  411576:	687b      	ldr	r3, [r7, #4]
  411578:	883a      	ldrh	r2, [r7, #0]
  41157a:	f8a3 2246 	strh.w	r2, [r3, #582]	; 0x246
			break;
  41157e:	e119      	b.n	4117b4 <inv_icm20948_set_odr+0x3c4>
		case ANDROID_SENSOR_RAW_ACCELEROMETER:
			if(inv_icm20948_ctrl_androidSensor_enabled(s, ANDROID_SENSOR_ACCELEROMETER))
  411580:	2101      	movs	r1, #1
  411582:	6878      	ldr	r0, [r7, #4]
  411584:	4b58      	ldr	r3, [pc, #352]	; (4116e8 <inv_icm20948_set_odr+0x2f8>)
  411586:	4798      	blx	r3
  411588:	4603      	mov	r3, r0
  41158a:	2b00      	cmp	r3, #0
  41158c:	d00b      	beq.n	4115a6 <inv_icm20948_set_odr+0x1b6>
				s->inv_dmp_odr_delays[INV_SENSOR_ACCEL] = min(delayInMs,s->odr_acc_ms);
  41158e:	687b      	ldr	r3, [r7, #4]
  411590:	f8b3 2246 	ldrh.w	r2, [r3, #582]	; 0x246
  411594:	883b      	ldrh	r3, [r7, #0]
  411596:	4293      	cmp	r3, r2
  411598:	bf28      	it	cs
  41159a:	4613      	movcs	r3, r2
  41159c:	b29a      	uxth	r2, r3
  41159e:	687b      	ldr	r3, [r7, #4]
  4115a0:	f8a3 2106 	strh.w	r2, [r3, #262]	; 0x106
  4115a4:	e003      	b.n	4115ae <inv_icm20948_set_odr+0x1be>
			else
				s->inv_dmp_odr_delays[INV_SENSOR_ACCEL] = delayInMs;
  4115a6:	687b      	ldr	r3, [r7, #4]
  4115a8:	883a      	ldrh	r2, [r7, #0]
  4115aa:	f8a3 2106 	strh.w	r2, [r3, #262]	; 0x106
			s->odr_racc_ms = delayInMs;
  4115ae:	687b      	ldr	r3, [r7, #4]
  4115b0:	883a      	ldrh	r2, [r7, #0]
  4115b2:	f8a3 2248 	strh.w	r2, [r3, #584]	; 0x248
			break;
  4115b6:	e0fd      	b.n	4117b4 <inv_icm20948_set_odr+0x3c4>

		case ANDROID_SENSOR_STEP_DETECTOR:
		case ANDROID_SENSOR_STEP_COUNTER:
			s->inv_dmp_odr_delays[INV_SENSOR_STEP_COUNTER] = delayInMs;
  4115b8:	687b      	ldr	r3, [r7, #4]
  4115ba:	883a      	ldrh	r2, [r7, #0]
  4115bc:	f8a3 211e 	strh.w	r2, [r3, #286]	; 0x11e
			break;
  4115c0:	e0f8      	b.n	4117b4 <inv_icm20948_set_odr+0x3c4>

		case ANDROID_SENSOR_GEOMAGNETIC_ROTATION_VECTOR:
			s->inv_dmp_odr_delays[INV_SENSOR_GEOMAG] = delayInMs;
  4115c2:	687b      	ldr	r3, [r7, #4]
  4115c4:	883a      	ldrh	r2, [r7, #0]
  4115c6:	f8a3 2114 	strh.w	r2, [r3, #276]	; 0x114
			s->inv_dmp_odr_delays[INV_SENSOR_GEOMAG_cpass] = delayInMs;
  4115ca:	687b      	ldr	r3, [r7, #4]
  4115cc:	883a      	ldrh	r2, [r7, #0]
  4115ce:	f8a3 212a 	strh.w	r2, [r3, #298]	; 0x12a
			break;
  4115d2:	e0ef      	b.n	4117b4 <inv_icm20948_set_odr+0x3c4>

		case ANDROID_SENSOR_ACTIVITY_CLASSIFICATON:
			s->inv_dmp_odr_delays[INV_SENSOR_ACTIVITY_CLASSIFIER] = delayInMs;
  4115d4:	687b      	ldr	r3, [r7, #4]
  4115d6:	883a      	ldrh	r2, [r7, #0]
  4115d8:	f8a3 2120 	strh.w	r2, [r3, #288]	; 0x120
			break;
  4115dc:	e0ea      	b.n	4117b4 <inv_icm20948_set_odr+0x3c4>

		case ANDROID_SENSOR_GYROSCOPE_UNCALIBRATED:
			if(inv_icm20948_ctrl_androidSensor_enabled(s, ANDROID_SENSOR_RAW_GYROSCOPE))
  4115de:	212b      	movs	r1, #43	; 0x2b
  4115e0:	6878      	ldr	r0, [r7, #4]
  4115e2:	4b41      	ldr	r3, [pc, #260]	; (4116e8 <inv_icm20948_set_odr+0x2f8>)
  4115e4:	4798      	blx	r3
  4115e6:	4603      	mov	r3, r0
  4115e8:	2b00      	cmp	r3, #0
  4115ea:	d00b      	beq.n	411604 <inv_icm20948_set_odr+0x214>
				s->inv_dmp_odr_delays[INV_SENSOR_GYRO] = min(delayInMs,s->odr_rgyr_ms);
  4115ec:	687b      	ldr	r3, [r7, #4]
  4115ee:	f8b3 224c 	ldrh.w	r2, [r3, #588]	; 0x24c
  4115f2:	883b      	ldrh	r3, [r7, #0]
  4115f4:	4293      	cmp	r3, r2
  4115f6:	bf28      	it	cs
  4115f8:	4613      	movcs	r3, r2
  4115fa:	b29a      	uxth	r2, r3
  4115fc:	687b      	ldr	r3, [r7, #4]
  4115fe:	f8a3 2108 	strh.w	r2, [r3, #264]	; 0x108
  411602:	e003      	b.n	41160c <inv_icm20948_set_odr+0x21c>
			else
				s->inv_dmp_odr_delays[INV_SENSOR_GYRO] = delayInMs;
  411604:	687b      	ldr	r3, [r7, #4]
  411606:	883a      	ldrh	r2, [r7, #0]
  411608:	f8a3 2108 	strh.w	r2, [r3, #264]	; 0x108
			s->odr_gyr_ms = delayInMs;
  41160c:	687b      	ldr	r3, [r7, #4]
  41160e:	883a      	ldrh	r2, [r7, #0]
  411610:	f8a3 224a 	strh.w	r2, [r3, #586]	; 0x24a
			break;
  411614:	e0ce      	b.n	4117b4 <inv_icm20948_set_odr+0x3c4>
		case ANDROID_SENSOR_RAW_GYROSCOPE:
			if(inv_icm20948_ctrl_androidSensor_enabled(s, ANDROID_SENSOR_GYROSCOPE_UNCALIBRATED))
  411616:	2110      	movs	r1, #16
  411618:	6878      	ldr	r0, [r7, #4]
  41161a:	4b33      	ldr	r3, [pc, #204]	; (4116e8 <inv_icm20948_set_odr+0x2f8>)
  41161c:	4798      	blx	r3
  41161e:	4603      	mov	r3, r0
  411620:	2b00      	cmp	r3, #0
  411622:	d00b      	beq.n	41163c <inv_icm20948_set_odr+0x24c>
				s->inv_dmp_odr_delays[INV_SENSOR_GYRO] = min(delayInMs,s->odr_gyr_ms);
  411624:	687b      	ldr	r3, [r7, #4]
  411626:	f8b3 224a 	ldrh.w	r2, [r3, #586]	; 0x24a
  41162a:	883b      	ldrh	r3, [r7, #0]
  41162c:	4293      	cmp	r3, r2
  41162e:	bf28      	it	cs
  411630:	4613      	movcs	r3, r2
  411632:	b29a      	uxth	r2, r3
  411634:	687b      	ldr	r3, [r7, #4]
  411636:	f8a3 2108 	strh.w	r2, [r3, #264]	; 0x108
  41163a:	e003      	b.n	411644 <inv_icm20948_set_odr+0x254>
			else
				s->inv_dmp_odr_delays[INV_SENSOR_GYRO] = delayInMs;
  41163c:	687b      	ldr	r3, [r7, #4]
  41163e:	883a      	ldrh	r2, [r7, #0]
  411640:	f8a3 2108 	strh.w	r2, [r3, #264]	; 0x108
			s->odr_rgyr_ms = delayInMs;
  411644:	687b      	ldr	r3, [r7, #4]
  411646:	883a      	ldrh	r2, [r7, #0]
  411648:	f8a3 224c 	strh.w	r2, [r3, #588]	; 0x24c
			break;
  41164c:	e0b2      	b.n	4117b4 <inv_icm20948_set_odr+0x3c4>
		case ANDROID_SENSOR_GYROSCOPE:
			s->inv_dmp_odr_delays[INV_SENSOR_CALIB_GYRO] = delayInMs;
  41164e:	687b      	ldr	r3, [r7, #4]
  411650:	883a      	ldrh	r2, [r7, #0]
  411652:	f8a3 211a 	strh.w	r2, [r3, #282]	; 0x11a
			break;
  411656:	e0ad      	b.n	4117b4 <inv_icm20948_set_odr+0x3c4>
		case ANDROID_SENSOR_GAME_ROTATION_VECTOR:
		case ANDROID_SENSOR_LINEAR_ACCELERATION:
			// if augmented sensors are handled by this driver,
			// then the fastest 6quat-based sensor which is enabled
			// should be applied to all 6quat-based sensors
			delayInMs = inv_icm20948_augmented_sensors_set_odr(s, androidSensor, delayInMs);
  411658:	883a      	ldrh	r2, [r7, #0]
  41165a:	78fb      	ldrb	r3, [r7, #3]
  41165c:	4619      	mov	r1, r3
  41165e:	6878      	ldr	r0, [r7, #4]
  411660:	4b22      	ldr	r3, [pc, #136]	; (4116ec <inv_icm20948_set_odr+0x2fc>)
  411662:	4798      	blx	r3
  411664:	4603      	mov	r3, r0
  411666:	803b      	strh	r3, [r7, #0]
			s->inv_dmp_odr_delays[INV_SENSOR_SIXQ] = delayInMs;
  411668:	687b      	ldr	r3, [r7, #4]
  41166a:	883a      	ldrh	r2, [r7, #0]
  41166c:	f8a3 2110 	strh.w	r2, [r3, #272]	; 0x110
			s->inv_dmp_odr_delays[INV_SENSOR_SIXQ_accel] = delayInMs;
  411670:	687b      	ldr	r3, [r7, #4]
  411672:	883a      	ldrh	r2, [r7, #0]
  411674:	f8a3 2126 	strh.w	r2, [r3, #294]	; 0x126
			break;
  411678:	e09c      	b.n	4117b4 <inv_icm20948_set_odr+0x3c4>
		case ANDROID_SENSOR_ORIENTATION:
		case ANDROID_SENSOR_ROTATION_VECTOR:
			// if augmented sensors are handled by this driver,
			// then the fastest 9quat-based sensor which is enabled
			// should be applied to all 9quat-based sensors
			delayInMs = inv_icm20948_augmented_sensors_set_odr(s, androidSensor, delayInMs);
  41167a:	883a      	ldrh	r2, [r7, #0]
  41167c:	78fb      	ldrb	r3, [r7, #3]
  41167e:	4619      	mov	r1, r3
  411680:	6878      	ldr	r0, [r7, #4]
  411682:	4b1a      	ldr	r3, [pc, #104]	; (4116ec <inv_icm20948_set_odr+0x2fc>)
  411684:	4798      	blx	r3
  411686:	4603      	mov	r3, r0
  411688:	803b      	strh	r3, [r7, #0]
			s->inv_dmp_odr_delays[INV_SENSOR_NINEQ] = delayInMs;
  41168a:	687b      	ldr	r3, [r7, #4]
  41168c:	883a      	ldrh	r2, [r7, #0]
  41168e:	f8a3 2112 	strh.w	r2, [r3, #274]	; 0x112
			s->inv_dmp_odr_delays[INV_SENSOR_NINEQ_accel] = delayInMs;
  411692:	687b      	ldr	r3, [r7, #4]
  411694:	883a      	ldrh	r2, [r7, #0]
  411696:	f8a3 2128 	strh.w	r2, [r3, #296]	; 0x128
			s->inv_dmp_odr_delays[INV_SENSOR_NINEQ_cpass] = delayInMs;
  41169a:	687b      	ldr	r3, [r7, #4]
  41169c:	883a      	ldrh	r2, [r7, #0]
  41169e:	f8a3 212c 	strh.w	r2, [r3, #300]	; 0x12c
			break;
  4116a2:	e087      	b.n	4117b4 <inv_icm20948_set_odr+0x3c4>

		case ANDROID_SENSOR_MAGNETIC_FIELD_UNCALIBRATED:
			s->inv_dmp_odr_delays[INV_SENSOR_COMPASS] = delayInMs;
  4116a4:	687b      	ldr	r3, [r7, #4]
  4116a6:	883a      	ldrh	r2, [r7, #0]
  4116a8:	f8a3 210c 	strh.w	r2, [r3, #268]	; 0x10c
			break;
  4116ac:	e082      	b.n	4117b4 <inv_icm20948_set_odr+0x3c4>

		case ANDROID_SENSOR_GEOMAGNETIC_FIELD:
			s->inv_dmp_odr_delays[INV_SENSOR_CALIB_COMPASS] = delayInMs;
  4116ae:	687b      	ldr	r3, [r7, #4]
  4116b0:	883a      	ldrh	r2, [r7, #0]
  4116b2:	f8a3 211c 	strh.w	r2, [r3, #284]	; 0x11c
			break;
  4116b6:	e07d      	b.n	4117b4 <inv_icm20948_set_odr+0x3c4>

		case ANDROID_SENSOR_LIGHT:
		case ANDROID_SENSOR_PROXIMITY:
			s->inv_dmp_odr_delays[INV_SENSOR_ALS] = delayInMs;
  4116b8:	687b      	ldr	r3, [r7, #4]
  4116ba:	883a      	ldrh	r2, [r7, #0]
  4116bc:	f8a3 210e 	strh.w	r2, [r3, #270]	; 0x10e
			break;
  4116c0:	e078      	b.n	4117b4 <inv_icm20948_set_odr+0x3c4>

		case ANDROID_SENSOR_WAKEUP_ACCELEROMETER:
			s->inv_dmp_odr_delays[INV_SENSOR_WAKEUP_ACCEL] = delayInMs;
  4116c2:	687b      	ldr	r3, [r7, #4]
  4116c4:	883a      	ldrh	r2, [r7, #0]
  4116c6:	f8a3 212e 	strh.w	r2, [r3, #302]	; 0x12e
			break;
  4116ca:	e073      	b.n	4117b4 <inv_icm20948_set_odr+0x3c4>

		case ANDROID_SENSOR_WAKEUP_STEP_DETECTOR:
		case ANDROID_SENSOR_WAKEUP_STEP_COUNTER:
		case ANDROID_SENSOR_WAKEUP_SIGNIFICANT_MOTION:
			s->inv_dmp_odr_delays[INV_SENSOR_WAKEUP_STEP_COUNTER] = delayInMs;
  4116cc:	687b      	ldr	r3, [r7, #4]
  4116ce:	883a      	ldrh	r2, [r7, #0]
  4116d0:	f8a3 2144 	strh.w	r2, [r3, #324]	; 0x144
			break;
  4116d4:	e06e      	b.n	4117b4 <inv_icm20948_set_odr+0x3c4>
  4116d6:	bf00      	nop
  4116d8:	004124c1 	.word	0x004124c1
  4116dc:	00405de9 	.word	0x00405de9
  4116e0:	00412585 	.word	0x00412585
  4116e4:	00405745 	.word	0x00405745
  4116e8:	004107b9 	.word	0x004107b9
  4116ec:	00410155 	.word	0x00410155

		case ANDROID_SENSOR_WAKEUP_GEOMAGNETIC_ROTATION_VECTOR:
			s->inv_dmp_odr_delays[INV_SENSOR_WAKEUP_GEOMAG] = delayInMs;
  4116f0:	687b      	ldr	r3, [r7, #4]
  4116f2:	883a      	ldrh	r2, [r7, #0]
  4116f4:	f8a3 213a 	strh.w	r2, [r3, #314]	; 0x13a
			s->inv_dmp_odr_delays[INV_SENSOR_WAKEUP_GEOMAG_cpass] = delayInMs;
  4116f8:	687b      	ldr	r3, [r7, #4]
  4116fa:	883a      	ldrh	r2, [r7, #0]
  4116fc:	f8a3 214c 	strh.w	r2, [r3, #332]	; 0x14c
			break;
  411700:	e058      	b.n	4117b4 <inv_icm20948_set_odr+0x3c4>

		case ANDROID_SENSOR_WAKEUP_TILT_DETECTOR:
			s->inv_dmp_odr_delays[INV_SENSOR_WAKEUP_TILT_DETECTOR] = delayInMs;
  411702:	687b      	ldr	r3, [r7, #4]
  411704:	883a      	ldrh	r2, [r7, #0]
  411706:	f8a3 2146 	strh.w	r2, [r3, #326]	; 0x146
			break;
  41170a:	e053      	b.n	4117b4 <inv_icm20948_set_odr+0x3c4>

		case ANDROID_SENSOR_B2S:
			s->inv_dmp_odr_delays[INV_SENSOR_BRING_TO_SEE] = delayInMs;
  41170c:	687b      	ldr	r3, [r7, #4]
  41170e:	883a      	ldrh	r2, [r7, #0]
  411710:	f8a3 2124 	strh.w	r2, [r3, #292]	; 0x124
			break;
  411714:	e04e      	b.n	4117b4 <inv_icm20948_set_odr+0x3c4>

		case ANDROID_SENSOR_WAKEUP_GYROSCOPE_UNCALIBRATED:
			s->inv_dmp_odr_delays[INV_SENSOR_WAKEUP_GYRO] = delayInMs;
  411716:	687b      	ldr	r3, [r7, #4]
  411718:	883a      	ldrh	r2, [r7, #0]
  41171a:	f8a3 2130 	strh.w	r2, [r3, #304]	; 0x130
			break;
  41171e:	e049      	b.n	4117b4 <inv_icm20948_set_odr+0x3c4>

		case ANDROID_SENSOR_WAKEUP_GYROSCOPE:
			s->inv_dmp_odr_delays[INV_SENSOR_WAKEUP_CALIB_GYRO] = delayInMs;
  411720:	687b      	ldr	r3, [r7, #4]
  411722:	883a      	ldrh	r2, [r7, #0]
  411724:	f8a3 2140 	strh.w	r2, [r3, #320]	; 0x140
			break;
  411728:	e044      	b.n	4117b4 <inv_icm20948_set_odr+0x3c4>
		case ANDROID_SENSOR_WAKEUP_GAME_ROTATION_VECTOR:
		case ANDROID_SENSOR_WAKEUP_LINEAR_ACCELERATION:
			// if augmented sensors are handled by this driver,
			// then the fastest 6quat-based sensor which is enabled
			// should be applied to all 6quat-based sensors
			delayInMs = inv_icm20948_augmented_sensors_set_odr(s, androidSensor, delayInMs);
  41172a:	883a      	ldrh	r2, [r7, #0]
  41172c:	78fb      	ldrb	r3, [r7, #3]
  41172e:	4619      	mov	r1, r3
  411730:	6878      	ldr	r0, [r7, #4]
  411732:	4b2f      	ldr	r3, [pc, #188]	; (4117f0 <inv_icm20948_set_odr+0x400>)
  411734:	4798      	blx	r3
  411736:	4603      	mov	r3, r0
  411738:	803b      	strh	r3, [r7, #0]
			s->inv_dmp_odr_delays[INV_SENSOR_WAKEUP_SIXQ] = delayInMs;
  41173a:	687b      	ldr	r3, [r7, #4]
  41173c:	883a      	ldrh	r2, [r7, #0]
  41173e:	f8a3 2136 	strh.w	r2, [r3, #310]	; 0x136
			s->inv_dmp_odr_delays[INV_SENSOR_WAKEUP_SIXQ_accel] = delayInMs;
  411742:	687b      	ldr	r3, [r7, #4]
  411744:	883a      	ldrh	r2, [r7, #0]
  411746:	f8a3 2148 	strh.w	r2, [r3, #328]	; 0x148
			break;
  41174a:	e033      	b.n	4117b4 <inv_icm20948_set_odr+0x3c4>
		case ANDROID_SENSOR_WAKEUP_ORIENTATION:
		case ANDROID_SENSOR_WAKEUP_ROTATION_VECTOR:
			// if augmented sensors are handled by this driver,
			// then the fastest 9quat-based sensor which is enabled
			// should be applied to all 9quat-based sensors
			delayInMs = inv_icm20948_augmented_sensors_set_odr(s, androidSensor, delayInMs);
  41174c:	883a      	ldrh	r2, [r7, #0]
  41174e:	78fb      	ldrb	r3, [r7, #3]
  411750:	4619      	mov	r1, r3
  411752:	6878      	ldr	r0, [r7, #4]
  411754:	4b26      	ldr	r3, [pc, #152]	; (4117f0 <inv_icm20948_set_odr+0x400>)
  411756:	4798      	blx	r3
  411758:	4603      	mov	r3, r0
  41175a:	803b      	strh	r3, [r7, #0]
			s->inv_dmp_odr_delays[INV_SENSOR_WAKEUP_NINEQ] = delayInMs;
  41175c:	687b      	ldr	r3, [r7, #4]
  41175e:	883a      	ldrh	r2, [r7, #0]
  411760:	f8a3 2138 	strh.w	r2, [r3, #312]	; 0x138
			s->inv_dmp_odr_delays[INV_SENSOR_WAKEUP_NINEQ_accel] = delayInMs;
  411764:	687b      	ldr	r3, [r7, #4]
  411766:	883a      	ldrh	r2, [r7, #0]
  411768:	f8a3 214a 	strh.w	r2, [r3, #330]	; 0x14a
			s->inv_dmp_odr_delays[INV_SENSOR_WAKEUP_NINEQ_cpass] = delayInMs;
  41176c:	687b      	ldr	r3, [r7, #4]
  41176e:	883a      	ldrh	r2, [r7, #0]
  411770:	f8a3 214e 	strh.w	r2, [r3, #334]	; 0x14e
			break;
  411774:	e01e      	b.n	4117b4 <inv_icm20948_set_odr+0x3c4>

		case ANDROID_SENSOR_WAKEUP_MAGNETIC_FIELD_UNCALIBRATED:
			s->inv_dmp_odr_delays[INV_SENSOR_WAKEUP_COMPASS] = delayInMs;
  411776:	687b      	ldr	r3, [r7, #4]
  411778:	883a      	ldrh	r2, [r7, #0]
  41177a:	f8a3 2132 	strh.w	r2, [r3, #306]	; 0x132
			break;
  41177e:	e019      	b.n	4117b4 <inv_icm20948_set_odr+0x3c4>

		case ANDROID_SENSOR_WAKEUP_MAGNETIC_FIELD:
			s->inv_dmp_odr_delays[INV_SENSOR_WAKEUP_CALIB_COMPASS] = delayInMs;
  411780:	687b      	ldr	r3, [r7, #4]
  411782:	883a      	ldrh	r2, [r7, #0]
  411784:	f8a3 2142 	strh.w	r2, [r3, #322]	; 0x142
			break;
  411788:	e014      	b.n	4117b4 <inv_icm20948_set_odr+0x3c4>

		case ANDROID_SENSOR_WAKEUP_LIGHT:
		case ANDROID_SENSOR_WAKEUP_PROXIMITY:
			s->inv_dmp_odr_delays[INV_SENSOR_WAKEUP_ALS] = delayInMs;
  41178a:	687b      	ldr	r3, [r7, #4]
  41178c:	883a      	ldrh	r2, [r7, #0]
  41178e:	f8a3 2134 	strh.w	r2, [r3, #308]	; 0x134
			break;
  411792:	e00f      	b.n	4117b4 <inv_icm20948_set_odr+0x3c4>

		case ANDROID_SENSOR_PRESSURE:
			s->inv_dmp_odr_delays[INV_SENSOR_PRESSURE] = delayInMs;
  411794:	687b      	ldr	r3, [r7, #4]
  411796:	883a      	ldrh	r2, [r7, #0]
  411798:	f8a3 2118 	strh.w	r2, [r3, #280]	; 0x118
			break;
  41179c:	e00a      	b.n	4117b4 <inv_icm20948_set_odr+0x3c4>

		case ANDROID_SENSOR_WAKEUP_PRESSURE:
			s->inv_dmp_odr_delays[INV_SENSOR_WAKEUP_PRESSURE] = delayInMs;
  41179e:	687b      	ldr	r3, [r7, #4]
  4117a0:	883a      	ldrh	r2, [r7, #0]
  4117a2:	f8a3 213e 	strh.w	r2, [r3, #318]	; 0x13e
			break;
  4117a6:	e005      	b.n	4117b4 <inv_icm20948_set_odr+0x3c4>

		case ANDROID_SENSOR_FLIP_PICKUP:
			s->inv_dmp_odr_delays[INV_SENSOR_FLIP_PICKUP] = delayInMs;
  4117a8:	687b      	ldr	r3, [r7, #4]
  4117aa:	883a      	ldrh	r2, [r7, #0]
  4117ac:	f8a3 2122 	strh.w	r2, [r3, #290]	; 0x122
			break;
  4117b0:	e000      	b.n	4117b4 <inv_icm20948_set_odr+0x3c4>
		case ANDROID_SENSOR_WAKEUP_RELATIVE_HUMIDITY:
		case ANDROID_SENSOR_WAKEUP_HEART_RATE:
			break;

		default:
			break;
  4117b2:	bf00      	nop
	}

	result = inv_set_hw_smplrt_dmp_odrs(s);
  4117b4:	6878      	ldr	r0, [r7, #4]
  4117b6:	4b0f      	ldr	r3, [pc, #60]	; (4117f4 <inv_icm20948_set_odr+0x404>)
  4117b8:	4798      	blx	r3
  4117ba:	60f8      	str	r0, [r7, #12]
	result |= inv_icm20948_set_gyro_sf(s, inv_icm20948_get_gyro_divider(s), inv_icm20948_get_gyro_fullscale(s));
  4117bc:	6878      	ldr	r0, [r7, #4]
  4117be:	4b0e      	ldr	r3, [pc, #56]	; (4117f8 <inv_icm20948_set_odr+0x408>)
  4117c0:	4798      	blx	r3
  4117c2:	4603      	mov	r3, r0
  4117c4:	461c      	mov	r4, r3
  4117c6:	6878      	ldr	r0, [r7, #4]
  4117c8:	4b0c      	ldr	r3, [pc, #48]	; (4117fc <inv_icm20948_set_odr+0x40c>)
  4117ca:	4798      	blx	r3
  4117cc:	4603      	mov	r3, r0
  4117ce:	461a      	mov	r2, r3
  4117d0:	4621      	mov	r1, r4
  4117d2:	6878      	ldr	r0, [r7, #4]
  4117d4:	4b0a      	ldr	r3, [pc, #40]	; (411800 <inv_icm20948_set_odr+0x410>)
  4117d6:	4798      	blx	r3
  4117d8:	4602      	mov	r2, r0
  4117da:	68fb      	ldr	r3, [r7, #12]
  4117dc:	4313      	orrs	r3, r2
  4117de:	60fb      	str	r3, [r7, #12]
	// i.e. If you use: O a 63 [ Press capital O then 'a' then 63 then ENTER]
	// You should get the nearest number to 63 here if you debug  the 'test_odr'  

	//inv_icm20948_ctrl_get_odr( androidSensor, &test_odr );

	inv_icm20948_allow_lpen_control(s);
  4117e0:	6878      	ldr	r0, [r7, #4]
  4117e2:	4b08      	ldr	r3, [pc, #32]	; (411804 <inv_icm20948_set_odr+0x414>)
  4117e4:	4798      	blx	r3
	return result;
  4117e6:	68fb      	ldr	r3, [r7, #12]
}
  4117e8:	4618      	mov	r0, r3
  4117ea:	3714      	adds	r7, #20
  4117ec:	46bd      	mov	sp, r7
  4117ee:	bd90      	pop	{r4, r7, pc}
  4117f0:	00410155 	.word	0x00410155
  4117f4:	00410da5 	.word	0x00410da5
  4117f8:	00405ebd 	.word	0x00405ebd
  4117fc:	00406161 	.word	0x00406161
  411800:	00405f59 	.word	0x00405f59
  411804:	00405761 	.word	0x00405761

00411808 <inv_reGenerate_sensorControl>:

	return result;
}

static void inv_reGenerate_sensorControl(struct inv_icm20948 * s, const short *sen_num_2_ctrl, unsigned short *sensor_control, uint8_t header2_count)
{
  411808:	b480      	push	{r7}
  41180a:	b089      	sub	sp, #36	; 0x24
  41180c:	af00      	add	r7, sp, #0
  41180e:	60f8      	str	r0, [r7, #12]
  411810:	60b9      	str	r1, [r7, #8]
  411812:	607a      	str	r2, [r7, #4]
  411814:	70fb      	strb	r3, [r7, #3]
	short delta;
	int i, cntr;
	unsigned long tmp_androidSensorsOn_mask;

	//check if only header2 still remaining
	if(header2_count)
  411816:	78fb      	ldrb	r3, [r7, #3]
  411818:	2b00      	cmp	r3, #0
  41181a:	d003      	beq.n	411824 <inv_reGenerate_sensorControl+0x1c>
		*sensor_control = HEADER2_SET;
  41181c:	687b      	ldr	r3, [r7, #4]
  41181e:	2208      	movs	r2, #8
  411820:	801a      	strh	r2, [r3, #0]
  411822:	e002      	b.n	41182a <inv_reGenerate_sensorControl+0x22>
	else
		*sensor_control = 0;
  411824:	687b      	ldr	r3, [r7, #4]
  411826:	2200      	movs	r2, #0
  411828:	801a      	strh	r2, [r3, #0]
	for (i = 0; i < 2; i++) {
  41182a:	2300      	movs	r3, #0
  41182c:	61fb      	str	r3, [r7, #28]
  41182e:	e02e      	b.n	41188e <inv_reGenerate_sensorControl+0x86>
		cntr = 32 * i;
  411830:	69fb      	ldr	r3, [r7, #28]
  411832:	015b      	lsls	r3, r3, #5
  411834:	61bb      	str	r3, [r7, #24]
		tmp_androidSensorsOn_mask = s->inv_androidSensorsOn_mask[i];
  411836:	68fb      	ldr	r3, [r7, #12]
  411838:	69fa      	ldr	r2, [r7, #28]
  41183a:	3258      	adds	r2, #88	; 0x58
  41183c:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
  411840:	617b      	str	r3, [r7, #20]
		while (tmp_androidSensorsOn_mask) {
  411842:	e01e      	b.n	411882 <inv_reGenerate_sensorControl+0x7a>
			if (tmp_androidSensorsOn_mask & 1) {
  411844:	697b      	ldr	r3, [r7, #20]
  411846:	f003 0301 	and.w	r3, r3, #1
  41184a:	2b00      	cmp	r3, #0
  41184c:	d013      	beq.n	411876 <inv_reGenerate_sensorControl+0x6e>
				delta = sen_num_2_ctrl[cntr];
  41184e:	69bb      	ldr	r3, [r7, #24]
  411850:	005b      	lsls	r3, r3, #1
  411852:	68ba      	ldr	r2, [r7, #8]
  411854:	4413      	add	r3, r2
  411856:	881b      	ldrh	r3, [r3, #0]
  411858:	827b      	strh	r3, [r7, #18]
				if (delta != -1) *sensor_control |= delta;
  41185a:	f9b7 3012 	ldrsh.w	r3, [r7, #18]
  41185e:	f1b3 3fff 	cmp.w	r3, #4294967295
  411862:	d008      	beq.n	411876 <inv_reGenerate_sensorControl+0x6e>
  411864:	687b      	ldr	r3, [r7, #4]
  411866:	881b      	ldrh	r3, [r3, #0]
  411868:	b21a      	sxth	r2, r3
  41186a:	8a7b      	ldrh	r3, [r7, #18]
  41186c:	4313      	orrs	r3, r2
  41186e:	b21b      	sxth	r3, r3
  411870:	b29a      	uxth	r2, r3
  411872:	687b      	ldr	r3, [r7, #4]
  411874:	801a      	strh	r2, [r3, #0]
			}
			tmp_androidSensorsOn_mask >>= 1;
  411876:	697b      	ldr	r3, [r7, #20]
  411878:	085b      	lsrs	r3, r3, #1
  41187a:	617b      	str	r3, [r7, #20]
			cntr++;
  41187c:	69bb      	ldr	r3, [r7, #24]
  41187e:	3301      	adds	r3, #1
  411880:	61bb      	str	r3, [r7, #24]
		while (tmp_androidSensorsOn_mask) {
  411882:	697b      	ldr	r3, [r7, #20]
  411884:	2b00      	cmp	r3, #0
  411886:	d1dd      	bne.n	411844 <inv_reGenerate_sensorControl+0x3c>
	for (i = 0; i < 2; i++) {
  411888:	69fb      	ldr	r3, [r7, #28]
  41188a:	3301      	adds	r3, #1
  41188c:	61fb      	str	r3, [r7, #28]
  41188e:	69fb      	ldr	r3, [r7, #28]
  411890:	2b01      	cmp	r3, #1
  411892:	ddcd      	ble.n	411830 <inv_reGenerate_sensorControl+0x28>
		}
	}
}
  411894:	bf00      	nop
  411896:	3724      	adds	r7, #36	; 0x24
  411898:	46bd      	mov	sp, r7
  41189a:	f85d 7b04 	ldr.w	r7, [sp], #4
  41189e:	4770      	bx	lr

004118a0 <inv_convert_androidSensor_to_control>:
* @param[in] enable non-zero to turn sensor on, 0 to turn sensor off
* @param[in] sen_num_2_ctrl Table matching android sensor number to bits in DMP control register
* @param[in,out] sensor_control Sensor control register to write to DMP to enable/disable sensors
*/
static void inv_convert_androidSensor_to_control(struct inv_icm20948 * s, unsigned char androidSensor, unsigned char enable, const short *sen_num_2_ctrl, unsigned short *sensor_control)
{
  4118a0:	b590      	push	{r4, r7, lr}
  4118a2:	b087      	sub	sp, #28
  4118a4:	af00      	add	r7, sp, #0
  4118a6:	60f8      	str	r0, [r7, #12]
  4118a8:	607b      	str	r3, [r7, #4]
  4118aa:	460b      	mov	r3, r1
  4118ac:	72fb      	strb	r3, [r7, #11]
  4118ae:	4613      	mov	r3, r2
  4118b0:	72bb      	strb	r3, [r7, #10]
	short delta = 0;
  4118b2:	2300      	movs	r3, #0
  4118b4:	82fb      	strh	r3, [r7, #22]

	if (androidSensor == ANDROID_SENSOR_ACTIVITY_CLASSIFICATON || androidSensor == ANDROID_SENSOR_FLIP_PICKUP || 
  4118b6:	7afb      	ldrb	r3, [r7, #11]
  4118b8:	2b2f      	cmp	r3, #47	; 0x2f
  4118ba:	d008      	beq.n	4118ce <inv_convert_androidSensor_to_control+0x2e>
  4118bc:	7afb      	ldrb	r3, [r7, #11]
  4118be:	2b2e      	cmp	r3, #46	; 0x2e
  4118c0:	d005      	beq.n	4118ce <inv_convert_androidSensor_to_control+0x2e>
  4118c2:	7afb      	ldrb	r3, [r7, #11]
  4118c4:	2b29      	cmp	r3, #41	; 0x29
  4118c6:	d002      	beq.n	4118ce <inv_convert_androidSensor_to_control+0x2e>
			androidSensor == ANDROID_SENSOR_WAKEUP_TILT_DETECTOR || androidSensor == ANDROID_SENSOR_B2S) {
  4118c8:	7afb      	ldrb	r3, [r7, #11]
  4118ca:	2b2d      	cmp	r3, #45	; 0x2d
  4118cc:	d122      	bne.n	411914 <inv_convert_androidSensor_to_control+0x74>
		if (enable) {
  4118ce:	7abb      	ldrb	r3, [r7, #10]
  4118d0:	2b00      	cmp	r3, #0
  4118d2:	d00f      	beq.n	4118f4 <inv_convert_androidSensor_to_control+0x54>
			*sensor_control |= HEADER2_SET;
  4118d4:	6abb      	ldr	r3, [r7, #40]	; 0x28
  4118d6:	881b      	ldrh	r3, [r3, #0]
  4118d8:	f043 0308 	orr.w	r3, r3, #8
  4118dc:	b29a      	uxth	r2, r3
  4118de:	6abb      	ldr	r3, [r7, #40]	; 0x28
  4118e0:	801a      	strh	r2, [r3, #0]
			//we increment counter
			s->header2_count ++;
  4118e2:	68fb      	ldr	r3, [r7, #12]
  4118e4:	f893 323b 	ldrb.w	r3, [r3, #571]	; 0x23b
  4118e8:	3301      	adds	r3, #1
  4118ea:	b2da      	uxtb	r2, r3
  4118ec:	68fb      	ldr	r3, [r7, #12]
  4118ee:	f883 223b 	strb.w	r2, [r3, #571]	; 0x23b
  4118f2:	e00f      	b.n	411914 <inv_convert_androidSensor_to_control+0x74>
		}
		else {
			s->header2_count --;
  4118f4:	68fb      	ldr	r3, [r7, #12]
  4118f6:	f893 323b 	ldrb.w	r3, [r3, #571]	; 0x23b
  4118fa:	3b01      	subs	r3, #1
  4118fc:	b2da      	uxtb	r2, r3
  4118fe:	68fb      	ldr	r3, [r7, #12]
  411900:	f883 223b 	strb.w	r2, [r3, #571]	; 0x23b
			// control has to be regenerated when removing sensors because of overlap
			inv_reGenerate_sensorControl(s, sen_num_2_ctrl, sensor_control, s->header2_count);
  411904:	68fb      	ldr	r3, [r7, #12]
  411906:	f893 323b 	ldrb.w	r3, [r3, #571]	; 0x23b
  41190a:	6aba      	ldr	r2, [r7, #40]	; 0x28
  41190c:	6879      	ldr	r1, [r7, #4]
  41190e:	68f8      	ldr	r0, [r7, #12]
  411910:	4c2f      	ldr	r4, [pc, #188]	; (4119d0 <inv_convert_androidSensor_to_control+0x130>)
  411912:	47a0      	blx	r4
		}
	}

	if (androidSensor >= ANDROID_SENSOR_NUM_MAX)
  411914:	7afb      	ldrb	r3, [r7, #11]
  411916:	2b2b      	cmp	r3, #43	; 0x2b
  411918:	d854      	bhi.n	4119c4 <inv_convert_androidSensor_to_control+0x124>
		return; // Sensor not supported

	delta = sen_num_2_ctrl[androidSensor];
  41191a:	7afb      	ldrb	r3, [r7, #11]
  41191c:	005b      	lsls	r3, r3, #1
  41191e:	687a      	ldr	r2, [r7, #4]
  411920:	4413      	add	r3, r2
  411922:	881b      	ldrh	r3, [r3, #0]
  411924:	82fb      	strh	r3, [r7, #22]
	if (delta == -1)
  411926:	f9b7 3016 	ldrsh.w	r3, [r7, #22]
  41192a:	f1b3 3fff 	cmp.w	r3, #4294967295
  41192e:	d04b      	beq.n	4119c8 <inv_convert_androidSensor_to_control+0x128>
		return; // This sensor not supported

	if (enable) {
  411930:	7abb      	ldrb	r3, [r7, #10]
  411932:	2b00      	cmp	r3, #0
  411934:	d022      	beq.n	41197c <inv_convert_androidSensor_to_control+0xdc>
		s->inv_androidSensorsOn_mask[(androidSensor>>5)] |= 1L << (androidSensor & 0x1F); // Set bit
  411936:	7afb      	ldrb	r3, [r7, #11]
  411938:	095b      	lsrs	r3, r3, #5
  41193a:	b2db      	uxtb	r3, r3
  41193c:	4618      	mov	r0, r3
  41193e:	7afb      	ldrb	r3, [r7, #11]
  411940:	095b      	lsrs	r3, r3, #5
  411942:	b2db      	uxtb	r3, r3
  411944:	461a      	mov	r2, r3
  411946:	68fb      	ldr	r3, [r7, #12]
  411948:	3258      	adds	r2, #88	; 0x58
  41194a:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
  41194e:	7afa      	ldrb	r2, [r7, #11]
  411950:	f002 021f 	and.w	r2, r2, #31
  411954:	2101      	movs	r1, #1
  411956:	fa01 f202 	lsl.w	r2, r1, r2
  41195a:	ea43 0102 	orr.w	r1, r3, r2
  41195e:	68fb      	ldr	r3, [r7, #12]
  411960:	f100 0258 	add.w	r2, r0, #88	; 0x58
  411964:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
		*sensor_control |= delta;
  411968:	6abb      	ldr	r3, [r7, #40]	; 0x28
  41196a:	881b      	ldrh	r3, [r3, #0]
  41196c:	b21a      	sxth	r2, r3
  41196e:	8afb      	ldrh	r3, [r7, #22]
  411970:	4313      	orrs	r3, r2
  411972:	b21b      	sxth	r3, r3
  411974:	b29a      	uxth	r2, r3
  411976:	6abb      	ldr	r3, [r7, #40]	; 0x28
  411978:	801a      	strh	r2, [r3, #0]
		s->inv_androidSensorsOn_mask[(androidSensor>>5)] &= ~(1L << (androidSensor & 0x1F)); // Clear bit
		// control has to be regenerated when removing sensors because of overlap
		inv_reGenerate_sensorControl(s, sen_num_2_ctrl, sensor_control, s->header2_count);
	}

	return;
  41197a:	e026      	b.n	4119ca <inv_convert_androidSensor_to_control+0x12a>
		s->inv_androidSensorsOn_mask[(androidSensor>>5)] &= ~(1L << (androidSensor & 0x1F)); // Clear bit
  41197c:	7afb      	ldrb	r3, [r7, #11]
  41197e:	095b      	lsrs	r3, r3, #5
  411980:	b2db      	uxtb	r3, r3
  411982:	4618      	mov	r0, r3
  411984:	7afb      	ldrb	r3, [r7, #11]
  411986:	095b      	lsrs	r3, r3, #5
  411988:	b2db      	uxtb	r3, r3
  41198a:	461a      	mov	r2, r3
  41198c:	68fb      	ldr	r3, [r7, #12]
  41198e:	3258      	adds	r2, #88	; 0x58
  411990:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
  411994:	7afa      	ldrb	r2, [r7, #11]
  411996:	f002 021f 	and.w	r2, r2, #31
  41199a:	2101      	movs	r1, #1
  41199c:	fa01 f202 	lsl.w	r2, r1, r2
  4119a0:	43d2      	mvns	r2, r2
  4119a2:	ea03 0102 	and.w	r1, r3, r2
  4119a6:	68fb      	ldr	r3, [r7, #12]
  4119a8:	f100 0258 	add.w	r2, r0, #88	; 0x58
  4119ac:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
		inv_reGenerate_sensorControl(s, sen_num_2_ctrl, sensor_control, s->header2_count);
  4119b0:	68fb      	ldr	r3, [r7, #12]
  4119b2:	f893 323b 	ldrb.w	r3, [r3, #571]	; 0x23b
  4119b6:	6aba      	ldr	r2, [r7, #40]	; 0x28
  4119b8:	6879      	ldr	r1, [r7, #4]
  4119ba:	68f8      	ldr	r0, [r7, #12]
  4119bc:	4c04      	ldr	r4, [pc, #16]	; (4119d0 <inv_convert_androidSensor_to_control+0x130>)
  4119be:	47a0      	blx	r4
	return;
  4119c0:	bf00      	nop
  4119c2:	e002      	b.n	4119ca <inv_convert_androidSensor_to_control+0x12a>
		return; // Sensor not supported
  4119c4:	bf00      	nop
  4119c6:	e000      	b.n	4119ca <inv_convert_androidSensor_to_control+0x12a>
		return; // This sensor not supported
  4119c8:	bf00      	nop
}
  4119ca:	371c      	adds	r7, #28
  4119cc:	46bd      	mov	sp, r7
  4119ce:	bd90      	pop	{r4, r7, pc}
  4119d0:	00411809 	.word	0x00411809

004119d4 <inv_icm20948_ctrl_enable_sensor>:

int inv_icm20948_ctrl_enable_sensor(struct inv_icm20948 * s, unsigned char androidSensor, unsigned char enable)
{
  4119d4:	b590      	push	{r4, r7, lr}
  4119d6:	b085      	sub	sp, #20
  4119d8:	af00      	add	r7, sp, #0
  4119da:	6078      	str	r0, [r7, #4]
  4119dc:	460b      	mov	r3, r1
  4119de:	70fb      	strb	r3, [r7, #3]
  4119e0:	4613      	mov	r3, r2
  4119e2:	70bb      	strb	r3, [r7, #2]
	int result = 0;
  4119e4:	2300      	movs	r3, #0
  4119e6:	60fb      	str	r3, [r7, #12]

	if(sensor_needs_compass(androidSensor))
  4119e8:	78fb      	ldrb	r3, [r7, #3]
  4119ea:	4618      	mov	r0, r3
  4119ec:	4b1a      	ldr	r3, [pc, #104]	; (411a58 <inv_icm20948_ctrl_enable_sensor+0x84>)
  4119ee:	4798      	blx	r3
  4119f0:	4603      	mov	r3, r0
  4119f2:	2b00      	cmp	r3, #0
  4119f4:	d008      	beq.n	411a08 <inv_icm20948_ctrl_enable_sensor+0x34>
		if(!inv_icm20948_get_compass_availability(s))
  4119f6:	6878      	ldr	r0, [r7, #4]
  4119f8:	4b18      	ldr	r3, [pc, #96]	; (411a5c <inv_icm20948_ctrl_enable_sensor+0x88>)
  4119fa:	4798      	blx	r3
  4119fc:	4603      	mov	r3, r0
  4119fe:	2b00      	cmp	r3, #0
  411a00:	d102      	bne.n	411a08 <inv_icm20948_ctrl_enable_sensor+0x34>
			return -1;
  411a02:	f04f 33ff 	mov.w	r3, #4294967295
  411a06:	e022      	b.n	411a4e <inv_icm20948_ctrl_enable_sensor+0x7a>

	inv_icm20948_prevent_lpen_control(s);
  411a08:	6878      	ldr	r0, [r7, #4]
  411a0a:	4b15      	ldr	r3, [pc, #84]	; (411a60 <inv_icm20948_ctrl_enable_sensor+0x8c>)
  411a0c:	4798      	blx	r3
	if( s->mems_put_to_sleep ) {
  411a0e:	687b      	ldr	r3, [r7, #4]
  411a10:	f993 323c 	ldrsb.w	r3, [r3, #572]	; 0x23c
  411a14:	2b00      	cmp	r3, #0
  411a16:	d00a      	beq.n	411a2e <inv_icm20948_ctrl_enable_sensor+0x5a>
		s->mems_put_to_sleep = 0;
  411a18:	687b      	ldr	r3, [r7, #4]
  411a1a:	2200      	movs	r2, #0
  411a1c:	f883 223c 	strb.w	r2, [r3, #572]	; 0x23c
		result |= inv_icm20948_wakeup_mems(s);
  411a20:	6878      	ldr	r0, [r7, #4]
  411a22:	4b10      	ldr	r3, [pc, #64]	; (411a64 <inv_icm20948_ctrl_enable_sensor+0x90>)
  411a24:	4798      	blx	r3
  411a26:	4602      	mov	r2, r0
  411a28:	68fb      	ldr	r3, [r7, #12]
  411a2a:	4313      	orrs	r3, r2
  411a2c:	60fb      	str	r3, [r7, #12]
	}
	result |= inv_enable_sensor_internal(s, androidSensor, enable, &s->mems_put_to_sleep);
  411a2e:	687b      	ldr	r3, [r7, #4]
  411a30:	f503 730f 	add.w	r3, r3, #572	; 0x23c
  411a34:	78ba      	ldrb	r2, [r7, #2]
  411a36:	78f9      	ldrb	r1, [r7, #3]
  411a38:	6878      	ldr	r0, [r7, #4]
  411a3a:	4c0b      	ldr	r4, [pc, #44]	; (411a68 <inv_icm20948_ctrl_enable_sensor+0x94>)
  411a3c:	47a0      	blx	r4
  411a3e:	4602      	mov	r2, r0
  411a40:	68fb      	ldr	r3, [r7, #12]
  411a42:	4313      	orrs	r3, r2
  411a44:	60fb      	str	r3, [r7, #12]
	inv_icm20948_allow_lpen_control(s);
  411a46:	6878      	ldr	r0, [r7, #4]
  411a48:	4b08      	ldr	r3, [pc, #32]	; (411a6c <inv_icm20948_ctrl_enable_sensor+0x98>)
  411a4a:	4798      	blx	r3
	return result;
  411a4c:	68fb      	ldr	r3, [r7, #12]
}
  411a4e:	4618      	mov	r0, r3
  411a50:	3714      	adds	r7, #20
  411a52:	46bd      	mov	sp, r7
  411a54:	bd90      	pop	{r4, r7, pc}
  411a56:	bf00      	nop
  411a58:	004124c1 	.word	0x004124c1
  411a5c:	00405de9 	.word	0x00405de9
  411a60:	00405745 	.word	0x00405745
  411a64:	0040591d 	.word	0x0040591d
  411a68:	00411a71 	.word	0x00411a71
  411a6c:	00405761 	.word	0x00405761

00411a70 <inv_enable_sensor_internal>:

static int inv_enable_sensor_internal(struct inv_icm20948 * s, unsigned char androidSensor, unsigned char enable, char * mems_put_to_sleep)
{
  411a70:	b590      	push	{r4, r7, lr}
  411a72:	b0a1      	sub	sp, #132	; 0x84
  411a74:	af02      	add	r7, sp, #8
  411a76:	60f8      	str	r0, [r7, #12]
  411a78:	607b      	str	r3, [r7, #4]
  411a7a:	460b      	mov	r3, r1
  411a7c:	72fb      	strb	r3, [r7, #11]
  411a7e:	4613      	mov	r3, r2
  411a80:	72bb      	strb	r3, [r7, #10]
	int result = 0;
  411a82:	2300      	movs	r3, #0
  411a84:	677b      	str	r3, [r7, #116]	; 0x74
	unsigned short inv_event_control = 0;
  411a86:	2300      	movs	r3, #0
  411a88:	f8a7 3072 	strh.w	r3, [r7, #114]	; 0x72
	unsigned short data_rdy_status = 0;
  411a8c:	2300      	movs	r3, #0
  411a8e:	f8a7 3070 	strh.w	r3, [r7, #112]	; 0x70
	unsigned long steps=0;
  411a92:	2300      	movs	r3, #0
  411a94:	66fb      	str	r3, [r7, #108]	; 0x6c
	const short inv_androidSensor_to_control_bits[ANDROID_SENSOR_NUM_MAX]=
  411a96:	4aaf      	ldr	r2, [pc, #700]	; (411d54 <inv_enable_sensor_internal+0x2e4>)
  411a98:	f107 0314 	add.w	r3, r7, #20
  411a9c:	4611      	mov	r1, r2
  411a9e:	2258      	movs	r2, #88	; 0x58
  411aa0:	4618      	mov	r0, r3
  411aa2:	4bad      	ldr	r3, [pc, #692]	; (411d58 <inv_enable_sensor_internal+0x2e8>)
  411aa4:	4798      	blx	r3
		-1,		// ANDROID_SENSOR_WAKEUP_HEART_RATE,
		0,		// ANDROID_SENSOR_WAKEUP_TILT_DETECTOR,
		0x8008, // Raw Acc
		0x4048, // Raw Gyr
	};
	if(enable && !inv_icm20948_ctrl_androidSensor_enabled(s, androidSensor))
  411aa6:	7abb      	ldrb	r3, [r7, #10]
  411aa8:	2b00      	cmp	r3, #0
  411aaa:	d012      	beq.n	411ad2 <inv_enable_sensor_internal+0x62>
  411aac:	7afb      	ldrb	r3, [r7, #11]
  411aae:	4619      	mov	r1, r3
  411ab0:	68f8      	ldr	r0, [r7, #12]
  411ab2:	4baa      	ldr	r3, [pc, #680]	; (411d5c <inv_enable_sensor_internal+0x2ec>)
  411ab4:	4798      	blx	r3
  411ab6:	4603      	mov	r3, r0
  411ab8:	2b00      	cmp	r3, #0
  411aba:	d10a      	bne.n	411ad2 <inv_enable_sensor_internal+0x62>
		s->skip_sample[inv_icm20948_sensor_android_2_sensor_type(androidSensor)] = 1;
  411abc:	7afb      	ldrb	r3, [r7, #11]
  411abe:	4618      	mov	r0, r3
  411ac0:	4ba7      	ldr	r3, [pc, #668]	; (411d60 <inv_enable_sensor_internal+0x2f0>)
  411ac2:	4798      	blx	r3
  411ac4:	4603      	mov	r3, r0
  411ac6:	461a      	mov	r2, r3
  411ac8:	68fb      	ldr	r3, [r7, #12]
  411aca:	4413      	add	r3, r2
  411acc:	2201      	movs	r2, #1
  411ace:	f883 22ac 	strb.w	r2, [r3, #684]	; 0x2ac
		
	if (androidSensor == ANDROID_SENSOR_WAKEUP_SIGNIFICANT_MOTION) {
  411ad2:	7afb      	ldrb	r3, [r7, #11]
  411ad4:	2b11      	cmp	r3, #17
  411ad6:	d11c      	bne.n	411b12 <inv_enable_sensor_internal+0xa2>
		if (enable) {
  411ad8:	7abb      	ldrb	r3, [r7, #10]
  411ada:	2b00      	cmp	r3, #0
  411adc:	d00d      	beq.n	411afa <inv_enable_sensor_internal+0x8a>
			s->smd_status = INV_SMD_EN;
  411ade:	68fb      	ldr	r3, [r7, #12]
  411ae0:	f44f 6200 	mov.w	r2, #2048	; 0x800
  411ae4:	f8a3 223e 	strh.w	r2, [r3, #574]	; 0x23e
			s->bac_request ++;
  411ae8:	68fb      	ldr	r3, [r7, #12]
  411aea:	f8b3 3242 	ldrh.w	r3, [r3, #578]	; 0x242
  411aee:	3301      	adds	r3, #1
  411af0:	b29a      	uxth	r2, r3
  411af2:	68fb      	ldr	r3, [r7, #12]
  411af4:	f8a3 2242 	strh.w	r2, [r3, #578]	; 0x242
  411af8:	e00b      	b.n	411b12 <inv_enable_sensor_internal+0xa2>
		}
		else {
			s->smd_status = 0;
  411afa:	68fb      	ldr	r3, [r7, #12]
  411afc:	2200      	movs	r2, #0
  411afe:	f8a3 223e 	strh.w	r2, [r3, #574]	; 0x23e
			s->bac_request --;
  411b02:	68fb      	ldr	r3, [r7, #12]
  411b04:	f8b3 3242 	ldrh.w	r3, [r3, #578]	; 0x242
  411b08:	3b01      	subs	r3, #1
  411b0a:	b29a      	uxth	r2, r3
  411b0c:	68fb      	ldr	r3, [r7, #12]
  411b0e:	f8a3 2242 	strh.w	r2, [r3, #578]	; 0x242
		}
	}

	if (androidSensor == ANDROID_SENSOR_STEP_DETECTOR) {
  411b12:	7afb      	ldrb	r3, [r7, #11]
  411b14:	2b12      	cmp	r3, #18
  411b16:	d11c      	bne.n	411b52 <inv_enable_sensor_internal+0xe2>
		if (enable) {
  411b18:	7abb      	ldrb	r3, [r7, #10]
  411b1a:	2b00      	cmp	r3, #0
  411b1c:	d00d      	beq.n	411b3a <inv_enable_sensor_internal+0xca>
			s->ped_int_status = INV_PEDOMETER_INT_EN;
  411b1e:	68fb      	ldr	r3, [r7, #12]
  411b20:	f44f 5200 	mov.w	r2, #8192	; 0x2000
  411b24:	f8a3 2240 	strh.w	r2, [r3, #576]	; 0x240
			s->bac_request ++;
  411b28:	68fb      	ldr	r3, [r7, #12]
  411b2a:	f8b3 3242 	ldrh.w	r3, [r3, #578]	; 0x242
  411b2e:	3301      	adds	r3, #1
  411b30:	b29a      	uxth	r2, r3
  411b32:	68fb      	ldr	r3, [r7, #12]
  411b34:	f8a3 2242 	strh.w	r2, [r3, #578]	; 0x242
  411b38:	e00b      	b.n	411b52 <inv_enable_sensor_internal+0xe2>
		}
		else {
			s->ped_int_status = 0;
  411b3a:	68fb      	ldr	r3, [r7, #12]
  411b3c:	2200      	movs	r2, #0
  411b3e:	f8a3 2240 	strh.w	r2, [r3, #576]	; 0x240
			s->bac_request --;
  411b42:	68fb      	ldr	r3, [r7, #12]
  411b44:	f8b3 3242 	ldrh.w	r3, [r3, #578]	; 0x242
  411b48:	3b01      	subs	r3, #1
  411b4a:	b29a      	uxth	r2, r3
  411b4c:	68fb      	ldr	r3, [r7, #12]
  411b4e:	f8a3 2242 	strh.w	r2, [r3, #578]	; 0x242
		}
	}
	
	if (androidSensor == ANDROID_SENSOR_STEP_COUNTER) {
  411b52:	7afb      	ldrb	r3, [r7, #11]
  411b54:	2b13      	cmp	r3, #19
  411b56:	d113      	bne.n	411b80 <inv_enable_sensor_internal+0x110>
		if (enable) {
  411b58:	7abb      	ldrb	r3, [r7, #10]
  411b5a:	2b00      	cmp	r3, #0
  411b5c:	d008      	beq.n	411b70 <inv_enable_sensor_internal+0x100>
			s->bac_request ++;
  411b5e:	68fb      	ldr	r3, [r7, #12]
  411b60:	f8b3 3242 	ldrh.w	r3, [r3, #578]	; 0x242
  411b64:	3301      	adds	r3, #1
  411b66:	b29a      	uxth	r2, r3
  411b68:	68fb      	ldr	r3, [r7, #12]
  411b6a:	f8a3 2242 	strh.w	r2, [r3, #578]	; 0x242
  411b6e:	e007      	b.n	411b80 <inv_enable_sensor_internal+0x110>
		}
		else {
			s->bac_request --;
  411b70:	68fb      	ldr	r3, [r7, #12]
  411b72:	f8b3 3242 	ldrh.w	r3, [r3, #578]	; 0x242
  411b76:	3b01      	subs	r3, #1
  411b78:	b29a      	uxth	r2, r3
  411b7a:	68fb      	ldr	r3, [r7, #12]
  411b7c:	f8a3 2242 	strh.w	r2, [r3, #578]	; 0x242
		}
	}

	if (androidSensor == ANDROID_SENSOR_FLIP_PICKUP) {
  411b80:	7afb      	ldrb	r3, [r7, #11]
  411b82:	2b2e      	cmp	r3, #46	; 0x2e
  411b84:	d10c      	bne.n	411ba0 <inv_enable_sensor_internal+0x130>
		if (enable){
  411b86:	7abb      	ldrb	r3, [r7, #10]
  411b88:	2b00      	cmp	r3, #0
  411b8a:	d005      	beq.n	411b98 <inv_enable_sensor_internal+0x128>
			s->flip_pickup_status = FLIP_PICKUP_SET;
  411b8c:	68fb      	ldr	r3, [r7, #12]
  411b8e:	f44f 6280 	mov.w	r2, #1024	; 0x400
  411b92:	f8a3 2158 	strh.w	r2, [r3, #344]	; 0x158
  411b96:	e003      	b.n	411ba0 <inv_enable_sensor_internal+0x130>
		}
		else
			s->flip_pickup_status = 0;
  411b98:	68fb      	ldr	r3, [r7, #12]
  411b9a:	2200      	movs	r2, #0
  411b9c:	f8a3 2158 	strh.w	r2, [r3, #344]	; 0x158
	}

	if (androidSensor == ANDROID_SENSOR_B2S) {
  411ba0:	7afb      	ldrb	r3, [r7, #11]
  411ba2:	2b2d      	cmp	r3, #45	; 0x2d
  411ba4:	d11b      	bne.n	411bde <inv_enable_sensor_internal+0x16e>
		if(enable){
  411ba6:	7abb      	ldrb	r3, [r7, #10]
  411ba8:	2b00      	cmp	r3, #0
  411baa:	d00c      	beq.n	411bc6 <inv_enable_sensor_internal+0x156>
			s->b2s_status = INV_BTS_EN;
  411bac:	68fb      	ldr	r3, [r7, #12]
  411bae:	2220      	movs	r2, #32
  411bb0:	f8a3 2156 	strh.w	r2, [r3, #342]	; 0x156
			s->bac_request ++;
  411bb4:	68fb      	ldr	r3, [r7, #12]
  411bb6:	f8b3 3242 	ldrh.w	r3, [r3, #578]	; 0x242
  411bba:	3301      	adds	r3, #1
  411bbc:	b29a      	uxth	r2, r3
  411bbe:	68fb      	ldr	r3, [r7, #12]
  411bc0:	f8a3 2242 	strh.w	r2, [r3, #578]	; 0x242
  411bc4:	e00b      	b.n	411bde <inv_enable_sensor_internal+0x16e>
		}
		else {
			s->b2s_status = 0;
  411bc6:	68fb      	ldr	r3, [r7, #12]
  411bc8:	2200      	movs	r2, #0
  411bca:	f8a3 2156 	strh.w	r2, [r3, #342]	; 0x156
			s->bac_request --;
  411bce:	68fb      	ldr	r3, [r7, #12]
  411bd0:	f8b3 3242 	ldrh.w	r3, [r3, #578]	; 0x242
  411bd4:	3b01      	subs	r3, #1
  411bd6:	b29a      	uxth	r2, r3
  411bd8:	68fb      	ldr	r3, [r7, #12]
  411bda:	f8a3 2242 	strh.w	r2, [r3, #578]	; 0x242
		}
	}
	if (androidSensor == ANDROID_SENSOR_ACTIVITY_CLASSIFICATON)
  411bde:	7afb      	ldrb	r3, [r7, #11]
  411be0:	2b2f      	cmp	r3, #47	; 0x2f
  411be2:	d104      	bne.n	411bee <inv_enable_sensor_internal+0x17e>
		inv_icm20948_ctrl_enable_activity_classifier(s, enable);
  411be4:	7abb      	ldrb	r3, [r7, #10]
  411be6:	4619      	mov	r1, r3
  411be8:	68f8      	ldr	r0, [r7, #12]
  411bea:	4b5e      	ldr	r3, [pc, #376]	; (411d64 <inv_enable_sensor_internal+0x2f4>)
  411bec:	4798      	blx	r3

	if (androidSensor == ANDROID_SENSOR_WAKEUP_TILT_DETECTOR)
  411bee:	7afb      	ldrb	r3, [r7, #11]
  411bf0:	2b29      	cmp	r3, #41	; 0x29
  411bf2:	d104      	bne.n	411bfe <inv_enable_sensor_internal+0x18e>
		inv_icm20948_ctrl_enable_tilt(s, enable);
  411bf4:	7abb      	ldrb	r3, [r7, #10]
  411bf6:	4619      	mov	r1, r3
  411bf8:	68f8      	ldr	r0, [r7, #12]
  411bfa:	4b5b      	ldr	r3, [pc, #364]	; (411d68 <inv_enable_sensor_internal+0x2f8>)
  411bfc:	4798      	blx	r3

	inv_convert_androidSensor_to_control(s, androidSensor, enable, inv_androidSensor_to_control_bits, &s->inv_sensor_control);
  411bfe:	68fb      	ldr	r3, [r7, #12]
  411c00:	f503 73ad 	add.w	r3, r3, #346	; 0x15a
  411c04:	f107 0014 	add.w	r0, r7, #20
  411c08:	7aba      	ldrb	r2, [r7, #10]
  411c0a:	7af9      	ldrb	r1, [r7, #11]
  411c0c:	9300      	str	r3, [sp, #0]
  411c0e:	4603      	mov	r3, r0
  411c10:	68f8      	ldr	r0, [r7, #12]
  411c12:	4c56      	ldr	r4, [pc, #344]	; (411d6c <inv_enable_sensor_internal+0x2fc>)
  411c14:	47a0      	blx	r4
	result = dmp_icm20948_set_data_output_control1(s, s->inv_sensor_control);
  411c16:	68fb      	ldr	r3, [r7, #12]
  411c18:	f8b3 315a 	ldrh.w	r3, [r3, #346]	; 0x15a
  411c1c:	4619      	mov	r1, r3
  411c1e:	68f8      	ldr	r0, [r7, #12]
  411c20:	4b53      	ldr	r3, [pc, #332]	; (411d70 <inv_enable_sensor_internal+0x300>)
  411c22:	4798      	blx	r3
  411c24:	6778      	str	r0, [r7, #116]	; 0x74
	if (s->b2s_status)
  411c26:	68fb      	ldr	r3, [r7, #12]
  411c28:	f8b3 3156 	ldrh.w	r3, [r3, #342]	; 0x156
  411c2c:	2b00      	cmp	r3, #0
  411c2e:	d00e      	beq.n	411c4e <inv_enable_sensor_internal+0x1de>
		result |= dmp_icm20948_set_data_interrupt_control(s, s->inv_sensor_control|0x8008);
  411c30:	68fb      	ldr	r3, [r7, #12]
  411c32:	f8b3 215a 	ldrh.w	r2, [r3, #346]	; 0x15a
  411c36:	4b4f      	ldr	r3, [pc, #316]	; (411d74 <inv_enable_sensor_internal+0x304>)
  411c38:	4313      	orrs	r3, r2
  411c3a:	b29b      	uxth	r3, r3
  411c3c:	4619      	mov	r1, r3
  411c3e:	68f8      	ldr	r0, [r7, #12]
  411c40:	4b4d      	ldr	r3, [pc, #308]	; (411d78 <inv_enable_sensor_internal+0x308>)
  411c42:	4798      	blx	r3
  411c44:	4602      	mov	r2, r0
  411c46:	6f7b      	ldr	r3, [r7, #116]	; 0x74
  411c48:	4313      	orrs	r3, r2
  411c4a:	677b      	str	r3, [r7, #116]	; 0x74
  411c4c:	e00a      	b.n	411c64 <inv_enable_sensor_internal+0x1f4>
		// result |= dmp_icm20948_set_data_interrupt_control(s, s->inv_sensor_control|0x0000);
	else
		result |= dmp_icm20948_set_data_interrupt_control(s, s->inv_sensor_control);
  411c4e:	68fb      	ldr	r3, [r7, #12]
  411c50:	f8b3 315a 	ldrh.w	r3, [r3, #346]	; 0x15a
  411c54:	4619      	mov	r1, r3
  411c56:	68f8      	ldr	r0, [r7, #12]
  411c58:	4b47      	ldr	r3, [pc, #284]	; (411d78 <inv_enable_sensor_internal+0x308>)
  411c5a:	4798      	blx	r3
  411c5c:	4602      	mov	r2, r0
  411c5e:	6f7b      	ldr	r3, [r7, #116]	; 0x74
  411c60:	4313      	orrs	r3, r2
  411c62:	677b      	str	r3, [r7, #116]	; 0x74

	if (s->inv_sensor_control & ACCEL_SET)
  411c64:	68fb      	ldr	r3, [r7, #12]
  411c66:	f8b3 315a 	ldrh.w	r3, [r3, #346]	; 0x15a
  411c6a:	b21b      	sxth	r3, r3
  411c6c:	2b00      	cmp	r3, #0
  411c6e:	da09      	bge.n	411c84 <inv_enable_sensor_internal+0x214>
		s->inv_sensor_control2 |= ACCEL_ACCURACY_SET;
  411c70:	68fb      	ldr	r3, [r7, #12]
  411c72:	f8b3 315c 	ldrh.w	r3, [r3, #348]	; 0x15c
  411c76:	f443 4380 	orr.w	r3, r3, #16384	; 0x4000
  411c7a:	b29a      	uxth	r2, r3
  411c7c:	68fb      	ldr	r3, [r7, #12]
  411c7e:	f8a3 215c 	strh.w	r2, [r3, #348]	; 0x15c
  411c82:	e008      	b.n	411c96 <inv_enable_sensor_internal+0x226>
	else
		s->inv_sensor_control2 &= ~ACCEL_ACCURACY_SET;
  411c84:	68fb      	ldr	r3, [r7, #12]
  411c86:	f8b3 315c 	ldrh.w	r3, [r3, #348]	; 0x15c
  411c8a:	f423 4380 	bic.w	r3, r3, #16384	; 0x4000
  411c8e:	b29a      	uxth	r2, r3
  411c90:	68fb      	ldr	r3, [r7, #12]
  411c92:	f8a3 215c 	strh.w	r2, [r3, #348]	; 0x15c

	if ((s->inv_sensor_control & GYRO_CALIBR_SET) || (s->inv_sensor_control & GYRO_SET))
  411c96:	68fb      	ldr	r3, [r7, #12]
  411c98:	f8b3 315a 	ldrh.w	r3, [r3, #346]	; 0x15a
  411c9c:	f003 0340 	and.w	r3, r3, #64	; 0x40
  411ca0:	2b00      	cmp	r3, #0
  411ca2:	d106      	bne.n	411cb2 <inv_enable_sensor_internal+0x242>
  411ca4:	68fb      	ldr	r3, [r7, #12]
  411ca6:	f8b3 315a 	ldrh.w	r3, [r3, #346]	; 0x15a
  411caa:	f403 4380 	and.w	r3, r3, #16384	; 0x4000
  411cae:	2b00      	cmp	r3, #0
  411cb0:	d009      	beq.n	411cc6 <inv_enable_sensor_internal+0x256>
		s->inv_sensor_control2 |= GYRO_ACCURACY_SET;
  411cb2:	68fb      	ldr	r3, [r7, #12]
  411cb4:	f8b3 315c 	ldrh.w	r3, [r3, #348]	; 0x15c
  411cb8:	f443 5300 	orr.w	r3, r3, #8192	; 0x2000
  411cbc:	b29a      	uxth	r2, r3
  411cbe:	68fb      	ldr	r3, [r7, #12]
  411cc0:	f8a3 215c 	strh.w	r2, [r3, #348]	; 0x15c
  411cc4:	e008      	b.n	411cd8 <inv_enable_sensor_internal+0x268>
	else
		s->inv_sensor_control2 &= ~GYRO_ACCURACY_SET;
  411cc6:	68fb      	ldr	r3, [r7, #12]
  411cc8:	f8b3 315c 	ldrh.w	r3, [r3, #348]	; 0x15c
  411ccc:	f423 5300 	bic.w	r3, r3, #8192	; 0x2000
  411cd0:	b29a      	uxth	r2, r3
  411cd2:	68fb      	ldr	r3, [r7, #12]
  411cd4:	f8a3 215c 	strh.w	r2, [r3, #348]	; 0x15c

	if ((s->inv_sensor_control & CPASS_CALIBR_SET) || (s->inv_sensor_control & QUAT9_SET)
  411cd8:	68fb      	ldr	r3, [r7, #12]
  411cda:	f8b3 315a 	ldrh.w	r3, [r3, #346]	; 0x15a
  411cde:	f003 0320 	and.w	r3, r3, #32
  411ce2:	2b00      	cmp	r3, #0
  411ce4:	d114      	bne.n	411d10 <inv_enable_sensor_internal+0x2a0>
  411ce6:	68fb      	ldr	r3, [r7, #12]
  411ce8:	f8b3 315a 	ldrh.w	r3, [r3, #346]	; 0x15a
  411cec:	f403 6380 	and.w	r3, r3, #1024	; 0x400
  411cf0:	2b00      	cmp	r3, #0
  411cf2:	d10d      	bne.n	411d10 <inv_enable_sensor_internal+0x2a0>
		|| (s->inv_sensor_control & GEOMAG_SET) || (s->inv_sensor_control & CPASS_SET))
  411cf4:	68fb      	ldr	r3, [r7, #12]
  411cf6:	f8b3 315a 	ldrh.w	r3, [r3, #346]	; 0x15a
  411cfa:	f403 7380 	and.w	r3, r3, #256	; 0x100
  411cfe:	2b00      	cmp	r3, #0
  411d00:	d106      	bne.n	411d10 <inv_enable_sensor_internal+0x2a0>
  411d02:	68fb      	ldr	r3, [r7, #12]
  411d04:	f8b3 315a 	ldrh.w	r3, [r3, #346]	; 0x15a
  411d08:	f403 5300 	and.w	r3, r3, #8192	; 0x2000
  411d0c:	2b00      	cmp	r3, #0
  411d0e:	d009      	beq.n	411d24 <inv_enable_sensor_internal+0x2b4>
		s->inv_sensor_control2 |= CPASS_ACCURACY_SET;
  411d10:	68fb      	ldr	r3, [r7, #12]
  411d12:	f8b3 315c 	ldrh.w	r3, [r3, #348]	; 0x15c
  411d16:	f443 5380 	orr.w	r3, r3, #4096	; 0x1000
  411d1a:	b29a      	uxth	r2, r3
  411d1c:	68fb      	ldr	r3, [r7, #12]
  411d1e:	f8a3 215c 	strh.w	r2, [r3, #348]	; 0x15c
  411d22:	e008      	b.n	411d36 <inv_enable_sensor_internal+0x2c6>
	else
		s->inv_sensor_control2 &= ~CPASS_ACCURACY_SET;
  411d24:	68fb      	ldr	r3, [r7, #12]
  411d26:	f8b3 315c 	ldrh.w	r3, [r3, #348]	; 0x15c
  411d2a:	f423 5380 	bic.w	r3, r3, #4096	; 0x1000
  411d2e:	b29a      	uxth	r2, r3
  411d30:	68fb      	ldr	r3, [r7, #12]
  411d32:	f8a3 215c 	strh.w	r2, [r3, #348]	; 0x15c

	if(s->flip_pickup_status)
  411d36:	68fb      	ldr	r3, [r7, #12]
  411d38:	f8b3 3158 	ldrh.w	r3, [r3, #344]	; 0x158
  411d3c:	2b00      	cmp	r3, #0
  411d3e:	d01d      	beq.n	411d7c <inv_enable_sensor_internal+0x30c>
		s->inv_sensor_control2 |= FLIP_PICKUP_SET;
  411d40:	68fb      	ldr	r3, [r7, #12]
  411d42:	f8b3 315c 	ldrh.w	r3, [r3, #348]	; 0x15c
  411d46:	f443 6380 	orr.w	r3, r3, #1024	; 0x400
  411d4a:	b29a      	uxth	r2, r3
  411d4c:	68fb      	ldr	r3, [r7, #12]
  411d4e:	f8a3 215c 	strh.w	r2, [r3, #348]	; 0x15c
  411d52:	e01c      	b.n	411d8e <inv_enable_sensor_internal+0x31e>
  411d54:	0041d1f4 	.word	0x0041d1f4
  411d58:	00414045 	.word	0x00414045
  411d5c:	004107b9 	.word	0x004107b9
  411d60:	0040a5c9 	.word	0x0040a5c9
  411d64:	004121e5 	.word	0x004121e5
  411d68:	00412271 	.word	0x00412271
  411d6c:	004118a1 	.word	0x004118a1
  411d70:	00407c39 	.word	0x00407c39
  411d74:	ffff8008 	.word	0xffff8008
  411d78:	00407d39 	.word	0x00407d39
	else
		s->inv_sensor_control2 &= ~FLIP_PICKUP_SET;
  411d7c:	68fb      	ldr	r3, [r7, #12]
  411d7e:	f8b3 315c 	ldrh.w	r3, [r3, #348]	; 0x15c
  411d82:	f423 6380 	bic.w	r3, r3, #1024	; 0x400
  411d86:	b29a      	uxth	r2, r3
  411d88:	68fb      	ldr	r3, [r7, #12]
  411d8a:	f8a3 215c 	strh.w	r2, [r3, #348]	; 0x15c

	// inv_event_control   |= s->b2s_status; 
	if(s->b2s_status)
  411d8e:	68fb      	ldr	r3, [r7, #12]
  411d90:	f8b3 3156 	ldrh.w	r3, [r3, #342]	; 0x156
  411d94:	2b00      	cmp	r3, #0
  411d96:	d01b      	beq.n	411dd0 <inv_enable_sensor_internal+0x360>
	{
		inv_event_control |= INV_BRING_AND_LOOK_T0_SEE_EN;
  411d98:	f8b7 3072 	ldrh.w	r3, [r7, #114]	; 0x72
  411d9c:	f043 0304 	orr.w	r3, r3, #4
  411da0:	f8a7 3072 	strh.w	r3, [r7, #114]	; 0x72
		inv_event_control |= INV_PEDOMETER_EN;
  411da4:	f8b7 3072 	ldrh.w	r3, [r7, #114]	; 0x72
  411da8:	f443 4380 	orr.w	r3, r3, #16384	; 0x4000
  411dac:	f8a7 3072 	strh.w	r3, [r7, #114]	; 0x72
#ifndef ICM20948_FOR_MOBILE // Next lines change BAC behavior to wearable platform
		inv_event_control |= INV_BAC_WEARABLE_EN;
  411db0:	f8b7 3072 	ldrh.w	r3, [r7, #114]	; 0x72
  411db4:	ea6f 4343 	mvn.w	r3, r3, lsl #17
  411db8:	ea6f 4353 	mvn.w	r3, r3, lsr #17
  411dbc:	f8a7 3072 	strh.w	r3, [r7, #114]	; 0x72
		dmp_icm20948_set_ped_y_ratio(s, BAC_PED_Y_RATIO_WEARABLE);
  411dc0:	f04f 4180 	mov.w	r1, #1073741824	; 0x40000000
  411dc4:	68f8      	ldr	r0, [r7, #12]
  411dc6:	4b01      	ldr	r3, [pc, #4]	; (411dcc <inv_enable_sensor_internal+0x35c>)
  411dc8:	4798      	blx	r3
  411dca:	e013      	b.n	411df4 <inv_enable_sensor_internal+0x384>
  411dcc:	00408821 	.word	0x00408821
#endif
	}
	else
	{
		inv_event_control &= ~INV_BRING_AND_LOOK_T0_SEE_EN;
  411dd0:	f8b7 3072 	ldrh.w	r3, [r7, #114]	; 0x72
  411dd4:	f023 0304 	bic.w	r3, r3, #4
  411dd8:	f8a7 3072 	strh.w	r3, [r7, #114]	; 0x72
		inv_event_control &= ~INV_PEDOMETER_EN;
  411ddc:	f8b7 3072 	ldrh.w	r3, [r7, #114]	; 0x72
  411de0:	f423 4380 	bic.w	r3, r3, #16384	; 0x4000
  411de4:	f8a7 3072 	strh.w	r3, [r7, #114]	; 0x72
#ifndef ICM20948_FOR_MOBILE // Next lines change BAC behavior to wearable platform
		inv_event_control &= ~INV_BAC_WEARABLE_EN;
  411de8:	f8b7 3072 	ldrh.w	r3, [r7, #114]	; 0x72
  411dec:	f3c3 030e 	ubfx	r3, r3, #0, #15
  411df0:	f8a7 3072 	strh.w	r3, [r7, #114]	; 0x72
#endif
	}

	result |= dmp_icm20948_set_data_output_control2(s, s->inv_sensor_control2);
  411df4:	68fb      	ldr	r3, [r7, #12]
  411df6:	f8b3 315c 	ldrh.w	r3, [r3, #348]	; 0x15c
  411dfa:	4619      	mov	r1, r3
  411dfc:	68f8      	ldr	r0, [r7, #12]
  411dfe:	4bbb      	ldr	r3, [pc, #748]	; (4120ec <inv_enable_sensor_internal+0x67c>)
  411e00:	4798      	blx	r3
  411e02:	4602      	mov	r2, r0
  411e04:	6f7b      	ldr	r3, [r7, #116]	; 0x74
  411e06:	4313      	orrs	r3, r2
  411e08:	677b      	str	r3, [r7, #116]	; 0x74

	// sets DATA_RDY_STATUS in DMP based on which sensors are on
	if (s->inv_androidSensorsOn_mask[0] & INV_NEEDS_GYRO_MASK || s->inv_androidSensorsOn_mask[1] & INV_NEEDS_GYRO_MASK1)
  411e0a:	68fb      	ldr	r3, [r7, #12]
  411e0c:	f8d3 2160 	ldr.w	r2, [r3, #352]	; 0x160
  411e10:	4bb7      	ldr	r3, [pc, #732]	; (4120f0 <inv_enable_sensor_internal+0x680>)
  411e12:	4013      	ands	r3, r2
  411e14:	2b00      	cmp	r3, #0
  411e16:	d107      	bne.n	411e28 <inv_enable_sensor_internal+0x3b8>
  411e18:	68fb      	ldr	r3, [r7, #12]
  411e1a:	f8d3 2164 	ldr.w	r2, [r3, #356]	; 0x164
  411e1e:	f640 0318 	movw	r3, #2072	; 0x818
  411e22:	4013      	ands	r3, r2
  411e24:	2b00      	cmp	r3, #0
  411e26:	d005      	beq.n	411e34 <inv_enable_sensor_internal+0x3c4>
		data_rdy_status |= GYRO_AVAILABLE;
  411e28:	f8b7 3070 	ldrh.w	r3, [r7, #112]	; 0x70
  411e2c:	f043 0301 	orr.w	r3, r3, #1
  411e30:	f8a7 3070 	strh.w	r3, [r7, #112]	; 0x70
	
	if (s->inv_androidSensorsOn_mask[0] & INV_NEEDS_ACCEL_MASK || s->inv_androidSensorsOn_mask[1] & INV_NEEDS_ACCEL_MASK1)
  411e34:	68fb      	ldr	r3, [r7, #12]
  411e36:	f8d3 2160 	ldr.w	r2, [r3, #352]	; 0x160
  411e3a:	4bae      	ldr	r3, [pc, #696]	; (4120f4 <inv_enable_sensor_internal+0x684>)
  411e3c:	4013      	ands	r3, r2
  411e3e:	2b00      	cmp	r3, #0
  411e40:	d106      	bne.n	411e50 <inv_enable_sensor_internal+0x3e0>
  411e42:	68fb      	ldr	r3, [r7, #12]
  411e44:	f8d3 3164 	ldr.w	r3, [r3, #356]	; 0x164
  411e48:	f403 63dd 	and.w	r3, r3, #1768	; 0x6e8
  411e4c:	2b00      	cmp	r3, #0
  411e4e:	d005      	beq.n	411e5c <inv_enable_sensor_internal+0x3ec>
		data_rdy_status |= ACCEL_AVAILABLE;
  411e50:	f8b7 3070 	ldrh.w	r3, [r7, #112]	; 0x70
  411e54:	f043 0302 	orr.w	r3, r3, #2
  411e58:	f8a7 3070 	strh.w	r3, [r7, #112]	; 0x70

	if (s->flip_pickup_status || s->b2s_status)
  411e5c:	68fb      	ldr	r3, [r7, #12]
  411e5e:	f8b3 3158 	ldrh.w	r3, [r3, #344]	; 0x158
  411e62:	2b00      	cmp	r3, #0
  411e64:	d104      	bne.n	411e70 <inv_enable_sensor_internal+0x400>
  411e66:	68fb      	ldr	r3, [r7, #12]
  411e68:	f8b3 3156 	ldrh.w	r3, [r3, #342]	; 0x156
  411e6c:	2b00      	cmp	r3, #0
  411e6e:	d005      	beq.n	411e7c <inv_enable_sensor_internal+0x40c>
		data_rdy_status |= ACCEL_AVAILABLE;
  411e70:	f8b7 3070 	ldrh.w	r3, [r7, #112]	; 0x70
  411e74:	f043 0302 	orr.w	r3, r3, #2
  411e78:	f8a7 3070 	strh.w	r3, [r7, #112]	; 0x70

	if (s->bac_status)
  411e7c:	68fb      	ldr	r3, [r7, #12]
  411e7e:	f8b3 3154 	ldrh.w	r3, [r3, #340]	; 0x154
  411e82:	2b00      	cmp	r3, #0
  411e84:	d005      	beq.n	411e92 <inv_enable_sensor_internal+0x422>
		data_rdy_status |= ACCEL_AVAILABLE;
  411e86:	f8b7 3070 	ldrh.w	r3, [r7, #112]	; 0x70
  411e8a:	f043 0302 	orr.w	r3, r3, #2
  411e8e:	f8a7 3070 	strh.w	r3, [r7, #112]	; 0x70

	if (s->inv_androidSensorsOn_mask[0] & INV_NEEDS_COMPASS_MASK || s->inv_androidSensorsOn_mask[1] & INV_NEEDS_COMPASS_MASK1) {
  411e92:	68fb      	ldr	r3, [r7, #12]
  411e94:	f8d3 2160 	ldr.w	r2, [r3, #352]	; 0x160
  411e98:	4b97      	ldr	r3, [pc, #604]	; (4120f8 <inv_enable_sensor_internal+0x688>)
  411e9a:	4013      	ands	r3, r2
  411e9c:	2b00      	cmp	r3, #0
  411e9e:	d106      	bne.n	411eae <inv_enable_sensor_internal+0x43e>
  411ea0:	68fb      	ldr	r3, [r7, #12]
  411ea2:	f8d3 3164 	ldr.w	r3, [r3, #356]	; 0x164
  411ea6:	f003 0384 	and.w	r3, r3, #132	; 0x84
  411eaa:	2b00      	cmp	r3, #0
  411eac:	d00b      	beq.n	411ec6 <inv_enable_sensor_internal+0x456>
		data_rdy_status |= SECONDARY_COMPASS_AVAILABLE;
  411eae:	f8b7 3070 	ldrh.w	r3, [r7, #112]	; 0x70
  411eb2:	f043 0308 	orr.w	r3, r3, #8
  411eb6:	f8a7 3070 	strh.w	r3, [r7, #112]	; 0x70
		inv_event_control |= INV_COMPASS_CAL_EN;
  411eba:	f8b7 3072 	ldrh.w	r3, [r7, #114]	; 0x72
  411ebe:	f043 0380 	orr.w	r3, r3, #128	; 0x80
  411ec2:	f8a7 3072 	strh.w	r3, [r7, #114]	; 0x72
	}
	// turn on gyro cal only if gyro is available
	if (data_rdy_status & GYRO_AVAILABLE)
  411ec6:	f8b7 3070 	ldrh.w	r3, [r7, #112]	; 0x70
  411eca:	f003 0301 	and.w	r3, r3, #1
  411ece:	2b00      	cmp	r3, #0
  411ed0:	d005      	beq.n	411ede <inv_enable_sensor_internal+0x46e>
		inv_event_control |= INV_GYRO_CAL_EN;
  411ed2:	f8b7 3072 	ldrh.w	r3, [r7, #114]	; 0x72
  411ed6:	f443 7380 	orr.w	r3, r3, #256	; 0x100
  411eda:	f8a7 3072 	strh.w	r3, [r7, #114]	; 0x72
		
	// turn on acc cal only if acc is available
	if (data_rdy_status & ACCEL_AVAILABLE)
  411ede:	f8b7 3070 	ldrh.w	r3, [r7, #112]	; 0x70
  411ee2:	f003 0302 	and.w	r3, r3, #2
  411ee6:	2b00      	cmp	r3, #0
  411ee8:	d005      	beq.n	411ef6 <inv_enable_sensor_internal+0x486>
		inv_event_control |= INV_ACCEL_CAL_EN;
  411eea:	f8b7 3072 	ldrh.w	r3, [r7, #114]	; 0x72
  411eee:	f443 7300 	orr.w	r3, r3, #512	; 0x200
  411ef2:	f8a7 3072 	strh.w	r3, [r7, #114]	; 0x72

	inv_event_control |= s->smd_status | s->ped_int_status;
  411ef6:	68fb      	ldr	r3, [r7, #12]
  411ef8:	f8b3 223e 	ldrh.w	r2, [r3, #574]	; 0x23e
  411efc:	68fb      	ldr	r3, [r7, #12]
  411efe:	f8b3 3240 	ldrh.w	r3, [r3, #576]	; 0x240
  411f02:	4313      	orrs	r3, r2
  411f04:	b29a      	uxth	r2, r3
  411f06:	f8b7 3072 	ldrh.w	r3, [r7, #114]	; 0x72
  411f0a:	4313      	orrs	r3, r2
  411f0c:	f8a7 3072 	strh.w	r3, [r7, #114]	; 0x72

	if (s->inv_sensor_control & QUAT9_SET)
  411f10:	68fb      	ldr	r3, [r7, #12]
  411f12:	f8b3 315a 	ldrh.w	r3, [r3, #346]	; 0x15a
  411f16:	f403 6380 	and.w	r3, r3, #1024	; 0x400
  411f1a:	2b00      	cmp	r3, #0
  411f1c:	d005      	beq.n	411f2a <inv_enable_sensor_internal+0x4ba>
		inv_event_control |= INV_NINE_AXIS_EN;
  411f1e:	f8b7 3072 	ldrh.w	r3, [r7, #114]	; 0x72
  411f22:	f043 0340 	orr.w	r3, r3, #64	; 0x40
  411f26:	f8a7 3072 	strh.w	r3, [r7, #114]	; 0x72

	if (s->inv_sensor_control & (PED_STEPDET_SET | PED_STEPIND_SET) || inv_event_control & INV_SMD_EN) {
  411f2a:	68fb      	ldr	r3, [r7, #12]
  411f2c:	f8b3 315a 	ldrh.w	r3, [r3, #346]	; 0x15a
  411f30:	f003 0317 	and.w	r3, r3, #23
  411f34:	2b00      	cmp	r3, #0
  411f36:	d105      	bne.n	411f44 <inv_enable_sensor_internal+0x4d4>
  411f38:	f8b7 3072 	ldrh.w	r3, [r7, #114]	; 0x72
  411f3c:	f403 6300 	and.w	r3, r3, #2048	; 0x800
  411f40:	2b00      	cmp	r3, #0
  411f42:	d012      	beq.n	411f6a <inv_enable_sensor_internal+0x4fa>
		inv_event_control |= INV_PEDOMETER_EN;
  411f44:	f8b7 3072 	ldrh.w	r3, [r7, #114]	; 0x72
  411f48:	f443 4380 	orr.w	r3, r3, #16384	; 0x4000
  411f4c:	f8a7 3072 	strh.w	r3, [r7, #114]	; 0x72
#ifndef ICM20948_FOR_MOBILE // Next lines change BAC behavior to wearable platform
		inv_event_control |= INV_BAC_WEARABLE_EN;
  411f50:	f8b7 3072 	ldrh.w	r3, [r7, #114]	; 0x72
  411f54:	ea6f 4343 	mvn.w	r3, r3, lsl #17
  411f58:	ea6f 4353 	mvn.w	r3, r3, lsr #17
  411f5c:	f8a7 3072 	strh.w	r3, [r7, #114]	; 0x72
		dmp_icm20948_set_ped_y_ratio(s, BAC_PED_Y_RATIO_WEARABLE);
  411f60:	f04f 4180 	mov.w	r1, #1073741824	; 0x40000000
  411f64:	68f8      	ldr	r0, [r7, #12]
  411f66:	4b65      	ldr	r3, [pc, #404]	; (4120fc <inv_enable_sensor_internal+0x68c>)
  411f68:	4798      	blx	r3
#endif
	}

	if (s->inv_sensor_control2 & ACT_RECOG_SET) {
  411f6a:	68fb      	ldr	r3, [r7, #12]
  411f6c:	f8b3 315c 	ldrh.w	r3, [r3, #348]	; 0x15c
  411f70:	f003 0380 	and.w	r3, r3, #128	; 0x80
  411f74:	2b00      	cmp	r3, #0
  411f76:	d012      	beq.n	411f9e <inv_enable_sensor_internal+0x52e>
		inv_event_control |= INV_PEDOMETER_EN;
  411f78:	f8b7 3072 	ldrh.w	r3, [r7, #114]	; 0x72
  411f7c:	f443 4380 	orr.w	r3, r3, #16384	; 0x4000
  411f80:	f8a7 3072 	strh.w	r3, [r7, #114]	; 0x72
#ifndef ICM20948_FOR_MOBILE // Next lines this to change BAC behavior to wearable platform
		inv_event_control |= INV_BAC_WEARABLE_EN;
  411f84:	f8b7 3072 	ldrh.w	r3, [r7, #114]	; 0x72
  411f88:	ea6f 4343 	mvn.w	r3, r3, lsl #17
  411f8c:	ea6f 4353 	mvn.w	r3, r3, lsr #17
  411f90:	f8a7 3072 	strh.w	r3, [r7, #114]	; 0x72
		dmp_icm20948_set_ped_y_ratio(s, BAC_PED_Y_RATIO_WEARABLE);
  411f94:	f04f 4180 	mov.w	r1, #1073741824	; 0x40000000
  411f98:	68f8      	ldr	r0, [r7, #12]
  411f9a:	4b58      	ldr	r3, [pc, #352]	; (4120fc <inv_enable_sensor_internal+0x68c>)
  411f9c:	4798      	blx	r3
#endif
	}

	if (s->inv_sensor_control2 & FLIP_PICKUP_SET){
  411f9e:	68fb      	ldr	r3, [r7, #12]
  411fa0:	f8b3 315c 	ldrh.w	r3, [r3, #348]	; 0x15c
  411fa4:	f403 6380 	and.w	r3, r3, #1024	; 0x400
  411fa8:	2b00      	cmp	r3, #0
  411faa:	d005      	beq.n	411fb8 <inv_enable_sensor_internal+0x548>
		inv_event_control |= FLIP_PICKUP_EN;
  411fac:	f8b7 3072 	ldrh.w	r3, [r7, #114]	; 0x72
  411fb0:	f043 0310 	orr.w	r3, r3, #16
  411fb4:	f8a7 3072 	strh.w	r3, [r7, #114]	; 0x72
	}

	if (s->inv_sensor_control & GEOMAG_SET)
  411fb8:	68fb      	ldr	r3, [r7, #12]
  411fba:	f8b3 315a 	ldrh.w	r3, [r3, #346]	; 0x15a
  411fbe:	f403 7380 	and.w	r3, r3, #256	; 0x100
  411fc2:	2b00      	cmp	r3, #0
  411fc4:	d005      	beq.n	411fd2 <inv_enable_sensor_internal+0x562>
		inv_event_control |= GEOMAG_EN;
  411fc6:	f8b7 3072 	ldrh.w	r3, [r7, #114]	; 0x72
  411fca:	f043 0308 	orr.w	r3, r3, #8
  411fce:	f8a7 3072 	strh.w	r3, [r7, #114]	; 0x72

	result |= dmp_icm20948_set_motion_event_control(s, inv_event_control);
  411fd2:	f8b7 3072 	ldrh.w	r3, [r7, #114]	; 0x72
  411fd6:	4619      	mov	r1, r3
  411fd8:	68f8      	ldr	r0, [r7, #12]
  411fda:	4b49      	ldr	r3, [pc, #292]	; (412100 <inv_enable_sensor_internal+0x690>)
  411fdc:	4798      	blx	r3
  411fde:	4602      	mov	r2, r0
  411fe0:	6f7b      	ldr	r3, [r7, #116]	; 0x74
  411fe2:	4313      	orrs	r3, r2
  411fe4:	677b      	str	r3, [r7, #116]	; 0x74
	
	// A sensor was just enabled/disabled, need to recompute the required ODR for all augmented sensor-related sensors
	// The fastest ODR will always be applied to other related sensors
	if (   (androidSensor == ANDROID_SENSOR_GRAVITY) 
  411fe6:	7afb      	ldrb	r3, [r7, #11]
  411fe8:	2b09      	cmp	r3, #9
  411fea:	d005      	beq.n	411ff8 <inv_enable_sensor_internal+0x588>
		|| (androidSensor == ANDROID_SENSOR_GAME_ROTATION_VECTOR) 
  411fec:	7afb      	ldrb	r3, [r7, #11]
  411fee:	2b0f      	cmp	r3, #15
  411ff0:	d002      	beq.n	411ff8 <inv_enable_sensor_internal+0x588>
		|| (androidSensor == ANDROID_SENSOR_LINEAR_ACCELERATION) ) {
  411ff2:	7afb      	ldrb	r3, [r7, #11]
  411ff4:	2b0a      	cmp	r3, #10
  411ff6:	d10f      	bne.n	412018 <inv_enable_sensor_internal+0x5a8>
		inv_icm20948_augmented_sensors_update_odr(s, androidSensor, &s->inv_dmp_odr_delays[INV_SENSOR_SIXQ]);
  411ff8:	68fb      	ldr	r3, [r7, #12]
  411ffa:	f503 7288 	add.w	r2, r3, #272	; 0x110
  411ffe:	7afb      	ldrb	r3, [r7, #11]
  412000:	4619      	mov	r1, r3
  412002:	68f8      	ldr	r0, [r7, #12]
  412004:	4b3f      	ldr	r3, [pc, #252]	; (412104 <inv_enable_sensor_internal+0x694>)
  412006:	4798      	blx	r3
		inv_icm20948_augmented_sensors_update_odr(s, androidSensor, &s->inv_dmp_odr_delays[INV_SENSOR_SIXQ_accel]);
  412008:	68fb      	ldr	r3, [r7, #12]
  41200a:	f503 7293 	add.w	r2, r3, #294	; 0x126
  41200e:	7afb      	ldrb	r3, [r7, #11]
  412010:	4619      	mov	r1, r3
  412012:	68f8      	ldr	r0, [r7, #12]
  412014:	4b3b      	ldr	r3, [pc, #236]	; (412104 <inv_enable_sensor_internal+0x694>)
  412016:	4798      	blx	r3
	}

	if (   (androidSensor == ANDROID_SENSOR_ORIENTATION) 
  412018:	7afb      	ldrb	r3, [r7, #11]
  41201a:	2b03      	cmp	r3, #3
  41201c:	d002      	beq.n	412024 <inv_enable_sensor_internal+0x5b4>
		|| (androidSensor == ANDROID_SENSOR_ROTATION_VECTOR) ) {
  41201e:	7afb      	ldrb	r3, [r7, #11]
  412020:	2b0b      	cmp	r3, #11
  412022:	d117      	bne.n	412054 <inv_enable_sensor_internal+0x5e4>
		inv_icm20948_augmented_sensors_update_odr(s, androidSensor, &s->inv_dmp_odr_delays[INV_SENSOR_NINEQ]);
  412024:	68fb      	ldr	r3, [r7, #12]
  412026:	f503 7289 	add.w	r2, r3, #274	; 0x112
  41202a:	7afb      	ldrb	r3, [r7, #11]
  41202c:	4619      	mov	r1, r3
  41202e:	68f8      	ldr	r0, [r7, #12]
  412030:	4b34      	ldr	r3, [pc, #208]	; (412104 <inv_enable_sensor_internal+0x694>)
  412032:	4798      	blx	r3
		inv_icm20948_augmented_sensors_update_odr(s, androidSensor, &s->inv_dmp_odr_delays[INV_SENSOR_NINEQ_accel]);
  412034:	68fb      	ldr	r3, [r7, #12]
  412036:	f503 7294 	add.w	r2, r3, #296	; 0x128
  41203a:	7afb      	ldrb	r3, [r7, #11]
  41203c:	4619      	mov	r1, r3
  41203e:	68f8      	ldr	r0, [r7, #12]
  412040:	4b30      	ldr	r3, [pc, #192]	; (412104 <inv_enable_sensor_internal+0x694>)
  412042:	4798      	blx	r3
		inv_icm20948_augmented_sensors_update_odr(s, androidSensor, &s->inv_dmp_odr_delays[INV_SENSOR_NINEQ_cpass]);
  412044:	68fb      	ldr	r3, [r7, #12]
  412046:	f503 7296 	add.w	r2, r3, #300	; 0x12c
  41204a:	7afb      	ldrb	r3, [r7, #11]
  41204c:	4619      	mov	r1, r3
  41204e:	68f8      	ldr	r0, [r7, #12]
  412050:	4b2c      	ldr	r3, [pc, #176]	; (412104 <inv_enable_sensor_internal+0x694>)
  412052:	4798      	blx	r3
	}

	if (   (androidSensor == ANDROID_SENSOR_WAKEUP_GRAVITY) 
  412054:	7afb      	ldrb	r3, [r7, #11]
  412056:	2b1d      	cmp	r3, #29
  412058:	d005      	beq.n	412066 <inv_enable_sensor_internal+0x5f6>
		|| (androidSensor == ANDROID_SENSOR_WAKEUP_GAME_ROTATION_VECTOR) 
  41205a:	7afb      	ldrb	r3, [r7, #11]
  41205c:	2b23      	cmp	r3, #35	; 0x23
  41205e:	d002      	beq.n	412066 <inv_enable_sensor_internal+0x5f6>
		|| (androidSensor == ANDROID_SENSOR_WAKEUP_LINEAR_ACCELERATION) ) {
  412060:	7afb      	ldrb	r3, [r7, #11]
  412062:	2b1e      	cmp	r3, #30
  412064:	d10f      	bne.n	412086 <inv_enable_sensor_internal+0x616>
		inv_icm20948_augmented_sensors_update_odr(s, androidSensor, &s->inv_dmp_odr_delays[INV_SENSOR_WAKEUP_SIXQ]);
  412066:	68fb      	ldr	r3, [r7, #12]
  412068:	f503 729b 	add.w	r2, r3, #310	; 0x136
  41206c:	7afb      	ldrb	r3, [r7, #11]
  41206e:	4619      	mov	r1, r3
  412070:	68f8      	ldr	r0, [r7, #12]
  412072:	4b24      	ldr	r3, [pc, #144]	; (412104 <inv_enable_sensor_internal+0x694>)
  412074:	4798      	blx	r3
		inv_icm20948_augmented_sensors_update_odr(s, androidSensor, &s->inv_dmp_odr_delays[INV_SENSOR_WAKEUP_SIXQ_accel]);
  412076:	68fb      	ldr	r3, [r7, #12]
  412078:	f503 72a4 	add.w	r2, r3, #328	; 0x148
  41207c:	7afb      	ldrb	r3, [r7, #11]
  41207e:	4619      	mov	r1, r3
  412080:	68f8      	ldr	r0, [r7, #12]
  412082:	4b20      	ldr	r3, [pc, #128]	; (412104 <inv_enable_sensor_internal+0x694>)
  412084:	4798      	blx	r3
	}

	if (   (androidSensor == ANDROID_SENSOR_WAKEUP_ORIENTATION) 
  412086:	7afb      	ldrb	r3, [r7, #11]
  412088:	2b19      	cmp	r3, #25
  41208a:	d002      	beq.n	412092 <inv_enable_sensor_internal+0x622>
		|| (androidSensor == ANDROID_SENSOR_WAKEUP_ROTATION_VECTOR) ) {
  41208c:	7afb      	ldrb	r3, [r7, #11]
  41208e:	2b1f      	cmp	r3, #31
  412090:	d117      	bne.n	4120c2 <inv_enable_sensor_internal+0x652>
		inv_icm20948_augmented_sensors_update_odr(s, androidSensor, &s->inv_dmp_odr_delays[INV_SENSOR_WAKEUP_NINEQ]);
  412092:	68fb      	ldr	r3, [r7, #12]
  412094:	f503 729c 	add.w	r2, r3, #312	; 0x138
  412098:	7afb      	ldrb	r3, [r7, #11]
  41209a:	4619      	mov	r1, r3
  41209c:	68f8      	ldr	r0, [r7, #12]
  41209e:	4b19      	ldr	r3, [pc, #100]	; (412104 <inv_enable_sensor_internal+0x694>)
  4120a0:	4798      	blx	r3
		inv_icm20948_augmented_sensors_update_odr(s, androidSensor, &s->inv_dmp_odr_delays[INV_SENSOR_WAKEUP_NINEQ_accel]);
  4120a2:	68fb      	ldr	r3, [r7, #12]
  4120a4:	f503 72a5 	add.w	r2, r3, #330	; 0x14a
  4120a8:	7afb      	ldrb	r3, [r7, #11]
  4120aa:	4619      	mov	r1, r3
  4120ac:	68f8      	ldr	r0, [r7, #12]
  4120ae:	4b15      	ldr	r3, [pc, #84]	; (412104 <inv_enable_sensor_internal+0x694>)
  4120b0:	4798      	blx	r3
		inv_icm20948_augmented_sensors_update_odr(s, androidSensor, &s->inv_dmp_odr_delays[INV_SENSOR_WAKEUP_NINEQ_cpass]);
  4120b2:	68fb      	ldr	r3, [r7, #12]
  4120b4:	f503 72a7 	add.w	r2, r3, #334	; 0x14e
  4120b8:	7afb      	ldrb	r3, [r7, #11]
  4120ba:	4619      	mov	r1, r3
  4120bc:	68f8      	ldr	r0, [r7, #12]
  4120be:	4b11      	ldr	r3, [pc, #68]	; (412104 <inv_enable_sensor_internal+0x694>)
  4120c0:	4798      	blx	r3
	}

	result |= inv_set_hw_smplrt_dmp_odrs(s);
  4120c2:	68f8      	ldr	r0, [r7, #12]
  4120c4:	4b10      	ldr	r3, [pc, #64]	; (412108 <inv_enable_sensor_internal+0x698>)
  4120c6:	4798      	blx	r3
  4120c8:	4602      	mov	r2, r0
  4120ca:	6f7b      	ldr	r3, [r7, #116]	; 0x74
  4120cc:	4313      	orrs	r3, r2
  4120ce:	677b      	str	r3, [r7, #116]	; 0x74
	result |= inv_icm20948_set_gyro_sf(s, inv_icm20948_get_gyro_divider(s), inv_icm20948_get_gyro_fullscale(s));
  4120d0:	68f8      	ldr	r0, [r7, #12]
  4120d2:	4b0e      	ldr	r3, [pc, #56]	; (41210c <inv_enable_sensor_internal+0x69c>)
  4120d4:	4798      	blx	r3
  4120d6:	4603      	mov	r3, r0
  4120d8:	461c      	mov	r4, r3
  4120da:	68f8      	ldr	r0, [r7, #12]
  4120dc:	4b0c      	ldr	r3, [pc, #48]	; (412110 <inv_enable_sensor_internal+0x6a0>)
  4120de:	4798      	blx	r3
  4120e0:	4603      	mov	r3, r0
  4120e2:	461a      	mov	r2, r3
  4120e4:	4621      	mov	r1, r4
  4120e6:	68f8      	ldr	r0, [r7, #12]
  4120e8:	e014      	b.n	412114 <inv_enable_sensor_internal+0x6a4>
  4120ea:	bf00      	nop
  4120ec:	00407c71 	.word	0x00407c71
  4120f0:	e6018e18 	.word	0xe6018e18
  4120f4:	e29e8e0a 	.word	0xe29e8e0a
  4120f8:	8310480c 	.word	0x8310480c
  4120fc:	00408821 	.word	0x00408821
  412100:	00407e19 	.word	0x00407e19
  412104:	004105b5 	.word	0x004105b5
  412108:	00410da5 	.word	0x00410da5
  41210c:	00405ebd 	.word	0x00405ebd
  412110:	00406161 	.word	0x00406161
  412114:	4b2e      	ldr	r3, [pc, #184]	; (4121d0 <inv_enable_sensor_internal+0x760>)
  412116:	4798      	blx	r3
  412118:	4602      	mov	r2, r0
  41211a:	6f7b      	ldr	r3, [r7, #116]	; 0x74
  41211c:	4313      	orrs	r3, r2
  41211e:	677b      	str	r3, [r7, #116]	; 0x74

	if (!s->inv_sensor_control && !(s->inv_androidSensorsOn_mask[0] & (1L << ANDROID_SENSOR_WAKEUP_SIGNIFICANT_MOTION)) && !s->b2s_status) {
  412120:	68fb      	ldr	r3, [r7, #12]
  412122:	f8b3 315a 	ldrh.w	r3, [r3, #346]	; 0x15a
  412126:	2b00      	cmp	r3, #0
  412128:	d115      	bne.n	412156 <inv_enable_sensor_internal+0x6e6>
  41212a:	68fb      	ldr	r3, [r7, #12]
  41212c:	f8d3 3160 	ldr.w	r3, [r3, #352]	; 0x160
  412130:	f403 3300 	and.w	r3, r3, #131072	; 0x20000
  412134:	2b00      	cmp	r3, #0
  412136:	d10e      	bne.n	412156 <inv_enable_sensor_internal+0x6e6>
  412138:	68fb      	ldr	r3, [r7, #12]
  41213a:	f8b3 3156 	ldrh.w	r3, [r3, #342]	; 0x156
  41213e:	2b00      	cmp	r3, #0
  412140:	d109      	bne.n	412156 <inv_enable_sensor_internal+0x6e6>
		*mems_put_to_sleep =1 ;
  412142:	687b      	ldr	r3, [r7, #4]
  412144:	2201      	movs	r2, #1
  412146:	701a      	strb	r2, [r3, #0]
		result |= inv_icm20948_sleep_mems(s);
  412148:	68f8      	ldr	r0, [r7, #12]
  41214a:	4b22      	ldr	r3, [pc, #136]	; (4121d4 <inv_enable_sensor_internal+0x764>)
  41214c:	4798      	blx	r3
  41214e:	4602      	mov	r2, r0
  412150:	6f7b      	ldr	r3, [r7, #116]	; 0x74
  412152:	4313      	orrs	r3, r2
  412154:	677b      	str	r3, [r7, #116]	; 0x74
	}

	// DMP no longer controls PWR_MGMT_2 because of hardware bug, 0x80 set to override default behaviour of inv_icm20948_enable_hw_sensors()
	result |= inv_icm20948_enable_hw_sensors(s, (int)data_rdy_status | 0x80);
  412156:	f8b7 3070 	ldrh.w	r3, [r7, #112]	; 0x70
  41215a:	f043 0380 	orr.w	r3, r3, #128	; 0x80
  41215e:	b29b      	uxth	r3, r3
  412160:	4619      	mov	r1, r3
  412162:	68f8      	ldr	r0, [r7, #12]
  412164:	4b1c      	ldr	r3, [pc, #112]	; (4121d8 <inv_enable_sensor_internal+0x768>)
  412166:	4798      	blx	r3
  412168:	4602      	mov	r2, r0
  41216a:	6f7b      	ldr	r3, [r7, #116]	; 0x74
  41216c:	4313      	orrs	r3, r2
  41216e:	677b      	str	r3, [r7, #116]	; 0x74

	// set DATA_RDY_STATUS in DMP
	if (data_rdy_status & SECONDARY_COMPASS_AVAILABLE)	{
  412170:	f8b7 3070 	ldrh.w	r3, [r7, #112]	; 0x70
  412174:	f003 0308 	and.w	r3, r3, #8
  412178:	2b00      	cmp	r3, #0
  41217a:	d005      	beq.n	412188 <inv_enable_sensor_internal+0x718>
		data_rdy_status |= SECONDARY_COMPASS_AVAILABLE;
  41217c:	f8b7 3070 	ldrh.w	r3, [r7, #112]	; 0x70
  412180:	f043 0308 	orr.w	r3, r3, #8
  412184:	f8a7 3070 	strh.w	r3, [r7, #112]	; 0x70
	}

	result |= dmp_icm20948_set_data_rdy_status(s, data_rdy_status);
  412188:	f8b7 3070 	ldrh.w	r3, [r7, #112]	; 0x70
  41218c:	4619      	mov	r1, r3
  41218e:	68f8      	ldr	r0, [r7, #12]
  412190:	4b12      	ldr	r3, [pc, #72]	; (4121dc <inv_enable_sensor_internal+0x76c>)
  412192:	4798      	blx	r3
  412194:	4602      	mov	r2, r0
  412196:	6f7b      	ldr	r3, [r7, #116]	; 0x74
  412198:	4313      	orrs	r3, r2
  41219a:	677b      	str	r3, [r7, #116]	; 0x74

	// To have the all steps when you enable the sensor
	if (androidSensor == ANDROID_SENSOR_STEP_COUNTER)
  41219c:	7afb      	ldrb	r3, [r7, #11]
  41219e:	2b13      	cmp	r3, #19
  4121a0:	d110      	bne.n	4121c4 <inv_enable_sensor_internal+0x754>
	{
		if (enable)
  4121a2:	7abb      	ldrb	r3, [r7, #10]
  4121a4:	2b00      	cmp	r3, #0
  4121a6:	d00d      	beq.n	4121c4 <inv_enable_sensor_internal+0x754>
		{
			dmp_icm20948_get_pedometer_num_of_steps(s, &steps);
  4121a8:	f107 036c 	add.w	r3, r7, #108	; 0x6c
  4121ac:	4619      	mov	r1, r3
  4121ae:	68f8      	ldr	r0, [r7, #12]
  4121b0:	4b0b      	ldr	r3, [pc, #44]	; (4121e0 <inv_enable_sensor_internal+0x770>)
  4121b2:	4798      	blx	r3
			s->sStepCounterToBeSubtracted = steps - s->sOldSteps;
  4121b4:	6efa      	ldr	r2, [r7, #108]	; 0x6c
  4121b6:	68fb      	ldr	r3, [r7, #12]
  4121b8:	f8d3 30a4 	ldr.w	r3, [r3, #164]	; 0xa4
  4121bc:	1ad2      	subs	r2, r2, r3
  4121be:	68fb      	ldr	r3, [r7, #12]
  4121c0:	f8c3 20a0 	str.w	r2, [r3, #160]	; 0xa0
		}
	}

	return result;
  4121c4:	6f7b      	ldr	r3, [r7, #116]	; 0x74
}
  4121c6:	4618      	mov	r0, r3
  4121c8:	377c      	adds	r7, #124	; 0x7c
  4121ca:	46bd      	mov	sp, r7
  4121cc:	bd90      	pop	{r4, r7, pc}
  4121ce:	bf00      	nop
  4121d0:	00405f59 	.word	0x00405f59
  4121d4:	004059d1 	.word	0x004059d1
  4121d8:	004064bd 	.word	0x004064bd
  4121dc:	00407dcd 	.word	0x00407dcd
  4121e0:	0040827d 	.word	0x0040827d

004121e4 <inv_icm20948_ctrl_enable_activity_classifier>:

void inv_icm20948_ctrl_enable_activity_classifier(struct inv_icm20948 * s, unsigned char enable) 
{
  4121e4:	b580      	push	{r7, lr}
  4121e6:	b082      	sub	sp, #8
  4121e8:	af00      	add	r7, sp, #0
  4121ea:	6078      	str	r0, [r7, #4]
  4121ec:	460b      	mov	r3, r1
  4121ee:	70fb      	strb	r3, [r7, #3]
	s->bac_on = enable;
  4121f0:	78fb      	ldrb	r3, [r7, #3]
  4121f2:	b29a      	uxth	r2, r3
  4121f4:	687b      	ldr	r3, [r7, #4]
  4121f6:	f8a3 2150 	strh.w	r2, [r3, #336]	; 0x150
	if (enable) {
  4121fa:	78fb      	ldrb	r3, [r7, #3]
  4121fc:	2b00      	cmp	r3, #0
  4121fe:	d015      	beq.n	41222c <inv_icm20948_ctrl_enable_activity_classifier+0x48>
		s->bac_status = ACT_RECOG_SET;
  412200:	687b      	ldr	r3, [r7, #4]
  412202:	2280      	movs	r2, #128	; 0x80
  412204:	f8a3 2154 	strh.w	r2, [r3, #340]	; 0x154
		s->inv_sensor_control2 |= ACT_RECOG_SET;
  412208:	687b      	ldr	r3, [r7, #4]
  41220a:	f8b3 315c 	ldrh.w	r3, [r3, #348]	; 0x15c
  41220e:	f043 0380 	orr.w	r3, r3, #128	; 0x80
  412212:	b29a      	uxth	r2, r3
  412214:	687b      	ldr	r3, [r7, #4]
  412216:	f8a3 215c 	strh.w	r2, [r3, #348]	; 0x15c
		s->bac_request ++;
  41221a:	687b      	ldr	r3, [r7, #4]
  41221c:	f8b3 3242 	ldrh.w	r3, [r3, #578]	; 0x242
  412220:	3301      	adds	r3, #1
  412222:	b29a      	uxth	r2, r3
  412224:	687b      	ldr	r3, [r7, #4]
  412226:	f8a3 2242 	strh.w	r2, [r3, #578]	; 0x242
			s->bac_status = 0;
			s->inv_sensor_control2 &= ~ACT_RECOG_SET;
			s->bac_request --;
		}
	}
}
  41222a:	e01b      	b.n	412264 <inv_icm20948_ctrl_enable_activity_classifier+0x80>
		if (!inv_icm20948_ctrl_androidSensor_enabled(s, ANDROID_SENSOR_WAKEUP_TILT_DETECTOR)) {
  41222c:	2129      	movs	r1, #41	; 0x29
  41222e:	6878      	ldr	r0, [r7, #4]
  412230:	4b0e      	ldr	r3, [pc, #56]	; (41226c <inv_icm20948_ctrl_enable_activity_classifier+0x88>)
  412232:	4798      	blx	r3
  412234:	4603      	mov	r3, r0
  412236:	2b00      	cmp	r3, #0
  412238:	d114      	bne.n	412264 <inv_icm20948_ctrl_enable_activity_classifier+0x80>
			s->bac_status = 0;
  41223a:	687b      	ldr	r3, [r7, #4]
  41223c:	2200      	movs	r2, #0
  41223e:	f8a3 2154 	strh.w	r2, [r3, #340]	; 0x154
			s->inv_sensor_control2 &= ~ACT_RECOG_SET;
  412242:	687b      	ldr	r3, [r7, #4]
  412244:	f8b3 315c 	ldrh.w	r3, [r3, #348]	; 0x15c
  412248:	f023 0380 	bic.w	r3, r3, #128	; 0x80
  41224c:	b29a      	uxth	r2, r3
  41224e:	687b      	ldr	r3, [r7, #4]
  412250:	f8a3 215c 	strh.w	r2, [r3, #348]	; 0x15c
			s->bac_request --;
  412254:	687b      	ldr	r3, [r7, #4]
  412256:	f8b3 3242 	ldrh.w	r3, [r3, #578]	; 0x242
  41225a:	3b01      	subs	r3, #1
  41225c:	b29a      	uxth	r2, r3
  41225e:	687b      	ldr	r3, [r7, #4]
  412260:	f8a3 2242 	strh.w	r2, [r3, #578]	; 0x242
}
  412264:	bf00      	nop
  412266:	3708      	adds	r7, #8
  412268:	46bd      	mov	sp, r7
  41226a:	bd80      	pop	{r7, pc}
  41226c:	004107b9 	.word	0x004107b9

00412270 <inv_icm20948_ctrl_enable_tilt>:

void inv_icm20948_ctrl_enable_tilt(struct inv_icm20948 * s, unsigned char enable) 
{
  412270:	b480      	push	{r7}
  412272:	b083      	sub	sp, #12
  412274:	af00      	add	r7, sp, #0
  412276:	6078      	str	r0, [r7, #4]
  412278:	460b      	mov	r3, r1
  41227a:	70fb      	strb	r3, [r7, #3]
	if (enable) {
  41227c:	78fb      	ldrb	r3, [r7, #3]
  41227e:	2b00      	cmp	r3, #0
  412280:	d015      	beq.n	4122ae <inv_icm20948_ctrl_enable_tilt+0x3e>
		s->bac_status = ACT_RECOG_SET;
  412282:	687b      	ldr	r3, [r7, #4]
  412284:	2280      	movs	r2, #128	; 0x80
  412286:	f8a3 2154 	strh.w	r2, [r3, #340]	; 0x154
		s->inv_sensor_control2 |= ACT_RECOG_SET;
  41228a:	687b      	ldr	r3, [r7, #4]
  41228c:	f8b3 315c 	ldrh.w	r3, [r3, #348]	; 0x15c
  412290:	f043 0380 	orr.w	r3, r3, #128	; 0x80
  412294:	b29a      	uxth	r2, r3
  412296:	687b      	ldr	r3, [r7, #4]
  412298:	f8a3 215c 	strh.w	r2, [r3, #348]	; 0x15c
		s->bac_request ++;
  41229c:	687b      	ldr	r3, [r7, #4]
  41229e:	f8b3 3242 	ldrh.w	r3, [r3, #578]	; 0x242
  4122a2:	3301      	adds	r3, #1
  4122a4:	b29a      	uxth	r2, r3
  4122a6:	687b      	ldr	r3, [r7, #4]
  4122a8:	f8a3 2242 	strh.w	r2, [r3, #578]	; 0x242
			s->bac_status = 0;
			s->inv_sensor_control2 &= ~ACT_RECOG_SET;
			s->bac_request --;
		}
	}
}
  4122ac:	e019      	b.n	4122e2 <inv_icm20948_ctrl_enable_tilt+0x72>
		if (!s->bac_on) {
  4122ae:	687b      	ldr	r3, [r7, #4]
  4122b0:	f8b3 3150 	ldrh.w	r3, [r3, #336]	; 0x150
  4122b4:	2b00      	cmp	r3, #0
  4122b6:	d114      	bne.n	4122e2 <inv_icm20948_ctrl_enable_tilt+0x72>
			s->bac_status = 0;
  4122b8:	687b      	ldr	r3, [r7, #4]
  4122ba:	2200      	movs	r2, #0
  4122bc:	f8a3 2154 	strh.w	r2, [r3, #340]	; 0x154
			s->inv_sensor_control2 &= ~ACT_RECOG_SET;
  4122c0:	687b      	ldr	r3, [r7, #4]
  4122c2:	f8b3 315c 	ldrh.w	r3, [r3, #348]	; 0x15c
  4122c6:	f023 0380 	bic.w	r3, r3, #128	; 0x80
  4122ca:	b29a      	uxth	r2, r3
  4122cc:	687b      	ldr	r3, [r7, #4]
  4122ce:	f8a3 215c 	strh.w	r2, [r3, #348]	; 0x15c
			s->bac_request --;
  4122d2:	687b      	ldr	r3, [r7, #4]
  4122d4:	f8b3 3242 	ldrh.w	r3, [r3, #578]	; 0x242
  4122d8:	3b01      	subs	r3, #1
  4122da:	b29a      	uxth	r2, r3
  4122dc:	687b      	ldr	r3, [r7, #4]
  4122de:	f8a3 2242 	strh.w	r2, [r3, #578]	; 0x242
}
  4122e2:	bf00      	nop
  4122e4:	370c      	adds	r7, #12
  4122e6:	46bd      	mov	sp, r7
  4122e8:	f85d 7b04 	ldr.w	r7, [sp], #4
  4122ec:	4770      	bx	lr

004122ee <inv_icm20948_ctrl_get_batch_mode_status>:
	else
		s->sBatchMode=0;
}

unsigned char inv_icm20948_ctrl_get_batch_mode_status(struct inv_icm20948 * s)
{
  4122ee:	b480      	push	{r7}
  4122f0:	b083      	sub	sp, #12
  4122f2:	af00      	add	r7, sp, #0
  4122f4:	6078      	str	r0, [r7, #4]
	return s->sBatchMode;
  4122f6:	687b      	ldr	r3, [r7, #4]
  4122f8:	f893 323a 	ldrb.w	r3, [r3, #570]	; 0x23a
}
  4122fc:	4618      	mov	r0, r3
  4122fe:	370c      	adds	r7, #12
  412300:	46bd      	mov	sp, r7
  412302:	f85d 7b04 	ldr.w	r7, [sp], #4
  412306:	4770      	bx	lr

00412308 <inv_icm20948_ctrl_get_activitiy_classifier_on_flag>:
{
	return s->inv_androidSensorsOn_mask;
}

unsigned short inv_icm20948_ctrl_get_activitiy_classifier_on_flag(struct inv_icm20948 * s)
{
  412308:	b480      	push	{r7}
  41230a:	b083      	sub	sp, #12
  41230c:	af00      	add	r7, sp, #0
  41230e:	6078      	str	r0, [r7, #4]
	return s->bac_on;
  412310:	687b      	ldr	r3, [r7, #4]
  412312:	f8b3 3150 	ldrh.w	r3, [r3, #336]	; 0x150
}
  412316:	4618      	mov	r0, r3
  412318:	370c      	adds	r7, #12
  41231a:	46bd      	mov	sp, r7
  41231c:	f85d 7b04 	ldr.w	r7, [sp], #4
  412320:	4770      	bx	lr
	...

00412324 <inv_icm20948_ctrl_set_accel_quaternion_gain>:
/** @brief Sets accel quaternion gain according to accel engine rate.
* @param[in] hw_smplrt_divider  hardware sample rate divider such that accel engine rate = 1125Hz/hw_smplrt_divider
* @return 0 in case of success, -1 for any error
*/
int inv_icm20948_ctrl_set_accel_quaternion_gain(struct inv_icm20948 * s, unsigned short hw_smplrt_divider)
{
  412324:	b580      	push	{r7, lr}
  412326:	b084      	sub	sp, #16
  412328:	af00      	add	r7, sp, #0
  41232a:	6078      	str	r0, [r7, #4]
  41232c:	460b      	mov	r3, r1
  41232e:	807b      	strh	r3, [r7, #2]
	int accel_gain = 15252014L; //set 225Hz gain as default
  412330:	4b23      	ldr	r3, [pc, #140]	; (4123c0 <inv_icm20948_ctrl_set_accel_quaternion_gain+0x9c>)
  412332:	60fb      	str	r3, [r7, #12]

	switch (hw_smplrt_divider) {
  412334:	887b      	ldrh	r3, [r7, #2]
  412336:	3b05      	subs	r3, #5
  412338:	2b11      	cmp	r3, #17
  41233a:	d835      	bhi.n	4123a8 <inv_icm20948_ctrl_set_accel_quaternion_gain+0x84>
  41233c:	a201      	add	r2, pc, #4	; (adr r2, 412344 <inv_icm20948_ctrl_set_accel_quaternion_gain+0x20>)
  41233e:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
  412342:	bf00      	nop
  412344:	0041238d 	.word	0x0041238d
  412348:	004123a9 	.word	0x004123a9
  41234c:	004123a9 	.word	0x004123a9
  412350:	004123a9 	.word	0x004123a9
  412354:	004123a9 	.word	0x004123a9
  412358:	00412393 	.word	0x00412393
  41235c:	00412399 	.word	0x00412399
  412360:	004123a9 	.word	0x004123a9
  412364:	004123a9 	.word	0x004123a9
  412368:	004123a9 	.word	0x004123a9
  41236c:	004123a9 	.word	0x004123a9
  412370:	004123a9 	.word	0x004123a9
  412374:	004123a9 	.word	0x004123a9
  412378:	004123a9 	.word	0x004123a9
  41237c:	004123a9 	.word	0x004123a9
  412380:	004123a9 	.word	0x004123a9
  412384:	004123a9 	.word	0x004123a9
  412388:	004123a1 	.word	0x004123a1
		case 5: //1125Hz/5 = 225Hz
			accel_gain = 15252014L;
  41238c:	4b0c      	ldr	r3, [pc, #48]	; (4123c0 <inv_icm20948_ctrl_set_accel_quaternion_gain+0x9c>)
  41238e:	60fb      	str	r3, [r7, #12]
			break;
  412390:	e00d      	b.n	4123ae <inv_icm20948_ctrl_set_accel_quaternion_gain+0x8a>
		case 10: //1125Hz/10 = 112Hz
			accel_gain = 30504029L;
  412392:	4b0c      	ldr	r3, [pc, #48]	; (4123c4 <inv_icm20948_ctrl_set_accel_quaternion_gain+0xa0>)
  412394:	60fb      	str	r3, [r7, #12]
			break;
  412396:	e00a      	b.n	4123ae <inv_icm20948_ctrl_set_accel_quaternion_gain+0x8a>
		case 11: //1125Hz/11 = 102Hz
			accel_gain = 33554432L;
  412398:	f04f 7300 	mov.w	r3, #33554432	; 0x2000000
  41239c:	60fb      	str	r3, [r7, #12]
			break;
  41239e:	e006      	b.n	4123ae <inv_icm20948_ctrl_set_accel_quaternion_gain+0x8a>
		case 22: //1125Hz/22 = 51Hz
			accel_gain = 67108864L;
  4123a0:	f04f 6380 	mov.w	r3, #67108864	; 0x4000000
  4123a4:	60fb      	str	r3, [r7, #12]
			break;
  4123a6:	e002      	b.n	4123ae <inv_icm20948_ctrl_set_accel_quaternion_gain+0x8a>
		default:
			accel_gain = 15252014L;
  4123a8:	4b05      	ldr	r3, [pc, #20]	; (4123c0 <inv_icm20948_ctrl_set_accel_quaternion_gain+0x9c>)
  4123aa:	60fb      	str	r3, [r7, #12]
			break;
  4123ac:	bf00      	nop
	}

	return dmp_icm20948_set_accel_feedback_gain(s, accel_gain);
  4123ae:	68f9      	ldr	r1, [r7, #12]
  4123b0:	6878      	ldr	r0, [r7, #4]
  4123b2:	4b05      	ldr	r3, [pc, #20]	; (4123c8 <inv_icm20948_ctrl_set_accel_quaternion_gain+0xa4>)
  4123b4:	4798      	blx	r3
  4123b6:	4603      	mov	r3, r0
}
  4123b8:	4618      	mov	r0, r3
  4123ba:	3710      	adds	r7, #16
  4123bc:	46bd      	mov	sp, r7
  4123be:	bd80      	pop	{r7, pc}
  4123c0:	00e8ba2e 	.word	0x00e8ba2e
  4123c4:	01d1745d 	.word	0x01d1745d
  4123c8:	00408009 	.word	0x00408009

004123cc <inv_icm20948_ctrl_set_accel_cal_params>:

int inv_icm20948_ctrl_set_accel_cal_params(struct inv_icm20948 * s, unsigned short hw_smplrt_divider)
{
  4123cc:	b580      	push	{r7, lr}
  4123ce:	b086      	sub	sp, #24
  4123d0:	af00      	add	r7, sp, #0
  4123d2:	6078      	str	r0, [r7, #4]
  4123d4:	460b      	mov	r3, r1
  4123d6:	807b      	strh	r3, [r7, #2]
	int accel_cal_params[NUM_ACCEL_CAL_PARAMS] = {0};
  4123d8:	f107 030c 	add.w	r3, r7, #12
  4123dc:	2200      	movs	r2, #0
  4123de:	601a      	str	r2, [r3, #0]
  4123e0:	605a      	str	r2, [r3, #4]
  4123e2:	609a      	str	r2, [r3, #8]

	if (hw_smplrt_divider <= 5) { // freq = 225Hz
  4123e4:	887b      	ldrh	r3, [r7, #2]
  4123e6:	2b05      	cmp	r3, #5
  4123e8:	d804      	bhi.n	4123f4 <inv_icm20948_ctrl_set_accel_cal_params+0x28>
		accel_cal_params[ACCEL_CAL_ALPHA_VAR] = 1026019965L;
  4123ea:	4b21      	ldr	r3, [pc, #132]	; (412470 <inv_icm20948_ctrl_set_accel_cal_params+0xa4>)
  4123ec:	60fb      	str	r3, [r7, #12]
		accel_cal_params[ACCEL_CAL_A_VAR] = 47721859L;
  4123ee:	4b21      	ldr	r3, [pc, #132]	; (412474 <inv_icm20948_ctrl_set_accel_cal_params+0xa8>)
  4123f0:	613b      	str	r3, [r7, #16]
  4123f2:	e032      	b.n	41245a <inv_icm20948_ctrl_set_accel_cal_params+0x8e>
	} 
	else if (hw_smplrt_divider <= 10) { // 225Hz > freq >= 112Hz
  4123f4:	887b      	ldrh	r3, [r7, #2]
  4123f6:	2b0a      	cmp	r3, #10
  4123f8:	d804      	bhi.n	412404 <inv_icm20948_ctrl_set_accel_cal_params+0x38>
		accel_cal_params[ACCEL_CAL_ALPHA_VAR] = 977872018L;
  4123fa:	4b1f      	ldr	r3, [pc, #124]	; (412478 <inv_icm20948_ctrl_set_accel_cal_params+0xac>)
  4123fc:	60fb      	str	r3, [r7, #12]
		accel_cal_params[ACCEL_CAL_A_VAR] = 95869806L;
  4123fe:	4b1f      	ldr	r3, [pc, #124]	; (41247c <inv_icm20948_ctrl_set_accel_cal_params+0xb0>)
  412400:	613b      	str	r3, [r7, #16]
  412402:	e02a      	b.n	41245a <inv_icm20948_ctrl_set_accel_cal_params+0x8e>
	} 
	else if (hw_smplrt_divider <= 11) { // 112Hz > freq >= 102Hz
  412404:	887b      	ldrh	r3, [r7, #2]
  412406:	2b0b      	cmp	r3, #11
  412408:	d807      	bhi.n	41241a <inv_icm20948_ctrl_set_accel_cal_params+0x4e>
		accel_cal_params[ACCEL_CAL_ALPHA_VAR] = 858993459L;
  41240a:	f04f 3333 	mov.w	r3, #858993459	; 0x33333333
  41240e:	60fb      	str	r3, [r7, #12]
		accel_cal_params[ACCEL_CAL_A_VAR] = 214748365L;
  412410:	4b1b      	ldr	r3, [pc, #108]	; (412480 <inv_icm20948_ctrl_set_accel_cal_params+0xb4>)
  412412:	613b      	str	r3, [r7, #16]
		accel_cal_params[ACCEL_CAL_DIV] = 1;
  412414:	2301      	movs	r3, #1
  412416:	617b      	str	r3, [r7, #20]
  412418:	e01f      	b.n	41245a <inv_icm20948_ctrl_set_accel_cal_params+0x8e>
	} 
	else if (hw_smplrt_divider <= 20) { // 102Hz > freq >= 56Hz
  41241a:	887b      	ldrh	r3, [r7, #2]
  41241c:	2b14      	cmp	r3, #20
  41241e:	d804      	bhi.n	41242a <inv_icm20948_ctrl_set_accel_cal_params+0x5e>
		accel_cal_params[ACCEL_CAL_ALPHA_VAR] = 882002213L;
  412420:	4b18      	ldr	r3, [pc, #96]	; (412484 <inv_icm20948_ctrl_set_accel_cal_params+0xb8>)
  412422:	60fb      	str	r3, [r7, #12]
		accel_cal_params[ACCEL_CAL_A_VAR] = 191739611L;
  412424:	4b18      	ldr	r3, [pc, #96]	; (412488 <inv_icm20948_ctrl_set_accel_cal_params+0xbc>)
  412426:	613b      	str	r3, [r7, #16]
  412428:	e017      	b.n	41245a <inv_icm20948_ctrl_set_accel_cal_params+0x8e>
	} 
	else if (hw_smplrt_divider <= 22) { // 56Hz > freq >= 51Hz
  41242a:	887b      	ldrh	r3, [r7, #2]
  41242c:	2b16      	cmp	r3, #22
  41242e:	d805      	bhi.n	41243c <inv_icm20948_ctrl_set_accel_cal_params+0x70>
		accel_cal_params[ACCEL_CAL_ALPHA_VAR] = 858993459L;
  412430:	f04f 3333 	mov.w	r3, #858993459	; 0x33333333
  412434:	60fb      	str	r3, [r7, #12]
		accel_cal_params[ACCEL_CAL_A_VAR] = 214748365L;
  412436:	4b12      	ldr	r3, [pc, #72]	; (412480 <inv_icm20948_ctrl_set_accel_cal_params+0xb4>)
  412438:	613b      	str	r3, [r7, #16]
  41243a:	e00e      	b.n	41245a <inv_icm20948_ctrl_set_accel_cal_params+0x8e>
	} 
	else if (hw_smplrt_divider <= 75) { // 51Hz > freq >= 15Hz
  41243c:	887b      	ldrh	r3, [r7, #2]
  41243e:	2b4b      	cmp	r3, #75	; 0x4b
  412440:	d804      	bhi.n	41244c <inv_icm20948_ctrl_set_accel_cal_params+0x80>
		accel_cal_params[ACCEL_CAL_ALPHA_VAR] = 357913941L;
  412442:	4b12      	ldr	r3, [pc, #72]	; (41248c <inv_icm20948_ctrl_set_accel_cal_params+0xc0>)
  412444:	60fb      	str	r3, [r7, #12]
		accel_cal_params[ACCEL_CAL_A_VAR] = 715827883L;
  412446:	4b12      	ldr	r3, [pc, #72]	; (412490 <inv_icm20948_ctrl_set_accel_cal_params+0xc4>)
  412448:	613b      	str	r3, [r7, #16]
  41244a:	e006      	b.n	41245a <inv_icm20948_ctrl_set_accel_cal_params+0x8e>
	} 
	else if (hw_smplrt_divider <= 225) { // 15Hz > freq >= 5Hz
  41244c:	887b      	ldrh	r3, [r7, #2]
  41244e:	2be1      	cmp	r3, #225	; 0xe1
  412450:	d803      	bhi.n	41245a <inv_icm20948_ctrl_set_accel_cal_params+0x8e>
		accel_cal_params[ACCEL_CAL_ALPHA_VAR] = 107374182L;
  412452:	4b10      	ldr	r3, [pc, #64]	; (412494 <inv_icm20948_ctrl_set_accel_cal_params+0xc8>)
  412454:	60fb      	str	r3, [r7, #12]
		accel_cal_params[ACCEL_CAL_A_VAR] = 966367642L;
  412456:	4b10      	ldr	r3, [pc, #64]	; (412498 <inv_icm20948_ctrl_set_accel_cal_params+0xcc>)
  412458:	613b      	str	r3, [r7, #16]
	}

	return dmp_icm20948_set_accel_cal_params(s, accel_cal_params);
  41245a:	f107 030c 	add.w	r3, r7, #12
  41245e:	4619      	mov	r1, r3
  412460:	6878      	ldr	r0, [r7, #4]
  412462:	4b0e      	ldr	r3, [pc, #56]	; (41249c <inv_icm20948_ctrl_set_accel_cal_params+0xd0>)
  412464:	4798      	blx	r3
  412466:	4603      	mov	r3, r0
}
  412468:	4618      	mov	r0, r3
  41246a:	3718      	adds	r7, #24
  41246c:	46bd      	mov	sp, r7
  41246e:	bd80      	pop	{r7, pc}
  412470:	3d27d27d 	.word	0x3d27d27d
  412474:	02d82d83 	.word	0x02d82d83
  412478:	3a492492 	.word	0x3a492492
  41247c:	05b6db6e 	.word	0x05b6db6e
  412480:	0ccccccd 	.word	0x0ccccccd
  412484:	34924925 	.word	0x34924925
  412488:	0b6db6db 	.word	0x0b6db6db
  41248c:	15555555 	.word	0x15555555
  412490:	2aaaaaab 	.word	0x2aaaaaab
  412494:	06666666 	.word	0x06666666
  412498:	3999999a 	.word	0x3999999a
  41249c:	00408051 	.word	0x00408051

004124a0 <inv_icm20948_ctrl_get_mag_bias>:
{
	return dmp_icm20948_get_bias_gyr(s, gyr_bias);
}

int inv_icm20948_ctrl_get_mag_bias(struct inv_icm20948 * s, int * mag_bias)
{
  4124a0:	b580      	push	{r7, lr}
  4124a2:	b082      	sub	sp, #8
  4124a4:	af00      	add	r7, sp, #0
  4124a6:	6078      	str	r0, [r7, #4]
  4124a8:	6039      	str	r1, [r7, #0]
	return dmp_icm20948_get_bias_cmp(s, mag_bias);
  4124aa:	6839      	ldr	r1, [r7, #0]
  4124ac:	6878      	ldr	r0, [r7, #4]
  4124ae:	4b03      	ldr	r3, [pc, #12]	; (4124bc <inv_icm20948_ctrl_get_mag_bias+0x1c>)
  4124b0:	4798      	blx	r3
  4124b2:	4603      	mov	r3, r0
}
  4124b4:	4618      	mov	r0, r3
  4124b6:	3708      	adds	r7, #8
  4124b8:	46bd      	mov	sp, r7
  4124ba:	bd80      	pop	{r7, pc}
  4124bc:	00407f2d 	.word	0x00407f2d

004124c0 <sensor_needs_compass>:
	rc = dmp_icm20948_set_bias_cmp(s, &s->bias[6]);
	
	return rc;
}
static unsigned char sensor_needs_compass(unsigned char androidSensor)
{
  4124c0:	b480      	push	{r7}
  4124c2:	b083      	sub	sp, #12
  4124c4:	af00      	add	r7, sp, #0
  4124c6:	4603      	mov	r3, r0
  4124c8:	71fb      	strb	r3, [r7, #7]
	switch(androidSensor) {
  4124ca:	79fb      	ldrb	r3, [r7, #7]
  4124cc:	3b02      	subs	r3, #2
  4124ce:	2b25      	cmp	r3, #37	; 0x25
  4124d0:	d850      	bhi.n	412574 <sensor_needs_compass+0xb4>
  4124d2:	a201      	add	r2, pc, #4	; (adr r2, 4124d8 <sensor_needs_compass+0x18>)
  4124d4:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
  4124d8:	00412571 	.word	0x00412571
  4124dc:	00412575 	.word	0x00412575
  4124e0:	00412575 	.word	0x00412575
  4124e4:	00412575 	.word	0x00412575
  4124e8:	00412575 	.word	0x00412575
  4124ec:	00412575 	.word	0x00412575
  4124f0:	00412575 	.word	0x00412575
  4124f4:	00412575 	.word	0x00412575
  4124f8:	00412575 	.word	0x00412575
  4124fc:	00412571 	.word	0x00412571
  412500:	00412575 	.word	0x00412575
  412504:	00412575 	.word	0x00412575
  412508:	00412571 	.word	0x00412571
  41250c:	00412575 	.word	0x00412575
  412510:	00412575 	.word	0x00412575
  412514:	00412575 	.word	0x00412575
  412518:	00412575 	.word	0x00412575
  41251c:	00412575 	.word	0x00412575
  412520:	00412571 	.word	0x00412571
  412524:	00412575 	.word	0x00412575
  412528:	00412575 	.word	0x00412575
  41252c:	00412575 	.word	0x00412575
  412530:	00412571 	.word	0x00412571
  412534:	00412575 	.word	0x00412575
  412538:	00412575 	.word	0x00412575
  41253c:	00412575 	.word	0x00412575
  412540:	00412575 	.word	0x00412575
  412544:	00412575 	.word	0x00412575
  412548:	00412575 	.word	0x00412575
  41254c:	00412571 	.word	0x00412571
  412550:	00412575 	.word	0x00412575
  412554:	00412575 	.word	0x00412575
  412558:	00412571 	.word	0x00412571
  41255c:	00412575 	.word	0x00412575
  412560:	00412575 	.word	0x00412575
  412564:	00412575 	.word	0x00412575
  412568:	00412575 	.word	0x00412575
  41256c:	00412571 	.word	0x00412571
		case ANDROID_SENSOR_GEOMAGNETIC_ROTATION_VECTOR:
		case ANDROID_SENSOR_WAKEUP_MAGNETIC_FIELD:
		case ANDROID_SENSOR_WAKEUP_ROTATION_VECTOR:
		case ANDROID_SENSOR_WAKEUP_MAGNETIC_FIELD_UNCALIBRATED:
		case ANDROID_SENSOR_WAKEUP_GEOMAGNETIC_ROTATION_VECTOR:
			return 1;
  412570:	2301      	movs	r3, #1
  412572:	e000      	b.n	412576 <sensor_needs_compass+0xb6>

		default :
			return 0;
  412574:	2300      	movs	r3, #0
	}
}
  412576:	4618      	mov	r0, r3
  412578:	370c      	adds	r7, #12
  41257a:	46bd      	mov	sp, r7
  41257c:	f85d 7b04 	ldr.w	r7, [sp], #4
  412580:	4770      	bx	lr
  412582:	bf00      	nop

00412584 <sensor_needs_bac_algo>:

static unsigned char sensor_needs_bac_algo(unsigned char androidSensor)
{
  412584:	b480      	push	{r7}
  412586:	b083      	sub	sp, #12
  412588:	af00      	add	r7, sp, #0
  41258a:	4603      	mov	r3, r0
  41258c:	71fb      	strb	r3, [r7, #7]
	switch(androidSensor){
  41258e:	79fb      	ldrb	r3, [r7, #7]
  412590:	3b11      	subs	r3, #17
  412592:	2b1e      	cmp	r3, #30
  412594:	d842      	bhi.n	41261c <sensor_needs_bac_algo+0x98>
  412596:	a201      	add	r2, pc, #4	; (adr r2, 41259c <sensor_needs_bac_algo+0x18>)
  412598:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
  41259c:	00412619 	.word	0x00412619
  4125a0:	00412619 	.word	0x00412619
  4125a4:	00412619 	.word	0x00412619
  4125a8:	0041261d 	.word	0x0041261d
  4125ac:	0041261d 	.word	0x0041261d
  4125b0:	0041261d 	.word	0x0041261d
  4125b4:	0041261d 	.word	0x0041261d
  4125b8:	0041261d 	.word	0x0041261d
  4125bc:	0041261d 	.word	0x0041261d
  4125c0:	0041261d 	.word	0x0041261d
  4125c4:	0041261d 	.word	0x0041261d
  4125c8:	0041261d 	.word	0x0041261d
  4125cc:	0041261d 	.word	0x0041261d
  4125d0:	0041261d 	.word	0x0041261d
  4125d4:	0041261d 	.word	0x0041261d
  4125d8:	0041261d 	.word	0x0041261d
  4125dc:	0041261d 	.word	0x0041261d
  4125e0:	0041261d 	.word	0x0041261d
  4125e4:	0041261d 	.word	0x0041261d
  4125e8:	0041261d 	.word	0x0041261d
  4125ec:	00412619 	.word	0x00412619
  4125f0:	00412619 	.word	0x00412619
  4125f4:	0041261d 	.word	0x0041261d
  4125f8:	0041261d 	.word	0x0041261d
  4125fc:	00412619 	.word	0x00412619
  412600:	0041261d 	.word	0x0041261d
  412604:	0041261d 	.word	0x0041261d
  412608:	0041261d 	.word	0x0041261d
  41260c:	00412619 	.word	0x00412619
  412610:	00412619 	.word	0x00412619
  412614:	00412619 	.word	0x00412619
	case ANDROID_SENSOR_WAKEUP_TILT_DETECTOR:
	case ANDROID_SENSOR_WAKEUP_STEP_DETECTOR:
	case ANDROID_SENSOR_WAKEUP_STEP_COUNTER:
	case ANDROID_SENSOR_WAKEUP_SIGNIFICANT_MOTION:
	case ANDROID_SENSOR_B2S:
		return 1;
  412618:	2301      	movs	r3, #1
  41261a:	e000      	b.n	41261e <sensor_needs_bac_algo+0x9a>
	default:
		return 0;
  41261c:	2300      	movs	r3, #0
	}
}
  41261e:	4618      	mov	r0, r3
  412620:	370c      	adds	r7, #12
  412622:	46bd      	mov	sp, r7
  412624:	f85d 7b04 	ldr.w	r7, [sp], #4
  412628:	4770      	bx	lr
  41262a:	bf00      	nop

0041262c <cosf>:
  41262c:	b500      	push	{lr}
  41262e:	ee10 3a10 	vmov	r3, s0
  412632:	4a20      	ldr	r2, [pc, #128]	; (4126b4 <cosf+0x88>)
  412634:	f023 4300 	bic.w	r3, r3, #2147483648	; 0x80000000
  412638:	4293      	cmp	r3, r2
  41263a:	b083      	sub	sp, #12
  41263c:	dd19      	ble.n	412672 <cosf+0x46>
  41263e:	f1b3 4fff 	cmp.w	r3, #2139095040	; 0x7f800000
  412642:	db04      	blt.n	41264e <cosf+0x22>
  412644:	ee30 0a40 	vsub.f32	s0, s0, s0
  412648:	b003      	add	sp, #12
  41264a:	f85d fb04 	ldr.w	pc, [sp], #4
  41264e:	4668      	mov	r0, sp
  412650:	f000 f8d4 	bl	4127fc <__ieee754_rem_pio2f>
  412654:	f000 0003 	and.w	r0, r0, #3
  412658:	2801      	cmp	r0, #1
  41265a:	d01a      	beq.n	412692 <cosf+0x66>
  41265c:	2802      	cmp	r0, #2
  41265e:	d00f      	beq.n	412680 <cosf+0x54>
  412660:	b300      	cbz	r0, 4126a4 <cosf+0x78>
  412662:	2001      	movs	r0, #1
  412664:	eddd 0a01 	vldr	s1, [sp, #4]
  412668:	ed9d 0a00 	vldr	s0, [sp]
  41266c:	f000 fddc 	bl	413228 <__kernel_sinf>
  412670:	e7ea      	b.n	412648 <cosf+0x1c>
  412672:	eddf 0a11 	vldr	s1, [pc, #68]	; 4126b8 <cosf+0x8c>
  412676:	f000 fa0d 	bl	412a94 <__kernel_cosf>
  41267a:	b003      	add	sp, #12
  41267c:	f85d fb04 	ldr.w	pc, [sp], #4
  412680:	eddd 0a01 	vldr	s1, [sp, #4]
  412684:	ed9d 0a00 	vldr	s0, [sp]
  412688:	f000 fa04 	bl	412a94 <__kernel_cosf>
  41268c:	eeb1 0a40 	vneg.f32	s0, s0
  412690:	e7da      	b.n	412648 <cosf+0x1c>
  412692:	eddd 0a01 	vldr	s1, [sp, #4]
  412696:	ed9d 0a00 	vldr	s0, [sp]
  41269a:	f000 fdc5 	bl	413228 <__kernel_sinf>
  41269e:	eeb1 0a40 	vneg.f32	s0, s0
  4126a2:	e7d1      	b.n	412648 <cosf+0x1c>
  4126a4:	eddd 0a01 	vldr	s1, [sp, #4]
  4126a8:	ed9d 0a00 	vldr	s0, [sp]
  4126ac:	f000 f9f2 	bl	412a94 <__kernel_cosf>
  4126b0:	e7ca      	b.n	412648 <cosf+0x1c>
  4126b2:	bf00      	nop
  4126b4:	3f490fd8 	.word	0x3f490fd8
  4126b8:	00000000 	.word	0x00000000

004126bc <sinf>:
  4126bc:	b500      	push	{lr}
  4126be:	ee10 3a10 	vmov	r3, s0
  4126c2:	4a21      	ldr	r2, [pc, #132]	; (412748 <sinf+0x8c>)
  4126c4:	f023 4300 	bic.w	r3, r3, #2147483648	; 0x80000000
  4126c8:	4293      	cmp	r3, r2
  4126ca:	b083      	sub	sp, #12
  4126cc:	dd1a      	ble.n	412704 <sinf+0x48>
  4126ce:	f1b3 4fff 	cmp.w	r3, #2139095040	; 0x7f800000
  4126d2:	db04      	blt.n	4126de <sinf+0x22>
  4126d4:	ee30 0a40 	vsub.f32	s0, s0, s0
  4126d8:	b003      	add	sp, #12
  4126da:	f85d fb04 	ldr.w	pc, [sp], #4
  4126de:	4668      	mov	r0, sp
  4126e0:	f000 f88c 	bl	4127fc <__ieee754_rem_pio2f>
  4126e4:	f000 0003 	and.w	r0, r0, #3
  4126e8:	2801      	cmp	r0, #1
  4126ea:	d01d      	beq.n	412728 <sinf+0x6c>
  4126ec:	2802      	cmp	r0, #2
  4126ee:	d011      	beq.n	412714 <sinf+0x58>
  4126f0:	b308      	cbz	r0, 412736 <sinf+0x7a>
  4126f2:	eddd 0a01 	vldr	s1, [sp, #4]
  4126f6:	ed9d 0a00 	vldr	s0, [sp]
  4126fa:	f000 f9cb 	bl	412a94 <__kernel_cosf>
  4126fe:	eeb1 0a40 	vneg.f32	s0, s0
  412702:	e7e9      	b.n	4126d8 <sinf+0x1c>
  412704:	2000      	movs	r0, #0
  412706:	eddf 0a11 	vldr	s1, [pc, #68]	; 41274c <sinf+0x90>
  41270a:	f000 fd8d 	bl	413228 <__kernel_sinf>
  41270e:	b003      	add	sp, #12
  412710:	f85d fb04 	ldr.w	pc, [sp], #4
  412714:	2001      	movs	r0, #1
  412716:	eddd 0a01 	vldr	s1, [sp, #4]
  41271a:	ed9d 0a00 	vldr	s0, [sp]
  41271e:	f000 fd83 	bl	413228 <__kernel_sinf>
  412722:	eeb1 0a40 	vneg.f32	s0, s0
  412726:	e7d7      	b.n	4126d8 <sinf+0x1c>
  412728:	eddd 0a01 	vldr	s1, [sp, #4]
  41272c:	ed9d 0a00 	vldr	s0, [sp]
  412730:	f000 f9b0 	bl	412a94 <__kernel_cosf>
  412734:	e7d0      	b.n	4126d8 <sinf+0x1c>
  412736:	2001      	movs	r0, #1
  412738:	eddd 0a01 	vldr	s1, [sp, #4]
  41273c:	ed9d 0a00 	vldr	s0, [sp]
  412740:	f000 fd72 	bl	413228 <__kernel_sinf>
  412744:	e7c8      	b.n	4126d8 <sinf+0x1c>
  412746:	bf00      	nop
  412748:	3f490fd8 	.word	0x3f490fd8
  41274c:	00000000 	.word	0x00000000

00412750 <sqrtf>:
  412750:	b510      	push	{r4, lr}
  412752:	ed2d 8b02 	vpush	{d8}
  412756:	b08a      	sub	sp, #40	; 0x28
  412758:	eeb0 8a40 	vmov.f32	s16, s0
  41275c:	f000 f996 	bl	412a8c <__ieee754_sqrtf>
  412760:	4b24      	ldr	r3, [pc, #144]	; (4127f4 <sqrtf+0xa4>)
  412762:	f993 4000 	ldrsb.w	r4, [r3]
  412766:	1c63      	adds	r3, r4, #1
  412768:	d009      	beq.n	41277e <sqrtf+0x2e>
  41276a:	eeb4 8a48 	vcmp.f32	s16, s16
  41276e:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
  412772:	d604      	bvs.n	41277e <sqrtf+0x2e>
  412774:	eeb5 8ac0 	vcmpe.f32	s16, #0.0
  412778:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
  41277c:	d403      	bmi.n	412786 <sqrtf+0x36>
  41277e:	b00a      	add	sp, #40	; 0x28
  412780:	ecbd 8b02 	vpop	{d8}
  412784:	bd10      	pop	{r4, pc}
  412786:	2301      	movs	r3, #1
  412788:	4a1b      	ldr	r2, [pc, #108]	; (4127f8 <sqrtf+0xa8>)
  41278a:	9300      	str	r3, [sp, #0]
  41278c:	ee18 0a10 	vmov	r0, s16
  412790:	2300      	movs	r3, #0
  412792:	9201      	str	r2, [sp, #4]
  412794:	9308      	str	r3, [sp, #32]
  412796:	f000 ffb9 	bl	41370c <__aeabi_f2d>
  41279a:	2200      	movs	r2, #0
  41279c:	e9cd 0104 	strd	r0, r1, [sp, #16]
  4127a0:	e9cd 0102 	strd	r0, r1, [sp, #8]
  4127a4:	2300      	movs	r3, #0
  4127a6:	b1bc      	cbz	r4, 4127d8 <sqrtf+0x88>
  4127a8:	4610      	mov	r0, r2
  4127aa:	4619      	mov	r1, r3
  4127ac:	f001 f92c 	bl	413a08 <__aeabi_ddiv>
  4127b0:	2c02      	cmp	r4, #2
  4127b2:	e9cd 0106 	strd	r0, r1, [sp, #24]
  4127b6:	d111      	bne.n	4127dc <sqrtf+0x8c>
  4127b8:	f001 fbe6 	bl	413f88 <__errno>
  4127bc:	2321      	movs	r3, #33	; 0x21
  4127be:	6003      	str	r3, [r0, #0]
  4127c0:	9b08      	ldr	r3, [sp, #32]
  4127c2:	b98b      	cbnz	r3, 4127e8 <sqrtf+0x98>
  4127c4:	e9dd 0106 	ldrd	r0, r1, [sp, #24]
  4127c8:	f001 fa06 	bl	413bd8 <__aeabi_d2f>
  4127cc:	ee00 0a10 	vmov	s0, r0
  4127d0:	b00a      	add	sp, #40	; 0x28
  4127d2:	ecbd 8b02 	vpop	{d8}
  4127d6:	bd10      	pop	{r4, pc}
  4127d8:	e9cd 2306 	strd	r2, r3, [sp, #24]
  4127dc:	4668      	mov	r0, sp
  4127de:	f000 fd6b 	bl	4132b8 <matherr>
  4127e2:	2800      	cmp	r0, #0
  4127e4:	d1ec      	bne.n	4127c0 <sqrtf+0x70>
  4127e6:	e7e7      	b.n	4127b8 <sqrtf+0x68>
  4127e8:	f001 fbce 	bl	413f88 <__errno>
  4127ec:	9b08      	ldr	r3, [sp, #32]
  4127ee:	6003      	str	r3, [r0, #0]
  4127f0:	e7e8      	b.n	4127c4 <sqrtf+0x74>
  4127f2:	bf00      	nop
  4127f4:	20000354 	.word	0x20000354
  4127f8:	0041d24c 	.word	0x0041d24c

004127fc <__ieee754_rem_pio2f>:
  4127fc:	b570      	push	{r4, r5, r6, lr}
  4127fe:	ee10 3a10 	vmov	r3, s0
  412802:	4a94      	ldr	r2, [pc, #592]	; (412a54 <__ieee754_rem_pio2f+0x258>)
  412804:	f023 4400 	bic.w	r4, r3, #2147483648	; 0x80000000
  412808:	4294      	cmp	r4, r2
  41280a:	b086      	sub	sp, #24
  41280c:	4605      	mov	r5, r0
  41280e:	dd68      	ble.n	4128e2 <__ieee754_rem_pio2f+0xe6>
  412810:	4a91      	ldr	r2, [pc, #580]	; (412a58 <__ieee754_rem_pio2f+0x25c>)
  412812:	4294      	cmp	r4, r2
  412814:	ee10 6a10 	vmov	r6, s0
  412818:	dc1a      	bgt.n	412850 <__ieee754_rem_pio2f+0x54>
  41281a:	2b00      	cmp	r3, #0
  41281c:	eddf 7a8f 	vldr	s15, [pc, #572]	; 412a5c <__ieee754_rem_pio2f+0x260>
  412820:	4a8f      	ldr	r2, [pc, #572]	; (412a60 <__ieee754_rem_pio2f+0x264>)
  412822:	f024 040f 	bic.w	r4, r4, #15
  412826:	f340 80dd 	ble.w	4129e4 <__ieee754_rem_pio2f+0x1e8>
  41282a:	4294      	cmp	r4, r2
  41282c:	ee70 7a67 	vsub.f32	s15, s0, s15
  412830:	d066      	beq.n	412900 <__ieee754_rem_pio2f+0x104>
  412832:	ed9f 7a8c 	vldr	s14, [pc, #560]	; 412a64 <__ieee754_rem_pio2f+0x268>
  412836:	ee77 6ac7 	vsub.f32	s13, s15, s14
  41283a:	2001      	movs	r0, #1
  41283c:	ee77 7ae6 	vsub.f32	s15, s15, s13
  412840:	edc5 6a00 	vstr	s13, [r5]
  412844:	ee77 7ac7 	vsub.f32	s15, s15, s14
  412848:	edc5 7a01 	vstr	s15, [r5, #4]
  41284c:	b006      	add	sp, #24
  41284e:	bd70      	pop	{r4, r5, r6, pc}
  412850:	4a85      	ldr	r2, [pc, #532]	; (412a68 <__ieee754_rem_pio2f+0x26c>)
  412852:	4294      	cmp	r4, r2
  412854:	dd66      	ble.n	412924 <__ieee754_rem_pio2f+0x128>
  412856:	f1b4 4fff 	cmp.w	r4, #2139095040	; 0x7f800000
  41285a:	da49      	bge.n	4128f0 <__ieee754_rem_pio2f+0xf4>
  41285c:	15e2      	asrs	r2, r4, #23
  41285e:	3a86      	subs	r2, #134	; 0x86
  412860:	eba4 53c2 	sub.w	r3, r4, r2, lsl #23
  412864:	ee07 3a90 	vmov	s15, r3
  412868:	eebd 7ae7 	vcvt.s32.f32	s14, s15
  41286c:	eddf 6a7f 	vldr	s13, [pc, #508]	; 412a6c <__ieee754_rem_pio2f+0x270>
  412870:	eeb8 7ac7 	vcvt.f32.s32	s14, s14
  412874:	ee77 7ac7 	vsub.f32	s15, s15, s14
  412878:	ed8d 7a03 	vstr	s14, [sp, #12]
  41287c:	ee67 7aa6 	vmul.f32	s15, s15, s13
  412880:	eebd 7ae7 	vcvt.s32.f32	s14, s15
  412884:	eeb8 7ac7 	vcvt.f32.s32	s14, s14
  412888:	ee77 7ac7 	vsub.f32	s15, s15, s14
  41288c:	ed8d 7a04 	vstr	s14, [sp, #16]
  412890:	ee67 7aa6 	vmul.f32	s15, s15, s13
  412894:	eef5 7a40 	vcmp.f32	s15, #0.0
  412898:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
  41289c:	edcd 7a05 	vstr	s15, [sp, #20]
  4128a0:	f040 80b3 	bne.w	412a0a <__ieee754_rem_pio2f+0x20e>
  4128a4:	eeb5 7a40 	vcmp.f32	s14, #0.0
  4128a8:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
  4128ac:	bf0c      	ite	eq
  4128ae:	2301      	moveq	r3, #1
  4128b0:	2302      	movne	r3, #2
  4128b2:	496f      	ldr	r1, [pc, #444]	; (412a70 <__ieee754_rem_pio2f+0x274>)
  4128b4:	9101      	str	r1, [sp, #4]
  4128b6:	2102      	movs	r1, #2
  4128b8:	9100      	str	r1, [sp, #0]
  4128ba:	a803      	add	r0, sp, #12
  4128bc:	4629      	mov	r1, r5
  4128be:	f000 f96b 	bl	412b98 <__kernel_rem_pio2f>
  4128c2:	2e00      	cmp	r6, #0
  4128c4:	da12      	bge.n	4128ec <__ieee754_rem_pio2f+0xf0>
  4128c6:	ed95 7a00 	vldr	s14, [r5]
  4128ca:	edd5 7a01 	vldr	s15, [r5, #4]
  4128ce:	eeb1 7a47 	vneg.f32	s14, s14
  4128d2:	eef1 7a67 	vneg.f32	s15, s15
  4128d6:	4240      	negs	r0, r0
  4128d8:	ed85 7a00 	vstr	s14, [r5]
  4128dc:	edc5 7a01 	vstr	s15, [r5, #4]
  4128e0:	e004      	b.n	4128ec <__ieee754_rem_pio2f+0xf0>
  4128e2:	2200      	movs	r2, #0
  4128e4:	ed85 0a00 	vstr	s0, [r5]
  4128e8:	6042      	str	r2, [r0, #4]
  4128ea:	2000      	movs	r0, #0
  4128ec:	b006      	add	sp, #24
  4128ee:	bd70      	pop	{r4, r5, r6, pc}
  4128f0:	ee70 7a40 	vsub.f32	s15, s0, s0
  4128f4:	2000      	movs	r0, #0
  4128f6:	edc5 7a01 	vstr	s15, [r5, #4]
  4128fa:	edc5 7a00 	vstr	s15, [r5]
  4128fe:	e7f5      	b.n	4128ec <__ieee754_rem_pio2f+0xf0>
  412900:	eddf 6a5c 	vldr	s13, [pc, #368]	; 412a74 <__ieee754_rem_pio2f+0x278>
  412904:	ed9f 7a5c 	vldr	s14, [pc, #368]	; 412a78 <__ieee754_rem_pio2f+0x27c>
  412908:	ee77 7ae6 	vsub.f32	s15, s15, s13
  41290c:	2001      	movs	r0, #1
  41290e:	ee77 6ac7 	vsub.f32	s13, s15, s14
  412912:	ee77 7ae6 	vsub.f32	s15, s15, s13
  412916:	edc5 6a00 	vstr	s13, [r5]
  41291a:	ee77 7ac7 	vsub.f32	s15, s15, s14
  41291e:	edc5 7a01 	vstr	s15, [r5, #4]
  412922:	e7e3      	b.n	4128ec <__ieee754_rem_pio2f+0xf0>
  412924:	f000 fcca 	bl	4132bc <fabsf>
  412928:	eddf 6a54 	vldr	s13, [pc, #336]	; 412a7c <__ieee754_rem_pio2f+0x280>
  41292c:	eddf 5a4b 	vldr	s11, [pc, #300]	; 412a5c <__ieee754_rem_pio2f+0x260>
  412930:	eddf 7a4c 	vldr	s15, [pc, #304]	; 412a64 <__ieee754_rem_pio2f+0x268>
  412934:	eeb6 7a00 	vmov.f32	s14, #96	; 0x3f000000  0.5
  412938:	eea0 7a26 	vfma.f32	s14, s0, s13
  41293c:	eebd 7ac7 	vcvt.s32.f32	s14, s14
  412940:	eef8 6ac7 	vcvt.f32.s32	s13, s14
  412944:	ee17 0a10 	vmov	r0, s14
  412948:	eeb1 6a66 	vneg.f32	s12, s13
  41294c:	281f      	cmp	r0, #31
  41294e:	eea6 0a25 	vfma.f32	s0, s12, s11
  412952:	ee66 7aa7 	vmul.f32	s15, s13, s15
  412956:	dc1d      	bgt.n	412994 <__ieee754_rem_pio2f+0x198>
  412958:	4a49      	ldr	r2, [pc, #292]	; (412a80 <__ieee754_rem_pio2f+0x284>)
  41295a:	1e41      	subs	r1, r0, #1
  41295c:	f024 03ff 	bic.w	r3, r4, #255	; 0xff
  412960:	f852 2021 	ldr.w	r2, [r2, r1, lsl #2]
  412964:	4293      	cmp	r3, r2
  412966:	d015      	beq.n	412994 <__ieee754_rem_pio2f+0x198>
  412968:	ee30 7a67 	vsub.f32	s14, s0, s15
  41296c:	ed85 7a00 	vstr	s14, [r5]
  412970:	ee30 0a47 	vsub.f32	s0, s0, s14
  412974:	2e00      	cmp	r6, #0
  412976:	ee30 0a67 	vsub.f32	s0, s0, s15
  41297a:	ed85 0a01 	vstr	s0, [r5, #4]
  41297e:	dab5      	bge.n	4128ec <__ieee754_rem_pio2f+0xf0>
  412980:	eeb1 7a47 	vneg.f32	s14, s14
  412984:	eeb1 0a40 	vneg.f32	s0, s0
  412988:	ed85 7a00 	vstr	s14, [r5]
  41298c:	ed85 0a01 	vstr	s0, [r5, #4]
  412990:	4240      	negs	r0, r0
  412992:	e7ab      	b.n	4128ec <__ieee754_rem_pio2f+0xf0>
  412994:	ee30 7a67 	vsub.f32	s14, s0, s15
  412998:	15e4      	asrs	r4, r4, #23
  41299a:	ee17 3a10 	vmov	r3, s14
  41299e:	f3c3 53c7 	ubfx	r3, r3, #23, #8
  4129a2:	1ae3      	subs	r3, r4, r3
  4129a4:	2b08      	cmp	r3, #8
  4129a6:	dde1      	ble.n	41296c <__ieee754_rem_pio2f+0x170>
  4129a8:	eddf 7a32 	vldr	s15, [pc, #200]	; 412a74 <__ieee754_rem_pio2f+0x278>
  4129ac:	ed9f 7a32 	vldr	s14, [pc, #200]	; 412a78 <__ieee754_rem_pio2f+0x27c>
  4129b0:	eef0 5a40 	vmov.f32	s11, s0
  4129b4:	eee6 5a27 	vfma.f32	s11, s12, s15
  4129b8:	ee30 0a65 	vsub.f32	s0, s0, s11
  4129bc:	eea6 0a27 	vfma.f32	s0, s12, s15
  4129c0:	eef0 7a40 	vmov.f32	s15, s0
  4129c4:	eed6 7a87 	vfnms.f32	s15, s13, s14
  4129c8:	ee35 7ae7 	vsub.f32	s14, s11, s15
  4129cc:	ee17 3a10 	vmov	r3, s14
  4129d0:	f3c3 53c7 	ubfx	r3, r3, #23, #8
  4129d4:	1ae4      	subs	r4, r4, r3
  4129d6:	2c19      	cmp	r4, #25
  4129d8:	dc2c      	bgt.n	412a34 <__ieee754_rem_pio2f+0x238>
  4129da:	ed85 7a00 	vstr	s14, [r5]
  4129de:	eeb0 0a65 	vmov.f32	s0, s11
  4129e2:	e7c5      	b.n	412970 <__ieee754_rem_pio2f+0x174>
  4129e4:	4294      	cmp	r4, r2
  4129e6:	ee70 7a27 	vadd.f32	s15, s0, s15
  4129ea:	d010      	beq.n	412a0e <__ieee754_rem_pio2f+0x212>
  4129ec:	ed9f 7a1d 	vldr	s14, [pc, #116]	; 412a64 <__ieee754_rem_pio2f+0x268>
  4129f0:	ee77 6a87 	vadd.f32	s13, s15, s14
  4129f4:	f04f 30ff 	mov.w	r0, #4294967295
  4129f8:	ee77 7ae6 	vsub.f32	s15, s15, s13
  4129fc:	edc5 6a00 	vstr	s13, [r5]
  412a00:	ee77 7a87 	vadd.f32	s15, s15, s14
  412a04:	edc5 7a01 	vstr	s15, [r5, #4]
  412a08:	e770      	b.n	4128ec <__ieee754_rem_pio2f+0xf0>
  412a0a:	2303      	movs	r3, #3
  412a0c:	e751      	b.n	4128b2 <__ieee754_rem_pio2f+0xb6>
  412a0e:	eddf 6a19 	vldr	s13, [pc, #100]	; 412a74 <__ieee754_rem_pio2f+0x278>
  412a12:	ed9f 7a19 	vldr	s14, [pc, #100]	; 412a78 <__ieee754_rem_pio2f+0x27c>
  412a16:	ee77 7aa6 	vadd.f32	s15, s15, s13
  412a1a:	f04f 30ff 	mov.w	r0, #4294967295
  412a1e:	ee77 6a87 	vadd.f32	s13, s15, s14
  412a22:	ee77 7ae6 	vsub.f32	s15, s15, s13
  412a26:	edc5 6a00 	vstr	s13, [r5]
  412a2a:	ee77 7a87 	vadd.f32	s15, s15, s14
  412a2e:	edc5 7a01 	vstr	s15, [r5, #4]
  412a32:	e75b      	b.n	4128ec <__ieee754_rem_pio2f+0xf0>
  412a34:	ed9f 7a13 	vldr	s14, [pc, #76]	; 412a84 <__ieee754_rem_pio2f+0x288>
  412a38:	ed9f 5a13 	vldr	s10, [pc, #76]	; 412a88 <__ieee754_rem_pio2f+0x28c>
  412a3c:	eeb0 0a65 	vmov.f32	s0, s11
  412a40:	eea6 0a07 	vfma.f32	s0, s12, s14
  412a44:	ee75 7ac0 	vsub.f32	s15, s11, s0
  412a48:	eee6 7a07 	vfma.f32	s15, s12, s14
  412a4c:	eed6 7a85 	vfnms.f32	s15, s13, s10
  412a50:	e78a      	b.n	412968 <__ieee754_rem_pio2f+0x16c>
  412a52:	bf00      	nop
  412a54:	3f490fd8 	.word	0x3f490fd8
  412a58:	4016cbe3 	.word	0x4016cbe3
  412a5c:	3fc90f80 	.word	0x3fc90f80
  412a60:	3fc90fd0 	.word	0x3fc90fd0
  412a64:	37354443 	.word	0x37354443
  412a68:	43490f80 	.word	0x43490f80
  412a6c:	43800000 	.word	0x43800000
  412a70:	0041d2d4 	.word	0x0041d2d4
  412a74:	37354400 	.word	0x37354400
  412a78:	2e85a308 	.word	0x2e85a308
  412a7c:	3f22f984 	.word	0x3f22f984
  412a80:	0041d254 	.word	0x0041d254
  412a84:	2e85a300 	.word	0x2e85a300
  412a88:	248d3132 	.word	0x248d3132

00412a8c <__ieee754_sqrtf>:
  412a8c:	eeb1 0ac0 	vsqrt.f32	s0, s0
  412a90:	4770      	bx	lr
  412a92:	bf00      	nop

00412a94 <__kernel_cosf>:
  412a94:	ee10 3a10 	vmov	r3, s0
  412a98:	f023 4300 	bic.w	r3, r3, #2147483648	; 0x80000000
  412a9c:	f1b3 5f48 	cmp.w	r3, #838860800	; 0x32000000
  412aa0:	da2c      	bge.n	412afc <__kernel_cosf+0x68>
  412aa2:	eefd 7ac0 	vcvt.s32.f32	s15, s0
  412aa6:	ee17 3a90 	vmov	r3, s15
  412aaa:	2b00      	cmp	r3, #0
  412aac:	d060      	beq.n	412b70 <__kernel_cosf+0xdc>
  412aae:	ee20 7a00 	vmul.f32	s14, s0, s0
  412ab2:	eddf 4a31 	vldr	s9, [pc, #196]	; 412b78 <__kernel_cosf+0xe4>
  412ab6:	ed9f 5a31 	vldr	s10, [pc, #196]	; 412b7c <__kernel_cosf+0xe8>
  412aba:	eddf 5a31 	vldr	s11, [pc, #196]	; 412b80 <__kernel_cosf+0xec>
  412abe:	ed9f 6a31 	vldr	s12, [pc, #196]	; 412b84 <__kernel_cosf+0xf0>
  412ac2:	eddf 7a31 	vldr	s15, [pc, #196]	; 412b88 <__kernel_cosf+0xf4>
  412ac6:	eddf 6a31 	vldr	s13, [pc, #196]	; 412b8c <__kernel_cosf+0xf8>
  412aca:	eea7 5a24 	vfma.f32	s10, s14, s9
  412ace:	eee7 5a05 	vfma.f32	s11, s14, s10
  412ad2:	eea7 6a25 	vfma.f32	s12, s14, s11
  412ad6:	eee7 7a06 	vfma.f32	s15, s14, s12
  412ada:	eee7 6a27 	vfma.f32	s13, s14, s15
  412ade:	ee66 6a87 	vmul.f32	s13, s13, s14
  412ae2:	ee60 0ac0 	vnmul.f32	s1, s1, s0
  412ae6:	eeb6 6a00 	vmov.f32	s12, #96	; 0x3f000000  0.5
  412aea:	eee7 0a26 	vfma.f32	s1, s14, s13
  412aee:	eef7 7a00 	vmov.f32	s15, #112	; 0x3f800000  1.0
  412af2:	eed7 0a06 	vfnms.f32	s1, s14, s12
  412af6:	ee37 0ae0 	vsub.f32	s0, s15, s1
  412afa:	4770      	bx	lr
  412afc:	ee20 7a00 	vmul.f32	s14, s0, s0
  412b00:	eddf 4a1d 	vldr	s9, [pc, #116]	; 412b78 <__kernel_cosf+0xe4>
  412b04:	ed9f 5a1d 	vldr	s10, [pc, #116]	; 412b7c <__kernel_cosf+0xe8>
  412b08:	eddf 5a1d 	vldr	s11, [pc, #116]	; 412b80 <__kernel_cosf+0xec>
  412b0c:	ed9f 6a1d 	vldr	s12, [pc, #116]	; 412b84 <__kernel_cosf+0xf0>
  412b10:	eddf 7a1d 	vldr	s15, [pc, #116]	; 412b88 <__kernel_cosf+0xf4>
  412b14:	eddf 6a1d 	vldr	s13, [pc, #116]	; 412b8c <__kernel_cosf+0xf8>
  412b18:	4a1d      	ldr	r2, [pc, #116]	; (412b90 <__kernel_cosf+0xfc>)
  412b1a:	eea7 5a24 	vfma.f32	s10, s14, s9
  412b1e:	4293      	cmp	r3, r2
  412b20:	eee7 5a05 	vfma.f32	s11, s14, s10
  412b24:	eea7 6a25 	vfma.f32	s12, s14, s11
  412b28:	eee7 7a06 	vfma.f32	s15, s14, s12
  412b2c:	eee7 6a27 	vfma.f32	s13, s14, s15
  412b30:	ee66 6a87 	vmul.f32	s13, s13, s14
  412b34:	ddd5      	ble.n	412ae2 <__kernel_cosf+0x4e>
  412b36:	4a17      	ldr	r2, [pc, #92]	; (412b94 <__kernel_cosf+0x100>)
  412b38:	4293      	cmp	r3, r2
  412b3a:	dc14      	bgt.n	412b66 <__kernel_cosf+0xd2>
  412b3c:	f103 437f 	add.w	r3, r3, #4278190080	; 0xff000000
  412b40:	ee07 3a90 	vmov	s15, r3
  412b44:	eeb7 6a00 	vmov.f32	s12, #112	; 0x3f800000  1.0
  412b48:	ee36 6a67 	vsub.f32	s12, s12, s15
  412b4c:	ee60 0ac0 	vnmul.f32	s1, s1, s0
  412b50:	eef6 5a00 	vmov.f32	s11, #96	; 0x3f000000  0.5
  412b54:	eee7 0a26 	vfma.f32	s1, s14, s13
  412b58:	eed7 7a25 	vfnms.f32	s15, s14, s11
  412b5c:	ee77 7ae0 	vsub.f32	s15, s15, s1
  412b60:	ee36 0a67 	vsub.f32	s0, s12, s15
  412b64:	4770      	bx	lr
  412b66:	eeb6 6a07 	vmov.f32	s12, #103	; 0x3f380000  0.7187500
  412b6a:	eef5 7a02 	vmov.f32	s15, #82	; 0x3e900000  0.2812500
  412b6e:	e7ed      	b.n	412b4c <__kernel_cosf+0xb8>
  412b70:	eeb7 0a00 	vmov.f32	s0, #112	; 0x3f800000  1.0
  412b74:	4770      	bx	lr
  412b76:	bf00      	nop
  412b78:	ad47d74e 	.word	0xad47d74e
  412b7c:	310f74f6 	.word	0x310f74f6
  412b80:	b493f27c 	.word	0xb493f27c
  412b84:	37d00d01 	.word	0x37d00d01
  412b88:	bab60b61 	.word	0xbab60b61
  412b8c:	3d2aaaab 	.word	0x3d2aaaab
  412b90:	3e999999 	.word	0x3e999999
  412b94:	3f480000 	.word	0x3f480000

00412b98 <__kernel_rem_pio2f>:
  412b98:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  412b9c:	ed2d 8b04 	vpush	{d8-d9}
  412ba0:	b0d9      	sub	sp, #356	; 0x164
  412ba2:	f103 3aff 	add.w	sl, r3, #4294967295
  412ba6:	9304      	str	r3, [sp, #16]
  412ba8:	1ed3      	subs	r3, r2, #3
  412baa:	bf48      	it	mi
  412bac:	1d13      	addmi	r3, r2, #4
  412bae:	4cd4      	ldr	r4, [pc, #848]	; (412f00 <__kernel_rem_pio2f+0x368>)
  412bb0:	9d66      	ldr	r5, [sp, #408]	; 0x198
  412bb2:	9102      	str	r1, [sp, #8]
  412bb4:	10db      	asrs	r3, r3, #3
  412bb6:	ea23 73e3 	bic.w	r3, r3, r3, asr #31
  412bba:	4619      	mov	r1, r3
  412bbc:	f854 6025 	ldr.w	r6, [r4, r5, lsl #2]
  412bc0:	9306      	str	r3, [sp, #24]
  412bc2:	3301      	adds	r3, #1
  412bc4:	eba2 03c3 	sub.w	r3, r2, r3, lsl #3
  412bc8:	9301      	str	r3, [sp, #4]
  412bca:	eba1 030a 	sub.w	r3, r1, sl
  412bce:	eb16 010a 	adds.w	r1, r6, sl
  412bd2:	4681      	mov	r9, r0
  412bd4:	d416      	bmi.n	412c04 <__kernel_rem_pio2f+0x6c>
  412bd6:	4419      	add	r1, r3
  412bd8:	ed9f 7aca 	vldr	s14, [pc, #808]	; 412f04 <__kernel_rem_pio2f+0x36c>
  412bdc:	9867      	ldr	r0, [sp, #412]	; 0x19c
  412bde:	3101      	adds	r1, #1
  412be0:	aa1c      	add	r2, sp, #112	; 0x70
  412be2:	2b00      	cmp	r3, #0
  412be4:	bfa4      	itt	ge
  412be6:	f850 4023 	ldrge.w	r4, [r0, r3, lsl #2]
  412bea:	ee07 4a90 	vmovge	s15, r4
  412bee:	f103 0301 	add.w	r3, r3, #1
  412bf2:	bfac      	ite	ge
  412bf4:	eef8 7ae7 	vcvtge.f32.s32	s15, s15
  412bf8:	eef0 7a47 	vmovlt.f32	s15, s14
  412bfc:	428b      	cmp	r3, r1
  412bfe:	ece2 7a01 	vstmia	r2!, {s15}
  412c02:	d1ee      	bne.n	412be2 <__kernel_rem_pio2f+0x4a>
  412c04:	2e00      	cmp	r6, #0
  412c06:	f2c0 8307 	blt.w	413218 <__kernel_rem_pio2f+0x680>
  412c0a:	9b04      	ldr	r3, [sp, #16]
  412c0c:	ad44      	add	r5, sp, #272	; 0x110
  412c0e:	009c      	lsls	r4, r3, #2
  412c10:	1c77      	adds	r7, r6, #1
  412c12:	ab1c      	add	r3, sp, #112	; 0x70
  412c14:	eb05 0787 	add.w	r7, r5, r7, lsl #2
  412c18:	1918      	adds	r0, r3, r4
  412c1a:	eb09 0104 	add.w	r1, r9, r4
  412c1e:	f1ba 0f00 	cmp.w	sl, #0
  412c22:	f2c0 8275 	blt.w	413110 <__kernel_rem_pio2f+0x578>
  412c26:	eddf 7ab7 	vldr	s15, [pc, #732]	; 412f04 <__kernel_rem_pio2f+0x36c>
  412c2a:	464b      	mov	r3, r9
  412c2c:	4602      	mov	r2, r0
  412c2e:	ecf3 6a01 	vldmia	r3!, {s13}
  412c32:	ed32 7a01 	vldmdb	r2!, {s14}
  412c36:	428b      	cmp	r3, r1
  412c38:	eee6 7a87 	vfma.f32	s15, s13, s14
  412c3c:	d1f7      	bne.n	412c2e <__kernel_rem_pio2f+0x96>
  412c3e:	ece5 7a01 	vstmia	r5!, {s15}
  412c42:	42bd      	cmp	r5, r7
  412c44:	f100 0004 	add.w	r0, r0, #4
  412c48:	d1e9      	bne.n	412c1e <__kernel_rem_pio2f+0x86>
  412c4a:	f106 4380 	add.w	r3, r6, #1073741824	; 0x40000000
  412c4e:	3b01      	subs	r3, #1
  412c50:	009b      	lsls	r3, r3, #2
  412c52:	ad08      	add	r5, sp, #32
  412c54:	1f1a      	subs	r2, r3, #4
  412c56:	18aa      	adds	r2, r5, r2
  412c58:	46b3      	mov	fp, r6
  412c5a:	9603      	str	r6, [sp, #12]
  412c5c:	eddf 8aab 	vldr	s17, [pc, #684]	; 412f0c <__kernel_rem_pio2f+0x374>
  412c60:	ed9f 8aa9 	vldr	s16, [pc, #676]	; 412f08 <__kernel_rem_pio2f+0x370>
  412c64:	9e01      	ldr	r6, [sp, #4]
  412c66:	9207      	str	r2, [sp, #28]
  412c68:	444c      	add	r4, r9
  412c6a:	eb05 0803 	add.w	r8, r5, r3
  412c6e:	af44      	add	r7, sp, #272	; 0x110
  412c70:	ea4f 038b 	mov.w	r3, fp, lsl #2
  412c74:	aa58      	add	r2, sp, #352	; 0x160
  412c76:	441a      	add	r2, r3
  412c78:	f1bb 0f00 	cmp.w	fp, #0
  412c7c:	ed12 0a14 	vldr	s0, [r2, #-80]	; 0xffffffb0
  412c80:	dd18      	ble.n	412cb4 <__kernel_rem_pio2f+0x11c>
  412c82:	a907      	add	r1, sp, #28
  412c84:	eb07 028b 	add.w	r2, r7, fp, lsl #2
  412c88:	ee60 7a28 	vmul.f32	s15, s0, s17
  412c8c:	eeb0 7a40 	vmov.f32	s14, s0
  412c90:	eefd 7ae7 	vcvt.s32.f32	s15, s15
  412c94:	ed72 6a01 	vldmdb	r2!, {s13}
  412c98:	eef8 7ae7 	vcvt.f32.s32	s15, s15
  412c9c:	42ba      	cmp	r2, r7
  412c9e:	eea7 7ac8 	vfms.f32	s14, s15, s16
  412ca2:	ee37 0aa6 	vadd.f32	s0, s15, s13
  412ca6:	eebd 7ac7 	vcvt.s32.f32	s14, s14
  412caa:	ee17 0a10 	vmov	r0, s14
  412cae:	f841 0f04 	str.w	r0, [r1, #4]!
  412cb2:	d1e9      	bne.n	412c88 <__kernel_rem_pio2f+0xf0>
  412cb4:	4630      	mov	r0, r6
  412cb6:	9305      	str	r3, [sp, #20]
  412cb8:	f000 fb50 	bl	41335c <scalbnf>
  412cbc:	eeb0 9a40 	vmov.f32	s18, s0
  412cc0:	eeb4 0a00 	vmov.f32	s0, #64	; 0x3e000000  0.125
  412cc4:	ee29 0a00 	vmul.f32	s0, s18, s0
  412cc8:	f000 fb00 	bl	4132cc <floorf>
  412ccc:	eef2 7a00 	vmov.f32	s15, #32	; 0x41000000  8.0
  412cd0:	eea0 9a67 	vfms.f32	s18, s0, s15
  412cd4:	2e00      	cmp	r6, #0
  412cd6:	9b05      	ldr	r3, [sp, #20]
  412cd8:	eefd 9ac9 	vcvt.s32.f32	s19, s18
  412cdc:	eef8 7ae9 	vcvt.f32.s32	s15, s19
  412ce0:	ee39 9a67 	vsub.f32	s18, s18, s15
  412ce4:	f340 80c9 	ble.w	412e7a <__kernel_rem_pio2f+0x2e2>
  412ce8:	f10b 3eff 	add.w	lr, fp, #4294967295
  412cec:	f1c6 0208 	rsb	r2, r6, #8
  412cf0:	f855 102e 	ldr.w	r1, [r5, lr, lsl #2]
  412cf4:	fa41 f002 	asr.w	r0, r1, r2
  412cf8:	fa00 f202 	lsl.w	r2, r0, r2
  412cfc:	1a89      	subs	r1, r1, r2
  412cfe:	f845 102e 	str.w	r1, [r5, lr, lsl #2]
  412d02:	ee19 ea90 	vmov	lr, s19
  412d06:	4486      	add	lr, r0
  412d08:	f1c6 0207 	rsb	r2, r6, #7
  412d0c:	ee09 ea90 	vmov	s19, lr
  412d10:	4111      	asrs	r1, r2
  412d12:	2900      	cmp	r1, #0
  412d14:	dd51      	ble.n	412dba <__kernel_rem_pio2f+0x222>
  412d16:	ee19 2a90 	vmov	r2, s19
  412d1a:	f1bb 0f00 	cmp.w	fp, #0
  412d1e:	f102 0201 	add.w	r2, r2, #1
  412d22:	ee09 2a90 	vmov	s19, r2
  412d26:	f340 8212 	ble.w	41314e <__kernel_rem_pio2f+0x5b6>
  412d2a:	682a      	ldr	r2, [r5, #0]
  412d2c:	2a00      	cmp	r2, #0
  412d2e:	f040 8269 	bne.w	413204 <__kernel_rem_pio2f+0x66c>
  412d32:	f1bb 0f01 	cmp.w	fp, #1
  412d36:	f340 8229 	ble.w	41318c <__kernel_rem_pio2f+0x5f4>
  412d3a:	46ae      	mov	lr, r5
  412d3c:	2001      	movs	r0, #1
  412d3e:	f85e 2f04 	ldr.w	r2, [lr, #4]!
  412d42:	2a00      	cmp	r2, #0
  412d44:	f000 821e 	beq.w	413184 <__kernel_rem_pio2f+0x5ec>
  412d48:	f100 0e01 	add.w	lr, r0, #1
  412d4c:	f5c2 7280 	rsb	r2, r2, #256	; 0x100
  412d50:	45f3      	cmp	fp, lr
  412d52:	f845 2020 	str.w	r2, [r5, r0, lsl #2]
  412d56:	dd12      	ble.n	412d7e <__kernel_rem_pio2f+0x1e6>
  412d58:	f855 202e 	ldr.w	r2, [r5, lr, lsl #2]
  412d5c:	3002      	adds	r0, #2
  412d5e:	f1c2 02ff 	rsb	r2, r2, #255	; 0xff
  412d62:	4583      	cmp	fp, r0
  412d64:	f845 202e 	str.w	r2, [r5, lr, lsl #2]
  412d68:	dd09      	ble.n	412d7e <__kernel_rem_pio2f+0x1e6>
  412d6a:	eb05 0080 	add.w	r0, r5, r0, lsl #2
  412d6e:	18ea      	adds	r2, r5, r3
  412d70:	6803      	ldr	r3, [r0, #0]
  412d72:	f1c3 03ff 	rsb	r3, r3, #255	; 0xff
  412d76:	f840 3b04 	str.w	r3, [r0], #4
  412d7a:	4290      	cmp	r0, r2
  412d7c:	d1f8      	bne.n	412d70 <__kernel_rem_pio2f+0x1d8>
  412d7e:	2e00      	cmp	r6, #0
  412d80:	dd0d      	ble.n	412d9e <__kernel_rem_pio2f+0x206>
  412d82:	2e01      	cmp	r6, #1
  412d84:	f04f 0201 	mov.w	r2, #1
  412d88:	f040 81e7 	bne.w	41315a <__kernel_rem_pio2f+0x5c2>
  412d8c:	f10b 30ff 	add.w	r0, fp, #4294967295
  412d90:	f855 3020 	ldr.w	r3, [r5, r0, lsl #2]
  412d94:	f003 037f 	and.w	r3, r3, #127	; 0x7f
  412d98:	f845 3020 	str.w	r3, [r5, r0, lsl #2]
  412d9c:	e1e7      	b.n	41316e <__kernel_rem_pio2f+0x5d6>
  412d9e:	2902      	cmp	r1, #2
  412da0:	d10b      	bne.n	412dba <__kernel_rem_pio2f+0x222>
  412da2:	eef7 7a00 	vmov.f32	s15, #112	; 0x3f800000  1.0
  412da6:	ee37 9ac9 	vsub.f32	s18, s15, s18
  412daa:	4630      	mov	r0, r6
  412dac:	eeb7 0a00 	vmov.f32	s0, #112	; 0x3f800000  1.0
  412db0:	f000 fad4 	bl	41335c <scalbnf>
  412db4:	ee39 9a40 	vsub.f32	s18, s18, s0
  412db8:	2102      	movs	r1, #2
  412dba:	eeb5 9a40 	vcmp.f32	s18, #0.0
  412dbe:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
  412dc2:	d170      	bne.n	412ea6 <__kernel_rem_pio2f+0x30e>
  412dc4:	9b03      	ldr	r3, [sp, #12]
  412dc6:	f10b 3eff 	add.w	lr, fp, #4294967295
  412dca:	4573      	cmp	r3, lr
  412dcc:	dc0e      	bgt.n	412dec <__kernel_rem_pio2f+0x254>
  412dce:	f10b 4280 	add.w	r2, fp, #1073741824	; 0x40000000
  412dd2:	3a01      	subs	r2, #1
  412dd4:	eb05 0282 	add.w	r2, r5, r2, lsl #2
  412dd8:	2000      	movs	r0, #0
  412dda:	f852 3904 	ldr.w	r3, [r2], #-4
  412dde:	4542      	cmp	r2, r8
  412de0:	ea40 0003 	orr.w	r0, r0, r3
  412de4:	d1f9      	bne.n	412dda <__kernel_rem_pio2f+0x242>
  412de6:	2800      	cmp	r0, #0
  412de8:	f040 8094 	bne.w	412f14 <__kernel_rem_pio2f+0x37c>
  412dec:	9b03      	ldr	r3, [sp, #12]
  412dee:	3b01      	subs	r3, #1
  412df0:	f855 3023 	ldr.w	r3, [r5, r3, lsl #2]
  412df4:	2b00      	cmp	r3, #0
  412df6:	f040 81d3 	bne.w	4131a0 <__kernel_rem_pio2f+0x608>
  412dfa:	9b07      	ldr	r3, [sp, #28]
  412dfc:	f04f 0c01 	mov.w	ip, #1
  412e00:	f853 2904 	ldr.w	r2, [r3], #-4
  412e04:	f10c 0c01 	add.w	ip, ip, #1
  412e08:	2a00      	cmp	r2, #0
  412e0a:	d0f9      	beq.n	412e00 <__kernel_rem_pio2f+0x268>
  412e0c:	44dc      	add	ip, fp
  412e0e:	f10b 0e01 	add.w	lr, fp, #1
  412e12:	45e6      	cmp	lr, ip
  412e14:	dc2f      	bgt.n	412e76 <__kernel_rem_pio2f+0x2de>
  412e16:	9a06      	ldr	r2, [sp, #24]
  412e18:	9b04      	ldr	r3, [sp, #16]
  412e1a:	eb0e 0102 	add.w	r1, lr, r2
  412e1e:	eb03 000b 	add.w	r0, r3, fp
  412e22:	eb0c 0302 	add.w	r3, ip, r2
  412e26:	aa1c      	add	r2, sp, #112	; 0x70
  412e28:	f101 4180 	add.w	r1, r1, #1073741824	; 0x40000000
  412e2c:	eb02 0080 	add.w	r0, r2, r0, lsl #2
  412e30:	9a67      	ldr	r2, [sp, #412]	; 0x19c
  412e32:	3901      	subs	r1, #1
  412e34:	eb02 0181 	add.w	r1, r2, r1, lsl #2
  412e38:	eb07 0e8e 	add.w	lr, r7, lr, lsl #2
  412e3c:	eb02 0b83 	add.w	fp, r2, r3, lsl #2
  412e40:	f851 3f04 	ldr.w	r3, [r1, #4]!
  412e44:	ee07 3a90 	vmov	s15, r3
  412e48:	eef8 7ae7 	vcvt.f32.s32	s15, s15
  412e4c:	f1ba 0f00 	cmp.w	sl, #0
  412e50:	ece0 7a01 	vstmia	r0!, {s15}
  412e54:	eddf 7a2b 	vldr	s15, [pc, #172]	; 412f04 <__kernel_rem_pio2f+0x36c>
  412e58:	db09      	blt.n	412e6e <__kernel_rem_pio2f+0x2d6>
  412e5a:	464b      	mov	r3, r9
  412e5c:	4602      	mov	r2, r0
  412e5e:	ecf3 6a01 	vldmia	r3!, {s13}
  412e62:	ed32 7a01 	vldmdb	r2!, {s14}
  412e66:	42a3      	cmp	r3, r4
  412e68:	eee6 7a87 	vfma.f32	s15, s13, s14
  412e6c:	d1f7      	bne.n	412e5e <__kernel_rem_pio2f+0x2c6>
  412e6e:	4559      	cmp	r1, fp
  412e70:	ecee 7a01 	vstmia	lr!, {s15}
  412e74:	d1e4      	bne.n	412e40 <__kernel_rem_pio2f+0x2a8>
  412e76:	46e3      	mov	fp, ip
  412e78:	e6fa      	b.n	412c70 <__kernel_rem_pio2f+0xd8>
  412e7a:	d105      	bne.n	412e88 <__kernel_rem_pio2f+0x2f0>
  412e7c:	f10b 32ff 	add.w	r2, fp, #4294967295
  412e80:	f855 1022 	ldr.w	r1, [r5, r2, lsl #2]
  412e84:	1209      	asrs	r1, r1, #8
  412e86:	e744      	b.n	412d12 <__kernel_rem_pio2f+0x17a>
  412e88:	eef6 7a00 	vmov.f32	s15, #96	; 0x3f000000  0.5
  412e8c:	eeb4 9ae7 	vcmpe.f32	s18, s15
  412e90:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
  412e94:	f280 8146 	bge.w	413124 <__kernel_rem_pio2f+0x58c>
  412e98:	eeb5 9a40 	vcmp.f32	s18, #0.0
  412e9c:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
  412ea0:	f04f 0100 	mov.w	r1, #0
  412ea4:	d08e      	beq.n	412dc4 <__kernel_rem_pio2f+0x22c>
  412ea6:	9c01      	ldr	r4, [sp, #4]
  412ea8:	9e03      	ldr	r6, [sp, #12]
  412eaa:	eeb0 0a49 	vmov.f32	s0, s18
  412eae:	4260      	negs	r0, r4
  412eb0:	4688      	mov	r8, r1
  412eb2:	f000 fa53 	bl	41335c <scalbnf>
  412eb6:	ed9f 7a14 	vldr	s14, [pc, #80]	; 412f08 <__kernel_rem_pio2f+0x370>
  412eba:	eeb4 0ac7 	vcmpe.f32	s0, s14
  412ebe:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
  412ec2:	f2c0 8185 	blt.w	4131d0 <__kernel_rem_pio2f+0x638>
  412ec6:	eddf 7a11 	vldr	s15, [pc, #68]	; 412f0c <__kernel_rem_pio2f+0x374>
  412eca:	ee60 7a27 	vmul.f32	s15, s0, s15
  412ece:	4623      	mov	r3, r4
  412ed0:	eefd 7ae7 	vcvt.s32.f32	s15, s15
  412ed4:	3308      	adds	r3, #8
  412ed6:	eef8 7ae7 	vcvt.f32.s32	s15, s15
  412eda:	9301      	str	r3, [sp, #4]
  412edc:	eea7 0ac7 	vfms.f32	s0, s15, s14
  412ee0:	f10b 0301 	add.w	r3, fp, #1
  412ee4:	eefd 7ae7 	vcvt.s32.f32	s15, s15
  412ee8:	eebd 0ac0 	vcvt.s32.f32	s0, s0
  412eec:	ee10 2a10 	vmov	r2, s0
  412ef0:	f845 202b 	str.w	r2, [r5, fp, lsl #2]
  412ef4:	ee17 2a90 	vmov	r2, s15
  412ef8:	f845 2023 	str.w	r2, [r5, r3, lsl #2]
  412efc:	e01f      	b.n	412f3e <__kernel_rem_pio2f+0x3a6>
  412efe:	bf00      	nop
  412f00:	0041d618 	.word	0x0041d618
  412f04:	00000000 	.word	0x00000000
  412f08:	43800000 	.word	0x43800000
  412f0c:	3b800000 	.word	0x3b800000
  412f10:	3fc90000 	.word	0x3fc90000
  412f14:	4688      	mov	r8, r1
  412f16:	9901      	ldr	r1, [sp, #4]
  412f18:	f855 202e 	ldr.w	r2, [r5, lr, lsl #2]
  412f1c:	9e03      	ldr	r6, [sp, #12]
  412f1e:	3908      	subs	r1, #8
  412f20:	4673      	mov	r3, lr
  412f22:	9101      	str	r1, [sp, #4]
  412f24:	b95a      	cbnz	r2, 412f3e <__kernel_rem_pio2f+0x3a6>
  412f26:	f10e 4280 	add.w	r2, lr, #1073741824	; 0x40000000
  412f2a:	3a01      	subs	r2, #1
  412f2c:	eb05 0282 	add.w	r2, r5, r2, lsl #2
  412f30:	f852 0904 	ldr.w	r0, [r2], #-4
  412f34:	3b01      	subs	r3, #1
  412f36:	3908      	subs	r1, #8
  412f38:	2800      	cmp	r0, #0
  412f3a:	d0f9      	beq.n	412f30 <__kernel_rem_pio2f+0x398>
  412f3c:	9101      	str	r1, [sp, #4]
  412f3e:	9801      	ldr	r0, [sp, #4]
  412f40:	9303      	str	r3, [sp, #12]
  412f42:	eeb7 0a00 	vmov.f32	s0, #112	; 0x3f800000  1.0
  412f46:	f000 fa09 	bl	41335c <scalbnf>
  412f4a:	9b03      	ldr	r3, [sp, #12]
  412f4c:	2b00      	cmp	r3, #0
  412f4e:	f2c0 814a 	blt.w	4131e6 <__kernel_rem_pio2f+0x64e>
  412f52:	009f      	lsls	r7, r3, #2
  412f54:	aa44      	add	r2, sp, #272	; 0x110
  412f56:	19d0      	adds	r0, r2, r7
  412f58:	f107 0e04 	add.w	lr, r7, #4
  412f5c:	ed1f 7a15 	vldr	s14, [pc, #-84]	; 412f0c <__kernel_rem_pio2f+0x374>
  412f60:	eb05 020e 	add.w	r2, r5, lr
  412f64:	1d01      	adds	r1, r0, #4
  412f66:	ed72 7a01 	vldmdb	r2!, {s15}
  412f6a:	eef8 7ae7 	vcvt.f32.s32	s15, s15
  412f6e:	42aa      	cmp	r2, r5
  412f70:	ee67 7a80 	vmul.f32	s15, s15, s0
  412f74:	ee20 0a07 	vmul.f32	s0, s0, s14
  412f78:	ed61 7a01 	vstmdb	r1!, {s15}
  412f7c:	d1f3      	bne.n	412f66 <__kernel_rem_pio2f+0x3ce>
  412f7e:	ed1f 6a1c 	vldr	s12, [pc, #-112]	; 412f10 <__kernel_rem_pio2f+0x378>
  412f82:	4605      	mov	r5, r0
  412f84:	f50d 7c86 	add.w	ip, sp, #268	; 0x10c
  412f88:	2400      	movs	r4, #0
  412f8a:	2e00      	cmp	r6, #0
  412f8c:	f2c0 80dc 	blt.w	413148 <__kernel_rem_pio2f+0x5b0>
  412f90:	48a3      	ldr	r0, [pc, #652]	; (413220 <__kernel_rem_pio2f+0x688>)
  412f92:	eddf 7aa4 	vldr	s15, [pc, #656]	; 413224 <__kernel_rem_pio2f+0x68c>
  412f96:	4629      	mov	r1, r5
  412f98:	eeb0 7a46 	vmov.f32	s14, s12
  412f9c:	2200      	movs	r2, #0
  412f9e:	e003      	b.n	412fa8 <__kernel_rem_pio2f+0x410>
  412fa0:	42a2      	cmp	r2, r4
  412fa2:	dc08      	bgt.n	412fb6 <__kernel_rem_pio2f+0x41e>
  412fa4:	ecb0 7a01 	vldmia	r0!, {s14}
  412fa8:	ecf1 6a01 	vldmia	r1!, {s13}
  412fac:	3201      	adds	r2, #1
  412fae:	4296      	cmp	r6, r2
  412fb0:	eee7 7a26 	vfma.f32	s15, s14, s13
  412fb4:	daf4      	bge.n	412fa0 <__kernel_rem_pio2f+0x408>
  412fb6:	3d04      	subs	r5, #4
  412fb8:	aa58      	add	r2, sp, #352	; 0x160
  412fba:	eb02 0284 	add.w	r2, r2, r4, lsl #2
  412fbe:	4565      	cmp	r5, ip
  412fc0:	ed42 7a28 	vstr	s15, [r2, #-160]	; 0xffffff60
  412fc4:	f104 0401 	add.w	r4, r4, #1
  412fc8:	d1df      	bne.n	412f8a <__kernel_rem_pio2f+0x3f2>
  412fca:	9a66      	ldr	r2, [sp, #408]	; 0x198
  412fcc:	2a03      	cmp	r2, #3
  412fce:	d85a      	bhi.n	413086 <__kernel_rem_pio2f+0x4ee>
  412fd0:	e8df f002 	tbb	[pc, r2]
  412fd4:	0262628c 	.word	0x0262628c
  412fd8:	2b00      	cmp	r3, #0
  412fda:	f340 8101 	ble.w	4131e0 <__kernel_rem_pio2f+0x648>
  412fde:	aa58      	add	r2, sp, #352	; 0x160
  412fe0:	443a      	add	r2, r7
  412fe2:	a930      	add	r1, sp, #192	; 0xc0
  412fe4:	ed12 7a28 	vldr	s14, [r2, #-160]	; 0xffffff60
  412fe8:	1d3a      	adds	r2, r7, #4
  412fea:	440a      	add	r2, r1
  412fec:	a831      	add	r0, sp, #196	; 0xc4
  412fee:	4439      	add	r1, r7
  412ff0:	ed51 7a01 	vldr	s15, [r1, #-4]
  412ff4:	ee77 6a87 	vadd.f32	s13, s15, s14
  412ff8:	ee77 7ae6 	vsub.f32	s15, s15, s13
  412ffc:	ee77 7a87 	vadd.f32	s15, s15, s14
  413000:	eeb0 7a66 	vmov.f32	s14, s13
  413004:	ed62 7a01 	vstmdb	r2!, {s15}
  413008:	4282      	cmp	r2, r0
  41300a:	ed61 6a01 	vstmdb	r1!, {s13}
  41300e:	d1ef      	bne.n	412ff0 <__kernel_rem_pio2f+0x458>
  413010:	2b01      	cmp	r3, #1
  413012:	f340 80e5 	ble.w	4131e0 <__kernel_rem_pio2f+0x648>
  413016:	ab58      	add	r3, sp, #352	; 0x160
  413018:	443b      	add	r3, r7
  41301a:	aa30      	add	r2, sp, #192	; 0xc0
  41301c:	ed13 7a28 	vldr	s14, [r3, #-160]	; 0xffffff60
  413020:	1d3b      	adds	r3, r7, #4
  413022:	a932      	add	r1, sp, #200	; 0xc8
  413024:	4417      	add	r7, r2
  413026:	441a      	add	r2, r3
  413028:	ed57 7a01 	vldr	s15, [r7, #-4]
  41302c:	ee77 6a87 	vadd.f32	s13, s15, s14
  413030:	ee77 7ae6 	vsub.f32	s15, s15, s13
  413034:	ee77 7a87 	vadd.f32	s15, s15, s14
  413038:	eeb0 7a66 	vmov.f32	s14, s13
  41303c:	ed62 7a01 	vstmdb	r2!, {s15}
  413040:	4291      	cmp	r1, r2
  413042:	ed67 6a01 	vstmdb	r7!, {s13}
  413046:	d1ef      	bne.n	413028 <__kernel_rem_pio2f+0x490>
  413048:	a930      	add	r1, sp, #192	; 0xc0
  41304a:	eddf 7a76 	vldr	s15, [pc, #472]	; 413224 <__kernel_rem_pio2f+0x68c>
  41304e:	440b      	add	r3, r1
  413050:	ed33 7a01 	vldmdb	r3!, {s14}
  413054:	429a      	cmp	r2, r3
  413056:	ee77 7a87 	vadd.f32	s15, s15, s14
  41305a:	d1f9      	bne.n	413050 <__kernel_rem_pio2f+0x4b8>
  41305c:	4643      	mov	r3, r8
  41305e:	2b00      	cmp	r3, #0
  413060:	f000 80ae 	beq.w	4131c0 <__kernel_rem_pio2f+0x628>
  413064:	eddd 6a30 	vldr	s13, [sp, #192]	; 0xc0
  413068:	ed9d 7a31 	vldr	s14, [sp, #196]	; 0xc4
  41306c:	9a02      	ldr	r2, [sp, #8]
  41306e:	eef1 7a67 	vneg.f32	s15, s15
  413072:	eef1 6a66 	vneg.f32	s13, s13
  413076:	eeb1 7a47 	vneg.f32	s14, s14
  41307a:	edc2 7a02 	vstr	s15, [r2, #8]
  41307e:	edc2 6a00 	vstr	s13, [r2]
  413082:	ed82 7a01 	vstr	s14, [r2, #4]
  413086:	ee19 3a90 	vmov	r3, s19
  41308a:	f003 0007 	and.w	r0, r3, #7
  41308e:	b059      	add	sp, #356	; 0x164
  413090:	ecbd 8b04 	vpop	{d8-d9}
  413094:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  413098:	1d3a      	adds	r2, r7, #4
  41309a:	a930      	add	r1, sp, #192	; 0xc0
  41309c:	eddf 7a61 	vldr	s15, [pc, #388]	; 413224 <__kernel_rem_pio2f+0x68c>
  4130a0:	440a      	add	r2, r1
  4130a2:	ed32 7a01 	vldmdb	r2!, {s14}
  4130a6:	428a      	cmp	r2, r1
  4130a8:	ee77 7a87 	vadd.f32	s15, s15, s14
  4130ac:	d1f9      	bne.n	4130a2 <__kernel_rem_pio2f+0x50a>
  4130ae:	4642      	mov	r2, r8
  4130b0:	2a00      	cmp	r2, #0
  4130b2:	d078      	beq.n	4131a6 <__kernel_rem_pio2f+0x60e>
  4130b4:	eddd 6a30 	vldr	s13, [sp, #192]	; 0xc0
  4130b8:	9a02      	ldr	r2, [sp, #8]
  4130ba:	eeb1 7a67 	vneg.f32	s14, s15
  4130be:	2b00      	cmp	r3, #0
  4130c0:	ee76 7ae7 	vsub.f32	s15, s13, s15
  4130c4:	ed82 7a00 	vstr	s14, [r2]
  4130c8:	dd0a      	ble.n	4130e0 <__kernel_rem_pio2f+0x548>
  4130ca:	a931      	add	r1, sp, #196	; 0xc4
  4130cc:	2201      	movs	r2, #1
  4130ce:	ecb1 7a01 	vldmia	r1!, {s14}
  4130d2:	3201      	adds	r2, #1
  4130d4:	4293      	cmp	r3, r2
  4130d6:	ee77 7a87 	vadd.f32	s15, s15, s14
  4130da:	daf8      	bge.n	4130ce <__kernel_rem_pio2f+0x536>
  4130dc:	4643      	mov	r3, r8
  4130de:	b10b      	cbz	r3, 4130e4 <__kernel_rem_pio2f+0x54c>
  4130e0:	eef1 7a67 	vneg.f32	s15, s15
  4130e4:	9b02      	ldr	r3, [sp, #8]
  4130e6:	edc3 7a01 	vstr	s15, [r3, #4]
  4130ea:	e7cc      	b.n	413086 <__kernel_rem_pio2f+0x4ee>
  4130ec:	ab30      	add	r3, sp, #192	; 0xc0
  4130ee:	eddf 7a4d 	vldr	s15, [pc, #308]	; 413224 <__kernel_rem_pio2f+0x68c>
  4130f2:	449e      	add	lr, r3
  4130f4:	ed3e 7a01 	vldmdb	lr!, {s14}
  4130f8:	4573      	cmp	r3, lr
  4130fa:	ee77 7a87 	vadd.f32	s15, s15, s14
  4130fe:	d1f9      	bne.n	4130f4 <__kernel_rem_pio2f+0x55c>
  413100:	4643      	mov	r3, r8
  413102:	b10b      	cbz	r3, 413108 <__kernel_rem_pio2f+0x570>
  413104:	eef1 7a67 	vneg.f32	s15, s15
  413108:	9b02      	ldr	r3, [sp, #8]
  41310a:	edc3 7a00 	vstr	s15, [r3]
  41310e:	e7ba      	b.n	413086 <__kernel_rem_pio2f+0x4ee>
  413110:	eddf 7a44 	vldr	s15, [pc, #272]	; 413224 <__kernel_rem_pio2f+0x68c>
  413114:	ece5 7a01 	vstmia	r5!, {s15}
  413118:	42bd      	cmp	r5, r7
  41311a:	f100 0004 	add.w	r0, r0, #4
  41311e:	f47f ad7e 	bne.w	412c1e <__kernel_rem_pio2f+0x86>
  413122:	e592      	b.n	412c4a <__kernel_rem_pio2f+0xb2>
  413124:	ee19 2a90 	vmov	r2, s19
  413128:	f1bb 0f00 	cmp.w	fp, #0
  41312c:	f102 0201 	add.w	r2, r2, #1
  413130:	ee09 2a90 	vmov	s19, r2
  413134:	bfc8      	it	gt
  413136:	2102      	movgt	r1, #2
  413138:	f73f adf7 	bgt.w	412d2a <__kernel_rem_pio2f+0x192>
  41313c:	eef7 7a00 	vmov.f32	s15, #112	; 0x3f800000  1.0
  413140:	ee37 9ac9 	vsub.f32	s18, s15, s18
  413144:	2102      	movs	r1, #2
  413146:	e638      	b.n	412dba <__kernel_rem_pio2f+0x222>
  413148:	eddf 7a36 	vldr	s15, [pc, #216]	; 413224 <__kernel_rem_pio2f+0x68c>
  41314c:	e733      	b.n	412fb6 <__kernel_rem_pio2f+0x41e>
  41314e:	2e00      	cmp	r6, #0
  413150:	dd1e      	ble.n	413190 <__kernel_rem_pio2f+0x5f8>
  413152:	2200      	movs	r2, #0
  413154:	2e01      	cmp	r6, #1
  413156:	f43f ae19 	beq.w	412d8c <__kernel_rem_pio2f+0x1f4>
  41315a:	2e02      	cmp	r6, #2
  41315c:	d107      	bne.n	41316e <__kernel_rem_pio2f+0x5d6>
  41315e:	f10b 30ff 	add.w	r0, fp, #4294967295
  413162:	f855 3020 	ldr.w	r3, [r5, r0, lsl #2]
  413166:	f003 033f 	and.w	r3, r3, #63	; 0x3f
  41316a:	f845 3020 	str.w	r3, [r5, r0, lsl #2]
  41316e:	2902      	cmp	r1, #2
  413170:	f47f ae23 	bne.w	412dba <__kernel_rem_pio2f+0x222>
  413174:	eef7 7a00 	vmov.f32	s15, #112	; 0x3f800000  1.0
  413178:	ee37 9ac9 	vsub.f32	s18, s15, s18
  41317c:	2a00      	cmp	r2, #0
  41317e:	f43f ae1c 	beq.w	412dba <__kernel_rem_pio2f+0x222>
  413182:	e612      	b.n	412daa <__kernel_rem_pio2f+0x212>
  413184:	3001      	adds	r0, #1
  413186:	4583      	cmp	fp, r0
  413188:	f47f add9 	bne.w	412d3e <__kernel_rem_pio2f+0x1a6>
  41318c:	2e00      	cmp	r6, #0
  41318e:	dce1      	bgt.n	413154 <__kernel_rem_pio2f+0x5bc>
  413190:	2902      	cmp	r1, #2
  413192:	f47f ae12 	bne.w	412dba <__kernel_rem_pio2f+0x222>
  413196:	eef7 7a00 	vmov.f32	s15, #112	; 0x3f800000  1.0
  41319a:	ee37 9ac9 	vsub.f32	s18, s15, s18
  41319e:	e60c      	b.n	412dba <__kernel_rem_pio2f+0x222>
  4131a0:	f04f 0c01 	mov.w	ip, #1
  4131a4:	e632      	b.n	412e0c <__kernel_rem_pio2f+0x274>
  4131a6:	ed9d 7a30 	vldr	s14, [sp, #192]	; 0xc0
  4131aa:	9a02      	ldr	r2, [sp, #8]
  4131ac:	2b00      	cmp	r3, #0
  4131ae:	edc2 7a00 	vstr	s15, [r2]
  4131b2:	ee77 7a67 	vsub.f32	s15, s14, s15
  4131b6:	dc88      	bgt.n	4130ca <__kernel_rem_pio2f+0x532>
  4131b8:	9b02      	ldr	r3, [sp, #8]
  4131ba:	edc3 7a01 	vstr	s15, [r3, #4]
  4131be:	e762      	b.n	413086 <__kernel_rem_pio2f+0x4ee>
  4131c0:	9802      	ldr	r0, [sp, #8]
  4131c2:	9a30      	ldr	r2, [sp, #192]	; 0xc0
  4131c4:	9b31      	ldr	r3, [sp, #196]	; 0xc4
  4131c6:	edc0 7a02 	vstr	s15, [r0, #8]
  4131ca:	6002      	str	r2, [r0, #0]
  4131cc:	6043      	str	r3, [r0, #4]
  4131ce:	e75a      	b.n	413086 <__kernel_rem_pio2f+0x4ee>
  4131d0:	eebd 0ac0 	vcvt.s32.f32	s0, s0
  4131d4:	465b      	mov	r3, fp
  4131d6:	ee10 2a10 	vmov	r2, s0
  4131da:	f845 202b 	str.w	r2, [r5, fp, lsl #2]
  4131de:	e6ae      	b.n	412f3e <__kernel_rem_pio2f+0x3a6>
  4131e0:	eddf 7a10 	vldr	s15, [pc, #64]	; 413224 <__kernel_rem_pio2f+0x68c>
  4131e4:	e73a      	b.n	41305c <__kernel_rem_pio2f+0x4c4>
  4131e6:	9a66      	ldr	r2, [sp, #408]	; 0x198
  4131e8:	2a03      	cmp	r2, #3
  4131ea:	f63f af4c 	bhi.w	413086 <__kernel_rem_pio2f+0x4ee>
  4131ee:	a101      	add	r1, pc, #4	; (adr r1, 4131f4 <__kernel_rem_pio2f+0x65c>)
  4131f0:	f851 f022 	ldr.w	pc, [r1, r2, lsl #2]
  4131f4:	00413213 	.word	0x00413213
  4131f8:	0041320d 	.word	0x0041320d
  4131fc:	0041320d 	.word	0x0041320d
  413200:	004131e1 	.word	0x004131e1
  413204:	f04f 0e01 	mov.w	lr, #1
  413208:	2000      	movs	r0, #0
  41320a:	e59f      	b.n	412d4c <__kernel_rem_pio2f+0x1b4>
  41320c:	eddf 7a05 	vldr	s15, [pc, #20]	; 413224 <__kernel_rem_pio2f+0x68c>
  413210:	e74d      	b.n	4130ae <__kernel_rem_pio2f+0x516>
  413212:	eddf 7a04 	vldr	s15, [pc, #16]	; 413224 <__kernel_rem_pio2f+0x68c>
  413216:	e773      	b.n	413100 <__kernel_rem_pio2f+0x568>
  413218:	9b04      	ldr	r3, [sp, #16]
  41321a:	009c      	lsls	r4, r3, #2
  41321c:	e515      	b.n	412c4a <__kernel_rem_pio2f+0xb2>
  41321e:	bf00      	nop
  413220:	0041d5f0 	.word	0x0041d5f0
  413224:	00000000 	.word	0x00000000

00413228 <__kernel_sinf>:
  413228:	ee10 3a10 	vmov	r3, s0
  41322c:	f023 4300 	bic.w	r3, r3, #2147483648	; 0x80000000
  413230:	f1b3 5f48 	cmp.w	r3, #838860800	; 0x32000000
  413234:	da04      	bge.n	413240 <__kernel_sinf+0x18>
  413236:	eefd 7ac0 	vcvt.s32.f32	s15, s0
  41323a:	ee17 3a90 	vmov	r3, s15
  41323e:	b323      	cbz	r3, 41328a <__kernel_sinf+0x62>
  413240:	ee60 7a00 	vmul.f32	s15, s0, s0
  413244:	ed9f 5a15 	vldr	s10, [pc, #84]	; 41329c <__kernel_sinf+0x74>
  413248:	eddf 5a15 	vldr	s11, [pc, #84]	; 4132a0 <__kernel_sinf+0x78>
  41324c:	ed9f 6a15 	vldr	s12, [pc, #84]	; 4132a4 <__kernel_sinf+0x7c>
  413250:	eddf 6a15 	vldr	s13, [pc, #84]	; 4132a8 <__kernel_sinf+0x80>
  413254:	ed9f 7a15 	vldr	s14, [pc, #84]	; 4132ac <__kernel_sinf+0x84>
  413258:	eee7 5a85 	vfma.f32	s11, s15, s10
  41325c:	ee20 5a27 	vmul.f32	s10, s0, s15
  413260:	eea7 6aa5 	vfma.f32	s12, s15, s11
  413264:	eee7 6a86 	vfma.f32	s13, s15, s12
  413268:	eea7 7aa6 	vfma.f32	s14, s15, s13
  41326c:	b170      	cbz	r0, 41328c <__kernel_sinf+0x64>
  41326e:	ee27 7a45 	vnmul.f32	s14, s14, s10
  413272:	eef6 6a00 	vmov.f32	s13, #96	; 0x3f000000  0.5
  413276:	eea0 7aa6 	vfma.f32	s14, s1, s13
  41327a:	eddf 6a0d 	vldr	s13, [pc, #52]	; 4132b0 <__kernel_sinf+0x88>
  41327e:	eed7 0a87 	vfnms.f32	s1, s15, s14
  413282:	eee5 0a26 	vfma.f32	s1, s10, s13
  413286:	ee30 0a60 	vsub.f32	s0, s0, s1
  41328a:	4770      	bx	lr
  41328c:	eddf 6a09 	vldr	s13, [pc, #36]	; 4132b4 <__kernel_sinf+0x8c>
  413290:	eee7 6a87 	vfma.f32	s13, s15, s14
  413294:	eea5 0a26 	vfma.f32	s0, s10, s13
  413298:	4770      	bx	lr
  41329a:	bf00      	nop
  41329c:	2f2ec9d3 	.word	0x2f2ec9d3
  4132a0:	b2d72f34 	.word	0xb2d72f34
  4132a4:	3638ef1b 	.word	0x3638ef1b
  4132a8:	b9500d01 	.word	0xb9500d01
  4132ac:	3c088889 	.word	0x3c088889
  4132b0:	3e2aaaab 	.word	0x3e2aaaab
  4132b4:	be2aaaab 	.word	0xbe2aaaab

004132b8 <matherr>:
  4132b8:	2000      	movs	r0, #0
  4132ba:	4770      	bx	lr

004132bc <fabsf>:
  4132bc:	ee10 3a10 	vmov	r3, s0
  4132c0:	f023 4300 	bic.w	r3, r3, #2147483648	; 0x80000000
  4132c4:	ee00 3a10 	vmov	s0, r3
  4132c8:	4770      	bx	lr
  4132ca:	bf00      	nop

004132cc <floorf>:
  4132cc:	ee10 2a10 	vmov	r2, s0
  4132d0:	f022 4100 	bic.w	r1, r2, #2147483648	; 0x80000000
  4132d4:	0dcb      	lsrs	r3, r1, #23
  4132d6:	3b7f      	subs	r3, #127	; 0x7f
  4132d8:	2b16      	cmp	r3, #22
  4132da:	dc17      	bgt.n	41330c <floorf+0x40>
  4132dc:	2b00      	cmp	r3, #0
  4132de:	ee10 0a10 	vmov	r0, s0
  4132e2:	db19      	blt.n	413318 <floorf+0x4c>
  4132e4:	491a      	ldr	r1, [pc, #104]	; (413350 <floorf+0x84>)
  4132e6:	4119      	asrs	r1, r3
  4132e8:	420a      	tst	r2, r1
  4132ea:	d022      	beq.n	413332 <floorf+0x66>
  4132ec:	eddf 7a19 	vldr	s15, [pc, #100]	; 413354 <floorf+0x88>
  4132f0:	ee70 7a27 	vadd.f32	s15, s0, s15
  4132f4:	eef5 7ac0 	vcmpe.f32	s15, #0.0
  4132f8:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
  4132fc:	dd19      	ble.n	413332 <floorf+0x66>
  4132fe:	2a00      	cmp	r2, #0
  413300:	db18      	blt.n	413334 <floorf+0x68>
  413302:	ea20 0301 	bic.w	r3, r0, r1
  413306:	ee00 3a10 	vmov	s0, r3
  41330a:	4770      	bx	lr
  41330c:	f1b1 4fff 	cmp.w	r1, #2139095040	; 0x7f800000
  413310:	d30f      	bcc.n	413332 <floorf+0x66>
  413312:	ee30 0a00 	vadd.f32	s0, s0, s0
  413316:	4770      	bx	lr
  413318:	eddf 7a0e 	vldr	s15, [pc, #56]	; 413354 <floorf+0x88>
  41331c:	ee70 7a27 	vadd.f32	s15, s0, s15
  413320:	eef5 7ac0 	vcmpe.f32	s15, #0.0
  413324:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
  413328:	dd03      	ble.n	413332 <floorf+0x66>
  41332a:	2a00      	cmp	r2, #0
  41332c:	db08      	blt.n	413340 <floorf+0x74>
  41332e:	ed9f 0a0a 	vldr	s0, [pc, #40]	; 413358 <floorf+0x8c>
  413332:	4770      	bx	lr
  413334:	f44f 0200 	mov.w	r2, #8388608	; 0x800000
  413338:	fa42 f303 	asr.w	r3, r2, r3
  41333c:	4418      	add	r0, r3
  41333e:	e7e0      	b.n	413302 <floorf+0x36>
  413340:	2900      	cmp	r1, #0
  413342:	eeff 7a00 	vmov.f32	s15, #240	; 0xbf800000 -1.0
  413346:	bf18      	it	ne
  413348:	eeb0 0a67 	vmovne.f32	s0, s15
  41334c:	4770      	bx	lr
  41334e:	bf00      	nop
  413350:	007fffff 	.word	0x007fffff
  413354:	7149f2ca 	.word	0x7149f2ca
  413358:	00000000 	.word	0x00000000

0041335c <scalbnf>:
  41335c:	b508      	push	{r3, lr}
  41335e:	ee10 3a10 	vmov	r3, s0
  413362:	f033 4200 	bics.w	r2, r3, #2147483648	; 0x80000000
  413366:	ed2d 8b02 	vpush	{d8}
  41336a:	d011      	beq.n	413390 <scalbnf+0x34>
  41336c:	f1b2 4fff 	cmp.w	r2, #2139095040	; 0x7f800000
  413370:	d211      	bcs.n	413396 <scalbnf+0x3a>
  413372:	f5b2 0f00 	cmp.w	r2, #8388608	; 0x800000
  413376:	d313      	bcc.n	4133a0 <scalbnf+0x44>
  413378:	0dd2      	lsrs	r2, r2, #23
  41337a:	4402      	add	r2, r0
  41337c:	2afe      	cmp	r2, #254	; 0xfe
  41337e:	dc2e      	bgt.n	4133de <scalbnf+0x82>
  413380:	2a00      	cmp	r2, #0
  413382:	dd1a      	ble.n	4133ba <scalbnf+0x5e>
  413384:	f023 43ff 	bic.w	r3, r3, #2139095040	; 0x7f800000
  413388:	ea43 53c2 	orr.w	r3, r3, r2, lsl #23
  41338c:	ee00 3a10 	vmov	s0, r3
  413390:	ecbd 8b02 	vpop	{d8}
  413394:	bd08      	pop	{r3, pc}
  413396:	ecbd 8b02 	vpop	{d8}
  41339a:	ee30 0a00 	vadd.f32	s0, s0, s0
  41339e:	bd08      	pop	{r3, pc}
  4133a0:	4b1d      	ldr	r3, [pc, #116]	; (413418 <scalbnf+0xbc>)
  4133a2:	eddf 7a1e 	vldr	s15, [pc, #120]	; 41341c <scalbnf+0xc0>
  4133a6:	4298      	cmp	r0, r3
  4133a8:	ee20 0a27 	vmul.f32	s0, s0, s15
  4133ac:	db22      	blt.n	4133f4 <scalbnf+0x98>
  4133ae:	ee10 3a10 	vmov	r3, s0
  4133b2:	f3c3 52c7 	ubfx	r2, r3, #23, #8
  4133b6:	3a19      	subs	r2, #25
  4133b8:	e7df      	b.n	41337a <scalbnf+0x1e>
  4133ba:	f112 0f16 	cmn.w	r2, #22
  4133be:	da1e      	bge.n	4133fe <scalbnf+0xa2>
  4133c0:	f24c 3350 	movw	r3, #50000	; 0xc350
  4133c4:	4298      	cmp	r0, r3
  4133c6:	dc0a      	bgt.n	4133de <scalbnf+0x82>
  4133c8:	ed9f 8a15 	vldr	s16, [pc, #84]	; 413420 <scalbnf+0xc4>
  4133cc:	eef0 0a40 	vmov.f32	s1, s0
  4133d0:	eeb0 0a48 	vmov.f32	s0, s16
  4133d4:	f000 f82a 	bl	41342c <copysignf>
  4133d8:	ee20 0a08 	vmul.f32	s0, s0, s16
  4133dc:	e7d8      	b.n	413390 <scalbnf+0x34>
  4133de:	ed9f 8a11 	vldr	s16, [pc, #68]	; 413424 <scalbnf+0xc8>
  4133e2:	eef0 0a40 	vmov.f32	s1, s0
  4133e6:	eeb0 0a48 	vmov.f32	s0, s16
  4133ea:	f000 f81f 	bl	41342c <copysignf>
  4133ee:	ee20 0a08 	vmul.f32	s0, s0, s16
  4133f2:	e7cd      	b.n	413390 <scalbnf+0x34>
  4133f4:	eddf 0a0a 	vldr	s1, [pc, #40]	; 413420 <scalbnf+0xc4>
  4133f8:	ee20 0a20 	vmul.f32	s0, s0, s1
  4133fc:	e7c8      	b.n	413390 <scalbnf+0x34>
  4133fe:	3219      	adds	r2, #25
  413400:	f023 43ff 	bic.w	r3, r3, #2139095040	; 0x7f800000
  413404:	ea43 53c2 	orr.w	r3, r3, r2, lsl #23
  413408:	eddf 7a07 	vldr	s15, [pc, #28]	; 413428 <scalbnf+0xcc>
  41340c:	ee00 3a10 	vmov	s0, r3
  413410:	ee20 0a27 	vmul.f32	s0, s0, s15
  413414:	e7bc      	b.n	413390 <scalbnf+0x34>
  413416:	bf00      	nop
  413418:	ffff3cb0 	.word	0xffff3cb0
  41341c:	4c000000 	.word	0x4c000000
  413420:	0da24260 	.word	0x0da24260
  413424:	7149f2ca 	.word	0x7149f2ca
  413428:	33000000 	.word	0x33000000

0041342c <copysignf>:
  41342c:	ee10 3a10 	vmov	r3, s0
  413430:	ee10 2a90 	vmov	r2, s1
  413434:	f023 4300 	bic.w	r3, r3, #2147483648	; 0x80000000
  413438:	f002 4200 	and.w	r2, r2, #2147483648	; 0x80000000
  41343c:	4313      	orrs	r3, r2
  41343e:	ee00 3a10 	vmov	s0, r3
  413442:	4770      	bx	lr

00413444 <__aeabi_drsub>:
  413444:	f081 4100 	eor.w	r1, r1, #2147483648	; 0x80000000
  413448:	e002      	b.n	413450 <__adddf3>
  41344a:	bf00      	nop

0041344c <__aeabi_dsub>:
  41344c:	f083 4300 	eor.w	r3, r3, #2147483648	; 0x80000000

00413450 <__adddf3>:
  413450:	b530      	push	{r4, r5, lr}
  413452:	ea4f 0441 	mov.w	r4, r1, lsl #1
  413456:	ea4f 0543 	mov.w	r5, r3, lsl #1
  41345a:	ea94 0f05 	teq	r4, r5
  41345e:	bf08      	it	eq
  413460:	ea90 0f02 	teqeq	r0, r2
  413464:	bf1f      	itttt	ne
  413466:	ea54 0c00 	orrsne.w	ip, r4, r0
  41346a:	ea55 0c02 	orrsne.w	ip, r5, r2
  41346e:	ea7f 5c64 	mvnsne.w	ip, r4, asr #21
  413472:	ea7f 5c65 	mvnsne.w	ip, r5, asr #21
  413476:	f000 80e2 	beq.w	41363e <__adddf3+0x1ee>
  41347a:	ea4f 5454 	mov.w	r4, r4, lsr #21
  41347e:	ebd4 5555 	rsbs	r5, r4, r5, lsr #21
  413482:	bfb8      	it	lt
  413484:	426d      	neglt	r5, r5
  413486:	dd0c      	ble.n	4134a2 <__adddf3+0x52>
  413488:	442c      	add	r4, r5
  41348a:	ea80 0202 	eor.w	r2, r0, r2
  41348e:	ea81 0303 	eor.w	r3, r1, r3
  413492:	ea82 0000 	eor.w	r0, r2, r0
  413496:	ea83 0101 	eor.w	r1, r3, r1
  41349a:	ea80 0202 	eor.w	r2, r0, r2
  41349e:	ea81 0303 	eor.w	r3, r1, r3
  4134a2:	2d36      	cmp	r5, #54	; 0x36
  4134a4:	bf88      	it	hi
  4134a6:	bd30      	pophi	{r4, r5, pc}
  4134a8:	f011 4f00 	tst.w	r1, #2147483648	; 0x80000000
  4134ac:	ea4f 3101 	mov.w	r1, r1, lsl #12
  4134b0:	f44f 1c80 	mov.w	ip, #1048576	; 0x100000
  4134b4:	ea4c 3111 	orr.w	r1, ip, r1, lsr #12
  4134b8:	d002      	beq.n	4134c0 <__adddf3+0x70>
  4134ba:	4240      	negs	r0, r0
  4134bc:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
  4134c0:	f013 4f00 	tst.w	r3, #2147483648	; 0x80000000
  4134c4:	ea4f 3303 	mov.w	r3, r3, lsl #12
  4134c8:	ea4c 3313 	orr.w	r3, ip, r3, lsr #12
  4134cc:	d002      	beq.n	4134d4 <__adddf3+0x84>
  4134ce:	4252      	negs	r2, r2
  4134d0:	eb63 0343 	sbc.w	r3, r3, r3, lsl #1
  4134d4:	ea94 0f05 	teq	r4, r5
  4134d8:	f000 80a7 	beq.w	41362a <__adddf3+0x1da>
  4134dc:	f1a4 0401 	sub.w	r4, r4, #1
  4134e0:	f1d5 0e20 	rsbs	lr, r5, #32
  4134e4:	db0d      	blt.n	413502 <__adddf3+0xb2>
  4134e6:	fa02 fc0e 	lsl.w	ip, r2, lr
  4134ea:	fa22 f205 	lsr.w	r2, r2, r5
  4134ee:	1880      	adds	r0, r0, r2
  4134f0:	f141 0100 	adc.w	r1, r1, #0
  4134f4:	fa03 f20e 	lsl.w	r2, r3, lr
  4134f8:	1880      	adds	r0, r0, r2
  4134fa:	fa43 f305 	asr.w	r3, r3, r5
  4134fe:	4159      	adcs	r1, r3
  413500:	e00e      	b.n	413520 <__adddf3+0xd0>
  413502:	f1a5 0520 	sub.w	r5, r5, #32
  413506:	f10e 0e20 	add.w	lr, lr, #32
  41350a:	2a01      	cmp	r2, #1
  41350c:	fa03 fc0e 	lsl.w	ip, r3, lr
  413510:	bf28      	it	cs
  413512:	f04c 0c02 	orrcs.w	ip, ip, #2
  413516:	fa43 f305 	asr.w	r3, r3, r5
  41351a:	18c0      	adds	r0, r0, r3
  41351c:	eb51 71e3 	adcs.w	r1, r1, r3, asr #31
  413520:	f001 4500 	and.w	r5, r1, #2147483648	; 0x80000000
  413524:	d507      	bpl.n	413536 <__adddf3+0xe6>
  413526:	f04f 0e00 	mov.w	lr, #0
  41352a:	f1dc 0c00 	rsbs	ip, ip, #0
  41352e:	eb7e 0000 	sbcs.w	r0, lr, r0
  413532:	eb6e 0101 	sbc.w	r1, lr, r1
  413536:	f5b1 1f80 	cmp.w	r1, #1048576	; 0x100000
  41353a:	d31b      	bcc.n	413574 <__adddf3+0x124>
  41353c:	f5b1 1f00 	cmp.w	r1, #2097152	; 0x200000
  413540:	d30c      	bcc.n	41355c <__adddf3+0x10c>
  413542:	0849      	lsrs	r1, r1, #1
  413544:	ea5f 0030 	movs.w	r0, r0, rrx
  413548:	ea4f 0c3c 	mov.w	ip, ip, rrx
  41354c:	f104 0401 	add.w	r4, r4, #1
  413550:	ea4f 5244 	mov.w	r2, r4, lsl #21
  413554:	f512 0f80 	cmn.w	r2, #4194304	; 0x400000
  413558:	f080 809a 	bcs.w	413690 <__adddf3+0x240>
  41355c:	f1bc 4f00 	cmp.w	ip, #2147483648	; 0x80000000
  413560:	bf08      	it	eq
  413562:	ea5f 0c50 	movseq.w	ip, r0, lsr #1
  413566:	f150 0000 	adcs.w	r0, r0, #0
  41356a:	eb41 5104 	adc.w	r1, r1, r4, lsl #20
  41356e:	ea41 0105 	orr.w	r1, r1, r5
  413572:	bd30      	pop	{r4, r5, pc}
  413574:	ea5f 0c4c 	movs.w	ip, ip, lsl #1
  413578:	4140      	adcs	r0, r0
  41357a:	eb41 0101 	adc.w	r1, r1, r1
  41357e:	f411 1f80 	tst.w	r1, #1048576	; 0x100000
  413582:	f1a4 0401 	sub.w	r4, r4, #1
  413586:	d1e9      	bne.n	41355c <__adddf3+0x10c>
  413588:	f091 0f00 	teq	r1, #0
  41358c:	bf04      	itt	eq
  41358e:	4601      	moveq	r1, r0
  413590:	2000      	moveq	r0, #0
  413592:	fab1 f381 	clz	r3, r1
  413596:	bf08      	it	eq
  413598:	3320      	addeq	r3, #32
  41359a:	f1a3 030b 	sub.w	r3, r3, #11
  41359e:	f1b3 0220 	subs.w	r2, r3, #32
  4135a2:	da0c      	bge.n	4135be <__adddf3+0x16e>
  4135a4:	320c      	adds	r2, #12
  4135a6:	dd08      	ble.n	4135ba <__adddf3+0x16a>
  4135a8:	f102 0c14 	add.w	ip, r2, #20
  4135ac:	f1c2 020c 	rsb	r2, r2, #12
  4135b0:	fa01 f00c 	lsl.w	r0, r1, ip
  4135b4:	fa21 f102 	lsr.w	r1, r1, r2
  4135b8:	e00c      	b.n	4135d4 <__adddf3+0x184>
  4135ba:	f102 0214 	add.w	r2, r2, #20
  4135be:	bfd8      	it	le
  4135c0:	f1c2 0c20 	rsble	ip, r2, #32
  4135c4:	fa01 f102 	lsl.w	r1, r1, r2
  4135c8:	fa20 fc0c 	lsr.w	ip, r0, ip
  4135cc:	bfdc      	itt	le
  4135ce:	ea41 010c 	orrle.w	r1, r1, ip
  4135d2:	4090      	lslle	r0, r2
  4135d4:	1ae4      	subs	r4, r4, r3
  4135d6:	bfa2      	ittt	ge
  4135d8:	eb01 5104 	addge.w	r1, r1, r4, lsl #20
  4135dc:	4329      	orrge	r1, r5
  4135de:	bd30      	popge	{r4, r5, pc}
  4135e0:	ea6f 0404 	mvn.w	r4, r4
  4135e4:	3c1f      	subs	r4, #31
  4135e6:	da1c      	bge.n	413622 <__adddf3+0x1d2>
  4135e8:	340c      	adds	r4, #12
  4135ea:	dc0e      	bgt.n	41360a <__adddf3+0x1ba>
  4135ec:	f104 0414 	add.w	r4, r4, #20
  4135f0:	f1c4 0220 	rsb	r2, r4, #32
  4135f4:	fa20 f004 	lsr.w	r0, r0, r4
  4135f8:	fa01 f302 	lsl.w	r3, r1, r2
  4135fc:	ea40 0003 	orr.w	r0, r0, r3
  413600:	fa21 f304 	lsr.w	r3, r1, r4
  413604:	ea45 0103 	orr.w	r1, r5, r3
  413608:	bd30      	pop	{r4, r5, pc}
  41360a:	f1c4 040c 	rsb	r4, r4, #12
  41360e:	f1c4 0220 	rsb	r2, r4, #32
  413612:	fa20 f002 	lsr.w	r0, r0, r2
  413616:	fa01 f304 	lsl.w	r3, r1, r4
  41361a:	ea40 0003 	orr.w	r0, r0, r3
  41361e:	4629      	mov	r1, r5
  413620:	bd30      	pop	{r4, r5, pc}
  413622:	fa21 f004 	lsr.w	r0, r1, r4
  413626:	4629      	mov	r1, r5
  413628:	bd30      	pop	{r4, r5, pc}
  41362a:	f094 0f00 	teq	r4, #0
  41362e:	f483 1380 	eor.w	r3, r3, #1048576	; 0x100000
  413632:	bf06      	itte	eq
  413634:	f481 1180 	eoreq.w	r1, r1, #1048576	; 0x100000
  413638:	3401      	addeq	r4, #1
  41363a:	3d01      	subne	r5, #1
  41363c:	e74e      	b.n	4134dc <__adddf3+0x8c>
  41363e:	ea7f 5c64 	mvns.w	ip, r4, asr #21
  413642:	bf18      	it	ne
  413644:	ea7f 5c65 	mvnsne.w	ip, r5, asr #21
  413648:	d029      	beq.n	41369e <__adddf3+0x24e>
  41364a:	ea94 0f05 	teq	r4, r5
  41364e:	bf08      	it	eq
  413650:	ea90 0f02 	teqeq	r0, r2
  413654:	d005      	beq.n	413662 <__adddf3+0x212>
  413656:	ea54 0c00 	orrs.w	ip, r4, r0
  41365a:	bf04      	itt	eq
  41365c:	4619      	moveq	r1, r3
  41365e:	4610      	moveq	r0, r2
  413660:	bd30      	pop	{r4, r5, pc}
  413662:	ea91 0f03 	teq	r1, r3
  413666:	bf1e      	ittt	ne
  413668:	2100      	movne	r1, #0
  41366a:	2000      	movne	r0, #0
  41366c:	bd30      	popne	{r4, r5, pc}
  41366e:	ea5f 5c54 	movs.w	ip, r4, lsr #21
  413672:	d105      	bne.n	413680 <__adddf3+0x230>
  413674:	0040      	lsls	r0, r0, #1
  413676:	4149      	adcs	r1, r1
  413678:	bf28      	it	cs
  41367a:	f041 4100 	orrcs.w	r1, r1, #2147483648	; 0x80000000
  41367e:	bd30      	pop	{r4, r5, pc}
  413680:	f514 0480 	adds.w	r4, r4, #4194304	; 0x400000
  413684:	bf3c      	itt	cc
  413686:	f501 1180 	addcc.w	r1, r1, #1048576	; 0x100000
  41368a:	bd30      	popcc	{r4, r5, pc}
  41368c:	f001 4500 	and.w	r5, r1, #2147483648	; 0x80000000
  413690:	f045 41fe 	orr.w	r1, r5, #2130706432	; 0x7f000000
  413694:	f441 0170 	orr.w	r1, r1, #15728640	; 0xf00000
  413698:	f04f 0000 	mov.w	r0, #0
  41369c:	bd30      	pop	{r4, r5, pc}
  41369e:	ea7f 5c64 	mvns.w	ip, r4, asr #21
  4136a2:	bf1a      	itte	ne
  4136a4:	4619      	movne	r1, r3
  4136a6:	4610      	movne	r0, r2
  4136a8:	ea7f 5c65 	mvnseq.w	ip, r5, asr #21
  4136ac:	bf1c      	itt	ne
  4136ae:	460b      	movne	r3, r1
  4136b0:	4602      	movne	r2, r0
  4136b2:	ea50 3401 	orrs.w	r4, r0, r1, lsl #12
  4136b6:	bf06      	itte	eq
  4136b8:	ea52 3503 	orrseq.w	r5, r2, r3, lsl #12
  4136bc:	ea91 0f03 	teqeq	r1, r3
  4136c0:	f441 2100 	orrne.w	r1, r1, #524288	; 0x80000
  4136c4:	bd30      	pop	{r4, r5, pc}
  4136c6:	bf00      	nop

004136c8 <__aeabi_ui2d>:
  4136c8:	f090 0f00 	teq	r0, #0
  4136cc:	bf04      	itt	eq
  4136ce:	2100      	moveq	r1, #0
  4136d0:	4770      	bxeq	lr
  4136d2:	b530      	push	{r4, r5, lr}
  4136d4:	f44f 6480 	mov.w	r4, #1024	; 0x400
  4136d8:	f104 0432 	add.w	r4, r4, #50	; 0x32
  4136dc:	f04f 0500 	mov.w	r5, #0
  4136e0:	f04f 0100 	mov.w	r1, #0
  4136e4:	e750      	b.n	413588 <__adddf3+0x138>
  4136e6:	bf00      	nop

004136e8 <__aeabi_i2d>:
  4136e8:	f090 0f00 	teq	r0, #0
  4136ec:	bf04      	itt	eq
  4136ee:	2100      	moveq	r1, #0
  4136f0:	4770      	bxeq	lr
  4136f2:	b530      	push	{r4, r5, lr}
  4136f4:	f44f 6480 	mov.w	r4, #1024	; 0x400
  4136f8:	f104 0432 	add.w	r4, r4, #50	; 0x32
  4136fc:	f010 4500 	ands.w	r5, r0, #2147483648	; 0x80000000
  413700:	bf48      	it	mi
  413702:	4240      	negmi	r0, r0
  413704:	f04f 0100 	mov.w	r1, #0
  413708:	e73e      	b.n	413588 <__adddf3+0x138>
  41370a:	bf00      	nop

0041370c <__aeabi_f2d>:
  41370c:	0042      	lsls	r2, r0, #1
  41370e:	ea4f 01e2 	mov.w	r1, r2, asr #3
  413712:	ea4f 0131 	mov.w	r1, r1, rrx
  413716:	ea4f 7002 	mov.w	r0, r2, lsl #28
  41371a:	bf1f      	itttt	ne
  41371c:	f012 437f 	andsne.w	r3, r2, #4278190080	; 0xff000000
  413720:	f093 4f7f 	teqne	r3, #4278190080	; 0xff000000
  413724:	f081 5160 	eorne.w	r1, r1, #939524096	; 0x38000000
  413728:	4770      	bxne	lr
  41372a:	f092 0f00 	teq	r2, #0
  41372e:	bf14      	ite	ne
  413730:	f093 4f7f 	teqne	r3, #4278190080	; 0xff000000
  413734:	4770      	bxeq	lr
  413736:	b530      	push	{r4, r5, lr}
  413738:	f44f 7460 	mov.w	r4, #896	; 0x380
  41373c:	f001 4500 	and.w	r5, r1, #2147483648	; 0x80000000
  413740:	f021 4100 	bic.w	r1, r1, #2147483648	; 0x80000000
  413744:	e720      	b.n	413588 <__adddf3+0x138>
  413746:	bf00      	nop

00413748 <__aeabi_ul2d>:
  413748:	ea50 0201 	orrs.w	r2, r0, r1
  41374c:	bf08      	it	eq
  41374e:	4770      	bxeq	lr
  413750:	b530      	push	{r4, r5, lr}
  413752:	f04f 0500 	mov.w	r5, #0
  413756:	e00a      	b.n	41376e <__aeabi_l2d+0x16>

00413758 <__aeabi_l2d>:
  413758:	ea50 0201 	orrs.w	r2, r0, r1
  41375c:	bf08      	it	eq
  41375e:	4770      	bxeq	lr
  413760:	b530      	push	{r4, r5, lr}
  413762:	f011 4500 	ands.w	r5, r1, #2147483648	; 0x80000000
  413766:	d502      	bpl.n	41376e <__aeabi_l2d+0x16>
  413768:	4240      	negs	r0, r0
  41376a:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
  41376e:	f44f 6480 	mov.w	r4, #1024	; 0x400
  413772:	f104 0432 	add.w	r4, r4, #50	; 0x32
  413776:	ea5f 5c91 	movs.w	ip, r1, lsr #22
  41377a:	f43f aedc 	beq.w	413536 <__adddf3+0xe6>
  41377e:	f04f 0203 	mov.w	r2, #3
  413782:	ea5f 0cdc 	movs.w	ip, ip, lsr #3
  413786:	bf18      	it	ne
  413788:	3203      	addne	r2, #3
  41378a:	ea5f 0cdc 	movs.w	ip, ip, lsr #3
  41378e:	bf18      	it	ne
  413790:	3203      	addne	r2, #3
  413792:	eb02 02dc 	add.w	r2, r2, ip, lsr #3
  413796:	f1c2 0320 	rsb	r3, r2, #32
  41379a:	fa00 fc03 	lsl.w	ip, r0, r3
  41379e:	fa20 f002 	lsr.w	r0, r0, r2
  4137a2:	fa01 fe03 	lsl.w	lr, r1, r3
  4137a6:	ea40 000e 	orr.w	r0, r0, lr
  4137aa:	fa21 f102 	lsr.w	r1, r1, r2
  4137ae:	4414      	add	r4, r2
  4137b0:	e6c1      	b.n	413536 <__adddf3+0xe6>
  4137b2:	bf00      	nop

004137b4 <__aeabi_dmul>:
  4137b4:	b570      	push	{r4, r5, r6, lr}
  4137b6:	f04f 0cff 	mov.w	ip, #255	; 0xff
  4137ba:	f44c 6ce0 	orr.w	ip, ip, #1792	; 0x700
  4137be:	ea1c 5411 	ands.w	r4, ip, r1, lsr #20
  4137c2:	bf1d      	ittte	ne
  4137c4:	ea1c 5513 	andsne.w	r5, ip, r3, lsr #20
  4137c8:	ea94 0f0c 	teqne	r4, ip
  4137cc:	ea95 0f0c 	teqne	r5, ip
  4137d0:	f000 f8de 	bleq	413990 <__aeabi_dmul+0x1dc>
  4137d4:	442c      	add	r4, r5
  4137d6:	ea81 0603 	eor.w	r6, r1, r3
  4137da:	ea21 514c 	bic.w	r1, r1, ip, lsl #21
  4137de:	ea23 534c 	bic.w	r3, r3, ip, lsl #21
  4137e2:	ea50 3501 	orrs.w	r5, r0, r1, lsl #12
  4137e6:	bf18      	it	ne
  4137e8:	ea52 3503 	orrsne.w	r5, r2, r3, lsl #12
  4137ec:	f441 1180 	orr.w	r1, r1, #1048576	; 0x100000
  4137f0:	f443 1380 	orr.w	r3, r3, #1048576	; 0x100000
  4137f4:	d038      	beq.n	413868 <__aeabi_dmul+0xb4>
  4137f6:	fba0 ce02 	umull	ip, lr, r0, r2
  4137fa:	f04f 0500 	mov.w	r5, #0
  4137fe:	fbe1 e502 	umlal	lr, r5, r1, r2
  413802:	f006 4200 	and.w	r2, r6, #2147483648	; 0x80000000
  413806:	fbe0 e503 	umlal	lr, r5, r0, r3
  41380a:	f04f 0600 	mov.w	r6, #0
  41380e:	fbe1 5603 	umlal	r5, r6, r1, r3
  413812:	f09c 0f00 	teq	ip, #0
  413816:	bf18      	it	ne
  413818:	f04e 0e01 	orrne.w	lr, lr, #1
  41381c:	f1a4 04ff 	sub.w	r4, r4, #255	; 0xff
  413820:	f5b6 7f00 	cmp.w	r6, #512	; 0x200
  413824:	f564 7440 	sbc.w	r4, r4, #768	; 0x300
  413828:	d204      	bcs.n	413834 <__aeabi_dmul+0x80>
  41382a:	ea5f 0e4e 	movs.w	lr, lr, lsl #1
  41382e:	416d      	adcs	r5, r5
  413830:	eb46 0606 	adc.w	r6, r6, r6
  413834:	ea42 21c6 	orr.w	r1, r2, r6, lsl #11
  413838:	ea41 5155 	orr.w	r1, r1, r5, lsr #21
  41383c:	ea4f 20c5 	mov.w	r0, r5, lsl #11
  413840:	ea40 505e 	orr.w	r0, r0, lr, lsr #21
  413844:	ea4f 2ece 	mov.w	lr, lr, lsl #11
  413848:	f1b4 0cfd 	subs.w	ip, r4, #253	; 0xfd
  41384c:	bf88      	it	hi
  41384e:	f5bc 6fe0 	cmphi.w	ip, #1792	; 0x700
  413852:	d81e      	bhi.n	413892 <__aeabi_dmul+0xde>
  413854:	f1be 4f00 	cmp.w	lr, #2147483648	; 0x80000000
  413858:	bf08      	it	eq
  41385a:	ea5f 0e50 	movseq.w	lr, r0, lsr #1
  41385e:	f150 0000 	adcs.w	r0, r0, #0
  413862:	eb41 5104 	adc.w	r1, r1, r4, lsl #20
  413866:	bd70      	pop	{r4, r5, r6, pc}
  413868:	f006 4600 	and.w	r6, r6, #2147483648	; 0x80000000
  41386c:	ea46 0101 	orr.w	r1, r6, r1
  413870:	ea40 0002 	orr.w	r0, r0, r2
  413874:	ea81 0103 	eor.w	r1, r1, r3
  413878:	ebb4 045c 	subs.w	r4, r4, ip, lsr #1
  41387c:	bfc2      	ittt	gt
  41387e:	ebd4 050c 	rsbsgt	r5, r4, ip
  413882:	ea41 5104 	orrgt.w	r1, r1, r4, lsl #20
  413886:	bd70      	popgt	{r4, r5, r6, pc}
  413888:	f441 1180 	orr.w	r1, r1, #1048576	; 0x100000
  41388c:	f04f 0e00 	mov.w	lr, #0
  413890:	3c01      	subs	r4, #1
  413892:	f300 80ab 	bgt.w	4139ec <__aeabi_dmul+0x238>
  413896:	f114 0f36 	cmn.w	r4, #54	; 0x36
  41389a:	bfde      	ittt	le
  41389c:	2000      	movle	r0, #0
  41389e:	f001 4100 	andle.w	r1, r1, #2147483648	; 0x80000000
  4138a2:	bd70      	pople	{r4, r5, r6, pc}
  4138a4:	f1c4 0400 	rsb	r4, r4, #0
  4138a8:	3c20      	subs	r4, #32
  4138aa:	da35      	bge.n	413918 <__aeabi_dmul+0x164>
  4138ac:	340c      	adds	r4, #12
  4138ae:	dc1b      	bgt.n	4138e8 <__aeabi_dmul+0x134>
  4138b0:	f104 0414 	add.w	r4, r4, #20
  4138b4:	f1c4 0520 	rsb	r5, r4, #32
  4138b8:	fa00 f305 	lsl.w	r3, r0, r5
  4138bc:	fa20 f004 	lsr.w	r0, r0, r4
  4138c0:	fa01 f205 	lsl.w	r2, r1, r5
  4138c4:	ea40 0002 	orr.w	r0, r0, r2
  4138c8:	f001 4200 	and.w	r2, r1, #2147483648	; 0x80000000
  4138cc:	f021 4100 	bic.w	r1, r1, #2147483648	; 0x80000000
  4138d0:	eb10 70d3 	adds.w	r0, r0, r3, lsr #31
  4138d4:	fa21 f604 	lsr.w	r6, r1, r4
  4138d8:	eb42 0106 	adc.w	r1, r2, r6
  4138dc:	ea5e 0e43 	orrs.w	lr, lr, r3, lsl #1
  4138e0:	bf08      	it	eq
  4138e2:	ea20 70d3 	biceq.w	r0, r0, r3, lsr #31
  4138e6:	bd70      	pop	{r4, r5, r6, pc}
  4138e8:	f1c4 040c 	rsb	r4, r4, #12
  4138ec:	f1c4 0520 	rsb	r5, r4, #32
  4138f0:	fa00 f304 	lsl.w	r3, r0, r4
  4138f4:	fa20 f005 	lsr.w	r0, r0, r5
  4138f8:	fa01 f204 	lsl.w	r2, r1, r4
  4138fc:	ea40 0002 	orr.w	r0, r0, r2
  413900:	f001 4100 	and.w	r1, r1, #2147483648	; 0x80000000
  413904:	eb10 70d3 	adds.w	r0, r0, r3, lsr #31
  413908:	f141 0100 	adc.w	r1, r1, #0
  41390c:	ea5e 0e43 	orrs.w	lr, lr, r3, lsl #1
  413910:	bf08      	it	eq
  413912:	ea20 70d3 	biceq.w	r0, r0, r3, lsr #31
  413916:	bd70      	pop	{r4, r5, r6, pc}
  413918:	f1c4 0520 	rsb	r5, r4, #32
  41391c:	fa00 f205 	lsl.w	r2, r0, r5
  413920:	ea4e 0e02 	orr.w	lr, lr, r2
  413924:	fa20 f304 	lsr.w	r3, r0, r4
  413928:	fa01 f205 	lsl.w	r2, r1, r5
  41392c:	ea43 0302 	orr.w	r3, r3, r2
  413930:	fa21 f004 	lsr.w	r0, r1, r4
  413934:	f001 4100 	and.w	r1, r1, #2147483648	; 0x80000000
  413938:	fa21 f204 	lsr.w	r2, r1, r4
  41393c:	ea20 0002 	bic.w	r0, r0, r2
  413940:	eb00 70d3 	add.w	r0, r0, r3, lsr #31
  413944:	ea5e 0e43 	orrs.w	lr, lr, r3, lsl #1
  413948:	bf08      	it	eq
  41394a:	ea20 70d3 	biceq.w	r0, r0, r3, lsr #31
  41394e:	bd70      	pop	{r4, r5, r6, pc}
  413950:	f094 0f00 	teq	r4, #0
  413954:	d10f      	bne.n	413976 <__aeabi_dmul+0x1c2>
  413956:	f001 4600 	and.w	r6, r1, #2147483648	; 0x80000000
  41395a:	0040      	lsls	r0, r0, #1
  41395c:	eb41 0101 	adc.w	r1, r1, r1
  413960:	f411 1f80 	tst.w	r1, #1048576	; 0x100000
  413964:	bf08      	it	eq
  413966:	3c01      	subeq	r4, #1
  413968:	d0f7      	beq.n	41395a <__aeabi_dmul+0x1a6>
  41396a:	ea41 0106 	orr.w	r1, r1, r6
  41396e:	f095 0f00 	teq	r5, #0
  413972:	bf18      	it	ne
  413974:	4770      	bxne	lr
  413976:	f003 4600 	and.w	r6, r3, #2147483648	; 0x80000000
  41397a:	0052      	lsls	r2, r2, #1
  41397c:	eb43 0303 	adc.w	r3, r3, r3
  413980:	f413 1f80 	tst.w	r3, #1048576	; 0x100000
  413984:	bf08      	it	eq
  413986:	3d01      	subeq	r5, #1
  413988:	d0f7      	beq.n	41397a <__aeabi_dmul+0x1c6>
  41398a:	ea43 0306 	orr.w	r3, r3, r6
  41398e:	4770      	bx	lr
  413990:	ea94 0f0c 	teq	r4, ip
  413994:	ea0c 5513 	and.w	r5, ip, r3, lsr #20
  413998:	bf18      	it	ne
  41399a:	ea95 0f0c 	teqne	r5, ip
  41399e:	d00c      	beq.n	4139ba <__aeabi_dmul+0x206>
  4139a0:	ea50 0641 	orrs.w	r6, r0, r1, lsl #1
  4139a4:	bf18      	it	ne
  4139a6:	ea52 0643 	orrsne.w	r6, r2, r3, lsl #1
  4139aa:	d1d1      	bne.n	413950 <__aeabi_dmul+0x19c>
  4139ac:	ea81 0103 	eor.w	r1, r1, r3
  4139b0:	f001 4100 	and.w	r1, r1, #2147483648	; 0x80000000
  4139b4:	f04f 0000 	mov.w	r0, #0
  4139b8:	bd70      	pop	{r4, r5, r6, pc}
  4139ba:	ea50 0641 	orrs.w	r6, r0, r1, lsl #1
  4139be:	bf06      	itte	eq
  4139c0:	4610      	moveq	r0, r2
  4139c2:	4619      	moveq	r1, r3
  4139c4:	ea52 0643 	orrsne.w	r6, r2, r3, lsl #1
  4139c8:	d019      	beq.n	4139fe <__aeabi_dmul+0x24a>
  4139ca:	ea94 0f0c 	teq	r4, ip
  4139ce:	d102      	bne.n	4139d6 <__aeabi_dmul+0x222>
  4139d0:	ea50 3601 	orrs.w	r6, r0, r1, lsl #12
  4139d4:	d113      	bne.n	4139fe <__aeabi_dmul+0x24a>
  4139d6:	ea95 0f0c 	teq	r5, ip
  4139da:	d105      	bne.n	4139e8 <__aeabi_dmul+0x234>
  4139dc:	ea52 3603 	orrs.w	r6, r2, r3, lsl #12
  4139e0:	bf1c      	itt	ne
  4139e2:	4610      	movne	r0, r2
  4139e4:	4619      	movne	r1, r3
  4139e6:	d10a      	bne.n	4139fe <__aeabi_dmul+0x24a>
  4139e8:	ea81 0103 	eor.w	r1, r1, r3
  4139ec:	f001 4100 	and.w	r1, r1, #2147483648	; 0x80000000
  4139f0:	f041 41fe 	orr.w	r1, r1, #2130706432	; 0x7f000000
  4139f4:	f441 0170 	orr.w	r1, r1, #15728640	; 0xf00000
  4139f8:	f04f 0000 	mov.w	r0, #0
  4139fc:	bd70      	pop	{r4, r5, r6, pc}
  4139fe:	f041 41fe 	orr.w	r1, r1, #2130706432	; 0x7f000000
  413a02:	f441 0178 	orr.w	r1, r1, #16252928	; 0xf80000
  413a06:	bd70      	pop	{r4, r5, r6, pc}

00413a08 <__aeabi_ddiv>:
  413a08:	b570      	push	{r4, r5, r6, lr}
  413a0a:	f04f 0cff 	mov.w	ip, #255	; 0xff
  413a0e:	f44c 6ce0 	orr.w	ip, ip, #1792	; 0x700
  413a12:	ea1c 5411 	ands.w	r4, ip, r1, lsr #20
  413a16:	bf1d      	ittte	ne
  413a18:	ea1c 5513 	andsne.w	r5, ip, r3, lsr #20
  413a1c:	ea94 0f0c 	teqne	r4, ip
  413a20:	ea95 0f0c 	teqne	r5, ip
  413a24:	f000 f8a7 	bleq	413b76 <__aeabi_ddiv+0x16e>
  413a28:	eba4 0405 	sub.w	r4, r4, r5
  413a2c:	ea81 0e03 	eor.w	lr, r1, r3
  413a30:	ea52 3503 	orrs.w	r5, r2, r3, lsl #12
  413a34:	ea4f 3101 	mov.w	r1, r1, lsl #12
  413a38:	f000 8088 	beq.w	413b4c <__aeabi_ddiv+0x144>
  413a3c:	ea4f 3303 	mov.w	r3, r3, lsl #12
  413a40:	f04f 5580 	mov.w	r5, #268435456	; 0x10000000
  413a44:	ea45 1313 	orr.w	r3, r5, r3, lsr #4
  413a48:	ea43 6312 	orr.w	r3, r3, r2, lsr #24
  413a4c:	ea4f 2202 	mov.w	r2, r2, lsl #8
  413a50:	ea45 1511 	orr.w	r5, r5, r1, lsr #4
  413a54:	ea45 6510 	orr.w	r5, r5, r0, lsr #24
  413a58:	ea4f 2600 	mov.w	r6, r0, lsl #8
  413a5c:	f00e 4100 	and.w	r1, lr, #2147483648	; 0x80000000
  413a60:	429d      	cmp	r5, r3
  413a62:	bf08      	it	eq
  413a64:	4296      	cmpeq	r6, r2
  413a66:	f144 04fd 	adc.w	r4, r4, #253	; 0xfd
  413a6a:	f504 7440 	add.w	r4, r4, #768	; 0x300
  413a6e:	d202      	bcs.n	413a76 <__aeabi_ddiv+0x6e>
  413a70:	085b      	lsrs	r3, r3, #1
  413a72:	ea4f 0232 	mov.w	r2, r2, rrx
  413a76:	1ab6      	subs	r6, r6, r2
  413a78:	eb65 0503 	sbc.w	r5, r5, r3
  413a7c:	085b      	lsrs	r3, r3, #1
  413a7e:	ea4f 0232 	mov.w	r2, r2, rrx
  413a82:	f44f 1080 	mov.w	r0, #1048576	; 0x100000
  413a86:	f44f 2c00 	mov.w	ip, #524288	; 0x80000
  413a8a:	ebb6 0e02 	subs.w	lr, r6, r2
  413a8e:	eb75 0e03 	sbcs.w	lr, r5, r3
  413a92:	bf22      	ittt	cs
  413a94:	1ab6      	subcs	r6, r6, r2
  413a96:	4675      	movcs	r5, lr
  413a98:	ea40 000c 	orrcs.w	r0, r0, ip
  413a9c:	085b      	lsrs	r3, r3, #1
  413a9e:	ea4f 0232 	mov.w	r2, r2, rrx
  413aa2:	ebb6 0e02 	subs.w	lr, r6, r2
  413aa6:	eb75 0e03 	sbcs.w	lr, r5, r3
  413aaa:	bf22      	ittt	cs
  413aac:	1ab6      	subcs	r6, r6, r2
  413aae:	4675      	movcs	r5, lr
  413ab0:	ea40 005c 	orrcs.w	r0, r0, ip, lsr #1
  413ab4:	085b      	lsrs	r3, r3, #1
  413ab6:	ea4f 0232 	mov.w	r2, r2, rrx
  413aba:	ebb6 0e02 	subs.w	lr, r6, r2
  413abe:	eb75 0e03 	sbcs.w	lr, r5, r3
  413ac2:	bf22      	ittt	cs
  413ac4:	1ab6      	subcs	r6, r6, r2
  413ac6:	4675      	movcs	r5, lr
  413ac8:	ea40 009c 	orrcs.w	r0, r0, ip, lsr #2
  413acc:	085b      	lsrs	r3, r3, #1
  413ace:	ea4f 0232 	mov.w	r2, r2, rrx
  413ad2:	ebb6 0e02 	subs.w	lr, r6, r2
  413ad6:	eb75 0e03 	sbcs.w	lr, r5, r3
  413ada:	bf22      	ittt	cs
  413adc:	1ab6      	subcs	r6, r6, r2
  413ade:	4675      	movcs	r5, lr
  413ae0:	ea40 00dc 	orrcs.w	r0, r0, ip, lsr #3
  413ae4:	ea55 0e06 	orrs.w	lr, r5, r6
  413ae8:	d018      	beq.n	413b1c <__aeabi_ddiv+0x114>
  413aea:	ea4f 1505 	mov.w	r5, r5, lsl #4
  413aee:	ea45 7516 	orr.w	r5, r5, r6, lsr #28
  413af2:	ea4f 1606 	mov.w	r6, r6, lsl #4
  413af6:	ea4f 03c3 	mov.w	r3, r3, lsl #3
  413afa:	ea43 7352 	orr.w	r3, r3, r2, lsr #29
  413afe:	ea4f 02c2 	mov.w	r2, r2, lsl #3
  413b02:	ea5f 1c1c 	movs.w	ip, ip, lsr #4
  413b06:	d1c0      	bne.n	413a8a <__aeabi_ddiv+0x82>
  413b08:	f411 1f80 	tst.w	r1, #1048576	; 0x100000
  413b0c:	d10b      	bne.n	413b26 <__aeabi_ddiv+0x11e>
  413b0e:	ea41 0100 	orr.w	r1, r1, r0
  413b12:	f04f 0000 	mov.w	r0, #0
  413b16:	f04f 4c00 	mov.w	ip, #2147483648	; 0x80000000
  413b1a:	e7b6      	b.n	413a8a <__aeabi_ddiv+0x82>
  413b1c:	f411 1f80 	tst.w	r1, #1048576	; 0x100000
  413b20:	bf04      	itt	eq
  413b22:	4301      	orreq	r1, r0
  413b24:	2000      	moveq	r0, #0
  413b26:	f1b4 0cfd 	subs.w	ip, r4, #253	; 0xfd
  413b2a:	bf88      	it	hi
  413b2c:	f5bc 6fe0 	cmphi.w	ip, #1792	; 0x700
  413b30:	f63f aeaf 	bhi.w	413892 <__aeabi_dmul+0xde>
  413b34:	ebb5 0c03 	subs.w	ip, r5, r3
  413b38:	bf04      	itt	eq
  413b3a:	ebb6 0c02 	subseq.w	ip, r6, r2
  413b3e:	ea5f 0c50 	movseq.w	ip, r0, lsr #1
  413b42:	f150 0000 	adcs.w	r0, r0, #0
  413b46:	eb41 5104 	adc.w	r1, r1, r4, lsl #20
  413b4a:	bd70      	pop	{r4, r5, r6, pc}
  413b4c:	f00e 4e00 	and.w	lr, lr, #2147483648	; 0x80000000
  413b50:	ea4e 3111 	orr.w	r1, lr, r1, lsr #12
  413b54:	eb14 045c 	adds.w	r4, r4, ip, lsr #1
  413b58:	bfc2      	ittt	gt
  413b5a:	ebd4 050c 	rsbsgt	r5, r4, ip
  413b5e:	ea41 5104 	orrgt.w	r1, r1, r4, lsl #20
  413b62:	bd70      	popgt	{r4, r5, r6, pc}
  413b64:	f441 1180 	orr.w	r1, r1, #1048576	; 0x100000
  413b68:	f04f 0e00 	mov.w	lr, #0
  413b6c:	3c01      	subs	r4, #1
  413b6e:	e690      	b.n	413892 <__aeabi_dmul+0xde>
  413b70:	ea45 0e06 	orr.w	lr, r5, r6
  413b74:	e68d      	b.n	413892 <__aeabi_dmul+0xde>
  413b76:	ea0c 5513 	and.w	r5, ip, r3, lsr #20
  413b7a:	ea94 0f0c 	teq	r4, ip
  413b7e:	bf08      	it	eq
  413b80:	ea95 0f0c 	teqeq	r5, ip
  413b84:	f43f af3b 	beq.w	4139fe <__aeabi_dmul+0x24a>
  413b88:	ea94 0f0c 	teq	r4, ip
  413b8c:	d10a      	bne.n	413ba4 <__aeabi_ddiv+0x19c>
  413b8e:	ea50 3401 	orrs.w	r4, r0, r1, lsl #12
  413b92:	f47f af34 	bne.w	4139fe <__aeabi_dmul+0x24a>
  413b96:	ea95 0f0c 	teq	r5, ip
  413b9a:	f47f af25 	bne.w	4139e8 <__aeabi_dmul+0x234>
  413b9e:	4610      	mov	r0, r2
  413ba0:	4619      	mov	r1, r3
  413ba2:	e72c      	b.n	4139fe <__aeabi_dmul+0x24a>
  413ba4:	ea95 0f0c 	teq	r5, ip
  413ba8:	d106      	bne.n	413bb8 <__aeabi_ddiv+0x1b0>
  413baa:	ea52 3503 	orrs.w	r5, r2, r3, lsl #12
  413bae:	f43f aefd 	beq.w	4139ac <__aeabi_dmul+0x1f8>
  413bb2:	4610      	mov	r0, r2
  413bb4:	4619      	mov	r1, r3
  413bb6:	e722      	b.n	4139fe <__aeabi_dmul+0x24a>
  413bb8:	ea50 0641 	orrs.w	r6, r0, r1, lsl #1
  413bbc:	bf18      	it	ne
  413bbe:	ea52 0643 	orrsne.w	r6, r2, r3, lsl #1
  413bc2:	f47f aec5 	bne.w	413950 <__aeabi_dmul+0x19c>
  413bc6:	ea50 0441 	orrs.w	r4, r0, r1, lsl #1
  413bca:	f47f af0d 	bne.w	4139e8 <__aeabi_dmul+0x234>
  413bce:	ea52 0543 	orrs.w	r5, r2, r3, lsl #1
  413bd2:	f47f aeeb 	bne.w	4139ac <__aeabi_dmul+0x1f8>
  413bd6:	e712      	b.n	4139fe <__aeabi_dmul+0x24a>

00413bd8 <__aeabi_d2f>:
  413bd8:	ea4f 0241 	mov.w	r2, r1, lsl #1
  413bdc:	f1b2 43e0 	subs.w	r3, r2, #1879048192	; 0x70000000
  413be0:	bf24      	itt	cs
  413be2:	f5b3 1c00 	subscs.w	ip, r3, #2097152	; 0x200000
  413be6:	f1dc 5cfe 	rsbscs	ip, ip, #532676608	; 0x1fc00000
  413bea:	d90d      	bls.n	413c08 <__aeabi_d2f+0x30>
  413bec:	f001 4c00 	and.w	ip, r1, #2147483648	; 0x80000000
  413bf0:	ea4f 02c0 	mov.w	r2, r0, lsl #3
  413bf4:	ea4c 7050 	orr.w	r0, ip, r0, lsr #29
  413bf8:	f1b2 4f00 	cmp.w	r2, #2147483648	; 0x80000000
  413bfc:	eb40 0083 	adc.w	r0, r0, r3, lsl #2
  413c00:	bf08      	it	eq
  413c02:	f020 0001 	biceq.w	r0, r0, #1
  413c06:	4770      	bx	lr
  413c08:	f011 4f80 	tst.w	r1, #1073741824	; 0x40000000
  413c0c:	d121      	bne.n	413c52 <__aeabi_d2f+0x7a>
  413c0e:	f113 7238 	adds.w	r2, r3, #48234496	; 0x2e00000
  413c12:	bfbc      	itt	lt
  413c14:	f001 4000 	andlt.w	r0, r1, #2147483648	; 0x80000000
  413c18:	4770      	bxlt	lr
  413c1a:	f441 1180 	orr.w	r1, r1, #1048576	; 0x100000
  413c1e:	ea4f 5252 	mov.w	r2, r2, lsr #21
  413c22:	f1c2 0218 	rsb	r2, r2, #24
  413c26:	f1c2 0c20 	rsb	ip, r2, #32
  413c2a:	fa10 f30c 	lsls.w	r3, r0, ip
  413c2e:	fa20 f002 	lsr.w	r0, r0, r2
  413c32:	bf18      	it	ne
  413c34:	f040 0001 	orrne.w	r0, r0, #1
  413c38:	ea4f 23c1 	mov.w	r3, r1, lsl #11
  413c3c:	ea4f 23d3 	mov.w	r3, r3, lsr #11
  413c40:	fa03 fc0c 	lsl.w	ip, r3, ip
  413c44:	ea40 000c 	orr.w	r0, r0, ip
  413c48:	fa23 f302 	lsr.w	r3, r3, r2
  413c4c:	ea4f 0343 	mov.w	r3, r3, lsl #1
  413c50:	e7cc      	b.n	413bec <__aeabi_d2f+0x14>
  413c52:	ea7f 5362 	mvns.w	r3, r2, asr #21
  413c56:	d107      	bne.n	413c68 <__aeabi_d2f+0x90>
  413c58:	ea50 3301 	orrs.w	r3, r0, r1, lsl #12
  413c5c:	bf1e      	ittt	ne
  413c5e:	f04f 40fe 	movne.w	r0, #2130706432	; 0x7f000000
  413c62:	f440 0040 	orrne.w	r0, r0, #12582912	; 0xc00000
  413c66:	4770      	bxne	lr
  413c68:	f001 4000 	and.w	r0, r1, #2147483648	; 0x80000000
  413c6c:	f040 40fe 	orr.w	r0, r0, #2130706432	; 0x7f000000
  413c70:	f440 0000 	orr.w	r0, r0, #8388608	; 0x800000
  413c74:	4770      	bx	lr
  413c76:	bf00      	nop

00413c78 <__aeabi_uldivmod>:
  413c78:	b953      	cbnz	r3, 413c90 <__aeabi_uldivmod+0x18>
  413c7a:	b94a      	cbnz	r2, 413c90 <__aeabi_uldivmod+0x18>
  413c7c:	2900      	cmp	r1, #0
  413c7e:	bf08      	it	eq
  413c80:	2800      	cmpeq	r0, #0
  413c82:	bf1c      	itt	ne
  413c84:	f04f 31ff 	movne.w	r1, #4294967295
  413c88:	f04f 30ff 	movne.w	r0, #4294967295
  413c8c:	f000 b97a 	b.w	413f84 <__aeabi_idiv0>
  413c90:	f1ad 0c08 	sub.w	ip, sp, #8
  413c94:	e96d ce04 	strd	ip, lr, [sp, #-16]!
  413c98:	f000 f806 	bl	413ca8 <__udivmoddi4>
  413c9c:	f8dd e004 	ldr.w	lr, [sp, #4]
  413ca0:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
  413ca4:	b004      	add	sp, #16
  413ca6:	4770      	bx	lr

00413ca8 <__udivmoddi4>:
  413ca8:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
  413cac:	468c      	mov	ip, r1
  413cae:	460d      	mov	r5, r1
  413cb0:	4604      	mov	r4, r0
  413cb2:	9e08      	ldr	r6, [sp, #32]
  413cb4:	2b00      	cmp	r3, #0
  413cb6:	d151      	bne.n	413d5c <__udivmoddi4+0xb4>
  413cb8:	428a      	cmp	r2, r1
  413cba:	4617      	mov	r7, r2
  413cbc:	d96d      	bls.n	413d9a <__udivmoddi4+0xf2>
  413cbe:	fab2 fe82 	clz	lr, r2
  413cc2:	f1be 0f00 	cmp.w	lr, #0
  413cc6:	d00b      	beq.n	413ce0 <__udivmoddi4+0x38>
  413cc8:	f1ce 0c20 	rsb	ip, lr, #32
  413ccc:	fa01 f50e 	lsl.w	r5, r1, lr
  413cd0:	fa20 fc0c 	lsr.w	ip, r0, ip
  413cd4:	fa02 f70e 	lsl.w	r7, r2, lr
  413cd8:	ea4c 0c05 	orr.w	ip, ip, r5
  413cdc:	fa00 f40e 	lsl.w	r4, r0, lr
  413ce0:	ea4f 4a17 	mov.w	sl, r7, lsr #16
  413ce4:	0c25      	lsrs	r5, r4, #16
  413ce6:	fbbc f8fa 	udiv	r8, ip, sl
  413cea:	fa1f f987 	uxth.w	r9, r7
  413cee:	fb0a cc18 	mls	ip, sl, r8, ip
  413cf2:	ea45 450c 	orr.w	r5, r5, ip, lsl #16
  413cf6:	fb08 f309 	mul.w	r3, r8, r9
  413cfa:	42ab      	cmp	r3, r5
  413cfc:	d90a      	bls.n	413d14 <__udivmoddi4+0x6c>
  413cfe:	19ed      	adds	r5, r5, r7
  413d00:	f108 32ff 	add.w	r2, r8, #4294967295
  413d04:	f080 8123 	bcs.w	413f4e <__udivmoddi4+0x2a6>
  413d08:	42ab      	cmp	r3, r5
  413d0a:	f240 8120 	bls.w	413f4e <__udivmoddi4+0x2a6>
  413d0e:	f1a8 0802 	sub.w	r8, r8, #2
  413d12:	443d      	add	r5, r7
  413d14:	1aed      	subs	r5, r5, r3
  413d16:	b2a4      	uxth	r4, r4
  413d18:	fbb5 f0fa 	udiv	r0, r5, sl
  413d1c:	fb0a 5510 	mls	r5, sl, r0, r5
  413d20:	ea44 4405 	orr.w	r4, r4, r5, lsl #16
  413d24:	fb00 f909 	mul.w	r9, r0, r9
  413d28:	45a1      	cmp	r9, r4
  413d2a:	d909      	bls.n	413d40 <__udivmoddi4+0x98>
  413d2c:	19e4      	adds	r4, r4, r7
  413d2e:	f100 33ff 	add.w	r3, r0, #4294967295
  413d32:	f080 810a 	bcs.w	413f4a <__udivmoddi4+0x2a2>
  413d36:	45a1      	cmp	r9, r4
  413d38:	f240 8107 	bls.w	413f4a <__udivmoddi4+0x2a2>
  413d3c:	3802      	subs	r0, #2
  413d3e:	443c      	add	r4, r7
  413d40:	eba4 0409 	sub.w	r4, r4, r9
  413d44:	ea40 4008 	orr.w	r0, r0, r8, lsl #16
  413d48:	2100      	movs	r1, #0
  413d4a:	2e00      	cmp	r6, #0
  413d4c:	d061      	beq.n	413e12 <__udivmoddi4+0x16a>
  413d4e:	fa24 f40e 	lsr.w	r4, r4, lr
  413d52:	2300      	movs	r3, #0
  413d54:	6034      	str	r4, [r6, #0]
  413d56:	6073      	str	r3, [r6, #4]
  413d58:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
  413d5c:	428b      	cmp	r3, r1
  413d5e:	d907      	bls.n	413d70 <__udivmoddi4+0xc8>
  413d60:	2e00      	cmp	r6, #0
  413d62:	d054      	beq.n	413e0e <__udivmoddi4+0x166>
  413d64:	2100      	movs	r1, #0
  413d66:	e886 0021 	stmia.w	r6, {r0, r5}
  413d6a:	4608      	mov	r0, r1
  413d6c:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
  413d70:	fab3 f183 	clz	r1, r3
  413d74:	2900      	cmp	r1, #0
  413d76:	f040 808e 	bne.w	413e96 <__udivmoddi4+0x1ee>
  413d7a:	42ab      	cmp	r3, r5
  413d7c:	d302      	bcc.n	413d84 <__udivmoddi4+0xdc>
  413d7e:	4282      	cmp	r2, r0
  413d80:	f200 80fa 	bhi.w	413f78 <__udivmoddi4+0x2d0>
  413d84:	1a84      	subs	r4, r0, r2
  413d86:	eb65 0503 	sbc.w	r5, r5, r3
  413d8a:	2001      	movs	r0, #1
  413d8c:	46ac      	mov	ip, r5
  413d8e:	2e00      	cmp	r6, #0
  413d90:	d03f      	beq.n	413e12 <__udivmoddi4+0x16a>
  413d92:	e886 1010 	stmia.w	r6, {r4, ip}
  413d96:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
  413d9a:	b912      	cbnz	r2, 413da2 <__udivmoddi4+0xfa>
  413d9c:	2701      	movs	r7, #1
  413d9e:	fbb7 f7f2 	udiv	r7, r7, r2
  413da2:	fab7 fe87 	clz	lr, r7
  413da6:	f1be 0f00 	cmp.w	lr, #0
  413daa:	d134      	bne.n	413e16 <__udivmoddi4+0x16e>
  413dac:	1beb      	subs	r3, r5, r7
  413dae:	0c3a      	lsrs	r2, r7, #16
  413db0:	fa1f fc87 	uxth.w	ip, r7
  413db4:	2101      	movs	r1, #1
  413db6:	fbb3 f8f2 	udiv	r8, r3, r2
  413dba:	0c25      	lsrs	r5, r4, #16
  413dbc:	fb02 3318 	mls	r3, r2, r8, r3
  413dc0:	ea45 4503 	orr.w	r5, r5, r3, lsl #16
  413dc4:	fb0c f308 	mul.w	r3, ip, r8
  413dc8:	42ab      	cmp	r3, r5
  413dca:	d907      	bls.n	413ddc <__udivmoddi4+0x134>
  413dcc:	19ed      	adds	r5, r5, r7
  413dce:	f108 30ff 	add.w	r0, r8, #4294967295
  413dd2:	d202      	bcs.n	413dda <__udivmoddi4+0x132>
  413dd4:	42ab      	cmp	r3, r5
  413dd6:	f200 80d1 	bhi.w	413f7c <__udivmoddi4+0x2d4>
  413dda:	4680      	mov	r8, r0
  413ddc:	1aed      	subs	r5, r5, r3
  413dde:	b2a3      	uxth	r3, r4
  413de0:	fbb5 f0f2 	udiv	r0, r5, r2
  413de4:	fb02 5510 	mls	r5, r2, r0, r5
  413de8:	ea43 4405 	orr.w	r4, r3, r5, lsl #16
  413dec:	fb0c fc00 	mul.w	ip, ip, r0
  413df0:	45a4      	cmp	ip, r4
  413df2:	d907      	bls.n	413e04 <__udivmoddi4+0x15c>
  413df4:	19e4      	adds	r4, r4, r7
  413df6:	f100 33ff 	add.w	r3, r0, #4294967295
  413dfa:	d202      	bcs.n	413e02 <__udivmoddi4+0x15a>
  413dfc:	45a4      	cmp	ip, r4
  413dfe:	f200 80b8 	bhi.w	413f72 <__udivmoddi4+0x2ca>
  413e02:	4618      	mov	r0, r3
  413e04:	eba4 040c 	sub.w	r4, r4, ip
  413e08:	ea40 4008 	orr.w	r0, r0, r8, lsl #16
  413e0c:	e79d      	b.n	413d4a <__udivmoddi4+0xa2>
  413e0e:	4631      	mov	r1, r6
  413e10:	4630      	mov	r0, r6
  413e12:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
  413e16:	f1ce 0420 	rsb	r4, lr, #32
  413e1a:	fa05 f30e 	lsl.w	r3, r5, lr
  413e1e:	fa07 f70e 	lsl.w	r7, r7, lr
  413e22:	fa20 f804 	lsr.w	r8, r0, r4
  413e26:	0c3a      	lsrs	r2, r7, #16
  413e28:	fa25 f404 	lsr.w	r4, r5, r4
  413e2c:	ea48 0803 	orr.w	r8, r8, r3
  413e30:	fbb4 f1f2 	udiv	r1, r4, r2
  413e34:	ea4f 4518 	mov.w	r5, r8, lsr #16
  413e38:	fb02 4411 	mls	r4, r2, r1, r4
  413e3c:	fa1f fc87 	uxth.w	ip, r7
  413e40:	ea45 4504 	orr.w	r5, r5, r4, lsl #16
  413e44:	fb01 f30c 	mul.w	r3, r1, ip
  413e48:	42ab      	cmp	r3, r5
  413e4a:	fa00 f40e 	lsl.w	r4, r0, lr
  413e4e:	d909      	bls.n	413e64 <__udivmoddi4+0x1bc>
  413e50:	19ed      	adds	r5, r5, r7
  413e52:	f101 30ff 	add.w	r0, r1, #4294967295
  413e56:	f080 808a 	bcs.w	413f6e <__udivmoddi4+0x2c6>
  413e5a:	42ab      	cmp	r3, r5
  413e5c:	f240 8087 	bls.w	413f6e <__udivmoddi4+0x2c6>
  413e60:	3902      	subs	r1, #2
  413e62:	443d      	add	r5, r7
  413e64:	1aeb      	subs	r3, r5, r3
  413e66:	fa1f f588 	uxth.w	r5, r8
  413e6a:	fbb3 f0f2 	udiv	r0, r3, r2
  413e6e:	fb02 3310 	mls	r3, r2, r0, r3
  413e72:	ea45 4503 	orr.w	r5, r5, r3, lsl #16
  413e76:	fb00 f30c 	mul.w	r3, r0, ip
  413e7a:	42ab      	cmp	r3, r5
  413e7c:	d907      	bls.n	413e8e <__udivmoddi4+0x1e6>
  413e7e:	19ed      	adds	r5, r5, r7
  413e80:	f100 38ff 	add.w	r8, r0, #4294967295
  413e84:	d26f      	bcs.n	413f66 <__udivmoddi4+0x2be>
  413e86:	42ab      	cmp	r3, r5
  413e88:	d96d      	bls.n	413f66 <__udivmoddi4+0x2be>
  413e8a:	3802      	subs	r0, #2
  413e8c:	443d      	add	r5, r7
  413e8e:	1aeb      	subs	r3, r5, r3
  413e90:	ea40 4101 	orr.w	r1, r0, r1, lsl #16
  413e94:	e78f      	b.n	413db6 <__udivmoddi4+0x10e>
  413e96:	f1c1 0720 	rsb	r7, r1, #32
  413e9a:	fa22 f807 	lsr.w	r8, r2, r7
  413e9e:	408b      	lsls	r3, r1
  413ea0:	fa05 f401 	lsl.w	r4, r5, r1
  413ea4:	ea48 0303 	orr.w	r3, r8, r3
  413ea8:	fa20 fe07 	lsr.w	lr, r0, r7
  413eac:	ea4f 4c13 	mov.w	ip, r3, lsr #16
  413eb0:	40fd      	lsrs	r5, r7
  413eb2:	ea4e 0e04 	orr.w	lr, lr, r4
  413eb6:	fbb5 f9fc 	udiv	r9, r5, ip
  413eba:	ea4f 441e 	mov.w	r4, lr, lsr #16
  413ebe:	fb0c 5519 	mls	r5, ip, r9, r5
  413ec2:	fa1f f883 	uxth.w	r8, r3
  413ec6:	ea44 4505 	orr.w	r5, r4, r5, lsl #16
  413eca:	fb09 f408 	mul.w	r4, r9, r8
  413ece:	42ac      	cmp	r4, r5
  413ed0:	fa02 f201 	lsl.w	r2, r2, r1
  413ed4:	fa00 fa01 	lsl.w	sl, r0, r1
  413ed8:	d908      	bls.n	413eec <__udivmoddi4+0x244>
  413eda:	18ed      	adds	r5, r5, r3
  413edc:	f109 30ff 	add.w	r0, r9, #4294967295
  413ee0:	d243      	bcs.n	413f6a <__udivmoddi4+0x2c2>
  413ee2:	42ac      	cmp	r4, r5
  413ee4:	d941      	bls.n	413f6a <__udivmoddi4+0x2c2>
  413ee6:	f1a9 0902 	sub.w	r9, r9, #2
  413eea:	441d      	add	r5, r3
  413eec:	1b2d      	subs	r5, r5, r4
  413eee:	fa1f fe8e 	uxth.w	lr, lr
  413ef2:	fbb5 f0fc 	udiv	r0, r5, ip
  413ef6:	fb0c 5510 	mls	r5, ip, r0, r5
  413efa:	ea4e 4405 	orr.w	r4, lr, r5, lsl #16
  413efe:	fb00 f808 	mul.w	r8, r0, r8
  413f02:	45a0      	cmp	r8, r4
  413f04:	d907      	bls.n	413f16 <__udivmoddi4+0x26e>
  413f06:	18e4      	adds	r4, r4, r3
  413f08:	f100 35ff 	add.w	r5, r0, #4294967295
  413f0c:	d229      	bcs.n	413f62 <__udivmoddi4+0x2ba>
  413f0e:	45a0      	cmp	r8, r4
  413f10:	d927      	bls.n	413f62 <__udivmoddi4+0x2ba>
  413f12:	3802      	subs	r0, #2
  413f14:	441c      	add	r4, r3
  413f16:	ea40 4009 	orr.w	r0, r0, r9, lsl #16
  413f1a:	eba4 0408 	sub.w	r4, r4, r8
  413f1e:	fba0 8902 	umull	r8, r9, r0, r2
  413f22:	454c      	cmp	r4, r9
  413f24:	46c6      	mov	lr, r8
  413f26:	464d      	mov	r5, r9
  413f28:	d315      	bcc.n	413f56 <__udivmoddi4+0x2ae>
  413f2a:	d012      	beq.n	413f52 <__udivmoddi4+0x2aa>
  413f2c:	b156      	cbz	r6, 413f44 <__udivmoddi4+0x29c>
  413f2e:	ebba 030e 	subs.w	r3, sl, lr
  413f32:	eb64 0405 	sbc.w	r4, r4, r5
  413f36:	fa04 f707 	lsl.w	r7, r4, r7
  413f3a:	40cb      	lsrs	r3, r1
  413f3c:	431f      	orrs	r7, r3
  413f3e:	40cc      	lsrs	r4, r1
  413f40:	6037      	str	r7, [r6, #0]
  413f42:	6074      	str	r4, [r6, #4]
  413f44:	2100      	movs	r1, #0
  413f46:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
  413f4a:	4618      	mov	r0, r3
  413f4c:	e6f8      	b.n	413d40 <__udivmoddi4+0x98>
  413f4e:	4690      	mov	r8, r2
  413f50:	e6e0      	b.n	413d14 <__udivmoddi4+0x6c>
  413f52:	45c2      	cmp	sl, r8
  413f54:	d2ea      	bcs.n	413f2c <__udivmoddi4+0x284>
  413f56:	ebb8 0e02 	subs.w	lr, r8, r2
  413f5a:	eb69 0503 	sbc.w	r5, r9, r3
  413f5e:	3801      	subs	r0, #1
  413f60:	e7e4      	b.n	413f2c <__udivmoddi4+0x284>
  413f62:	4628      	mov	r0, r5
  413f64:	e7d7      	b.n	413f16 <__udivmoddi4+0x26e>
  413f66:	4640      	mov	r0, r8
  413f68:	e791      	b.n	413e8e <__udivmoddi4+0x1e6>
  413f6a:	4681      	mov	r9, r0
  413f6c:	e7be      	b.n	413eec <__udivmoddi4+0x244>
  413f6e:	4601      	mov	r1, r0
  413f70:	e778      	b.n	413e64 <__udivmoddi4+0x1bc>
  413f72:	3802      	subs	r0, #2
  413f74:	443c      	add	r4, r7
  413f76:	e745      	b.n	413e04 <__udivmoddi4+0x15c>
  413f78:	4608      	mov	r0, r1
  413f7a:	e708      	b.n	413d8e <__udivmoddi4+0xe6>
  413f7c:	f1a8 0802 	sub.w	r8, r8, #2
  413f80:	443d      	add	r5, r7
  413f82:	e72b      	b.n	413ddc <__udivmoddi4+0x134>

00413f84 <__aeabi_idiv0>:
  413f84:	4770      	bx	lr
  413f86:	bf00      	nop

00413f88 <__errno>:
  413f88:	4b01      	ldr	r3, [pc, #4]	; (413f90 <__errno+0x8>)
  413f8a:	6818      	ldr	r0, [r3, #0]
  413f8c:	4770      	bx	lr
  413f8e:	bf00      	nop
  413f90:	20000358 	.word	0x20000358

00413f94 <__libc_init_array>:
  413f94:	b570      	push	{r4, r5, r6, lr}
  413f96:	4e0f      	ldr	r6, [pc, #60]	; (413fd4 <__libc_init_array+0x40>)
  413f98:	4d0f      	ldr	r5, [pc, #60]	; (413fd8 <__libc_init_array+0x44>)
  413f9a:	1b76      	subs	r6, r6, r5
  413f9c:	10b6      	asrs	r6, r6, #2
  413f9e:	bf18      	it	ne
  413fa0:	2400      	movne	r4, #0
  413fa2:	d005      	beq.n	413fb0 <__libc_init_array+0x1c>
  413fa4:	3401      	adds	r4, #1
  413fa6:	f855 3b04 	ldr.w	r3, [r5], #4
  413faa:	4798      	blx	r3
  413fac:	42a6      	cmp	r6, r4
  413fae:	d1f9      	bne.n	413fa4 <__libc_init_array+0x10>
  413fb0:	4e0a      	ldr	r6, [pc, #40]	; (413fdc <__libc_init_array+0x48>)
  413fb2:	4d0b      	ldr	r5, [pc, #44]	; (413fe0 <__libc_init_array+0x4c>)
  413fb4:	1b76      	subs	r6, r6, r5
  413fb6:	f009 fc7b 	bl	41d8b0 <_init>
  413fba:	10b6      	asrs	r6, r6, #2
  413fbc:	bf18      	it	ne
  413fbe:	2400      	movne	r4, #0
  413fc0:	d006      	beq.n	413fd0 <__libc_init_array+0x3c>
  413fc2:	3401      	adds	r4, #1
  413fc4:	f855 3b04 	ldr.w	r3, [r5], #4
  413fc8:	4798      	blx	r3
  413fca:	42a6      	cmp	r6, r4
  413fcc:	d1f9      	bne.n	413fc2 <__libc_init_array+0x2e>
  413fce:	bd70      	pop	{r4, r5, r6, pc}
  413fd0:	bd70      	pop	{r4, r5, r6, pc}
  413fd2:	bf00      	nop
  413fd4:	0041d8bc 	.word	0x0041d8bc
  413fd8:	0041d8bc 	.word	0x0041d8bc
  413fdc:	0041d8c4 	.word	0x0041d8c4
  413fe0:	0041d8bc 	.word	0x0041d8bc

00413fe4 <memcmp>:
  413fe4:	2a03      	cmp	r2, #3
  413fe6:	b470      	push	{r4, r5, r6}
  413fe8:	d922      	bls.n	414030 <memcmp+0x4c>
  413fea:	ea40 0301 	orr.w	r3, r0, r1
  413fee:	079b      	lsls	r3, r3, #30
  413ff0:	d011      	beq.n	414016 <memcmp+0x32>
  413ff2:	7803      	ldrb	r3, [r0, #0]
  413ff4:	780c      	ldrb	r4, [r1, #0]
  413ff6:	42a3      	cmp	r3, r4
  413ff8:	d11d      	bne.n	414036 <memcmp+0x52>
  413ffa:	440a      	add	r2, r1
  413ffc:	3101      	adds	r1, #1
  413ffe:	e005      	b.n	41400c <memcmp+0x28>
  414000:	f810 3f01 	ldrb.w	r3, [r0, #1]!
  414004:	f811 4b01 	ldrb.w	r4, [r1], #1
  414008:	42a3      	cmp	r3, r4
  41400a:	d114      	bne.n	414036 <memcmp+0x52>
  41400c:	4291      	cmp	r1, r2
  41400e:	d1f7      	bne.n	414000 <memcmp+0x1c>
  414010:	2000      	movs	r0, #0
  414012:	bc70      	pop	{r4, r5, r6}
  414014:	4770      	bx	lr
  414016:	680d      	ldr	r5, [r1, #0]
  414018:	6806      	ldr	r6, [r0, #0]
  41401a:	42ae      	cmp	r6, r5
  41401c:	460c      	mov	r4, r1
  41401e:	4603      	mov	r3, r0
  414020:	f101 0104 	add.w	r1, r1, #4
  414024:	f100 0004 	add.w	r0, r0, #4
  414028:	d108      	bne.n	41403c <memcmp+0x58>
  41402a:	3a04      	subs	r2, #4
  41402c:	2a03      	cmp	r2, #3
  41402e:	d8f2      	bhi.n	414016 <memcmp+0x32>
  414030:	2a00      	cmp	r2, #0
  414032:	d1de      	bne.n	413ff2 <memcmp+0xe>
  414034:	e7ec      	b.n	414010 <memcmp+0x2c>
  414036:	1b18      	subs	r0, r3, r4
  414038:	bc70      	pop	{r4, r5, r6}
  41403a:	4770      	bx	lr
  41403c:	4621      	mov	r1, r4
  41403e:	4618      	mov	r0, r3
  414040:	e7d7      	b.n	413ff2 <memcmp+0xe>
  414042:	bf00      	nop

00414044 <memcpy>:
  414044:	4684      	mov	ip, r0
  414046:	ea41 0300 	orr.w	r3, r1, r0
  41404a:	f013 0303 	ands.w	r3, r3, #3
  41404e:	d16d      	bne.n	41412c <memcpy+0xe8>
  414050:	3a40      	subs	r2, #64	; 0x40
  414052:	d341      	bcc.n	4140d8 <memcpy+0x94>
  414054:	f851 3b04 	ldr.w	r3, [r1], #4
  414058:	f840 3b04 	str.w	r3, [r0], #4
  41405c:	f851 3b04 	ldr.w	r3, [r1], #4
  414060:	f840 3b04 	str.w	r3, [r0], #4
  414064:	f851 3b04 	ldr.w	r3, [r1], #4
  414068:	f840 3b04 	str.w	r3, [r0], #4
  41406c:	f851 3b04 	ldr.w	r3, [r1], #4
  414070:	f840 3b04 	str.w	r3, [r0], #4
  414074:	f851 3b04 	ldr.w	r3, [r1], #4
  414078:	f840 3b04 	str.w	r3, [r0], #4
  41407c:	f851 3b04 	ldr.w	r3, [r1], #4
  414080:	f840 3b04 	str.w	r3, [r0], #4
  414084:	f851 3b04 	ldr.w	r3, [r1], #4
  414088:	f840 3b04 	str.w	r3, [r0], #4
  41408c:	f851 3b04 	ldr.w	r3, [r1], #4
  414090:	f840 3b04 	str.w	r3, [r0], #4
  414094:	f851 3b04 	ldr.w	r3, [r1], #4
  414098:	f840 3b04 	str.w	r3, [r0], #4
  41409c:	f851 3b04 	ldr.w	r3, [r1], #4
  4140a0:	f840 3b04 	str.w	r3, [r0], #4
  4140a4:	f851 3b04 	ldr.w	r3, [r1], #4
  4140a8:	f840 3b04 	str.w	r3, [r0], #4
  4140ac:	f851 3b04 	ldr.w	r3, [r1], #4
  4140b0:	f840 3b04 	str.w	r3, [r0], #4
  4140b4:	f851 3b04 	ldr.w	r3, [r1], #4
  4140b8:	f840 3b04 	str.w	r3, [r0], #4
  4140bc:	f851 3b04 	ldr.w	r3, [r1], #4
  4140c0:	f840 3b04 	str.w	r3, [r0], #4
  4140c4:	f851 3b04 	ldr.w	r3, [r1], #4
  4140c8:	f840 3b04 	str.w	r3, [r0], #4
  4140cc:	f851 3b04 	ldr.w	r3, [r1], #4
  4140d0:	f840 3b04 	str.w	r3, [r0], #4
  4140d4:	3a40      	subs	r2, #64	; 0x40
  4140d6:	d2bd      	bcs.n	414054 <memcpy+0x10>
  4140d8:	3230      	adds	r2, #48	; 0x30
  4140da:	d311      	bcc.n	414100 <memcpy+0xbc>
  4140dc:	f851 3b04 	ldr.w	r3, [r1], #4
  4140e0:	f840 3b04 	str.w	r3, [r0], #4
  4140e4:	f851 3b04 	ldr.w	r3, [r1], #4
  4140e8:	f840 3b04 	str.w	r3, [r0], #4
  4140ec:	f851 3b04 	ldr.w	r3, [r1], #4
  4140f0:	f840 3b04 	str.w	r3, [r0], #4
  4140f4:	f851 3b04 	ldr.w	r3, [r1], #4
  4140f8:	f840 3b04 	str.w	r3, [r0], #4
  4140fc:	3a10      	subs	r2, #16
  4140fe:	d2ed      	bcs.n	4140dc <memcpy+0x98>
  414100:	320c      	adds	r2, #12
  414102:	d305      	bcc.n	414110 <memcpy+0xcc>
  414104:	f851 3b04 	ldr.w	r3, [r1], #4
  414108:	f840 3b04 	str.w	r3, [r0], #4
  41410c:	3a04      	subs	r2, #4
  41410e:	d2f9      	bcs.n	414104 <memcpy+0xc0>
  414110:	3204      	adds	r2, #4
  414112:	d008      	beq.n	414126 <memcpy+0xe2>
  414114:	07d2      	lsls	r2, r2, #31
  414116:	bf1c      	itt	ne
  414118:	f811 3b01 	ldrbne.w	r3, [r1], #1
  41411c:	f800 3b01 	strbne.w	r3, [r0], #1
  414120:	d301      	bcc.n	414126 <memcpy+0xe2>
  414122:	880b      	ldrh	r3, [r1, #0]
  414124:	8003      	strh	r3, [r0, #0]
  414126:	4660      	mov	r0, ip
  414128:	4770      	bx	lr
  41412a:	bf00      	nop
  41412c:	2a08      	cmp	r2, #8
  41412e:	d313      	bcc.n	414158 <memcpy+0x114>
  414130:	078b      	lsls	r3, r1, #30
  414132:	d08d      	beq.n	414050 <memcpy+0xc>
  414134:	f010 0303 	ands.w	r3, r0, #3
  414138:	d08a      	beq.n	414050 <memcpy+0xc>
  41413a:	f1c3 0304 	rsb	r3, r3, #4
  41413e:	1ad2      	subs	r2, r2, r3
  414140:	07db      	lsls	r3, r3, #31
  414142:	bf1c      	itt	ne
  414144:	f811 3b01 	ldrbne.w	r3, [r1], #1
  414148:	f800 3b01 	strbne.w	r3, [r0], #1
  41414c:	d380      	bcc.n	414050 <memcpy+0xc>
  41414e:	f831 3b02 	ldrh.w	r3, [r1], #2
  414152:	f820 3b02 	strh.w	r3, [r0], #2
  414156:	e77b      	b.n	414050 <memcpy+0xc>
  414158:	3a04      	subs	r2, #4
  41415a:	d3d9      	bcc.n	414110 <memcpy+0xcc>
  41415c:	3a01      	subs	r2, #1
  41415e:	f811 3b01 	ldrb.w	r3, [r1], #1
  414162:	f800 3b01 	strb.w	r3, [r0], #1
  414166:	d2f9      	bcs.n	41415c <memcpy+0x118>
  414168:	780b      	ldrb	r3, [r1, #0]
  41416a:	7003      	strb	r3, [r0, #0]
  41416c:	784b      	ldrb	r3, [r1, #1]
  41416e:	7043      	strb	r3, [r0, #1]
  414170:	788b      	ldrb	r3, [r1, #2]
  414172:	7083      	strb	r3, [r0, #2]
  414174:	4660      	mov	r0, ip
  414176:	4770      	bx	lr

00414178 <memmove>:
  414178:	4288      	cmp	r0, r1
  41417a:	b5f0      	push	{r4, r5, r6, r7, lr}
  41417c:	d90d      	bls.n	41419a <memmove+0x22>
  41417e:	188b      	adds	r3, r1, r2
  414180:	4298      	cmp	r0, r3
  414182:	d20a      	bcs.n	41419a <memmove+0x22>
  414184:	1884      	adds	r4, r0, r2
  414186:	2a00      	cmp	r2, #0
  414188:	d051      	beq.n	41422e <memmove+0xb6>
  41418a:	4622      	mov	r2, r4
  41418c:	f813 4d01 	ldrb.w	r4, [r3, #-1]!
  414190:	f802 4d01 	strb.w	r4, [r2, #-1]!
  414194:	4299      	cmp	r1, r3
  414196:	d1f9      	bne.n	41418c <memmove+0x14>
  414198:	bdf0      	pop	{r4, r5, r6, r7, pc}
  41419a:	2a0f      	cmp	r2, #15
  41419c:	d948      	bls.n	414230 <memmove+0xb8>
  41419e:	ea41 0300 	orr.w	r3, r1, r0
  4141a2:	079b      	lsls	r3, r3, #30
  4141a4:	d146      	bne.n	414234 <memmove+0xbc>
  4141a6:	f100 0410 	add.w	r4, r0, #16
  4141aa:	f101 0310 	add.w	r3, r1, #16
  4141ae:	4615      	mov	r5, r2
  4141b0:	f853 6c10 	ldr.w	r6, [r3, #-16]
  4141b4:	f844 6c10 	str.w	r6, [r4, #-16]
  4141b8:	f853 6c0c 	ldr.w	r6, [r3, #-12]
  4141bc:	f844 6c0c 	str.w	r6, [r4, #-12]
  4141c0:	f853 6c08 	ldr.w	r6, [r3, #-8]
  4141c4:	f844 6c08 	str.w	r6, [r4, #-8]
  4141c8:	3d10      	subs	r5, #16
  4141ca:	f853 6c04 	ldr.w	r6, [r3, #-4]
  4141ce:	f844 6c04 	str.w	r6, [r4, #-4]
  4141d2:	2d0f      	cmp	r5, #15
  4141d4:	f103 0310 	add.w	r3, r3, #16
  4141d8:	f104 0410 	add.w	r4, r4, #16
  4141dc:	d8e8      	bhi.n	4141b0 <memmove+0x38>
  4141de:	f1a2 0310 	sub.w	r3, r2, #16
  4141e2:	f023 030f 	bic.w	r3, r3, #15
  4141e6:	f002 0e0f 	and.w	lr, r2, #15
  4141ea:	3310      	adds	r3, #16
  4141ec:	f1be 0f03 	cmp.w	lr, #3
  4141f0:	4419      	add	r1, r3
  4141f2:	4403      	add	r3, r0
  4141f4:	d921      	bls.n	41423a <memmove+0xc2>
  4141f6:	1f1e      	subs	r6, r3, #4
  4141f8:	460d      	mov	r5, r1
  4141fa:	4674      	mov	r4, lr
  4141fc:	3c04      	subs	r4, #4
  4141fe:	f855 7b04 	ldr.w	r7, [r5], #4
  414202:	f846 7f04 	str.w	r7, [r6, #4]!
  414206:	2c03      	cmp	r4, #3
  414208:	d8f8      	bhi.n	4141fc <memmove+0x84>
  41420a:	f1ae 0404 	sub.w	r4, lr, #4
  41420e:	f024 0403 	bic.w	r4, r4, #3
  414212:	3404      	adds	r4, #4
  414214:	4421      	add	r1, r4
  414216:	4423      	add	r3, r4
  414218:	f002 0203 	and.w	r2, r2, #3
  41421c:	b162      	cbz	r2, 414238 <memmove+0xc0>
  41421e:	3b01      	subs	r3, #1
  414220:	440a      	add	r2, r1
  414222:	f811 4b01 	ldrb.w	r4, [r1], #1
  414226:	f803 4f01 	strb.w	r4, [r3, #1]!
  41422a:	428a      	cmp	r2, r1
  41422c:	d1f9      	bne.n	414222 <memmove+0xaa>
  41422e:	bdf0      	pop	{r4, r5, r6, r7, pc}
  414230:	4603      	mov	r3, r0
  414232:	e7f3      	b.n	41421c <memmove+0xa4>
  414234:	4603      	mov	r3, r0
  414236:	e7f2      	b.n	41421e <memmove+0xa6>
  414238:	bdf0      	pop	{r4, r5, r6, r7, pc}
  41423a:	4672      	mov	r2, lr
  41423c:	e7ee      	b.n	41421c <memmove+0xa4>
  41423e:	bf00      	nop

00414240 <memset>:
  414240:	b470      	push	{r4, r5, r6}
  414242:	0786      	lsls	r6, r0, #30
  414244:	d046      	beq.n	4142d4 <memset+0x94>
  414246:	1e54      	subs	r4, r2, #1
  414248:	2a00      	cmp	r2, #0
  41424a:	d041      	beq.n	4142d0 <memset+0x90>
  41424c:	b2ca      	uxtb	r2, r1
  41424e:	4603      	mov	r3, r0
  414250:	e002      	b.n	414258 <memset+0x18>
  414252:	f114 34ff 	adds.w	r4, r4, #4294967295
  414256:	d33b      	bcc.n	4142d0 <memset+0x90>
  414258:	f803 2b01 	strb.w	r2, [r3], #1
  41425c:	079d      	lsls	r5, r3, #30
  41425e:	d1f8      	bne.n	414252 <memset+0x12>
  414260:	2c03      	cmp	r4, #3
  414262:	d92e      	bls.n	4142c2 <memset+0x82>
  414264:	b2cd      	uxtb	r5, r1
  414266:	ea45 2505 	orr.w	r5, r5, r5, lsl #8
  41426a:	2c0f      	cmp	r4, #15
  41426c:	ea45 4505 	orr.w	r5, r5, r5, lsl #16
  414270:	d919      	bls.n	4142a6 <memset+0x66>
  414272:	f103 0210 	add.w	r2, r3, #16
  414276:	4626      	mov	r6, r4
  414278:	3e10      	subs	r6, #16
  41427a:	2e0f      	cmp	r6, #15
  41427c:	f842 5c10 	str.w	r5, [r2, #-16]
  414280:	f842 5c0c 	str.w	r5, [r2, #-12]
  414284:	f842 5c08 	str.w	r5, [r2, #-8]
  414288:	f842 5c04 	str.w	r5, [r2, #-4]
  41428c:	f102 0210 	add.w	r2, r2, #16
  414290:	d8f2      	bhi.n	414278 <memset+0x38>
  414292:	f1a4 0210 	sub.w	r2, r4, #16
  414296:	f022 020f 	bic.w	r2, r2, #15
  41429a:	f004 040f 	and.w	r4, r4, #15
  41429e:	3210      	adds	r2, #16
  4142a0:	2c03      	cmp	r4, #3
  4142a2:	4413      	add	r3, r2
  4142a4:	d90d      	bls.n	4142c2 <memset+0x82>
  4142a6:	461e      	mov	r6, r3
  4142a8:	4622      	mov	r2, r4
  4142aa:	3a04      	subs	r2, #4
  4142ac:	2a03      	cmp	r2, #3
  4142ae:	f846 5b04 	str.w	r5, [r6], #4
  4142b2:	d8fa      	bhi.n	4142aa <memset+0x6a>
  4142b4:	1f22      	subs	r2, r4, #4
  4142b6:	f022 0203 	bic.w	r2, r2, #3
  4142ba:	3204      	adds	r2, #4
  4142bc:	4413      	add	r3, r2
  4142be:	f004 0403 	and.w	r4, r4, #3
  4142c2:	b12c      	cbz	r4, 4142d0 <memset+0x90>
  4142c4:	b2c9      	uxtb	r1, r1
  4142c6:	441c      	add	r4, r3
  4142c8:	f803 1b01 	strb.w	r1, [r3], #1
  4142cc:	429c      	cmp	r4, r3
  4142ce:	d1fb      	bne.n	4142c8 <memset+0x88>
  4142d0:	bc70      	pop	{r4, r5, r6}
  4142d2:	4770      	bx	lr
  4142d4:	4614      	mov	r4, r2
  4142d6:	4603      	mov	r3, r0
  4142d8:	e7c2      	b.n	414260 <memset+0x20>
  4142da:	bf00      	nop

004142dc <snprintf>:
  4142dc:	b40c      	push	{r2, r3}
  4142de:	b5f0      	push	{r4, r5, r6, r7, lr}
  4142e0:	4b23      	ldr	r3, [pc, #140]	; (414370 <snprintf+0x94>)
  4142e2:	1e0c      	subs	r4, r1, #0
  4142e4:	b09d      	sub	sp, #116	; 0x74
  4142e6:	681d      	ldr	r5, [r3, #0]
  4142e8:	db3d      	blt.n	414366 <snprintf+0x8a>
  4142ea:	f44f 7302 	mov.w	r3, #520	; 0x208
  4142ee:	9002      	str	r0, [sp, #8]
  4142f0:	9006      	str	r0, [sp, #24]
  4142f2:	f8ad 3014 	strh.w	r3, [sp, #20]
  4142f6:	ae23      	add	r6, sp, #140	; 0x8c
  4142f8:	d017      	beq.n	41432a <snprintf+0x4e>
  4142fa:	3c01      	subs	r4, #1
  4142fc:	9a22      	ldr	r2, [sp, #136]	; 0x88
  4142fe:	9404      	str	r4, [sp, #16]
  414300:	4633      	mov	r3, r6
  414302:	f64f 77ff 	movw	r7, #65535	; 0xffff
  414306:	a902      	add	r1, sp, #8
  414308:	4628      	mov	r0, r5
  41430a:	9407      	str	r4, [sp, #28]
  41430c:	9601      	str	r6, [sp, #4]
  41430e:	f8ad 7016 	strh.w	r7, [sp, #22]
  414312:	f000 f831 	bl	414378 <_svfprintf_r>
  414316:	1c42      	adds	r2, r0, #1
  414318:	db1b      	blt.n	414352 <snprintf+0x76>
  41431a:	9b02      	ldr	r3, [sp, #8]
  41431c:	2200      	movs	r2, #0
  41431e:	701a      	strb	r2, [r3, #0]
  414320:	b01d      	add	sp, #116	; 0x74
  414322:	e8bd 40f0 	ldmia.w	sp!, {r4, r5, r6, r7, lr}
  414326:	b002      	add	sp, #8
  414328:	4770      	bx	lr
  41432a:	4633      	mov	r3, r6
  41432c:	f64f 77ff 	movw	r7, #65535	; 0xffff
  414330:	9a22      	ldr	r2, [sp, #136]	; 0x88
  414332:	9404      	str	r4, [sp, #16]
  414334:	a902      	add	r1, sp, #8
  414336:	4628      	mov	r0, r5
  414338:	9407      	str	r4, [sp, #28]
  41433a:	9601      	str	r6, [sp, #4]
  41433c:	f8ad 7016 	strh.w	r7, [sp, #22]
  414340:	f000 f81a 	bl	414378 <_svfprintf_r>
  414344:	1c43      	adds	r3, r0, #1
  414346:	db07      	blt.n	414358 <snprintf+0x7c>
  414348:	b01d      	add	sp, #116	; 0x74
  41434a:	e8bd 40f0 	ldmia.w	sp!, {r4, r5, r6, r7, lr}
  41434e:	b002      	add	sp, #8
  414350:	4770      	bx	lr
  414352:	238b      	movs	r3, #139	; 0x8b
  414354:	602b      	str	r3, [r5, #0]
  414356:	e7e0      	b.n	41431a <snprintf+0x3e>
  414358:	238b      	movs	r3, #139	; 0x8b
  41435a:	602b      	str	r3, [r5, #0]
  41435c:	b01d      	add	sp, #116	; 0x74
  41435e:	e8bd 40f0 	ldmia.w	sp!, {r4, r5, r6, r7, lr}
  414362:	b002      	add	sp, #8
  414364:	4770      	bx	lr
  414366:	238b      	movs	r3, #139	; 0x8b
  414368:	602b      	str	r3, [r5, #0]
  41436a:	f04f 30ff 	mov.w	r0, #4294967295
  41436e:	e7eb      	b.n	414348 <snprintf+0x6c>
  414370:	20000358 	.word	0x20000358
  414374:	00000000 	.word	0x00000000

00414378 <_svfprintf_r>:
  414378:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  41437c:	b0c1      	sub	sp, #260	; 0x104
  41437e:	460c      	mov	r4, r1
  414380:	9107      	str	r1, [sp, #28]
  414382:	4692      	mov	sl, r2
  414384:	930b      	str	r3, [sp, #44]	; 0x2c
  414386:	9008      	str	r0, [sp, #32]
  414388:	f002 fa6e 	bl	416868 <_localeconv_r>
  41438c:	6803      	ldr	r3, [r0, #0]
  41438e:	9314      	str	r3, [sp, #80]	; 0x50
  414390:	4618      	mov	r0, r3
  414392:	f003 f8b5 	bl	417500 <strlen>
  414396:	89a3      	ldrh	r3, [r4, #12]
  414398:	9013      	str	r0, [sp, #76]	; 0x4c
  41439a:	0619      	lsls	r1, r3, #24
  41439c:	d503      	bpl.n	4143a6 <_svfprintf_r+0x2e>
  41439e:	6923      	ldr	r3, [r4, #16]
  4143a0:	2b00      	cmp	r3, #0
  4143a2:	f001 801b 	beq.w	4153dc <_svfprintf_r+0x1064>
  4143a6:	ed9f 7b94 	vldr	d7, [pc, #592]	; 4145f8 <_svfprintf_r+0x280>
  4143aa:	ed8d 7b10 	vstr	d7, [sp, #64]	; 0x40
  4143ae:	2300      	movs	r3, #0
  4143b0:	f10d 09c0 	add.w	r9, sp, #192	; 0xc0
  4143b4:	930f      	str	r3, [sp, #60]	; 0x3c
  4143b6:	9325      	str	r3, [sp, #148]	; 0x94
  4143b8:	9324      	str	r3, [sp, #144]	; 0x90
  4143ba:	9312      	str	r3, [sp, #72]	; 0x48
  4143bc:	9315      	str	r3, [sp, #84]	; 0x54
  4143be:	9305      	str	r3, [sp, #20]
  4143c0:	f8cd 908c 	str.w	r9, [sp, #140]	; 0x8c
  4143c4:	46c8      	mov	r8, r9
  4143c6:	f89a 3000 	ldrb.w	r3, [sl]
  4143ca:	4654      	mov	r4, sl
  4143cc:	b1e3      	cbz	r3, 414408 <_svfprintf_r+0x90>
  4143ce:	2b25      	cmp	r3, #37	; 0x25
  4143d0:	d102      	bne.n	4143d8 <_svfprintf_r+0x60>
  4143d2:	e019      	b.n	414408 <_svfprintf_r+0x90>
  4143d4:	2b25      	cmp	r3, #37	; 0x25
  4143d6:	d003      	beq.n	4143e0 <_svfprintf_r+0x68>
  4143d8:	f814 3f01 	ldrb.w	r3, [r4, #1]!
  4143dc:	2b00      	cmp	r3, #0
  4143de:	d1f9      	bne.n	4143d4 <_svfprintf_r+0x5c>
  4143e0:	eba4 050a 	sub.w	r5, r4, sl
  4143e4:	b185      	cbz	r5, 414408 <_svfprintf_r+0x90>
  4143e6:	9b24      	ldr	r3, [sp, #144]	; 0x90
  4143e8:	9a25      	ldr	r2, [sp, #148]	; 0x94
  4143ea:	f8c8 a000 	str.w	sl, [r8]
  4143ee:	3301      	adds	r3, #1
  4143f0:	442a      	add	r2, r5
  4143f2:	2b07      	cmp	r3, #7
  4143f4:	f8c8 5004 	str.w	r5, [r8, #4]
  4143f8:	9225      	str	r2, [sp, #148]	; 0x94
  4143fa:	9324      	str	r3, [sp, #144]	; 0x90
  4143fc:	dc7f      	bgt.n	4144fe <_svfprintf_r+0x186>
  4143fe:	f108 0808 	add.w	r8, r8, #8
  414402:	9b05      	ldr	r3, [sp, #20]
  414404:	442b      	add	r3, r5
  414406:	9305      	str	r3, [sp, #20]
  414408:	7823      	ldrb	r3, [r4, #0]
  41440a:	2b00      	cmp	r3, #0
  41440c:	d07f      	beq.n	41450e <_svfprintf_r+0x196>
  41440e:	2300      	movs	r3, #0
  414410:	461a      	mov	r2, r3
  414412:	f88d 306f 	strb.w	r3, [sp, #111]	; 0x6f
  414416:	4619      	mov	r1, r3
  414418:	9309      	str	r3, [sp, #36]	; 0x24
  41441a:	469b      	mov	fp, r3
  41441c:	f04f 30ff 	mov.w	r0, #4294967295
  414420:	7863      	ldrb	r3, [r4, #1]
  414422:	9006      	str	r0, [sp, #24]
  414424:	f104 0a01 	add.w	sl, r4, #1
  414428:	f10a 0a01 	add.w	sl, sl, #1
  41442c:	f1a3 0020 	sub.w	r0, r3, #32
  414430:	2858      	cmp	r0, #88	; 0x58
  414432:	f200 83d3 	bhi.w	414bdc <_svfprintf_r+0x864>
  414436:	e8df f010 	tbh	[pc, r0, lsl #1]
  41443a:	023f      	.short	0x023f
  41443c:	03d103d1 	.word	0x03d103d1
  414440:	03d10247 	.word	0x03d10247
  414444:	03d103d1 	.word	0x03d103d1
  414448:	03d103d1 	.word	0x03d103d1
  41444c:	024c03d1 	.word	0x024c03d1
  414450:	03d1020a 	.word	0x03d1020a
  414454:	0273005d 	.word	0x0273005d
  414458:	028e03d1 	.word	0x028e03d1
  41445c:	03c103c1 	.word	0x03c103c1
  414460:	03c103c1 	.word	0x03c103c1
  414464:	03c103c1 	.word	0x03c103c1
  414468:	03c103c1 	.word	0x03c103c1
  41446c:	03d103c1 	.word	0x03d103c1
  414470:	03d103d1 	.word	0x03d103d1
  414474:	03d103d1 	.word	0x03d103d1
  414478:	03d103d1 	.word	0x03d103d1
  41447c:	03d103d1 	.word	0x03d103d1
  414480:	033f03d1 	.word	0x033f03d1
  414484:	03d1035f 	.word	0x03d1035f
  414488:	03d1035f 	.word	0x03d1035f
  41448c:	03d103d1 	.word	0x03d103d1
  414490:	03aa03d1 	.word	0x03aa03d1
  414494:	03d103d1 	.word	0x03d103d1
  414498:	03d103af 	.word	0x03d103af
  41449c:	03d103d1 	.word	0x03d103d1
  4144a0:	03d103d1 	.word	0x03d103d1
  4144a4:	03d10261 	.word	0x03d10261
  4144a8:	032603d1 	.word	0x032603d1
  4144ac:	03d103d1 	.word	0x03d103d1
  4144b0:	03d103d1 	.word	0x03d103d1
  4144b4:	03d103d1 	.word	0x03d103d1
  4144b8:	03d103d1 	.word	0x03d103d1
  4144bc:	03d103d1 	.word	0x03d103d1
  4144c0:	02e302ce 	.word	0x02e302ce
  4144c4:	035f035f 	.word	0x035f035f
  4144c8:	0293035f 	.word	0x0293035f
  4144cc:	03d102e3 	.word	0x03d102e3
  4144d0:	029803d1 	.word	0x029803d1
  4144d4:	02a503d1 	.word	0x02a503d1
  4144d8:	02bc01d3 	.word	0x02bc01d3
  4144dc:	03d1020f 	.word	0x03d1020f
  4144e0:	03d101e8 	.word	0x03d101e8
  4144e4:	03d1007e 	.word	0x03d1007e
  4144e8:	021403d1 	.word	0x021403d1
  4144ec:	9809      	ldr	r0, [sp, #36]	; 0x24
  4144ee:	930b      	str	r3, [sp, #44]	; 0x2c
  4144f0:	4240      	negs	r0, r0
  4144f2:	9009      	str	r0, [sp, #36]	; 0x24
  4144f4:	f04b 0b04 	orr.w	fp, fp, #4
  4144f8:	f89a 3000 	ldrb.w	r3, [sl]
  4144fc:	e794      	b.n	414428 <_svfprintf_r+0xb0>
  4144fe:	aa23      	add	r2, sp, #140	; 0x8c
  414500:	9907      	ldr	r1, [sp, #28]
  414502:	9808      	ldr	r0, [sp, #32]
  414504:	f003 f86a 	bl	4175dc <__ssprint_r>
  414508:	b940      	cbnz	r0, 41451c <_svfprintf_r+0x1a4>
  41450a:	46c8      	mov	r8, r9
  41450c:	e779      	b.n	414402 <_svfprintf_r+0x8a>
  41450e:	9b25      	ldr	r3, [sp, #148]	; 0x94
  414510:	b123      	cbz	r3, 41451c <_svfprintf_r+0x1a4>
  414512:	9808      	ldr	r0, [sp, #32]
  414514:	9907      	ldr	r1, [sp, #28]
  414516:	aa23      	add	r2, sp, #140	; 0x8c
  414518:	f003 f860 	bl	4175dc <__ssprint_r>
  41451c:	9b07      	ldr	r3, [sp, #28]
  41451e:	899b      	ldrh	r3, [r3, #12]
  414520:	f013 0f40 	tst.w	r3, #64	; 0x40
  414524:	9b05      	ldr	r3, [sp, #20]
  414526:	bf18      	it	ne
  414528:	f04f 33ff 	movne.w	r3, #4294967295
  41452c:	9305      	str	r3, [sp, #20]
  41452e:	9805      	ldr	r0, [sp, #20]
  414530:	b041      	add	sp, #260	; 0x104
  414532:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  414536:	f01b 0f20 	tst.w	fp, #32
  41453a:	930d      	str	r3, [sp, #52]	; 0x34
  41453c:	f040 81e5 	bne.w	41490a <_svfprintf_r+0x592>
  414540:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
  414542:	f01b 0f10 	tst.w	fp, #16
  414546:	4613      	mov	r3, r2
  414548:	f040 8588 	bne.w	41505c <_svfprintf_r+0xce4>
  41454c:	f01b 0f40 	tst.w	fp, #64	; 0x40
  414550:	f000 8584 	beq.w	41505c <_svfprintf_r+0xce4>
  414554:	8814      	ldrh	r4, [r2, #0]
  414556:	3204      	adds	r2, #4
  414558:	2500      	movs	r5, #0
  41455a:	2301      	movs	r3, #1
  41455c:	920b      	str	r2, [sp, #44]	; 0x2c
  41455e:	2700      	movs	r7, #0
  414560:	f88d 706f 	strb.w	r7, [sp, #111]	; 0x6f
  414564:	9906      	ldr	r1, [sp, #24]
  414566:	1c4a      	adds	r2, r1, #1
  414568:	f000 826d 	beq.w	414a46 <_svfprintf_r+0x6ce>
  41456c:	f02b 0280 	bic.w	r2, fp, #128	; 0x80
  414570:	9203      	str	r2, [sp, #12]
  414572:	ea54 0205 	orrs.w	r2, r4, r5
  414576:	f040 826c 	bne.w	414a52 <_svfprintf_r+0x6da>
  41457a:	2900      	cmp	r1, #0
  41457c:	f040 8451 	bne.w	414e22 <_svfprintf_r+0xaaa>
  414580:	2b00      	cmp	r3, #0
  414582:	f040 850b 	bne.w	414f9c <_svfprintf_r+0xc24>
  414586:	f01b 0301 	ands.w	r3, fp, #1
  41458a:	930a      	str	r3, [sp, #40]	; 0x28
  41458c:	f000 861a 	beq.w	4151c4 <_svfprintf_r+0xe4c>
  414590:	ae40      	add	r6, sp, #256	; 0x100
  414592:	2330      	movs	r3, #48	; 0x30
  414594:	f806 3d41 	strb.w	r3, [r6, #-65]!
  414598:	9b06      	ldr	r3, [sp, #24]
  41459a:	9a0a      	ldr	r2, [sp, #40]	; 0x28
  41459c:	4293      	cmp	r3, r2
  41459e:	bfb8      	it	lt
  4145a0:	4613      	movlt	r3, r2
  4145a2:	9304      	str	r3, [sp, #16]
  4145a4:	2300      	movs	r3, #0
  4145a6:	930e      	str	r3, [sp, #56]	; 0x38
  4145a8:	b117      	cbz	r7, 4145b0 <_svfprintf_r+0x238>
  4145aa:	9b04      	ldr	r3, [sp, #16]
  4145ac:	3301      	adds	r3, #1
  4145ae:	9304      	str	r3, [sp, #16]
  4145b0:	9b03      	ldr	r3, [sp, #12]
  4145b2:	f013 0302 	ands.w	r3, r3, #2
  4145b6:	930c      	str	r3, [sp, #48]	; 0x30
  4145b8:	d002      	beq.n	4145c0 <_svfprintf_r+0x248>
  4145ba:	9b04      	ldr	r3, [sp, #16]
  4145bc:	3302      	adds	r3, #2
  4145be:	9304      	str	r3, [sp, #16]
  4145c0:	9b03      	ldr	r3, [sp, #12]
  4145c2:	f013 0584 	ands.w	r5, r3, #132	; 0x84
  4145c6:	f040 8320 	bne.w	414c0a <_svfprintf_r+0x892>
  4145ca:	9b09      	ldr	r3, [sp, #36]	; 0x24
  4145cc:	9a04      	ldr	r2, [sp, #16]
  4145ce:	eba3 0b02 	sub.w	fp, r3, r2
  4145d2:	f1bb 0f00 	cmp.w	fp, #0
  4145d6:	f340 8318 	ble.w	414c0a <_svfprintf_r+0x892>
  4145da:	f1bb 0f10 	cmp.w	fp, #16
  4145de:	9c25      	ldr	r4, [sp, #148]	; 0x94
  4145e0:	9a24      	ldr	r2, [sp, #144]	; 0x90
  4145e2:	dd30      	ble.n	414646 <_svfprintf_r+0x2ce>
  4145e4:	4643      	mov	r3, r8
  4145e6:	4621      	mov	r1, r4
  4145e8:	46a8      	mov	r8, r5
  4145ea:	2710      	movs	r7, #16
  4145ec:	9c08      	ldr	r4, [sp, #32]
  4145ee:	9d07      	ldr	r5, [sp, #28]
  4145f0:	e00d      	b.n	41460e <_svfprintf_r+0x296>
  4145f2:	bf00      	nop
  4145f4:	f3af 8000 	nop.w
	...
  414600:	f1ab 0b10 	sub.w	fp, fp, #16
  414604:	f1bb 0f10 	cmp.w	fp, #16
  414608:	f103 0308 	add.w	r3, r3, #8
  41460c:	dd18      	ble.n	414640 <_svfprintf_r+0x2c8>
  41460e:	3201      	adds	r2, #1
  414610:	48b7      	ldr	r0, [pc, #732]	; (4148f0 <_svfprintf_r+0x578>)
  414612:	9224      	str	r2, [sp, #144]	; 0x90
  414614:	3110      	adds	r1, #16
  414616:	2a07      	cmp	r2, #7
  414618:	9125      	str	r1, [sp, #148]	; 0x94
  41461a:	e883 0081 	stmia.w	r3, {r0, r7}
  41461e:	ddef      	ble.n	414600 <_svfprintf_r+0x288>
  414620:	aa23      	add	r2, sp, #140	; 0x8c
  414622:	4629      	mov	r1, r5
  414624:	4620      	mov	r0, r4
  414626:	f002 ffd9 	bl	4175dc <__ssprint_r>
  41462a:	2800      	cmp	r0, #0
  41462c:	f47f af76 	bne.w	41451c <_svfprintf_r+0x1a4>
  414630:	f1ab 0b10 	sub.w	fp, fp, #16
  414634:	f1bb 0f10 	cmp.w	fp, #16
  414638:	9925      	ldr	r1, [sp, #148]	; 0x94
  41463a:	9a24      	ldr	r2, [sp, #144]	; 0x90
  41463c:	464b      	mov	r3, r9
  41463e:	dce6      	bgt.n	41460e <_svfprintf_r+0x296>
  414640:	4645      	mov	r5, r8
  414642:	460c      	mov	r4, r1
  414644:	4698      	mov	r8, r3
  414646:	3201      	adds	r2, #1
  414648:	4ba9      	ldr	r3, [pc, #676]	; (4148f0 <_svfprintf_r+0x578>)
  41464a:	9224      	str	r2, [sp, #144]	; 0x90
  41464c:	445c      	add	r4, fp
  41464e:	2a07      	cmp	r2, #7
  414650:	9425      	str	r4, [sp, #148]	; 0x94
  414652:	e888 0808 	stmia.w	r8, {r3, fp}
  414656:	f300 84a6 	bgt.w	414fa6 <_svfprintf_r+0xc2e>
  41465a:	f89d 706f 	ldrb.w	r7, [sp, #111]	; 0x6f
  41465e:	f108 0808 	add.w	r8, r8, #8
  414662:	b177      	cbz	r7, 414682 <_svfprintf_r+0x30a>
  414664:	9b24      	ldr	r3, [sp, #144]	; 0x90
  414666:	3301      	adds	r3, #1
  414668:	3401      	adds	r4, #1
  41466a:	f10d 016f 	add.w	r1, sp, #111	; 0x6f
  41466e:	2201      	movs	r2, #1
  414670:	2b07      	cmp	r3, #7
  414672:	9425      	str	r4, [sp, #148]	; 0x94
  414674:	9324      	str	r3, [sp, #144]	; 0x90
  414676:	e888 0006 	stmia.w	r8, {r1, r2}
  41467a:	f300 83f4 	bgt.w	414e66 <_svfprintf_r+0xaee>
  41467e:	f108 0808 	add.w	r8, r8, #8
  414682:	9b0c      	ldr	r3, [sp, #48]	; 0x30
  414684:	b16b      	cbz	r3, 4146a2 <_svfprintf_r+0x32a>
  414686:	9b24      	ldr	r3, [sp, #144]	; 0x90
  414688:	3301      	adds	r3, #1
  41468a:	3402      	adds	r4, #2
  41468c:	a91c      	add	r1, sp, #112	; 0x70
  41468e:	2202      	movs	r2, #2
  414690:	2b07      	cmp	r3, #7
  414692:	9425      	str	r4, [sp, #148]	; 0x94
  414694:	9324      	str	r3, [sp, #144]	; 0x90
  414696:	e888 0006 	stmia.w	r8, {r1, r2}
  41469a:	f300 83d9 	bgt.w	414e50 <_svfprintf_r+0xad8>
  41469e:	f108 0808 	add.w	r8, r8, #8
  4146a2:	2d80      	cmp	r5, #128	; 0x80
  4146a4:	f000 8322 	beq.w	414cec <_svfprintf_r+0x974>
  4146a8:	9b06      	ldr	r3, [sp, #24]
  4146aa:	9a0a      	ldr	r2, [sp, #40]	; 0x28
  4146ac:	1a9f      	subs	r7, r3, r2
  4146ae:	2f00      	cmp	r7, #0
  4146b0:	dd36      	ble.n	414720 <_svfprintf_r+0x3a8>
  4146b2:	2f10      	cmp	r7, #16
  4146b4:	9b24      	ldr	r3, [sp, #144]	; 0x90
  4146b6:	4d8f      	ldr	r5, [pc, #572]	; (4148f4 <_svfprintf_r+0x57c>)
  4146b8:	dd27      	ble.n	41470a <_svfprintf_r+0x392>
  4146ba:	4642      	mov	r2, r8
  4146bc:	4621      	mov	r1, r4
  4146be:	46b0      	mov	r8, r6
  4146c0:	f04f 0b10 	mov.w	fp, #16
  4146c4:	462e      	mov	r6, r5
  4146c6:	9c08      	ldr	r4, [sp, #32]
  4146c8:	9d07      	ldr	r5, [sp, #28]
  4146ca:	e004      	b.n	4146d6 <_svfprintf_r+0x35e>
  4146cc:	3f10      	subs	r7, #16
  4146ce:	2f10      	cmp	r7, #16
  4146d0:	f102 0208 	add.w	r2, r2, #8
  4146d4:	dd15      	ble.n	414702 <_svfprintf_r+0x38a>
  4146d6:	3301      	adds	r3, #1
  4146d8:	3110      	adds	r1, #16
  4146da:	2b07      	cmp	r3, #7
  4146dc:	9125      	str	r1, [sp, #148]	; 0x94
  4146de:	9324      	str	r3, [sp, #144]	; 0x90
  4146e0:	e882 0840 	stmia.w	r2, {r6, fp}
  4146e4:	ddf2      	ble.n	4146cc <_svfprintf_r+0x354>
  4146e6:	aa23      	add	r2, sp, #140	; 0x8c
  4146e8:	4629      	mov	r1, r5
  4146ea:	4620      	mov	r0, r4
  4146ec:	f002 ff76 	bl	4175dc <__ssprint_r>
  4146f0:	2800      	cmp	r0, #0
  4146f2:	f47f af13 	bne.w	41451c <_svfprintf_r+0x1a4>
  4146f6:	3f10      	subs	r7, #16
  4146f8:	2f10      	cmp	r7, #16
  4146fa:	9925      	ldr	r1, [sp, #148]	; 0x94
  4146fc:	9b24      	ldr	r3, [sp, #144]	; 0x90
  4146fe:	464a      	mov	r2, r9
  414700:	dce9      	bgt.n	4146d6 <_svfprintf_r+0x35e>
  414702:	4635      	mov	r5, r6
  414704:	460c      	mov	r4, r1
  414706:	4646      	mov	r6, r8
  414708:	4690      	mov	r8, r2
  41470a:	3301      	adds	r3, #1
  41470c:	443c      	add	r4, r7
  41470e:	2b07      	cmp	r3, #7
  414710:	9425      	str	r4, [sp, #148]	; 0x94
  414712:	9324      	str	r3, [sp, #144]	; 0x90
  414714:	e888 00a0 	stmia.w	r8, {r5, r7}
  414718:	f300 838f 	bgt.w	414e3a <_svfprintf_r+0xac2>
  41471c:	f108 0808 	add.w	r8, r8, #8
  414720:	9b03      	ldr	r3, [sp, #12]
  414722:	05df      	lsls	r7, r3, #23
  414724:	f100 8273 	bmi.w	414c0e <_svfprintf_r+0x896>
  414728:	9b24      	ldr	r3, [sp, #144]	; 0x90
  41472a:	990a      	ldr	r1, [sp, #40]	; 0x28
  41472c:	f8c8 6000 	str.w	r6, [r8]
  414730:	3301      	adds	r3, #1
  414732:	440c      	add	r4, r1
  414734:	2b07      	cmp	r3, #7
  414736:	9425      	str	r4, [sp, #148]	; 0x94
  414738:	f8c8 1004 	str.w	r1, [r8, #4]
  41473c:	9324      	str	r3, [sp, #144]	; 0x90
  41473e:	f300 835b 	bgt.w	414df8 <_svfprintf_r+0xa80>
  414742:	f108 0808 	add.w	r8, r8, #8
  414746:	9b03      	ldr	r3, [sp, #12]
  414748:	075b      	lsls	r3, r3, #29
  41474a:	d53a      	bpl.n	4147c2 <_svfprintf_r+0x44a>
  41474c:	9b09      	ldr	r3, [sp, #36]	; 0x24
  41474e:	9a04      	ldr	r2, [sp, #16]
  414750:	1a9d      	subs	r5, r3, r2
  414752:	2d00      	cmp	r5, #0
  414754:	dd35      	ble.n	4147c2 <_svfprintf_r+0x44a>
  414756:	2d10      	cmp	r5, #16
  414758:	9b24      	ldr	r3, [sp, #144]	; 0x90
  41475a:	dd20      	ble.n	41479e <_svfprintf_r+0x426>
  41475c:	2610      	movs	r6, #16
  41475e:	9f08      	ldr	r7, [sp, #32]
  414760:	f8dd b01c 	ldr.w	fp, [sp, #28]
  414764:	e004      	b.n	414770 <_svfprintf_r+0x3f8>
  414766:	3d10      	subs	r5, #16
  414768:	2d10      	cmp	r5, #16
  41476a:	f108 0808 	add.w	r8, r8, #8
  41476e:	dd16      	ble.n	41479e <_svfprintf_r+0x426>
  414770:	3301      	adds	r3, #1
  414772:	4a5f      	ldr	r2, [pc, #380]	; (4148f0 <_svfprintf_r+0x578>)
  414774:	9324      	str	r3, [sp, #144]	; 0x90
  414776:	3410      	adds	r4, #16
  414778:	2b07      	cmp	r3, #7
  41477a:	9425      	str	r4, [sp, #148]	; 0x94
  41477c:	e888 0044 	stmia.w	r8, {r2, r6}
  414780:	ddf1      	ble.n	414766 <_svfprintf_r+0x3ee>
  414782:	aa23      	add	r2, sp, #140	; 0x8c
  414784:	4659      	mov	r1, fp
  414786:	4638      	mov	r0, r7
  414788:	f002 ff28 	bl	4175dc <__ssprint_r>
  41478c:	2800      	cmp	r0, #0
  41478e:	f47f aec5 	bne.w	41451c <_svfprintf_r+0x1a4>
  414792:	3d10      	subs	r5, #16
  414794:	2d10      	cmp	r5, #16
  414796:	9c25      	ldr	r4, [sp, #148]	; 0x94
  414798:	9b24      	ldr	r3, [sp, #144]	; 0x90
  41479a:	46c8      	mov	r8, r9
  41479c:	dce8      	bgt.n	414770 <_svfprintf_r+0x3f8>
  41479e:	3301      	adds	r3, #1
  4147a0:	4a53      	ldr	r2, [pc, #332]	; (4148f0 <_svfprintf_r+0x578>)
  4147a2:	9324      	str	r3, [sp, #144]	; 0x90
  4147a4:	442c      	add	r4, r5
  4147a6:	2b07      	cmp	r3, #7
  4147a8:	9425      	str	r4, [sp, #148]	; 0x94
  4147aa:	e888 0024 	stmia.w	r8, {r2, r5}
  4147ae:	dd08      	ble.n	4147c2 <_svfprintf_r+0x44a>
  4147b0:	aa23      	add	r2, sp, #140	; 0x8c
  4147b2:	9907      	ldr	r1, [sp, #28]
  4147b4:	9808      	ldr	r0, [sp, #32]
  4147b6:	f002 ff11 	bl	4175dc <__ssprint_r>
  4147ba:	2800      	cmp	r0, #0
  4147bc:	f47f aeae 	bne.w	41451c <_svfprintf_r+0x1a4>
  4147c0:	9c25      	ldr	r4, [sp, #148]	; 0x94
  4147c2:	9b05      	ldr	r3, [sp, #20]
  4147c4:	9a09      	ldr	r2, [sp, #36]	; 0x24
  4147c6:	9904      	ldr	r1, [sp, #16]
  4147c8:	428a      	cmp	r2, r1
  4147ca:	bfac      	ite	ge
  4147cc:	189b      	addge	r3, r3, r2
  4147ce:	185b      	addlt	r3, r3, r1
  4147d0:	9305      	str	r3, [sp, #20]
  4147d2:	2c00      	cmp	r4, #0
  4147d4:	f040 831b 	bne.w	414e0e <_svfprintf_r+0xa96>
  4147d8:	2300      	movs	r3, #0
  4147da:	9324      	str	r3, [sp, #144]	; 0x90
  4147dc:	46c8      	mov	r8, r9
  4147de:	e5f2      	b.n	4143c6 <_svfprintf_r+0x4e>
  4147e0:	930d      	str	r3, [sp, #52]	; 0x34
  4147e2:	f01b 0320 	ands.w	r3, fp, #32
  4147e6:	f040 81de 	bne.w	414ba6 <_svfprintf_r+0x82e>
  4147ea:	f01b 0210 	ands.w	r2, fp, #16
  4147ee:	f040 842d 	bne.w	41504c <_svfprintf_r+0xcd4>
  4147f2:	f01b 0340 	ands.w	r3, fp, #64	; 0x40
  4147f6:	f000 8429 	beq.w	41504c <_svfprintf_r+0xcd4>
  4147fa:	990b      	ldr	r1, [sp, #44]	; 0x2c
  4147fc:	4613      	mov	r3, r2
  4147fe:	460a      	mov	r2, r1
  414800:	3204      	adds	r2, #4
  414802:	880c      	ldrh	r4, [r1, #0]
  414804:	920b      	str	r2, [sp, #44]	; 0x2c
  414806:	2500      	movs	r5, #0
  414808:	e6a9      	b.n	41455e <_svfprintf_r+0x1e6>
  41480a:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
  41480c:	930d      	str	r3, [sp, #52]	; 0x34
  41480e:	6816      	ldr	r6, [r2, #0]
  414810:	2400      	movs	r4, #0
  414812:	f88d 406f 	strb.w	r4, [sp, #111]	; 0x6f
  414816:	1d15      	adds	r5, r2, #4
  414818:	2e00      	cmp	r6, #0
  41481a:	f000 86b5 	beq.w	415588 <_svfprintf_r+0x1210>
  41481e:	9a06      	ldr	r2, [sp, #24]
  414820:	1c53      	adds	r3, r2, #1
  414822:	f000 8617 	beq.w	415454 <_svfprintf_r+0x10dc>
  414826:	4621      	mov	r1, r4
  414828:	4630      	mov	r0, r6
  41482a:	f002 fae1 	bl	416df0 <memchr>
  41482e:	2800      	cmp	r0, #0
  414830:	f000 8708 	beq.w	415644 <_svfprintf_r+0x12cc>
  414834:	1b83      	subs	r3, r0, r6
  414836:	930a      	str	r3, [sp, #40]	; 0x28
  414838:	9406      	str	r4, [sp, #24]
  41483a:	950b      	str	r5, [sp, #44]	; 0x2c
  41483c:	f8cd b00c 	str.w	fp, [sp, #12]
  414840:	ea23 73e3 	bic.w	r3, r3, r3, asr #31
  414844:	9304      	str	r3, [sp, #16]
  414846:	940e      	str	r4, [sp, #56]	; 0x38
  414848:	f89d 706f 	ldrb.w	r7, [sp, #111]	; 0x6f
  41484c:	e6ac      	b.n	4145a8 <_svfprintf_r+0x230>
  41484e:	f89a 3000 	ldrb.w	r3, [sl]
  414852:	2201      	movs	r2, #1
  414854:	212b      	movs	r1, #43	; 0x2b
  414856:	e5e7      	b.n	414428 <_svfprintf_r+0xb0>
  414858:	f04b 0b20 	orr.w	fp, fp, #32
  41485c:	f89a 3000 	ldrb.w	r3, [sl]
  414860:	e5e2      	b.n	414428 <_svfprintf_r+0xb0>
  414862:	930d      	str	r3, [sp, #52]	; 0x34
  414864:	2a00      	cmp	r2, #0
  414866:	f040 87aa 	bne.w	4157be <_svfprintf_r+0x1446>
  41486a:	4b23      	ldr	r3, [pc, #140]	; (4148f8 <_svfprintf_r+0x580>)
  41486c:	9312      	str	r3, [sp, #72]	; 0x48
  41486e:	f01b 0f20 	tst.w	fp, #32
  414872:	f040 8112 	bne.w	414a9a <_svfprintf_r+0x722>
  414876:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
  414878:	f01b 0f10 	tst.w	fp, #16
  41487c:	4613      	mov	r3, r2
  41487e:	f040 83e0 	bne.w	415042 <_svfprintf_r+0xcca>
  414882:	f01b 0f40 	tst.w	fp, #64	; 0x40
  414886:	f000 83dc 	beq.w	415042 <_svfprintf_r+0xcca>
  41488a:	3304      	adds	r3, #4
  41488c:	8814      	ldrh	r4, [r2, #0]
  41488e:	930b      	str	r3, [sp, #44]	; 0x2c
  414890:	2500      	movs	r5, #0
  414892:	f01b 0f01 	tst.w	fp, #1
  414896:	f000 810d 	beq.w	414ab4 <_svfprintf_r+0x73c>
  41489a:	ea54 0305 	orrs.w	r3, r4, r5
  41489e:	f000 8109 	beq.w	414ab4 <_svfprintf_r+0x73c>
  4148a2:	2330      	movs	r3, #48	; 0x30
  4148a4:	f89d 2034 	ldrb.w	r2, [sp, #52]	; 0x34
  4148a8:	f88d 3070 	strb.w	r3, [sp, #112]	; 0x70
  4148ac:	f88d 2071 	strb.w	r2, [sp, #113]	; 0x71
  4148b0:	f04b 0b02 	orr.w	fp, fp, #2
  4148b4:	2302      	movs	r3, #2
  4148b6:	e652      	b.n	41455e <_svfprintf_r+0x1e6>
  4148b8:	f89a 3000 	ldrb.w	r3, [sl]
  4148bc:	2900      	cmp	r1, #0
  4148be:	f47f adb3 	bne.w	414428 <_svfprintf_r+0xb0>
  4148c2:	2201      	movs	r2, #1
  4148c4:	2120      	movs	r1, #32
  4148c6:	e5af      	b.n	414428 <_svfprintf_r+0xb0>
  4148c8:	f04b 0b01 	orr.w	fp, fp, #1
  4148cc:	f89a 3000 	ldrb.w	r3, [sl]
  4148d0:	e5aa      	b.n	414428 <_svfprintf_r+0xb0>
  4148d2:	9c0b      	ldr	r4, [sp, #44]	; 0x2c
  4148d4:	6823      	ldr	r3, [r4, #0]
  4148d6:	9309      	str	r3, [sp, #36]	; 0x24
  4148d8:	4618      	mov	r0, r3
  4148da:	2800      	cmp	r0, #0
  4148dc:	4623      	mov	r3, r4
  4148de:	f103 0304 	add.w	r3, r3, #4
  4148e2:	f6ff ae03 	blt.w	4144ec <_svfprintf_r+0x174>
  4148e6:	930b      	str	r3, [sp, #44]	; 0x2c
  4148e8:	f89a 3000 	ldrb.w	r3, [sl]
  4148ec:	e59c      	b.n	414428 <_svfprintf_r+0xb0>
  4148ee:	bf00      	nop
  4148f0:	0041d66c 	.word	0x0041d66c
  4148f4:	0041d67c 	.word	0x0041d67c
  4148f8:	0041d64c 	.word	0x0041d64c
  4148fc:	f04b 0b10 	orr.w	fp, fp, #16
  414900:	f01b 0f20 	tst.w	fp, #32
  414904:	930d      	str	r3, [sp, #52]	; 0x34
  414906:	f43f ae1b 	beq.w	414540 <_svfprintf_r+0x1c8>
  41490a:	9d0b      	ldr	r5, [sp, #44]	; 0x2c
  41490c:	3507      	adds	r5, #7
  41490e:	f025 0307 	bic.w	r3, r5, #7
  414912:	f103 0208 	add.w	r2, r3, #8
  414916:	e9d3 4500 	ldrd	r4, r5, [r3]
  41491a:	920b      	str	r2, [sp, #44]	; 0x2c
  41491c:	2301      	movs	r3, #1
  41491e:	e61e      	b.n	41455e <_svfprintf_r+0x1e6>
  414920:	f89a 3000 	ldrb.w	r3, [sl]
  414924:	2b2a      	cmp	r3, #42	; 0x2a
  414926:	f10a 0401 	add.w	r4, sl, #1
  41492a:	f000 873b 	beq.w	4157a4 <_svfprintf_r+0x142c>
  41492e:	f1a3 0030 	sub.w	r0, r3, #48	; 0x30
  414932:	2809      	cmp	r0, #9
  414934:	46a2      	mov	sl, r4
  414936:	f200 8691 	bhi.w	41565c <_svfprintf_r+0x12e4>
  41493a:	2300      	movs	r3, #0
  41493c:	461c      	mov	r4, r3
  41493e:	f81a 3b01 	ldrb.w	r3, [sl], #1
  414942:	eb04 0484 	add.w	r4, r4, r4, lsl #2
  414946:	eb00 0444 	add.w	r4, r0, r4, lsl #1
  41494a:	f1a3 0030 	sub.w	r0, r3, #48	; 0x30
  41494e:	2809      	cmp	r0, #9
  414950:	d9f5      	bls.n	41493e <_svfprintf_r+0x5c6>
  414952:	9406      	str	r4, [sp, #24]
  414954:	e56a      	b.n	41442c <_svfprintf_r+0xb4>
  414956:	f04b 0b80 	orr.w	fp, fp, #128	; 0x80
  41495a:	f89a 3000 	ldrb.w	r3, [sl]
  41495e:	e563      	b.n	414428 <_svfprintf_r+0xb0>
  414960:	f04b 0b40 	orr.w	fp, fp, #64	; 0x40
  414964:	f89a 3000 	ldrb.w	r3, [sl]
  414968:	e55e      	b.n	414428 <_svfprintf_r+0xb0>
  41496a:	f89a 3000 	ldrb.w	r3, [sl]
  41496e:	2b6c      	cmp	r3, #108	; 0x6c
  414970:	bf03      	ittte	eq
  414972:	f89a 3001 	ldrbeq.w	r3, [sl, #1]
  414976:	f04b 0b20 	orreq.w	fp, fp, #32
  41497a:	f10a 0a01 	addeq.w	sl, sl, #1
  41497e:	f04b 0b10 	orrne.w	fp, fp, #16
  414982:	e551      	b.n	414428 <_svfprintf_r+0xb0>
  414984:	2a00      	cmp	r2, #0
  414986:	f040 871e 	bne.w	4157c6 <_svfprintf_r+0x144e>
  41498a:	f01b 0f20 	tst.w	fp, #32
  41498e:	f040 8509 	bne.w	4153a4 <_svfprintf_r+0x102c>
  414992:	f01b 0f10 	tst.w	fp, #16
  414996:	f040 84bc 	bne.w	415312 <_svfprintf_r+0xf9a>
  41499a:	f01b 0f40 	tst.w	fp, #64	; 0x40
  41499e:	f000 84b8 	beq.w	415312 <_svfprintf_r+0xf9a>
  4149a2:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
  4149a4:	6813      	ldr	r3, [r2, #0]
  4149a6:	3204      	adds	r2, #4
  4149a8:	920b      	str	r2, [sp, #44]	; 0x2c
  4149aa:	f8bd 2014 	ldrh.w	r2, [sp, #20]
  4149ae:	801a      	strh	r2, [r3, #0]
  4149b0:	e509      	b.n	4143c6 <_svfprintf_r+0x4e>
  4149b2:	990b      	ldr	r1, [sp, #44]	; 0x2c
  4149b4:	4bb9      	ldr	r3, [pc, #740]	; (414c9c <_svfprintf_r+0x924>)
  4149b6:	680c      	ldr	r4, [r1, #0]
  4149b8:	9312      	str	r3, [sp, #72]	; 0x48
  4149ba:	2230      	movs	r2, #48	; 0x30
  4149bc:	2378      	movs	r3, #120	; 0x78
  4149be:	3104      	adds	r1, #4
  4149c0:	f88d 3071 	strb.w	r3, [sp, #113]	; 0x71
  4149c4:	930d      	str	r3, [sp, #52]	; 0x34
  4149c6:	f04b 0b02 	orr.w	fp, fp, #2
  4149ca:	910b      	str	r1, [sp, #44]	; 0x2c
  4149cc:	2500      	movs	r5, #0
  4149ce:	f88d 2070 	strb.w	r2, [sp, #112]	; 0x70
  4149d2:	2302      	movs	r3, #2
  4149d4:	e5c3      	b.n	41455e <_svfprintf_r+0x1e6>
  4149d6:	990b      	ldr	r1, [sp, #44]	; 0x2c
  4149d8:	930d      	str	r3, [sp, #52]	; 0x34
  4149da:	680a      	ldr	r2, [r1, #0]
  4149dc:	f88d 2098 	strb.w	r2, [sp, #152]	; 0x98
  4149e0:	2300      	movs	r3, #0
  4149e2:	460a      	mov	r2, r1
  4149e4:	461f      	mov	r7, r3
  4149e6:	f88d 306f 	strb.w	r3, [sp, #111]	; 0x6f
  4149ea:	3204      	adds	r2, #4
  4149ec:	2301      	movs	r3, #1
  4149ee:	9304      	str	r3, [sp, #16]
  4149f0:	f8cd b00c 	str.w	fp, [sp, #12]
  4149f4:	9706      	str	r7, [sp, #24]
  4149f6:	970e      	str	r7, [sp, #56]	; 0x38
  4149f8:	920b      	str	r2, [sp, #44]	; 0x2c
  4149fa:	930a      	str	r3, [sp, #40]	; 0x28
  4149fc:	ae26      	add	r6, sp, #152	; 0x98
  4149fe:	e5d7      	b.n	4145b0 <_svfprintf_r+0x238>
  414a00:	930d      	str	r3, [sp, #52]	; 0x34
  414a02:	2a00      	cmp	r2, #0
  414a04:	f040 86fe 	bne.w	415804 <_svfprintf_r+0x148c>
  414a08:	f01b 0f20 	tst.w	fp, #32
  414a0c:	d15d      	bne.n	414aca <_svfprintf_r+0x752>
  414a0e:	f01b 0f10 	tst.w	fp, #16
  414a12:	f040 8335 	bne.w	415080 <_svfprintf_r+0xd08>
  414a16:	f01b 0f40 	tst.w	fp, #64	; 0x40
  414a1a:	f000 8331 	beq.w	415080 <_svfprintf_r+0xd08>
  414a1e:	990b      	ldr	r1, [sp, #44]	; 0x2c
  414a20:	f9b1 4000 	ldrsh.w	r4, [r1]
  414a24:	3104      	adds	r1, #4
  414a26:	17e5      	asrs	r5, r4, #31
  414a28:	4622      	mov	r2, r4
  414a2a:	462b      	mov	r3, r5
  414a2c:	910b      	str	r1, [sp, #44]	; 0x2c
  414a2e:	2a00      	cmp	r2, #0
  414a30:	f173 0300 	sbcs.w	r3, r3, #0
  414a34:	db58      	blt.n	414ae8 <_svfprintf_r+0x770>
  414a36:	9906      	ldr	r1, [sp, #24]
  414a38:	f89d 706f 	ldrb.w	r7, [sp, #111]	; 0x6f
  414a3c:	1c4a      	adds	r2, r1, #1
  414a3e:	f04f 0301 	mov.w	r3, #1
  414a42:	f47f ad93 	bne.w	41456c <_svfprintf_r+0x1f4>
  414a46:	ea54 0205 	orrs.w	r2, r4, r5
  414a4a:	f000 81ec 	beq.w	414e26 <_svfprintf_r+0xaae>
  414a4e:	f8cd b00c 	str.w	fp, [sp, #12]
  414a52:	2b01      	cmp	r3, #1
  414a54:	f000 8283 	beq.w	414f5e <_svfprintf_r+0xbe6>
  414a58:	2b02      	cmp	r3, #2
  414a5a:	f040 8213 	bne.w	414e84 <_svfprintf_r+0xb0c>
  414a5e:	9812      	ldr	r0, [sp, #72]	; 0x48
  414a60:	464e      	mov	r6, r9
  414a62:	0923      	lsrs	r3, r4, #4
  414a64:	f004 010f 	and.w	r1, r4, #15
  414a68:	ea43 7305 	orr.w	r3, r3, r5, lsl #28
  414a6c:	092a      	lsrs	r2, r5, #4
  414a6e:	461c      	mov	r4, r3
  414a70:	4615      	mov	r5, r2
  414a72:	5c43      	ldrb	r3, [r0, r1]
  414a74:	f806 3d01 	strb.w	r3, [r6, #-1]!
  414a78:	ea54 0305 	orrs.w	r3, r4, r5
  414a7c:	d1f1      	bne.n	414a62 <_svfprintf_r+0x6ea>
  414a7e:	eba9 0306 	sub.w	r3, r9, r6
  414a82:	930a      	str	r3, [sp, #40]	; 0x28
  414a84:	e588      	b.n	414598 <_svfprintf_r+0x220>
  414a86:	930d      	str	r3, [sp, #52]	; 0x34
  414a88:	2a00      	cmp	r2, #0
  414a8a:	f040 86b7 	bne.w	4157fc <_svfprintf_r+0x1484>
  414a8e:	4b84      	ldr	r3, [pc, #528]	; (414ca0 <_svfprintf_r+0x928>)
  414a90:	9312      	str	r3, [sp, #72]	; 0x48
  414a92:	f01b 0f20 	tst.w	fp, #32
  414a96:	f43f aeee 	beq.w	414876 <_svfprintf_r+0x4fe>
  414a9a:	9d0b      	ldr	r5, [sp, #44]	; 0x2c
  414a9c:	3507      	adds	r5, #7
  414a9e:	f025 0307 	bic.w	r3, r5, #7
  414aa2:	f103 0208 	add.w	r2, r3, #8
  414aa6:	f01b 0f01 	tst.w	fp, #1
  414aaa:	920b      	str	r2, [sp, #44]	; 0x2c
  414aac:	e9d3 4500 	ldrd	r4, r5, [r3]
  414ab0:	f47f aef3 	bne.w	41489a <_svfprintf_r+0x522>
  414ab4:	2302      	movs	r3, #2
  414ab6:	e552      	b.n	41455e <_svfprintf_r+0x1e6>
  414ab8:	930d      	str	r3, [sp, #52]	; 0x34
  414aba:	2a00      	cmp	r2, #0
  414abc:	f040 869a 	bne.w	4157f4 <_svfprintf_r+0x147c>
  414ac0:	f04b 0b10 	orr.w	fp, fp, #16
  414ac4:	f01b 0f20 	tst.w	fp, #32
  414ac8:	d0a1      	beq.n	414a0e <_svfprintf_r+0x696>
  414aca:	9d0b      	ldr	r5, [sp, #44]	; 0x2c
  414acc:	3507      	adds	r5, #7
  414ace:	f025 0507 	bic.w	r5, r5, #7
  414ad2:	e9d5 2300 	ldrd	r2, r3, [r5]
  414ad6:	2a00      	cmp	r2, #0
  414ad8:	f105 0108 	add.w	r1, r5, #8
  414adc:	461d      	mov	r5, r3
  414ade:	f173 0300 	sbcs.w	r3, r3, #0
  414ae2:	910b      	str	r1, [sp, #44]	; 0x2c
  414ae4:	4614      	mov	r4, r2
  414ae6:	daa6      	bge.n	414a36 <_svfprintf_r+0x6be>
  414ae8:	272d      	movs	r7, #45	; 0x2d
  414aea:	4264      	negs	r4, r4
  414aec:	eb65 0545 	sbc.w	r5, r5, r5, lsl #1
  414af0:	f88d 706f 	strb.w	r7, [sp, #111]	; 0x6f
  414af4:	2301      	movs	r3, #1
  414af6:	e535      	b.n	414564 <_svfprintf_r+0x1ec>
  414af8:	930d      	str	r3, [sp, #52]	; 0x34
  414afa:	2a00      	cmp	r2, #0
  414afc:	f040 8676 	bne.w	4157ec <_svfprintf_r+0x1474>
  414b00:	9d0b      	ldr	r5, [sp, #44]	; 0x2c
  414b02:	f01b 0f08 	tst.w	fp, #8
  414b06:	f105 0507 	add.w	r5, r5, #7
  414b0a:	f000 83e8 	beq.w	4152de <_svfprintf_r+0xf66>
  414b0e:	f025 0307 	bic.w	r3, r5, #7
  414b12:	ed93 7b00 	vldr	d7, [r3]
  414b16:	ed8d 7b10 	vstr	d7, [sp, #64]	; 0x40
  414b1a:	f103 0208 	add.w	r2, r3, #8
  414b1e:	920b      	str	r2, [sp, #44]	; 0x2c
  414b20:	e9dd 1210 	ldrd	r1, r2, [sp, #64]	; 0x40
  414b24:	f022 4300 	bic.w	r3, r2, #2147483648	; 0x80000000
  414b28:	9116      	str	r1, [sp, #88]	; 0x58
  414b2a:	9317      	str	r3, [sp, #92]	; 0x5c
  414b2c:	e9dd 4516 	ldrd	r4, r5, [sp, #88]	; 0x58
  414b30:	f04f 32ff 	mov.w	r2, #4294967295
  414b34:	4620      	mov	r0, r4
  414b36:	4629      	mov	r1, r5
  414b38:	4b5a      	ldr	r3, [pc, #360]	; (414ca4 <_svfprintf_r+0x92c>)
  414b3a:	f003 f9e7 	bl	417f0c <__aeabi_dcmpun>
  414b3e:	2800      	cmp	r0, #0
  414b40:	f040 834f 	bne.w	4151e2 <_svfprintf_r+0xe6a>
  414b44:	f04f 32ff 	mov.w	r2, #4294967295
  414b48:	4b56      	ldr	r3, [pc, #344]	; (414ca4 <_svfprintf_r+0x92c>)
  414b4a:	4620      	mov	r0, r4
  414b4c:	4629      	mov	r1, r5
  414b4e:	f003 f9bf 	bl	417ed0 <__aeabi_dcmple>
  414b52:	2800      	cmp	r0, #0
  414b54:	f040 8345 	bne.w	4151e2 <_svfprintf_r+0xe6a>
  414b58:	2200      	movs	r2, #0
  414b5a:	2300      	movs	r3, #0
  414b5c:	e9dd 0110 	ldrd	r0, r1, [sp, #64]	; 0x40
  414b60:	f003 f9ac 	bl	417ebc <__aeabi_dcmplt>
  414b64:	2800      	cmp	r0, #0
  414b66:	f040 8533 	bne.w	4155d0 <_svfprintf_r+0x1258>
  414b6a:	f89d 706f 	ldrb.w	r7, [sp, #111]	; 0x6f
  414b6e:	4e4e      	ldr	r6, [pc, #312]	; (414ca8 <_svfprintf_r+0x930>)
  414b70:	4b4e      	ldr	r3, [pc, #312]	; (414cac <_svfprintf_r+0x934>)
  414b72:	f02b 0080 	bic.w	r0, fp, #128	; 0x80
  414b76:	9003      	str	r0, [sp, #12]
  414b78:	980d      	ldr	r0, [sp, #52]	; 0x34
  414b7a:	2203      	movs	r2, #3
  414b7c:	2100      	movs	r1, #0
  414b7e:	9204      	str	r2, [sp, #16]
  414b80:	9106      	str	r1, [sp, #24]
  414b82:	2847      	cmp	r0, #71	; 0x47
  414b84:	bfd8      	it	le
  414b86:	461e      	movle	r6, r3
  414b88:	920a      	str	r2, [sp, #40]	; 0x28
  414b8a:	910e      	str	r1, [sp, #56]	; 0x38
  414b8c:	e50c      	b.n	4145a8 <_svfprintf_r+0x230>
  414b8e:	f04b 0b08 	orr.w	fp, fp, #8
  414b92:	f89a 3000 	ldrb.w	r3, [sl]
  414b96:	e447      	b.n	414428 <_svfprintf_r+0xb0>
  414b98:	f04b 0b10 	orr.w	fp, fp, #16
  414b9c:	930d      	str	r3, [sp, #52]	; 0x34
  414b9e:	f01b 0320 	ands.w	r3, fp, #32
  414ba2:	f43f ae22 	beq.w	4147ea <_svfprintf_r+0x472>
  414ba6:	9d0b      	ldr	r5, [sp, #44]	; 0x2c
  414ba8:	3507      	adds	r5, #7
  414baa:	f025 0307 	bic.w	r3, r5, #7
  414bae:	f103 0208 	add.w	r2, r3, #8
  414bb2:	e9d3 4500 	ldrd	r4, r5, [r3]
  414bb6:	920b      	str	r2, [sp, #44]	; 0x2c
  414bb8:	2300      	movs	r3, #0
  414bba:	e4d0      	b.n	41455e <_svfprintf_r+0x1e6>
  414bbc:	f1a3 0030 	sub.w	r0, r3, #48	; 0x30
  414bc0:	2300      	movs	r3, #0
  414bc2:	461c      	mov	r4, r3
  414bc4:	f81a 3b01 	ldrb.w	r3, [sl], #1
  414bc8:	eb04 0484 	add.w	r4, r4, r4, lsl #2
  414bcc:	eb00 0444 	add.w	r4, r0, r4, lsl #1
  414bd0:	f1a3 0030 	sub.w	r0, r3, #48	; 0x30
  414bd4:	2809      	cmp	r0, #9
  414bd6:	d9f5      	bls.n	414bc4 <_svfprintf_r+0x84c>
  414bd8:	9409      	str	r4, [sp, #36]	; 0x24
  414bda:	e427      	b.n	41442c <_svfprintf_r+0xb4>
  414bdc:	930d      	str	r3, [sp, #52]	; 0x34
  414bde:	2a00      	cmp	r2, #0
  414be0:	f040 85f5 	bne.w	4157ce <_svfprintf_r+0x1456>
  414be4:	9a0d      	ldr	r2, [sp, #52]	; 0x34
  414be6:	2a00      	cmp	r2, #0
  414be8:	f43f ac91 	beq.w	41450e <_svfprintf_r+0x196>
  414bec:	2300      	movs	r3, #0
  414bee:	2101      	movs	r1, #1
  414bf0:	461f      	mov	r7, r3
  414bf2:	9104      	str	r1, [sp, #16]
  414bf4:	f88d 2098 	strb.w	r2, [sp, #152]	; 0x98
  414bf8:	f8cd b00c 	str.w	fp, [sp, #12]
  414bfc:	f88d 306f 	strb.w	r3, [sp, #111]	; 0x6f
  414c00:	9306      	str	r3, [sp, #24]
  414c02:	930e      	str	r3, [sp, #56]	; 0x38
  414c04:	910a      	str	r1, [sp, #40]	; 0x28
  414c06:	ae26      	add	r6, sp, #152	; 0x98
  414c08:	e4d2      	b.n	4145b0 <_svfprintf_r+0x238>
  414c0a:	9c25      	ldr	r4, [sp, #148]	; 0x94
  414c0c:	e529      	b.n	414662 <_svfprintf_r+0x2ea>
  414c0e:	9b0d      	ldr	r3, [sp, #52]	; 0x34
  414c10:	2b65      	cmp	r3, #101	; 0x65
  414c12:	f340 80a9 	ble.w	414d68 <_svfprintf_r+0x9f0>
  414c16:	2200      	movs	r2, #0
  414c18:	2300      	movs	r3, #0
  414c1a:	e9dd 0110 	ldrd	r0, r1, [sp, #64]	; 0x40
  414c1e:	f003 f943 	bl	417ea8 <__aeabi_dcmpeq>
  414c22:	2800      	cmp	r0, #0
  414c24:	f000 8152 	beq.w	414ecc <_svfprintf_r+0xb54>
  414c28:	9b24      	ldr	r3, [sp, #144]	; 0x90
  414c2a:	4a21      	ldr	r2, [pc, #132]	; (414cb0 <_svfprintf_r+0x938>)
  414c2c:	f8c8 2000 	str.w	r2, [r8]
  414c30:	3301      	adds	r3, #1
  414c32:	3401      	adds	r4, #1
  414c34:	2201      	movs	r2, #1
  414c36:	2b07      	cmp	r3, #7
  414c38:	9425      	str	r4, [sp, #148]	; 0x94
  414c3a:	9324      	str	r3, [sp, #144]	; 0x90
  414c3c:	f8c8 2004 	str.w	r2, [r8, #4]
  414c40:	f300 836f 	bgt.w	415322 <_svfprintf_r+0xfaa>
  414c44:	f108 0808 	add.w	r8, r8, #8
  414c48:	9b1d      	ldr	r3, [sp, #116]	; 0x74
  414c4a:	9a0f      	ldr	r2, [sp, #60]	; 0x3c
  414c4c:	9c25      	ldr	r4, [sp, #148]	; 0x94
  414c4e:	4293      	cmp	r3, r2
  414c50:	db03      	blt.n	414c5a <_svfprintf_r+0x8e2>
  414c52:	9b03      	ldr	r3, [sp, #12]
  414c54:	07dd      	lsls	r5, r3, #31
  414c56:	f57f ad76 	bpl.w	414746 <_svfprintf_r+0x3ce>
  414c5a:	9b24      	ldr	r3, [sp, #144]	; 0x90
  414c5c:	9913      	ldr	r1, [sp, #76]	; 0x4c
  414c5e:	9a14      	ldr	r2, [sp, #80]	; 0x50
  414c60:	f8c8 2000 	str.w	r2, [r8]
  414c64:	3301      	adds	r3, #1
  414c66:	440c      	add	r4, r1
  414c68:	2b07      	cmp	r3, #7
  414c6a:	f8c8 1004 	str.w	r1, [r8, #4]
  414c6e:	9425      	str	r4, [sp, #148]	; 0x94
  414c70:	9324      	str	r3, [sp, #144]	; 0x90
  414c72:	f300 83a3 	bgt.w	4153bc <_svfprintf_r+0x1044>
  414c76:	f108 0808 	add.w	r8, r8, #8
  414c7a:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
  414c7c:	1e5e      	subs	r6, r3, #1
  414c7e:	2e00      	cmp	r6, #0
  414c80:	f77f ad61 	ble.w	414746 <_svfprintf_r+0x3ce>
  414c84:	2e10      	cmp	r6, #16
  414c86:	9b24      	ldr	r3, [sp, #144]	; 0x90
  414c88:	4d0a      	ldr	r5, [pc, #40]	; (414cb4 <_svfprintf_r+0x93c>)
  414c8a:	f340 81ef 	ble.w	41506c <_svfprintf_r+0xcf4>
  414c8e:	4622      	mov	r2, r4
  414c90:	2710      	movs	r7, #16
  414c92:	f8dd b020 	ldr.w	fp, [sp, #32]
  414c96:	9c07      	ldr	r4, [sp, #28]
  414c98:	e014      	b.n	414cc4 <_svfprintf_r+0x94c>
  414c9a:	bf00      	nop
  414c9c:	0041d64c 	.word	0x0041d64c
  414ca0:	0041d638 	.word	0x0041d638
  414ca4:	7fefffff 	.word	0x7fefffff
  414ca8:	0041d62c 	.word	0x0041d62c
  414cac:	0041d628 	.word	0x0041d628
  414cb0:	0041d668 	.word	0x0041d668
  414cb4:	0041d67c 	.word	0x0041d67c
  414cb8:	f108 0808 	add.w	r8, r8, #8
  414cbc:	3e10      	subs	r6, #16
  414cbe:	2e10      	cmp	r6, #16
  414cc0:	f340 81d3 	ble.w	41506a <_svfprintf_r+0xcf2>
  414cc4:	3301      	adds	r3, #1
  414cc6:	3210      	adds	r2, #16
  414cc8:	2b07      	cmp	r3, #7
  414cca:	9225      	str	r2, [sp, #148]	; 0x94
  414ccc:	9324      	str	r3, [sp, #144]	; 0x90
  414cce:	e888 00a0 	stmia.w	r8, {r5, r7}
  414cd2:	ddf1      	ble.n	414cb8 <_svfprintf_r+0x940>
  414cd4:	aa23      	add	r2, sp, #140	; 0x8c
  414cd6:	4621      	mov	r1, r4
  414cd8:	4658      	mov	r0, fp
  414cda:	f002 fc7f 	bl	4175dc <__ssprint_r>
  414cde:	2800      	cmp	r0, #0
  414ce0:	f47f ac1c 	bne.w	41451c <_svfprintf_r+0x1a4>
  414ce4:	9a25      	ldr	r2, [sp, #148]	; 0x94
  414ce6:	9b24      	ldr	r3, [sp, #144]	; 0x90
  414ce8:	46c8      	mov	r8, r9
  414cea:	e7e7      	b.n	414cbc <_svfprintf_r+0x944>
  414cec:	9b09      	ldr	r3, [sp, #36]	; 0x24
  414cee:	9a04      	ldr	r2, [sp, #16]
  414cf0:	1a9f      	subs	r7, r3, r2
  414cf2:	2f00      	cmp	r7, #0
  414cf4:	f77f acd8 	ble.w	4146a8 <_svfprintf_r+0x330>
  414cf8:	2f10      	cmp	r7, #16
  414cfa:	9b24      	ldr	r3, [sp, #144]	; 0x90
  414cfc:	4db7      	ldr	r5, [pc, #732]	; (414fdc <_svfprintf_r+0xc64>)
  414cfe:	dd27      	ble.n	414d50 <_svfprintf_r+0x9d8>
  414d00:	4642      	mov	r2, r8
  414d02:	4621      	mov	r1, r4
  414d04:	46b0      	mov	r8, r6
  414d06:	f04f 0b10 	mov.w	fp, #16
  414d0a:	462e      	mov	r6, r5
  414d0c:	9c08      	ldr	r4, [sp, #32]
  414d0e:	9d07      	ldr	r5, [sp, #28]
  414d10:	e004      	b.n	414d1c <_svfprintf_r+0x9a4>
  414d12:	3f10      	subs	r7, #16
  414d14:	2f10      	cmp	r7, #16
  414d16:	f102 0208 	add.w	r2, r2, #8
  414d1a:	dd15      	ble.n	414d48 <_svfprintf_r+0x9d0>
  414d1c:	3301      	adds	r3, #1
  414d1e:	3110      	adds	r1, #16
  414d20:	2b07      	cmp	r3, #7
  414d22:	9125      	str	r1, [sp, #148]	; 0x94
  414d24:	9324      	str	r3, [sp, #144]	; 0x90
  414d26:	e882 0840 	stmia.w	r2, {r6, fp}
  414d2a:	ddf2      	ble.n	414d12 <_svfprintf_r+0x99a>
  414d2c:	aa23      	add	r2, sp, #140	; 0x8c
  414d2e:	4629      	mov	r1, r5
  414d30:	4620      	mov	r0, r4
  414d32:	f002 fc53 	bl	4175dc <__ssprint_r>
  414d36:	2800      	cmp	r0, #0
  414d38:	f47f abf0 	bne.w	41451c <_svfprintf_r+0x1a4>
  414d3c:	3f10      	subs	r7, #16
  414d3e:	2f10      	cmp	r7, #16
  414d40:	9925      	ldr	r1, [sp, #148]	; 0x94
  414d42:	9b24      	ldr	r3, [sp, #144]	; 0x90
  414d44:	464a      	mov	r2, r9
  414d46:	dce9      	bgt.n	414d1c <_svfprintf_r+0x9a4>
  414d48:	4635      	mov	r5, r6
  414d4a:	460c      	mov	r4, r1
  414d4c:	4646      	mov	r6, r8
  414d4e:	4690      	mov	r8, r2
  414d50:	3301      	adds	r3, #1
  414d52:	443c      	add	r4, r7
  414d54:	2b07      	cmp	r3, #7
  414d56:	9425      	str	r4, [sp, #148]	; 0x94
  414d58:	9324      	str	r3, [sp, #144]	; 0x90
  414d5a:	e888 00a0 	stmia.w	r8, {r5, r7}
  414d5e:	f300 8234 	bgt.w	4151ca <_svfprintf_r+0xe52>
  414d62:	f108 0808 	add.w	r8, r8, #8
  414d66:	e49f      	b.n	4146a8 <_svfprintf_r+0x330>
  414d68:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
  414d6a:	9f24      	ldr	r7, [sp, #144]	; 0x90
  414d6c:	2b01      	cmp	r3, #1
  414d6e:	f340 8200 	ble.w	415172 <_svfprintf_r+0xdfa>
  414d72:	3701      	adds	r7, #1
  414d74:	3401      	adds	r4, #1
  414d76:	2301      	movs	r3, #1
  414d78:	2f07      	cmp	r7, #7
  414d7a:	9425      	str	r4, [sp, #148]	; 0x94
  414d7c:	9724      	str	r7, [sp, #144]	; 0x90
  414d7e:	f8c8 6000 	str.w	r6, [r8]
  414d82:	f8c8 3004 	str.w	r3, [r8, #4]
  414d86:	f300 8205 	bgt.w	415194 <_svfprintf_r+0xe1c>
  414d8a:	f108 0808 	add.w	r8, r8, #8
  414d8e:	9a13      	ldr	r2, [sp, #76]	; 0x4c
  414d90:	9b14      	ldr	r3, [sp, #80]	; 0x50
  414d92:	f8c8 3000 	str.w	r3, [r8]
  414d96:	3701      	adds	r7, #1
  414d98:	4414      	add	r4, r2
  414d9a:	2f07      	cmp	r7, #7
  414d9c:	9425      	str	r4, [sp, #148]	; 0x94
  414d9e:	9724      	str	r7, [sp, #144]	; 0x90
  414da0:	f8c8 2004 	str.w	r2, [r8, #4]
  414da4:	f300 8202 	bgt.w	4151ac <_svfprintf_r+0xe34>
  414da8:	f108 0808 	add.w	r8, r8, #8
  414dac:	2300      	movs	r3, #0
  414dae:	2200      	movs	r2, #0
  414db0:	e9dd 0110 	ldrd	r0, r1, [sp, #64]	; 0x40
  414db4:	f003 f878 	bl	417ea8 <__aeabi_dcmpeq>
  414db8:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
  414dba:	2800      	cmp	r0, #0
  414dbc:	f040 8101 	bne.w	414fc2 <_svfprintf_r+0xc4a>
  414dc0:	3b01      	subs	r3, #1
  414dc2:	3701      	adds	r7, #1
  414dc4:	3601      	adds	r6, #1
  414dc6:	441c      	add	r4, r3
  414dc8:	2f07      	cmp	r7, #7
  414dca:	9724      	str	r7, [sp, #144]	; 0x90
  414dcc:	9425      	str	r4, [sp, #148]	; 0x94
  414dce:	f8c8 6000 	str.w	r6, [r8]
  414dd2:	f8c8 3004 	str.w	r3, [r8, #4]
  414dd6:	f300 8128 	bgt.w	41502a <_svfprintf_r+0xcb2>
  414dda:	f108 0808 	add.w	r8, r8, #8
  414dde:	9a15      	ldr	r2, [sp, #84]	; 0x54
  414de0:	f8c8 2004 	str.w	r2, [r8, #4]
  414de4:	3701      	adds	r7, #1
  414de6:	4414      	add	r4, r2
  414de8:	ab1f      	add	r3, sp, #124	; 0x7c
  414dea:	2f07      	cmp	r7, #7
  414dec:	9425      	str	r4, [sp, #148]	; 0x94
  414dee:	9724      	str	r7, [sp, #144]	; 0x90
  414df0:	f8c8 3000 	str.w	r3, [r8]
  414df4:	f77f aca5 	ble.w	414742 <_svfprintf_r+0x3ca>
  414df8:	aa23      	add	r2, sp, #140	; 0x8c
  414dfa:	9907      	ldr	r1, [sp, #28]
  414dfc:	9808      	ldr	r0, [sp, #32]
  414dfe:	f002 fbed 	bl	4175dc <__ssprint_r>
  414e02:	2800      	cmp	r0, #0
  414e04:	f47f ab8a 	bne.w	41451c <_svfprintf_r+0x1a4>
  414e08:	9c25      	ldr	r4, [sp, #148]	; 0x94
  414e0a:	46c8      	mov	r8, r9
  414e0c:	e49b      	b.n	414746 <_svfprintf_r+0x3ce>
  414e0e:	aa23      	add	r2, sp, #140	; 0x8c
  414e10:	9907      	ldr	r1, [sp, #28]
  414e12:	9808      	ldr	r0, [sp, #32]
  414e14:	f002 fbe2 	bl	4175dc <__ssprint_r>
  414e18:	2800      	cmp	r0, #0
  414e1a:	f43f acdd 	beq.w	4147d8 <_svfprintf_r+0x460>
  414e1e:	f7ff bb7d 	b.w	41451c <_svfprintf_r+0x1a4>
  414e22:	f8dd b00c 	ldr.w	fp, [sp, #12]
  414e26:	2b01      	cmp	r3, #1
  414e28:	f000 8135 	beq.w	415096 <_svfprintf_r+0xd1e>
  414e2c:	2b02      	cmp	r3, #2
  414e2e:	d125      	bne.n	414e7c <_svfprintf_r+0xb04>
  414e30:	f8cd b00c 	str.w	fp, [sp, #12]
  414e34:	2400      	movs	r4, #0
  414e36:	2500      	movs	r5, #0
  414e38:	e611      	b.n	414a5e <_svfprintf_r+0x6e6>
  414e3a:	aa23      	add	r2, sp, #140	; 0x8c
  414e3c:	9907      	ldr	r1, [sp, #28]
  414e3e:	9808      	ldr	r0, [sp, #32]
  414e40:	f002 fbcc 	bl	4175dc <__ssprint_r>
  414e44:	2800      	cmp	r0, #0
  414e46:	f47f ab69 	bne.w	41451c <_svfprintf_r+0x1a4>
  414e4a:	9c25      	ldr	r4, [sp, #148]	; 0x94
  414e4c:	46c8      	mov	r8, r9
  414e4e:	e467      	b.n	414720 <_svfprintf_r+0x3a8>
  414e50:	aa23      	add	r2, sp, #140	; 0x8c
  414e52:	9907      	ldr	r1, [sp, #28]
  414e54:	9808      	ldr	r0, [sp, #32]
  414e56:	f002 fbc1 	bl	4175dc <__ssprint_r>
  414e5a:	2800      	cmp	r0, #0
  414e5c:	f47f ab5e 	bne.w	41451c <_svfprintf_r+0x1a4>
  414e60:	9c25      	ldr	r4, [sp, #148]	; 0x94
  414e62:	46c8      	mov	r8, r9
  414e64:	e41d      	b.n	4146a2 <_svfprintf_r+0x32a>
  414e66:	aa23      	add	r2, sp, #140	; 0x8c
  414e68:	9907      	ldr	r1, [sp, #28]
  414e6a:	9808      	ldr	r0, [sp, #32]
  414e6c:	f002 fbb6 	bl	4175dc <__ssprint_r>
  414e70:	2800      	cmp	r0, #0
  414e72:	f47f ab53 	bne.w	41451c <_svfprintf_r+0x1a4>
  414e76:	9c25      	ldr	r4, [sp, #148]	; 0x94
  414e78:	46c8      	mov	r8, r9
  414e7a:	e402      	b.n	414682 <_svfprintf_r+0x30a>
  414e7c:	f8cd b00c 	str.w	fp, [sp, #12]
  414e80:	2400      	movs	r4, #0
  414e82:	2500      	movs	r5, #0
  414e84:	4649      	mov	r1, r9
  414e86:	e000      	b.n	414e8a <_svfprintf_r+0xb12>
  414e88:	4631      	mov	r1, r6
  414e8a:	08e2      	lsrs	r2, r4, #3
  414e8c:	ea42 7245 	orr.w	r2, r2, r5, lsl #29
  414e90:	08e8      	lsrs	r0, r5, #3
  414e92:	f004 0307 	and.w	r3, r4, #7
  414e96:	4605      	mov	r5, r0
  414e98:	4614      	mov	r4, r2
  414e9a:	3330      	adds	r3, #48	; 0x30
  414e9c:	ea54 0205 	orrs.w	r2, r4, r5
  414ea0:	f801 3c01 	strb.w	r3, [r1, #-1]
  414ea4:	f101 36ff 	add.w	r6, r1, #4294967295
  414ea8:	d1ee      	bne.n	414e88 <_svfprintf_r+0xb10>
  414eaa:	9a03      	ldr	r2, [sp, #12]
  414eac:	07d2      	lsls	r2, r2, #31
  414eae:	f57f ade6 	bpl.w	414a7e <_svfprintf_r+0x706>
  414eb2:	2b30      	cmp	r3, #48	; 0x30
  414eb4:	f43f ade3 	beq.w	414a7e <_svfprintf_r+0x706>
  414eb8:	3902      	subs	r1, #2
  414eba:	2330      	movs	r3, #48	; 0x30
  414ebc:	f806 3c01 	strb.w	r3, [r6, #-1]
  414ec0:	eba9 0301 	sub.w	r3, r9, r1
  414ec4:	930a      	str	r3, [sp, #40]	; 0x28
  414ec6:	460e      	mov	r6, r1
  414ec8:	f7ff bb66 	b.w	414598 <_svfprintf_r+0x220>
  414ecc:	991d      	ldr	r1, [sp, #116]	; 0x74
  414ece:	2900      	cmp	r1, #0
  414ed0:	f340 8231 	ble.w	415336 <_svfprintf_r+0xfbe>
  414ed4:	9b0e      	ldr	r3, [sp, #56]	; 0x38
  414ed6:	9a0f      	ldr	r2, [sp, #60]	; 0x3c
  414ed8:	4293      	cmp	r3, r2
  414eda:	bfa8      	it	ge
  414edc:	4613      	movge	r3, r2
  414ede:	2b00      	cmp	r3, #0
  414ee0:	461f      	mov	r7, r3
  414ee2:	dd0d      	ble.n	414f00 <_svfprintf_r+0xb88>
  414ee4:	9b24      	ldr	r3, [sp, #144]	; 0x90
  414ee6:	f8c8 6000 	str.w	r6, [r8]
  414eea:	3301      	adds	r3, #1
  414eec:	443c      	add	r4, r7
  414eee:	2b07      	cmp	r3, #7
  414ef0:	9425      	str	r4, [sp, #148]	; 0x94
  414ef2:	f8c8 7004 	str.w	r7, [r8, #4]
  414ef6:	9324      	str	r3, [sp, #144]	; 0x90
  414ef8:	f300 8321 	bgt.w	41553e <_svfprintf_r+0x11c6>
  414efc:	f108 0808 	add.w	r8, r8, #8
  414f00:	9b0e      	ldr	r3, [sp, #56]	; 0x38
  414f02:	2f00      	cmp	r7, #0
  414f04:	bfa8      	it	ge
  414f06:	1bdb      	subge	r3, r3, r7
  414f08:	2b00      	cmp	r3, #0
  414f0a:	461f      	mov	r7, r3
  414f0c:	f340 80d7 	ble.w	4150be <_svfprintf_r+0xd46>
  414f10:	2f10      	cmp	r7, #16
  414f12:	9b24      	ldr	r3, [sp, #144]	; 0x90
  414f14:	4d31      	ldr	r5, [pc, #196]	; (414fdc <_svfprintf_r+0xc64>)
  414f16:	f340 81f0 	ble.w	4152fa <_svfprintf_r+0xf82>
  414f1a:	4642      	mov	r2, r8
  414f1c:	4621      	mov	r1, r4
  414f1e:	46b0      	mov	r8, r6
  414f20:	f04f 0b10 	mov.w	fp, #16
  414f24:	462e      	mov	r6, r5
  414f26:	9c08      	ldr	r4, [sp, #32]
  414f28:	9d07      	ldr	r5, [sp, #28]
  414f2a:	e004      	b.n	414f36 <_svfprintf_r+0xbbe>
  414f2c:	3208      	adds	r2, #8
  414f2e:	3f10      	subs	r7, #16
  414f30:	2f10      	cmp	r7, #16
  414f32:	f340 81de 	ble.w	4152f2 <_svfprintf_r+0xf7a>
  414f36:	3301      	adds	r3, #1
  414f38:	3110      	adds	r1, #16
  414f3a:	2b07      	cmp	r3, #7
  414f3c:	9125      	str	r1, [sp, #148]	; 0x94
  414f3e:	9324      	str	r3, [sp, #144]	; 0x90
  414f40:	e882 0840 	stmia.w	r2, {r6, fp}
  414f44:	ddf2      	ble.n	414f2c <_svfprintf_r+0xbb4>
  414f46:	aa23      	add	r2, sp, #140	; 0x8c
  414f48:	4629      	mov	r1, r5
  414f4a:	4620      	mov	r0, r4
  414f4c:	f002 fb46 	bl	4175dc <__ssprint_r>
  414f50:	2800      	cmp	r0, #0
  414f52:	f47f aae3 	bne.w	41451c <_svfprintf_r+0x1a4>
  414f56:	9925      	ldr	r1, [sp, #148]	; 0x94
  414f58:	9b24      	ldr	r3, [sp, #144]	; 0x90
  414f5a:	464a      	mov	r2, r9
  414f5c:	e7e7      	b.n	414f2e <_svfprintf_r+0xbb6>
  414f5e:	2d00      	cmp	r5, #0
  414f60:	bf08      	it	eq
  414f62:	2c0a      	cmpeq	r4, #10
  414f64:	f0c0 8095 	bcc.w	415092 <_svfprintf_r+0xd1a>
  414f68:	464e      	mov	r6, r9
  414f6a:	4620      	mov	r0, r4
  414f6c:	4629      	mov	r1, r5
  414f6e:	220a      	movs	r2, #10
  414f70:	2300      	movs	r3, #0
  414f72:	f7fe fe81 	bl	413c78 <__aeabi_uldivmod>
  414f76:	3230      	adds	r2, #48	; 0x30
  414f78:	f806 2d01 	strb.w	r2, [r6, #-1]!
  414f7c:	4620      	mov	r0, r4
  414f7e:	4629      	mov	r1, r5
  414f80:	2300      	movs	r3, #0
  414f82:	220a      	movs	r2, #10
  414f84:	f7fe fe78 	bl	413c78 <__aeabi_uldivmod>
  414f88:	4604      	mov	r4, r0
  414f8a:	460d      	mov	r5, r1
  414f8c:	ea54 0305 	orrs.w	r3, r4, r5
  414f90:	d1eb      	bne.n	414f6a <_svfprintf_r+0xbf2>
  414f92:	eba9 0306 	sub.w	r3, r9, r6
  414f96:	930a      	str	r3, [sp, #40]	; 0x28
  414f98:	f7ff bafe 	b.w	414598 <_svfprintf_r+0x220>
  414f9c:	9b06      	ldr	r3, [sp, #24]
  414f9e:	930a      	str	r3, [sp, #40]	; 0x28
  414fa0:	464e      	mov	r6, r9
  414fa2:	f7ff baf9 	b.w	414598 <_svfprintf_r+0x220>
  414fa6:	aa23      	add	r2, sp, #140	; 0x8c
  414fa8:	9907      	ldr	r1, [sp, #28]
  414faa:	9808      	ldr	r0, [sp, #32]
  414fac:	f002 fb16 	bl	4175dc <__ssprint_r>
  414fb0:	2800      	cmp	r0, #0
  414fb2:	f47f aab3 	bne.w	41451c <_svfprintf_r+0x1a4>
  414fb6:	f89d 706f 	ldrb.w	r7, [sp, #111]	; 0x6f
  414fba:	9c25      	ldr	r4, [sp, #148]	; 0x94
  414fbc:	46c8      	mov	r8, r9
  414fbe:	f7ff bb50 	b.w	414662 <_svfprintf_r+0x2ea>
  414fc2:	1e5e      	subs	r6, r3, #1
  414fc4:	2e00      	cmp	r6, #0
  414fc6:	f77f af0a 	ble.w	414dde <_svfprintf_r+0xa66>
  414fca:	2e10      	cmp	r6, #16
  414fcc:	4d03      	ldr	r5, [pc, #12]	; (414fdc <_svfprintf_r+0xc64>)
  414fce:	dd23      	ble.n	415018 <_svfprintf_r+0xca0>
  414fd0:	4622      	mov	r2, r4
  414fd2:	f04f 0b10 	mov.w	fp, #16
  414fd6:	9c08      	ldr	r4, [sp, #32]
  414fd8:	e007      	b.n	414fea <_svfprintf_r+0xc72>
  414fda:	bf00      	nop
  414fdc:	0041d67c 	.word	0x0041d67c
  414fe0:	3e10      	subs	r6, #16
  414fe2:	2e10      	cmp	r6, #16
  414fe4:	f108 0808 	add.w	r8, r8, #8
  414fe8:	dd15      	ble.n	415016 <_svfprintf_r+0xc9e>
  414fea:	3701      	adds	r7, #1
  414fec:	3210      	adds	r2, #16
  414fee:	2f07      	cmp	r7, #7
  414ff0:	9225      	str	r2, [sp, #148]	; 0x94
  414ff2:	9724      	str	r7, [sp, #144]	; 0x90
  414ff4:	e888 0820 	stmia.w	r8, {r5, fp}
  414ff8:	ddf2      	ble.n	414fe0 <_svfprintf_r+0xc68>
  414ffa:	aa23      	add	r2, sp, #140	; 0x8c
  414ffc:	9907      	ldr	r1, [sp, #28]
  414ffe:	4620      	mov	r0, r4
  415000:	f002 faec 	bl	4175dc <__ssprint_r>
  415004:	2800      	cmp	r0, #0
  415006:	f47f aa89 	bne.w	41451c <_svfprintf_r+0x1a4>
  41500a:	3e10      	subs	r6, #16
  41500c:	2e10      	cmp	r6, #16
  41500e:	9a25      	ldr	r2, [sp, #148]	; 0x94
  415010:	9f24      	ldr	r7, [sp, #144]	; 0x90
  415012:	46c8      	mov	r8, r9
  415014:	dce9      	bgt.n	414fea <_svfprintf_r+0xc72>
  415016:	4614      	mov	r4, r2
  415018:	3701      	adds	r7, #1
  41501a:	4434      	add	r4, r6
  41501c:	2f07      	cmp	r7, #7
  41501e:	9425      	str	r4, [sp, #148]	; 0x94
  415020:	9724      	str	r7, [sp, #144]	; 0x90
  415022:	e888 0060 	stmia.w	r8, {r5, r6}
  415026:	f77f aed8 	ble.w	414dda <_svfprintf_r+0xa62>
  41502a:	aa23      	add	r2, sp, #140	; 0x8c
  41502c:	9907      	ldr	r1, [sp, #28]
  41502e:	9808      	ldr	r0, [sp, #32]
  415030:	f002 fad4 	bl	4175dc <__ssprint_r>
  415034:	2800      	cmp	r0, #0
  415036:	f47f aa71 	bne.w	41451c <_svfprintf_r+0x1a4>
  41503a:	9c25      	ldr	r4, [sp, #148]	; 0x94
  41503c:	9f24      	ldr	r7, [sp, #144]	; 0x90
  41503e:	46c8      	mov	r8, r9
  415040:	e6cd      	b.n	414dde <_svfprintf_r+0xa66>
  415042:	681c      	ldr	r4, [r3, #0]
  415044:	3304      	adds	r3, #4
  415046:	930b      	str	r3, [sp, #44]	; 0x2c
  415048:	2500      	movs	r5, #0
  41504a:	e422      	b.n	414892 <_svfprintf_r+0x51a>
  41504c:	990b      	ldr	r1, [sp, #44]	; 0x2c
  41504e:	460a      	mov	r2, r1
  415050:	3204      	adds	r2, #4
  415052:	680c      	ldr	r4, [r1, #0]
  415054:	920b      	str	r2, [sp, #44]	; 0x2c
  415056:	2500      	movs	r5, #0
  415058:	f7ff ba81 	b.w	41455e <_svfprintf_r+0x1e6>
  41505c:	3204      	adds	r2, #4
  41505e:	681c      	ldr	r4, [r3, #0]
  415060:	920b      	str	r2, [sp, #44]	; 0x2c
  415062:	2301      	movs	r3, #1
  415064:	2500      	movs	r5, #0
  415066:	f7ff ba7a 	b.w	41455e <_svfprintf_r+0x1e6>
  41506a:	4614      	mov	r4, r2
  41506c:	3301      	adds	r3, #1
  41506e:	4434      	add	r4, r6
  415070:	2b07      	cmp	r3, #7
  415072:	9425      	str	r4, [sp, #148]	; 0x94
  415074:	9324      	str	r3, [sp, #144]	; 0x90
  415076:	e888 0060 	stmia.w	r8, {r5, r6}
  41507a:	f77f ab62 	ble.w	414742 <_svfprintf_r+0x3ca>
  41507e:	e6bb      	b.n	414df8 <_svfprintf_r+0xa80>
  415080:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
  415082:	6814      	ldr	r4, [r2, #0]
  415084:	4613      	mov	r3, r2
  415086:	3304      	adds	r3, #4
  415088:	17e5      	asrs	r5, r4, #31
  41508a:	930b      	str	r3, [sp, #44]	; 0x2c
  41508c:	4622      	mov	r2, r4
  41508e:	462b      	mov	r3, r5
  415090:	e4cd      	b.n	414a2e <_svfprintf_r+0x6b6>
  415092:	f8dd b00c 	ldr.w	fp, [sp, #12]
  415096:	f8cd b00c 	str.w	fp, [sp, #12]
  41509a:	ae40      	add	r6, sp, #256	; 0x100
  41509c:	3430      	adds	r4, #48	; 0x30
  41509e:	2301      	movs	r3, #1
  4150a0:	f806 4d41 	strb.w	r4, [r6, #-65]!
  4150a4:	930a      	str	r3, [sp, #40]	; 0x28
  4150a6:	f7ff ba77 	b.w	414598 <_svfprintf_r+0x220>
  4150aa:	aa23      	add	r2, sp, #140	; 0x8c
  4150ac:	9907      	ldr	r1, [sp, #28]
  4150ae:	9808      	ldr	r0, [sp, #32]
  4150b0:	f002 fa94 	bl	4175dc <__ssprint_r>
  4150b4:	2800      	cmp	r0, #0
  4150b6:	f47f aa31 	bne.w	41451c <_svfprintf_r+0x1a4>
  4150ba:	9c25      	ldr	r4, [sp, #148]	; 0x94
  4150bc:	46c8      	mov	r8, r9
  4150be:	9a1d      	ldr	r2, [sp, #116]	; 0x74
  4150c0:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
  4150c2:	429a      	cmp	r2, r3
  4150c4:	db44      	blt.n	415150 <_svfprintf_r+0xdd8>
  4150c6:	9b03      	ldr	r3, [sp, #12]
  4150c8:	07d9      	lsls	r1, r3, #31
  4150ca:	d441      	bmi.n	415150 <_svfprintf_r+0xdd8>
  4150cc:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
  4150ce:	980e      	ldr	r0, [sp, #56]	; 0x38
  4150d0:	1a9a      	subs	r2, r3, r2
  4150d2:	1a1d      	subs	r5, r3, r0
  4150d4:	4295      	cmp	r5, r2
  4150d6:	bfa8      	it	ge
  4150d8:	4615      	movge	r5, r2
  4150da:	2d00      	cmp	r5, #0
  4150dc:	dd0e      	ble.n	4150fc <_svfprintf_r+0xd84>
  4150de:	9924      	ldr	r1, [sp, #144]	; 0x90
  4150e0:	f8c8 5004 	str.w	r5, [r8, #4]
  4150e4:	3101      	adds	r1, #1
  4150e6:	4406      	add	r6, r0
  4150e8:	442c      	add	r4, r5
  4150ea:	2907      	cmp	r1, #7
  4150ec:	f8c8 6000 	str.w	r6, [r8]
  4150f0:	9425      	str	r4, [sp, #148]	; 0x94
  4150f2:	9124      	str	r1, [sp, #144]	; 0x90
  4150f4:	f300 823a 	bgt.w	41556c <_svfprintf_r+0x11f4>
  4150f8:	f108 0808 	add.w	r8, r8, #8
  4150fc:	2d00      	cmp	r5, #0
  4150fe:	bfac      	ite	ge
  415100:	1b56      	subge	r6, r2, r5
  415102:	4616      	movlt	r6, r2
  415104:	2e00      	cmp	r6, #0
  415106:	f77f ab1e 	ble.w	414746 <_svfprintf_r+0x3ce>
  41510a:	2e10      	cmp	r6, #16
  41510c:	9b24      	ldr	r3, [sp, #144]	; 0x90
  41510e:	4db1      	ldr	r5, [pc, #708]	; (4153d4 <_svfprintf_r+0x105c>)
  415110:	ddac      	ble.n	41506c <_svfprintf_r+0xcf4>
  415112:	4622      	mov	r2, r4
  415114:	2710      	movs	r7, #16
  415116:	f8dd b020 	ldr.w	fp, [sp, #32]
  41511a:	9c07      	ldr	r4, [sp, #28]
  41511c:	e004      	b.n	415128 <_svfprintf_r+0xdb0>
  41511e:	f108 0808 	add.w	r8, r8, #8
  415122:	3e10      	subs	r6, #16
  415124:	2e10      	cmp	r6, #16
  415126:	dda0      	ble.n	41506a <_svfprintf_r+0xcf2>
  415128:	3301      	adds	r3, #1
  41512a:	3210      	adds	r2, #16
  41512c:	2b07      	cmp	r3, #7
  41512e:	9225      	str	r2, [sp, #148]	; 0x94
  415130:	9324      	str	r3, [sp, #144]	; 0x90
  415132:	e888 00a0 	stmia.w	r8, {r5, r7}
  415136:	ddf2      	ble.n	41511e <_svfprintf_r+0xda6>
  415138:	aa23      	add	r2, sp, #140	; 0x8c
  41513a:	4621      	mov	r1, r4
  41513c:	4658      	mov	r0, fp
  41513e:	f002 fa4d 	bl	4175dc <__ssprint_r>
  415142:	2800      	cmp	r0, #0
  415144:	f47f a9ea 	bne.w	41451c <_svfprintf_r+0x1a4>
  415148:	9a25      	ldr	r2, [sp, #148]	; 0x94
  41514a:	9b24      	ldr	r3, [sp, #144]	; 0x90
  41514c:	46c8      	mov	r8, r9
  41514e:	e7e8      	b.n	415122 <_svfprintf_r+0xdaa>
  415150:	9b24      	ldr	r3, [sp, #144]	; 0x90
  415152:	9813      	ldr	r0, [sp, #76]	; 0x4c
  415154:	9914      	ldr	r1, [sp, #80]	; 0x50
  415156:	f8c8 1000 	str.w	r1, [r8]
  41515a:	3301      	adds	r3, #1
  41515c:	4404      	add	r4, r0
  41515e:	2b07      	cmp	r3, #7
  415160:	9425      	str	r4, [sp, #148]	; 0x94
  415162:	f8c8 0004 	str.w	r0, [r8, #4]
  415166:	9324      	str	r3, [sp, #144]	; 0x90
  415168:	f300 81f4 	bgt.w	415554 <_svfprintf_r+0x11dc>
  41516c:	f108 0808 	add.w	r8, r8, #8
  415170:	e7ac      	b.n	4150cc <_svfprintf_r+0xd54>
  415172:	9b03      	ldr	r3, [sp, #12]
  415174:	07da      	lsls	r2, r3, #31
  415176:	f53f adfc 	bmi.w	414d72 <_svfprintf_r+0x9fa>
  41517a:	3701      	adds	r7, #1
  41517c:	3401      	adds	r4, #1
  41517e:	2301      	movs	r3, #1
  415180:	2f07      	cmp	r7, #7
  415182:	9425      	str	r4, [sp, #148]	; 0x94
  415184:	9724      	str	r7, [sp, #144]	; 0x90
  415186:	f8c8 6000 	str.w	r6, [r8]
  41518a:	f8c8 3004 	str.w	r3, [r8, #4]
  41518e:	f77f ae24 	ble.w	414dda <_svfprintf_r+0xa62>
  415192:	e74a      	b.n	41502a <_svfprintf_r+0xcb2>
  415194:	aa23      	add	r2, sp, #140	; 0x8c
  415196:	9907      	ldr	r1, [sp, #28]
  415198:	9808      	ldr	r0, [sp, #32]
  41519a:	f002 fa1f 	bl	4175dc <__ssprint_r>
  41519e:	2800      	cmp	r0, #0
  4151a0:	f47f a9bc 	bne.w	41451c <_svfprintf_r+0x1a4>
  4151a4:	9c25      	ldr	r4, [sp, #148]	; 0x94
  4151a6:	9f24      	ldr	r7, [sp, #144]	; 0x90
  4151a8:	46c8      	mov	r8, r9
  4151aa:	e5f0      	b.n	414d8e <_svfprintf_r+0xa16>
  4151ac:	aa23      	add	r2, sp, #140	; 0x8c
  4151ae:	9907      	ldr	r1, [sp, #28]
  4151b0:	9808      	ldr	r0, [sp, #32]
  4151b2:	f002 fa13 	bl	4175dc <__ssprint_r>
  4151b6:	2800      	cmp	r0, #0
  4151b8:	f47f a9b0 	bne.w	41451c <_svfprintf_r+0x1a4>
  4151bc:	9c25      	ldr	r4, [sp, #148]	; 0x94
  4151be:	9f24      	ldr	r7, [sp, #144]	; 0x90
  4151c0:	46c8      	mov	r8, r9
  4151c2:	e5f3      	b.n	414dac <_svfprintf_r+0xa34>
  4151c4:	464e      	mov	r6, r9
  4151c6:	f7ff b9e7 	b.w	414598 <_svfprintf_r+0x220>
  4151ca:	aa23      	add	r2, sp, #140	; 0x8c
  4151cc:	9907      	ldr	r1, [sp, #28]
  4151ce:	9808      	ldr	r0, [sp, #32]
  4151d0:	f002 fa04 	bl	4175dc <__ssprint_r>
  4151d4:	2800      	cmp	r0, #0
  4151d6:	f47f a9a1 	bne.w	41451c <_svfprintf_r+0x1a4>
  4151da:	9c25      	ldr	r4, [sp, #148]	; 0x94
  4151dc:	46c8      	mov	r8, r9
  4151de:	f7ff ba63 	b.w	4146a8 <_svfprintf_r+0x330>
  4151e2:	e9dd 0110 	ldrd	r0, r1, [sp, #64]	; 0x40
  4151e6:	4602      	mov	r2, r0
  4151e8:	460b      	mov	r3, r1
  4151ea:	f002 fe8f 	bl	417f0c <__aeabi_dcmpun>
  4151ee:	2800      	cmp	r0, #0
  4151f0:	f040 8298 	bne.w	415724 <_svfprintf_r+0x13ac>
  4151f4:	9b06      	ldr	r3, [sp, #24]
  4151f6:	3301      	adds	r3, #1
  4151f8:	9b0d      	ldr	r3, [sp, #52]	; 0x34
  4151fa:	f023 0720 	bic.w	r7, r3, #32
  4151fe:	f000 81d2 	beq.w	4155a6 <_svfprintf_r+0x122e>
  415202:	2f47      	cmp	r7, #71	; 0x47
  415204:	f000 8120 	beq.w	415448 <_svfprintf_r+0x10d0>
  415208:	9b11      	ldr	r3, [sp, #68]	; 0x44
  41520a:	f44b 7280 	orr.w	r2, fp, #256	; 0x100
  41520e:	2b00      	cmp	r3, #0
  415210:	9203      	str	r2, [sp, #12]
  415212:	f2c0 81f0 	blt.w	4155f6 <_svfprintf_r+0x127e>
  415216:	ed9d 7b10 	vldr	d7, [sp, #64]	; 0x40
  41521a:	ed8d 7b18 	vstr	d7, [sp, #96]	; 0x60
  41521e:	2300      	movs	r3, #0
  415220:	930c      	str	r3, [sp, #48]	; 0x30
  415222:	9b0d      	ldr	r3, [sp, #52]	; 0x34
  415224:	2b66      	cmp	r3, #102	; 0x66
  415226:	f000 81c1 	beq.w	4155ac <_svfprintf_r+0x1234>
  41522a:	2b46      	cmp	r3, #70	; 0x46
  41522c:	f000 80f1 	beq.w	415412 <_svfprintf_r+0x109a>
  415230:	2f45      	cmp	r7, #69	; 0x45
  415232:	bf0c      	ite	eq
  415234:	9b06      	ldreq	r3, [sp, #24]
  415236:	9d06      	ldrne	r5, [sp, #24]
  415238:	9808      	ldr	r0, [sp, #32]
  41523a:	bf08      	it	eq
  41523c:	1c5d      	addeq	r5, r3, #1
  41523e:	aa21      	add	r2, sp, #132	; 0x84
  415240:	ab1e      	add	r3, sp, #120	; 0x78
  415242:	9201      	str	r2, [sp, #4]
  415244:	9300      	str	r3, [sp, #0]
  415246:	462a      	mov	r2, r5
  415248:	ab1d      	add	r3, sp, #116	; 0x74
  41524a:	2102      	movs	r1, #2
  41524c:	ed9d 0b18 	vldr	d0, [sp, #96]	; 0x60
  415250:	f000 fbca 	bl	4159e8 <_dtoa_r>
  415254:	9b0d      	ldr	r3, [sp, #52]	; 0x34
  415256:	2b67      	cmp	r3, #103	; 0x67
  415258:	4606      	mov	r6, r0
  41525a:	f040 81d5 	bne.w	415608 <_svfprintf_r+0x1290>
  41525e:	f01b 0f01 	tst.w	fp, #1
  415262:	f000 824e 	beq.w	415702 <_svfprintf_r+0x138a>
  415266:	1974      	adds	r4, r6, r5
  415268:	2200      	movs	r2, #0
  41526a:	2300      	movs	r3, #0
  41526c:	e9dd 0118 	ldrd	r0, r1, [sp, #96]	; 0x60
  415270:	f002 fe1a 	bl	417ea8 <__aeabi_dcmpeq>
  415274:	2800      	cmp	r0, #0
  415276:	f040 8160 	bne.w	41553a <_svfprintf_r+0x11c2>
  41527a:	9b21      	ldr	r3, [sp, #132]	; 0x84
  41527c:	42a3      	cmp	r3, r4
  41527e:	d206      	bcs.n	41528e <_svfprintf_r+0xf16>
  415280:	2130      	movs	r1, #48	; 0x30
  415282:	1c5a      	adds	r2, r3, #1
  415284:	9221      	str	r2, [sp, #132]	; 0x84
  415286:	7019      	strb	r1, [r3, #0]
  415288:	9b21      	ldr	r3, [sp, #132]	; 0x84
  41528a:	429c      	cmp	r4, r3
  41528c:	d8f9      	bhi.n	415282 <_svfprintf_r+0xf0a>
  41528e:	1b9b      	subs	r3, r3, r6
  415290:	2f47      	cmp	r7, #71	; 0x47
  415292:	930f      	str	r3, [sp, #60]	; 0x3c
  415294:	f000 80f0 	beq.w	415478 <_svfprintf_r+0x1100>
  415298:	9b0d      	ldr	r3, [sp, #52]	; 0x34
  41529a:	2b65      	cmp	r3, #101	; 0x65
  41529c:	f340 81c3 	ble.w	415626 <_svfprintf_r+0x12ae>
  4152a0:	9b0d      	ldr	r3, [sp, #52]	; 0x34
  4152a2:	2b66      	cmp	r3, #102	; 0x66
  4152a4:	9b1d      	ldr	r3, [sp, #116]	; 0x74
  4152a6:	930e      	str	r3, [sp, #56]	; 0x38
  4152a8:	f000 81c0 	beq.w	41562c <_svfprintf_r+0x12b4>
  4152ac:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
  4152ae:	9a0e      	ldr	r2, [sp, #56]	; 0x38
  4152b0:	4619      	mov	r1, r3
  4152b2:	4291      	cmp	r1, r2
  4152b4:	f300 8191 	bgt.w	4155da <_svfprintf_r+0x1262>
  4152b8:	f01b 0f01 	tst.w	fp, #1
  4152bc:	f040 8223 	bne.w	415706 <_svfprintf_r+0x138e>
  4152c0:	ea22 73e2 	bic.w	r3, r2, r2, asr #31
  4152c4:	9304      	str	r3, [sp, #16]
  4152c6:	2367      	movs	r3, #103	; 0x67
  4152c8:	920a      	str	r2, [sp, #40]	; 0x28
  4152ca:	930d      	str	r3, [sp, #52]	; 0x34
  4152cc:	9b0c      	ldr	r3, [sp, #48]	; 0x30
  4152ce:	2b00      	cmp	r3, #0
  4152d0:	f040 80cb 	bne.w	41546a <_svfprintf_r+0x10f2>
  4152d4:	9306      	str	r3, [sp, #24]
  4152d6:	f89d 706f 	ldrb.w	r7, [sp, #111]	; 0x6f
  4152da:	f7ff b965 	b.w	4145a8 <_svfprintf_r+0x230>
  4152de:	f025 0507 	bic.w	r5, r5, #7
  4152e2:	ed95 7b00 	vldr	d7, [r5]
  4152e6:	f105 0308 	add.w	r3, r5, #8
  4152ea:	ed8d 7b10 	vstr	d7, [sp, #64]	; 0x40
  4152ee:	930b      	str	r3, [sp, #44]	; 0x2c
  4152f0:	e416      	b.n	414b20 <_svfprintf_r+0x7a8>
  4152f2:	4635      	mov	r5, r6
  4152f4:	460c      	mov	r4, r1
  4152f6:	4646      	mov	r6, r8
  4152f8:	4690      	mov	r8, r2
  4152fa:	3301      	adds	r3, #1
  4152fc:	443c      	add	r4, r7
  4152fe:	2b07      	cmp	r3, #7
  415300:	9425      	str	r4, [sp, #148]	; 0x94
  415302:	9324      	str	r3, [sp, #144]	; 0x90
  415304:	e888 00a0 	stmia.w	r8, {r5, r7}
  415308:	f73f aecf 	bgt.w	4150aa <_svfprintf_r+0xd32>
  41530c:	f108 0808 	add.w	r8, r8, #8
  415310:	e6d5      	b.n	4150be <_svfprintf_r+0xd46>
  415312:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
  415314:	6813      	ldr	r3, [r2, #0]
  415316:	3204      	adds	r2, #4
  415318:	920b      	str	r2, [sp, #44]	; 0x2c
  41531a:	9a05      	ldr	r2, [sp, #20]
  41531c:	601a      	str	r2, [r3, #0]
  41531e:	f7ff b852 	b.w	4143c6 <_svfprintf_r+0x4e>
  415322:	aa23      	add	r2, sp, #140	; 0x8c
  415324:	9907      	ldr	r1, [sp, #28]
  415326:	9808      	ldr	r0, [sp, #32]
  415328:	f002 f958 	bl	4175dc <__ssprint_r>
  41532c:	2800      	cmp	r0, #0
  41532e:	f47f a8f5 	bne.w	41451c <_svfprintf_r+0x1a4>
  415332:	46c8      	mov	r8, r9
  415334:	e488      	b.n	414c48 <_svfprintf_r+0x8d0>
  415336:	9b24      	ldr	r3, [sp, #144]	; 0x90
  415338:	4a27      	ldr	r2, [pc, #156]	; (4153d8 <_svfprintf_r+0x1060>)
  41533a:	f8c8 2000 	str.w	r2, [r8]
  41533e:	3301      	adds	r3, #1
  415340:	3401      	adds	r4, #1
  415342:	2201      	movs	r2, #1
  415344:	2b07      	cmp	r3, #7
  415346:	9425      	str	r4, [sp, #148]	; 0x94
  415348:	9324      	str	r3, [sp, #144]	; 0x90
  41534a:	f8c8 2004 	str.w	r2, [r8, #4]
  41534e:	dc54      	bgt.n	4153fa <_svfprintf_r+0x1082>
  415350:	f108 0808 	add.w	r8, r8, #8
  415354:	b929      	cbnz	r1, 415362 <_svfprintf_r+0xfea>
  415356:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
  415358:	b91b      	cbnz	r3, 415362 <_svfprintf_r+0xfea>
  41535a:	9b03      	ldr	r3, [sp, #12]
  41535c:	07d8      	lsls	r0, r3, #31
  41535e:	f57f a9f2 	bpl.w	414746 <_svfprintf_r+0x3ce>
  415362:	9b24      	ldr	r3, [sp, #144]	; 0x90
  415364:	9813      	ldr	r0, [sp, #76]	; 0x4c
  415366:	9a14      	ldr	r2, [sp, #80]	; 0x50
  415368:	f8c8 2000 	str.w	r2, [r8]
  41536c:	3301      	adds	r3, #1
  41536e:	4602      	mov	r2, r0
  415370:	4422      	add	r2, r4
  415372:	2b07      	cmp	r3, #7
  415374:	9225      	str	r2, [sp, #148]	; 0x94
  415376:	f8c8 0004 	str.w	r0, [r8, #4]
  41537a:	9324      	str	r3, [sp, #144]	; 0x90
  41537c:	f300 8195 	bgt.w	4156aa <_svfprintf_r+0x1332>
  415380:	f108 0808 	add.w	r8, r8, #8
  415384:	2900      	cmp	r1, #0
  415386:	f2c0 816d 	blt.w	415664 <_svfprintf_r+0x12ec>
  41538a:	990f      	ldr	r1, [sp, #60]	; 0x3c
  41538c:	f8c8 6000 	str.w	r6, [r8]
  415390:	3301      	adds	r3, #1
  415392:	188c      	adds	r4, r1, r2
  415394:	2b07      	cmp	r3, #7
  415396:	9425      	str	r4, [sp, #148]	; 0x94
  415398:	9324      	str	r3, [sp, #144]	; 0x90
  41539a:	f8c8 1004 	str.w	r1, [r8, #4]
  41539e:	f77f a9d0 	ble.w	414742 <_svfprintf_r+0x3ca>
  4153a2:	e529      	b.n	414df8 <_svfprintf_r+0xa80>
  4153a4:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
  4153a6:	9905      	ldr	r1, [sp, #20]
  4153a8:	6813      	ldr	r3, [r2, #0]
  4153aa:	17cd      	asrs	r5, r1, #31
  4153ac:	4608      	mov	r0, r1
  4153ae:	3204      	adds	r2, #4
  4153b0:	4629      	mov	r1, r5
  4153b2:	920b      	str	r2, [sp, #44]	; 0x2c
  4153b4:	e9c3 0100 	strd	r0, r1, [r3]
  4153b8:	f7ff b805 	b.w	4143c6 <_svfprintf_r+0x4e>
  4153bc:	aa23      	add	r2, sp, #140	; 0x8c
  4153be:	9907      	ldr	r1, [sp, #28]
  4153c0:	9808      	ldr	r0, [sp, #32]
  4153c2:	f002 f90b 	bl	4175dc <__ssprint_r>
  4153c6:	2800      	cmp	r0, #0
  4153c8:	f47f a8a8 	bne.w	41451c <_svfprintf_r+0x1a4>
  4153cc:	9c25      	ldr	r4, [sp, #148]	; 0x94
  4153ce:	46c8      	mov	r8, r9
  4153d0:	e453      	b.n	414c7a <_svfprintf_r+0x902>
  4153d2:	bf00      	nop
  4153d4:	0041d67c 	.word	0x0041d67c
  4153d8:	0041d668 	.word	0x0041d668
  4153dc:	2140      	movs	r1, #64	; 0x40
  4153de:	9808      	ldr	r0, [sp, #32]
  4153e0:	f001 fa54 	bl	41688c <_malloc_r>
  4153e4:	9a07      	ldr	r2, [sp, #28]
  4153e6:	6010      	str	r0, [r2, #0]
  4153e8:	6110      	str	r0, [r2, #16]
  4153ea:	2800      	cmp	r0, #0
  4153ec:	f000 81f6 	beq.w	4157dc <_svfprintf_r+0x1464>
  4153f0:	9a07      	ldr	r2, [sp, #28]
  4153f2:	2340      	movs	r3, #64	; 0x40
  4153f4:	6153      	str	r3, [r2, #20]
  4153f6:	f7fe bfd6 	b.w	4143a6 <_svfprintf_r+0x2e>
  4153fa:	aa23      	add	r2, sp, #140	; 0x8c
  4153fc:	9907      	ldr	r1, [sp, #28]
  4153fe:	9808      	ldr	r0, [sp, #32]
  415400:	f002 f8ec 	bl	4175dc <__ssprint_r>
  415404:	2800      	cmp	r0, #0
  415406:	f47f a889 	bne.w	41451c <_svfprintf_r+0x1a4>
  41540a:	991d      	ldr	r1, [sp, #116]	; 0x74
  41540c:	9c25      	ldr	r4, [sp, #148]	; 0x94
  41540e:	46c8      	mov	r8, r9
  415410:	e7a0      	b.n	415354 <_svfprintf_r+0xfdc>
  415412:	9d06      	ldr	r5, [sp, #24]
  415414:	9808      	ldr	r0, [sp, #32]
  415416:	aa21      	add	r2, sp, #132	; 0x84
  415418:	ab1e      	add	r3, sp, #120	; 0x78
  41541a:	9201      	str	r2, [sp, #4]
  41541c:	9300      	str	r3, [sp, #0]
  41541e:	462a      	mov	r2, r5
  415420:	ab1d      	add	r3, sp, #116	; 0x74
  415422:	2103      	movs	r1, #3
  415424:	ed9d 0b18 	vldr	d0, [sp, #96]	; 0x60
  415428:	f000 fade 	bl	4159e8 <_dtoa_r>
  41542c:	4606      	mov	r6, r0
  41542e:	9b0d      	ldr	r3, [sp, #52]	; 0x34
  415430:	2b46      	cmp	r3, #70	; 0x46
  415432:	eb06 0405 	add.w	r4, r6, r5
  415436:	f47f af17 	bne.w	415268 <_svfprintf_r+0xef0>
  41543a:	7833      	ldrb	r3, [r6, #0]
  41543c:	2b30      	cmp	r3, #48	; 0x30
  41543e:	f000 817d 	beq.w	41573c <_svfprintf_r+0x13c4>
  415442:	9d1d      	ldr	r5, [sp, #116]	; 0x74
  415444:	442c      	add	r4, r5
  415446:	e70f      	b.n	415268 <_svfprintf_r+0xef0>
  415448:	9b06      	ldr	r3, [sp, #24]
  41544a:	2b00      	cmp	r3, #0
  41544c:	bf08      	it	eq
  41544e:	2301      	moveq	r3, #1
  415450:	9306      	str	r3, [sp, #24]
  415452:	e6d9      	b.n	415208 <_svfprintf_r+0xe90>
  415454:	4630      	mov	r0, r6
  415456:	9406      	str	r4, [sp, #24]
  415458:	f002 f852 	bl	417500 <strlen>
  41545c:	950b      	str	r5, [sp, #44]	; 0x2c
  41545e:	900a      	str	r0, [sp, #40]	; 0x28
  415460:	f8cd b00c 	str.w	fp, [sp, #12]
  415464:	4603      	mov	r3, r0
  415466:	f7ff b9eb 	b.w	414840 <_svfprintf_r+0x4c8>
  41546a:	272d      	movs	r7, #45	; 0x2d
  41546c:	2300      	movs	r3, #0
  41546e:	f88d 706f 	strb.w	r7, [sp, #111]	; 0x6f
  415472:	9306      	str	r3, [sp, #24]
  415474:	f7ff b899 	b.w	4145aa <_svfprintf_r+0x232>
  415478:	9b1d      	ldr	r3, [sp, #116]	; 0x74
  41547a:	930e      	str	r3, [sp, #56]	; 0x38
  41547c:	461a      	mov	r2, r3
  41547e:	3303      	adds	r3, #3
  415480:	db04      	blt.n	41548c <_svfprintf_r+0x1114>
  415482:	9b06      	ldr	r3, [sp, #24]
  415484:	4619      	mov	r1, r3
  415486:	4291      	cmp	r1, r2
  415488:	f6bf af10 	bge.w	4152ac <_svfprintf_r+0xf34>
  41548c:	9b0d      	ldr	r3, [sp, #52]	; 0x34
  41548e:	3b02      	subs	r3, #2
  415490:	930d      	str	r3, [sp, #52]	; 0x34
  415492:	f89d 3034 	ldrb.w	r3, [sp, #52]	; 0x34
  415496:	f88d 307c 	strb.w	r3, [sp, #124]	; 0x7c
  41549a:	9b0e      	ldr	r3, [sp, #56]	; 0x38
  41549c:	3b01      	subs	r3, #1
  41549e:	2b00      	cmp	r3, #0
  4154a0:	931d      	str	r3, [sp, #116]	; 0x74
  4154a2:	bfbd      	ittte	lt
  4154a4:	9b0e      	ldrlt	r3, [sp, #56]	; 0x38
  4154a6:	f1c3 0301 	rsblt	r3, r3, #1
  4154aa:	222d      	movlt	r2, #45	; 0x2d
  4154ac:	222b      	movge	r2, #43	; 0x2b
  4154ae:	2b09      	cmp	r3, #9
  4154b0:	f88d 207d 	strb.w	r2, [sp, #125]	; 0x7d
  4154b4:	f340 811d 	ble.w	4156f2 <_svfprintf_r+0x137a>
  4154b8:	f10d 048b 	add.w	r4, sp, #139	; 0x8b
  4154bc:	4620      	mov	r0, r4
  4154be:	4daf      	ldr	r5, [pc, #700]	; (41577c <_svfprintf_r+0x1404>)
  4154c0:	e000      	b.n	4154c4 <_svfprintf_r+0x114c>
  4154c2:	4610      	mov	r0, r2
  4154c4:	fb85 1203 	smull	r1, r2, r5, r3
  4154c8:	17d9      	asrs	r1, r3, #31
  4154ca:	ebc1 01a2 	rsb	r1, r1, r2, asr #2
  4154ce:	eb01 0281 	add.w	r2, r1, r1, lsl #2
  4154d2:	eba3 0242 	sub.w	r2, r3, r2, lsl #1
  4154d6:	3230      	adds	r2, #48	; 0x30
  4154d8:	2909      	cmp	r1, #9
  4154da:	f800 2c01 	strb.w	r2, [r0, #-1]
  4154de:	460b      	mov	r3, r1
  4154e0:	f100 32ff 	add.w	r2, r0, #4294967295
  4154e4:	dced      	bgt.n	4154c2 <_svfprintf_r+0x114a>
  4154e6:	3330      	adds	r3, #48	; 0x30
  4154e8:	3802      	subs	r0, #2
  4154ea:	b2d9      	uxtb	r1, r3
  4154ec:	4284      	cmp	r4, r0
  4154ee:	f802 1c01 	strb.w	r1, [r2, #-1]
  4154f2:	f240 8170 	bls.w	4157d6 <_svfprintf_r+0x145e>
  4154f6:	f10d 007e 	add.w	r0, sp, #126	; 0x7e
  4154fa:	4613      	mov	r3, r2
  4154fc:	e001      	b.n	415502 <_svfprintf_r+0x118a>
  4154fe:	f813 1b01 	ldrb.w	r1, [r3], #1
  415502:	f800 1b01 	strb.w	r1, [r0], #1
  415506:	42a3      	cmp	r3, r4
  415508:	d1f9      	bne.n	4154fe <_svfprintf_r+0x1186>
  41550a:	3301      	adds	r3, #1
  41550c:	1a9b      	subs	r3, r3, r2
  41550e:	f10d 027e 	add.w	r2, sp, #126	; 0x7e
  415512:	4413      	add	r3, r2
  415514:	aa1f      	add	r2, sp, #124	; 0x7c
  415516:	1a9b      	subs	r3, r3, r2
  415518:	9a0f      	ldr	r2, [sp, #60]	; 0x3c
  41551a:	9315      	str	r3, [sp, #84]	; 0x54
  41551c:	2a01      	cmp	r2, #1
  41551e:	4413      	add	r3, r2
  415520:	930a      	str	r3, [sp, #40]	; 0x28
  415522:	f340 8120 	ble.w	415766 <_svfprintf_r+0x13ee>
  415526:	9b0a      	ldr	r3, [sp, #40]	; 0x28
  415528:	9a13      	ldr	r2, [sp, #76]	; 0x4c
  41552a:	4413      	add	r3, r2
  41552c:	930a      	str	r3, [sp, #40]	; 0x28
  41552e:	ea23 73e3 	bic.w	r3, r3, r3, asr #31
  415532:	9304      	str	r3, [sp, #16]
  415534:	2300      	movs	r3, #0
  415536:	930e      	str	r3, [sp, #56]	; 0x38
  415538:	e6c8      	b.n	4152cc <_svfprintf_r+0xf54>
  41553a:	4623      	mov	r3, r4
  41553c:	e6a7      	b.n	41528e <_svfprintf_r+0xf16>
  41553e:	aa23      	add	r2, sp, #140	; 0x8c
  415540:	9907      	ldr	r1, [sp, #28]
  415542:	9808      	ldr	r0, [sp, #32]
  415544:	f002 f84a 	bl	4175dc <__ssprint_r>
  415548:	2800      	cmp	r0, #0
  41554a:	f47e afe7 	bne.w	41451c <_svfprintf_r+0x1a4>
  41554e:	9c25      	ldr	r4, [sp, #148]	; 0x94
  415550:	46c8      	mov	r8, r9
  415552:	e4d5      	b.n	414f00 <_svfprintf_r+0xb88>
  415554:	aa23      	add	r2, sp, #140	; 0x8c
  415556:	9907      	ldr	r1, [sp, #28]
  415558:	9808      	ldr	r0, [sp, #32]
  41555a:	f002 f83f 	bl	4175dc <__ssprint_r>
  41555e:	2800      	cmp	r0, #0
  415560:	f47e afdc 	bne.w	41451c <_svfprintf_r+0x1a4>
  415564:	9a1d      	ldr	r2, [sp, #116]	; 0x74
  415566:	9c25      	ldr	r4, [sp, #148]	; 0x94
  415568:	46c8      	mov	r8, r9
  41556a:	e5af      	b.n	4150cc <_svfprintf_r+0xd54>
  41556c:	aa23      	add	r2, sp, #140	; 0x8c
  41556e:	9907      	ldr	r1, [sp, #28]
  415570:	9808      	ldr	r0, [sp, #32]
  415572:	f002 f833 	bl	4175dc <__ssprint_r>
  415576:	2800      	cmp	r0, #0
  415578:	f47e afd0 	bne.w	41451c <_svfprintf_r+0x1a4>
  41557c:	9a1d      	ldr	r2, [sp, #116]	; 0x74
  41557e:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
  415580:	9c25      	ldr	r4, [sp, #148]	; 0x94
  415582:	1a9a      	subs	r2, r3, r2
  415584:	46c8      	mov	r8, r9
  415586:	e5b9      	b.n	4150fc <_svfprintf_r+0xd84>
  415588:	9b06      	ldr	r3, [sp, #24]
  41558a:	960e      	str	r6, [sp, #56]	; 0x38
  41558c:	2b06      	cmp	r3, #6
  41558e:	bf28      	it	cs
  415590:	2306      	movcs	r3, #6
  415592:	9606      	str	r6, [sp, #24]
  415594:	4637      	mov	r7, r6
  415596:	9304      	str	r3, [sp, #16]
  415598:	950b      	str	r5, [sp, #44]	; 0x2c
  41559a:	f8cd b00c 	str.w	fp, [sp, #12]
  41559e:	930a      	str	r3, [sp, #40]	; 0x28
  4155a0:	4e77      	ldr	r6, [pc, #476]	; (415780 <_svfprintf_r+0x1408>)
  4155a2:	f7ff b801 	b.w	4145a8 <_svfprintf_r+0x230>
  4155a6:	2306      	movs	r3, #6
  4155a8:	9306      	str	r3, [sp, #24]
  4155aa:	e62d      	b.n	415208 <_svfprintf_r+0xe90>
  4155ac:	9c06      	ldr	r4, [sp, #24]
  4155ae:	9808      	ldr	r0, [sp, #32]
  4155b0:	aa21      	add	r2, sp, #132	; 0x84
  4155b2:	ab1e      	add	r3, sp, #120	; 0x78
  4155b4:	9201      	str	r2, [sp, #4]
  4155b6:	9300      	str	r3, [sp, #0]
  4155b8:	4622      	mov	r2, r4
  4155ba:	ab1d      	add	r3, sp, #116	; 0x74
  4155bc:	2103      	movs	r1, #3
  4155be:	ed9d 0b18 	vldr	d0, [sp, #96]	; 0x60
  4155c2:	f000 fa11 	bl	4159e8 <_dtoa_r>
  4155c6:	4623      	mov	r3, r4
  4155c8:	4606      	mov	r6, r0
  4155ca:	1904      	adds	r4, r0, r4
  4155cc:	461d      	mov	r5, r3
  4155ce:	e734      	b.n	41543a <_svfprintf_r+0x10c2>
  4155d0:	272d      	movs	r7, #45	; 0x2d
  4155d2:	f88d 706f 	strb.w	r7, [sp, #111]	; 0x6f
  4155d6:	f7ff baca 	b.w	414b6e <_svfprintf_r+0x7f6>
  4155da:	9a13      	ldr	r2, [sp, #76]	; 0x4c
  4155dc:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
  4155de:	4413      	add	r3, r2
  4155e0:	9a0e      	ldr	r2, [sp, #56]	; 0x38
  4155e2:	930a      	str	r3, [sp, #40]	; 0x28
  4155e4:	2a00      	cmp	r2, #0
  4155e6:	f340 80b7 	ble.w	415758 <_svfprintf_r+0x13e0>
  4155ea:	ea23 73e3 	bic.w	r3, r3, r3, asr #31
  4155ee:	9304      	str	r3, [sp, #16]
  4155f0:	2367      	movs	r3, #103	; 0x67
  4155f2:	930d      	str	r3, [sp, #52]	; 0x34
  4155f4:	e66a      	b.n	4152cc <_svfprintf_r+0xf54>
  4155f6:	e9dd 1210 	ldrd	r1, r2, [sp, #64]	; 0x40
  4155fa:	f102 4300 	add.w	r3, r2, #2147483648	; 0x80000000
  4155fe:	9319      	str	r3, [sp, #100]	; 0x64
  415600:	232d      	movs	r3, #45	; 0x2d
  415602:	9118      	str	r1, [sp, #96]	; 0x60
  415604:	930c      	str	r3, [sp, #48]	; 0x30
  415606:	e60c      	b.n	415222 <_svfprintf_r+0xeaa>
  415608:	9b0d      	ldr	r3, [sp, #52]	; 0x34
  41560a:	2b47      	cmp	r3, #71	; 0x47
  41560c:	f47f ae2b 	bne.w	415266 <_svfprintf_r+0xeee>
  415610:	f01b 0f01 	tst.w	fp, #1
  415614:	f47f af0b 	bne.w	41542e <_svfprintf_r+0x10b6>
  415618:	9b21      	ldr	r3, [sp, #132]	; 0x84
  41561a:	2f47      	cmp	r7, #71	; 0x47
  41561c:	eba3 0306 	sub.w	r3, r3, r6
  415620:	930f      	str	r3, [sp, #60]	; 0x3c
  415622:	f43f af29 	beq.w	415478 <_svfprintf_r+0x1100>
  415626:	9b1d      	ldr	r3, [sp, #116]	; 0x74
  415628:	930e      	str	r3, [sp, #56]	; 0x38
  41562a:	e732      	b.n	415492 <_svfprintf_r+0x111a>
  41562c:	2b00      	cmp	r3, #0
  41562e:	f340 80af 	ble.w	415790 <_svfprintf_r+0x1418>
  415632:	9a06      	ldr	r2, [sp, #24]
  415634:	2a00      	cmp	r2, #0
  415636:	d16b      	bne.n	415710 <_svfprintf_r+0x1398>
  415638:	f01b 0f01 	tst.w	fp, #1
  41563c:	d168      	bne.n	415710 <_svfprintf_r+0x1398>
  41563e:	9304      	str	r3, [sp, #16]
  415640:	930a      	str	r3, [sp, #40]	; 0x28
  415642:	e643      	b.n	4152cc <_svfprintf_r+0xf54>
  415644:	9b06      	ldr	r3, [sp, #24]
  415646:	9304      	str	r3, [sp, #16]
  415648:	930a      	str	r3, [sp, #40]	; 0x28
  41564a:	9006      	str	r0, [sp, #24]
  41564c:	950b      	str	r5, [sp, #44]	; 0x2c
  41564e:	f8cd b00c 	str.w	fp, [sp, #12]
  415652:	900e      	str	r0, [sp, #56]	; 0x38
  415654:	f89d 706f 	ldrb.w	r7, [sp, #111]	; 0x6f
  415658:	f7fe bfa6 	b.w	4145a8 <_svfprintf_r+0x230>
  41565c:	2000      	movs	r0, #0
  41565e:	9006      	str	r0, [sp, #24]
  415660:	f7fe bee4 	b.w	41442c <_svfprintf_r+0xb4>
  415664:	424f      	negs	r7, r1
  415666:	3110      	adds	r1, #16
  415668:	4d46      	ldr	r5, [pc, #280]	; (415784 <_svfprintf_r+0x140c>)
  41566a:	da2b      	bge.n	4156c4 <_svfprintf_r+0x134c>
  41566c:	2410      	movs	r4, #16
  41566e:	f8dd b020 	ldr.w	fp, [sp, #32]
  415672:	e004      	b.n	41567e <_svfprintf_r+0x1306>
  415674:	f108 0808 	add.w	r8, r8, #8
  415678:	3f10      	subs	r7, #16
  41567a:	2f10      	cmp	r7, #16
  41567c:	dd22      	ble.n	4156c4 <_svfprintf_r+0x134c>
  41567e:	3301      	adds	r3, #1
  415680:	3210      	adds	r2, #16
  415682:	2b07      	cmp	r3, #7
  415684:	9225      	str	r2, [sp, #148]	; 0x94
  415686:	9324      	str	r3, [sp, #144]	; 0x90
  415688:	f8c8 5000 	str.w	r5, [r8]
  41568c:	f8c8 4004 	str.w	r4, [r8, #4]
  415690:	ddf0      	ble.n	415674 <_svfprintf_r+0x12fc>
  415692:	aa23      	add	r2, sp, #140	; 0x8c
  415694:	9907      	ldr	r1, [sp, #28]
  415696:	4658      	mov	r0, fp
  415698:	f001 ffa0 	bl	4175dc <__ssprint_r>
  41569c:	2800      	cmp	r0, #0
  41569e:	f47e af3d 	bne.w	41451c <_svfprintf_r+0x1a4>
  4156a2:	9a25      	ldr	r2, [sp, #148]	; 0x94
  4156a4:	9b24      	ldr	r3, [sp, #144]	; 0x90
  4156a6:	46c8      	mov	r8, r9
  4156a8:	e7e6      	b.n	415678 <_svfprintf_r+0x1300>
  4156aa:	aa23      	add	r2, sp, #140	; 0x8c
  4156ac:	9907      	ldr	r1, [sp, #28]
  4156ae:	9808      	ldr	r0, [sp, #32]
  4156b0:	f001 ff94 	bl	4175dc <__ssprint_r>
  4156b4:	2800      	cmp	r0, #0
  4156b6:	f47e af31 	bne.w	41451c <_svfprintf_r+0x1a4>
  4156ba:	991d      	ldr	r1, [sp, #116]	; 0x74
  4156bc:	9a25      	ldr	r2, [sp, #148]	; 0x94
  4156be:	9b24      	ldr	r3, [sp, #144]	; 0x90
  4156c0:	46c8      	mov	r8, r9
  4156c2:	e65f      	b.n	415384 <_svfprintf_r+0x100c>
  4156c4:	3301      	adds	r3, #1
  4156c6:	443a      	add	r2, r7
  4156c8:	2b07      	cmp	r3, #7
  4156ca:	e888 00a0 	stmia.w	r8, {r5, r7}
  4156ce:	9225      	str	r2, [sp, #148]	; 0x94
  4156d0:	9324      	str	r3, [sp, #144]	; 0x90
  4156d2:	f108 0808 	add.w	r8, r8, #8
  4156d6:	f77f ae58 	ble.w	41538a <_svfprintf_r+0x1012>
  4156da:	aa23      	add	r2, sp, #140	; 0x8c
  4156dc:	9907      	ldr	r1, [sp, #28]
  4156de:	9808      	ldr	r0, [sp, #32]
  4156e0:	f001 ff7c 	bl	4175dc <__ssprint_r>
  4156e4:	2800      	cmp	r0, #0
  4156e6:	f47e af19 	bne.w	41451c <_svfprintf_r+0x1a4>
  4156ea:	9a25      	ldr	r2, [sp, #148]	; 0x94
  4156ec:	9b24      	ldr	r3, [sp, #144]	; 0x90
  4156ee:	46c8      	mov	r8, r9
  4156f0:	e64b      	b.n	41538a <_svfprintf_r+0x1012>
  4156f2:	3330      	adds	r3, #48	; 0x30
  4156f4:	2230      	movs	r2, #48	; 0x30
  4156f6:	f88d 307f 	strb.w	r3, [sp, #127]	; 0x7f
  4156fa:	f88d 207e 	strb.w	r2, [sp, #126]	; 0x7e
  4156fe:	ab20      	add	r3, sp, #128	; 0x80
  415700:	e708      	b.n	415514 <_svfprintf_r+0x119c>
  415702:	9b21      	ldr	r3, [sp, #132]	; 0x84
  415704:	e5c3      	b.n	41528e <_svfprintf_r+0xf16>
  415706:	9b0e      	ldr	r3, [sp, #56]	; 0x38
  415708:	9a13      	ldr	r2, [sp, #76]	; 0x4c
  41570a:	4413      	add	r3, r2
  41570c:	930a      	str	r3, [sp, #40]	; 0x28
  41570e:	e76c      	b.n	4155ea <_svfprintf_r+0x1272>
  415710:	9b0e      	ldr	r3, [sp, #56]	; 0x38
  415712:	9a13      	ldr	r2, [sp, #76]	; 0x4c
  415714:	4413      	add	r3, r2
  415716:	9a06      	ldr	r2, [sp, #24]
  415718:	441a      	add	r2, r3
  41571a:	ea22 73e2 	bic.w	r3, r2, r2, asr #31
  41571e:	920a      	str	r2, [sp, #40]	; 0x28
  415720:	9304      	str	r3, [sp, #16]
  415722:	e5d3      	b.n	4152cc <_svfprintf_r+0xf54>
  415724:	9b11      	ldr	r3, [sp, #68]	; 0x44
  415726:	4e18      	ldr	r6, [pc, #96]	; (415788 <_svfprintf_r+0x1410>)
  415728:	2b00      	cmp	r3, #0
  41572a:	bfb6      	itet	lt
  41572c:	272d      	movlt	r7, #45	; 0x2d
  41572e:	f89d 706f 	ldrbge.w	r7, [sp, #111]	; 0x6f
  415732:	f88d 706f 	strblt.w	r7, [sp, #111]	; 0x6f
  415736:	4b15      	ldr	r3, [pc, #84]	; (41578c <_svfprintf_r+0x1414>)
  415738:	f7ff ba1b 	b.w	414b72 <_svfprintf_r+0x7fa>
  41573c:	2200      	movs	r2, #0
  41573e:	2300      	movs	r3, #0
  415740:	e9dd 0118 	ldrd	r0, r1, [sp, #96]	; 0x60
  415744:	f002 fbb0 	bl	417ea8 <__aeabi_dcmpeq>
  415748:	2800      	cmp	r0, #0
  41574a:	f47f ae7a 	bne.w	415442 <_svfprintf_r+0x10ca>
  41574e:	f1c5 0501 	rsb	r5, r5, #1
  415752:	951d      	str	r5, [sp, #116]	; 0x74
  415754:	442c      	add	r4, r5
  415756:	e587      	b.n	415268 <_svfprintf_r+0xef0>
  415758:	9b0e      	ldr	r3, [sp, #56]	; 0x38
  41575a:	9a0a      	ldr	r2, [sp, #40]	; 0x28
  41575c:	f1c3 0301 	rsb	r3, r3, #1
  415760:	441a      	add	r2, r3
  415762:	4613      	mov	r3, r2
  415764:	e7d2      	b.n	41570c <_svfprintf_r+0x1394>
  415766:	f01b 0301 	ands.w	r3, fp, #1
  41576a:	930e      	str	r3, [sp, #56]	; 0x38
  41576c:	f47f aedb 	bne.w	415526 <_svfprintf_r+0x11ae>
  415770:	9b0a      	ldr	r3, [sp, #40]	; 0x28
  415772:	ea23 73e3 	bic.w	r3, r3, r3, asr #31
  415776:	9304      	str	r3, [sp, #16]
  415778:	e5a8      	b.n	4152cc <_svfprintf_r+0xf54>
  41577a:	bf00      	nop
  41577c:	66666667 	.word	0x66666667
  415780:	0041d660 	.word	0x0041d660
  415784:	0041d67c 	.word	0x0041d67c
  415788:	0041d634 	.word	0x0041d634
  41578c:	0041d630 	.word	0x0041d630
  415790:	9b06      	ldr	r3, [sp, #24]
  415792:	b913      	cbnz	r3, 41579a <_svfprintf_r+0x1422>
  415794:	f01b 0f01 	tst.w	fp, #1
  415798:	d002      	beq.n	4157a0 <_svfprintf_r+0x1428>
  41579a:	9b13      	ldr	r3, [sp, #76]	; 0x4c
  41579c:	3301      	adds	r3, #1
  41579e:	e7ba      	b.n	415716 <_svfprintf_r+0x139e>
  4157a0:	2301      	movs	r3, #1
  4157a2:	e74c      	b.n	41563e <_svfprintf_r+0x12c6>
  4157a4:	9d0b      	ldr	r5, [sp, #44]	; 0x2c
  4157a6:	f89a 3001 	ldrb.w	r3, [sl, #1]
  4157aa:	6828      	ldr	r0, [r5, #0]
  4157ac:	ea40 70e0 	orr.w	r0, r0, r0, asr #31
  4157b0:	9006      	str	r0, [sp, #24]
  4157b2:	4628      	mov	r0, r5
  4157b4:	3004      	adds	r0, #4
  4157b6:	46a2      	mov	sl, r4
  4157b8:	900b      	str	r0, [sp, #44]	; 0x2c
  4157ba:	f7fe be35 	b.w	414428 <_svfprintf_r+0xb0>
  4157be:	f88d 106f 	strb.w	r1, [sp, #111]	; 0x6f
  4157c2:	f7ff b852 	b.w	41486a <_svfprintf_r+0x4f2>
  4157c6:	f88d 106f 	strb.w	r1, [sp, #111]	; 0x6f
  4157ca:	f7ff b8de 	b.w	41498a <_svfprintf_r+0x612>
  4157ce:	f88d 106f 	strb.w	r1, [sp, #111]	; 0x6f
  4157d2:	f7ff ba07 	b.w	414be4 <_svfprintf_r+0x86c>
  4157d6:	f10d 037e 	add.w	r3, sp, #126	; 0x7e
  4157da:	e69b      	b.n	415514 <_svfprintf_r+0x119c>
  4157dc:	9a08      	ldr	r2, [sp, #32]
  4157de:	230c      	movs	r3, #12
  4157e0:	6013      	str	r3, [r2, #0]
  4157e2:	f04f 33ff 	mov.w	r3, #4294967295
  4157e6:	9305      	str	r3, [sp, #20]
  4157e8:	f7fe bea1 	b.w	41452e <_svfprintf_r+0x1b6>
  4157ec:	f88d 106f 	strb.w	r1, [sp, #111]	; 0x6f
  4157f0:	f7ff b986 	b.w	414b00 <_svfprintf_r+0x788>
  4157f4:	f88d 106f 	strb.w	r1, [sp, #111]	; 0x6f
  4157f8:	f7ff b962 	b.w	414ac0 <_svfprintf_r+0x748>
  4157fc:	f88d 106f 	strb.w	r1, [sp, #111]	; 0x6f
  415800:	f7ff b945 	b.w	414a8e <_svfprintf_r+0x716>
  415804:	f88d 106f 	strb.w	r1, [sp, #111]	; 0x6f
  415808:	f7ff b8fe 	b.w	414a08 <_svfprintf_r+0x690>

0041580c <_vsnprintf_r>:
  41580c:	b570      	push	{r4, r5, r6, lr}
  41580e:	1e14      	subs	r4, r2, #0
  415810:	b09a      	sub	sp, #104	; 0x68
  415812:	4605      	mov	r5, r0
  415814:	db2e      	blt.n	415874 <_vsnprintf_r+0x68>
  415816:	461a      	mov	r2, r3
  415818:	f44f 7302 	mov.w	r3, #520	; 0x208
  41581c:	9100      	str	r1, [sp, #0]
  41581e:	9104      	str	r1, [sp, #16]
  415820:	f8ad 300c 	strh.w	r3, [sp, #12]
  415824:	d011      	beq.n	41584a <_vsnprintf_r+0x3e>
  415826:	3c01      	subs	r4, #1
  415828:	f64f 76ff 	movw	r6, #65535	; 0xffff
  41582c:	9b1e      	ldr	r3, [sp, #120]	; 0x78
  41582e:	9402      	str	r4, [sp, #8]
  415830:	4669      	mov	r1, sp
  415832:	9405      	str	r4, [sp, #20]
  415834:	f8ad 600e 	strh.w	r6, [sp, #14]
  415838:	f7fe fd9e 	bl	414378 <_svfprintf_r>
  41583c:	1c42      	adds	r2, r0, #1
  41583e:	db12      	blt.n	415866 <_vsnprintf_r+0x5a>
  415840:	9b00      	ldr	r3, [sp, #0]
  415842:	2200      	movs	r2, #0
  415844:	701a      	strb	r2, [r3, #0]
  415846:	b01a      	add	sp, #104	; 0x68
  415848:	bd70      	pop	{r4, r5, r6, pc}
  41584a:	9b1e      	ldr	r3, [sp, #120]	; 0x78
  41584c:	9402      	str	r4, [sp, #8]
  41584e:	f64f 76ff 	movw	r6, #65535	; 0xffff
  415852:	4669      	mov	r1, sp
  415854:	9405      	str	r4, [sp, #20]
  415856:	f8ad 600e 	strh.w	r6, [sp, #14]
  41585a:	f7fe fd8d 	bl	414378 <_svfprintf_r>
  41585e:	1c43      	adds	r3, r0, #1
  415860:	db04      	blt.n	41586c <_vsnprintf_r+0x60>
  415862:	b01a      	add	sp, #104	; 0x68
  415864:	bd70      	pop	{r4, r5, r6, pc}
  415866:	238b      	movs	r3, #139	; 0x8b
  415868:	602b      	str	r3, [r5, #0]
  41586a:	e7e9      	b.n	415840 <_vsnprintf_r+0x34>
  41586c:	238b      	movs	r3, #139	; 0x8b
  41586e:	602b      	str	r3, [r5, #0]
  415870:	b01a      	add	sp, #104	; 0x68
  415872:	bd70      	pop	{r4, r5, r6, pc}
  415874:	238b      	movs	r3, #139	; 0x8b
  415876:	6003      	str	r3, [r0, #0]
  415878:	f04f 30ff 	mov.w	r0, #4294967295
  41587c:	e7f1      	b.n	415862 <_vsnprintf_r+0x56>
  41587e:	bf00      	nop

00415880 <vsnprintf>:
  415880:	b510      	push	{r4, lr}
  415882:	b082      	sub	sp, #8
  415884:	4c05      	ldr	r4, [pc, #20]	; (41589c <vsnprintf+0x1c>)
  415886:	9300      	str	r3, [sp, #0]
  415888:	6824      	ldr	r4, [r4, #0]
  41588a:	4613      	mov	r3, r2
  41588c:	460a      	mov	r2, r1
  41588e:	4601      	mov	r1, r0
  415890:	4620      	mov	r0, r4
  415892:	f7ff ffbb 	bl	41580c <_vsnprintf_r>
  415896:	b002      	add	sp, #8
  415898:	bd10      	pop	{r4, pc}
  41589a:	bf00      	nop
  41589c:	20000358 	.word	0x20000358

004158a0 <register_fini>:
  4158a0:	4b02      	ldr	r3, [pc, #8]	; (4158ac <register_fini+0xc>)
  4158a2:	b113      	cbz	r3, 4158aa <register_fini+0xa>
  4158a4:	4802      	ldr	r0, [pc, #8]	; (4158b0 <register_fini+0x10>)
  4158a6:	f000 b805 	b.w	4158b4 <atexit>
  4158aa:	4770      	bx	lr
  4158ac:	00000000 	.word	0x00000000
  4158b0:	00416835 	.word	0x00416835

004158b4 <atexit>:
  4158b4:	2300      	movs	r3, #0
  4158b6:	4601      	mov	r1, r0
  4158b8:	461a      	mov	r2, r3
  4158ba:	4618      	mov	r0, r3
  4158bc:	f001 bf0c 	b.w	4176d8 <__register_exitproc>

004158c0 <quorem>:
  4158c0:	6902      	ldr	r2, [r0, #16]
  4158c2:	690b      	ldr	r3, [r1, #16]
  4158c4:	4293      	cmp	r3, r2
  4158c6:	f300 808d 	bgt.w	4159e4 <quorem+0x124>
  4158ca:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  4158ce:	f103 38ff 	add.w	r8, r3, #4294967295
  4158d2:	f101 0714 	add.w	r7, r1, #20
  4158d6:	f100 0b14 	add.w	fp, r0, #20
  4158da:	f857 2028 	ldr.w	r2, [r7, r8, lsl #2]
  4158de:	f85b 3028 	ldr.w	r3, [fp, r8, lsl #2]
  4158e2:	ea4f 0488 	mov.w	r4, r8, lsl #2
  4158e6:	b083      	sub	sp, #12
  4158e8:	3201      	adds	r2, #1
  4158ea:	fbb3 f9f2 	udiv	r9, r3, r2
  4158ee:	eb0b 0304 	add.w	r3, fp, r4
  4158f2:	9400      	str	r4, [sp, #0]
  4158f4:	eb07 0a04 	add.w	sl, r7, r4
  4158f8:	9301      	str	r3, [sp, #4]
  4158fa:	f1b9 0f00 	cmp.w	r9, #0
  4158fe:	d039      	beq.n	415974 <quorem+0xb4>
  415900:	2500      	movs	r5, #0
  415902:	462e      	mov	r6, r5
  415904:	46bc      	mov	ip, r7
  415906:	46de      	mov	lr, fp
  415908:	f85c 4b04 	ldr.w	r4, [ip], #4
  41590c:	f8de 3000 	ldr.w	r3, [lr]
  415910:	b2a2      	uxth	r2, r4
  415912:	fb09 5502 	mla	r5, r9, r2, r5
  415916:	0c22      	lsrs	r2, r4, #16
  415918:	0c2c      	lsrs	r4, r5, #16
  41591a:	fb09 4202 	mla	r2, r9, r2, r4
  41591e:	b2ad      	uxth	r5, r5
  415920:	1b75      	subs	r5, r6, r5
  415922:	b296      	uxth	r6, r2
  415924:	ebc6 4613 	rsb	r6, r6, r3, lsr #16
  415928:	fa15 f383 	uxtah	r3, r5, r3
  41592c:	eb06 4623 	add.w	r6, r6, r3, asr #16
  415930:	b29b      	uxth	r3, r3
  415932:	ea43 4306 	orr.w	r3, r3, r6, lsl #16
  415936:	45e2      	cmp	sl, ip
  415938:	ea4f 4512 	mov.w	r5, r2, lsr #16
  41593c:	f84e 3b04 	str.w	r3, [lr], #4
  415940:	ea4f 4626 	mov.w	r6, r6, asr #16
  415944:	d2e0      	bcs.n	415908 <quorem+0x48>
  415946:	9b00      	ldr	r3, [sp, #0]
  415948:	f85b 3003 	ldr.w	r3, [fp, r3]
  41594c:	b993      	cbnz	r3, 415974 <quorem+0xb4>
  41594e:	9c01      	ldr	r4, [sp, #4]
  415950:	1f23      	subs	r3, r4, #4
  415952:	459b      	cmp	fp, r3
  415954:	d20c      	bcs.n	415970 <quorem+0xb0>
  415956:	f854 3c04 	ldr.w	r3, [r4, #-4]
  41595a:	b94b      	cbnz	r3, 415970 <quorem+0xb0>
  41595c:	f1a4 0308 	sub.w	r3, r4, #8
  415960:	e002      	b.n	415968 <quorem+0xa8>
  415962:	681a      	ldr	r2, [r3, #0]
  415964:	3b04      	subs	r3, #4
  415966:	b91a      	cbnz	r2, 415970 <quorem+0xb0>
  415968:	459b      	cmp	fp, r3
  41596a:	f108 38ff 	add.w	r8, r8, #4294967295
  41596e:	d3f8      	bcc.n	415962 <quorem+0xa2>
  415970:	f8c0 8010 	str.w	r8, [r0, #16]
  415974:	4604      	mov	r4, r0
  415976:	f001 fc95 	bl	4172a4 <__mcmp>
  41597a:	2800      	cmp	r0, #0
  41597c:	db2e      	blt.n	4159dc <quorem+0x11c>
  41597e:	f109 0901 	add.w	r9, r9, #1
  415982:	465d      	mov	r5, fp
  415984:	2300      	movs	r3, #0
  415986:	f857 1b04 	ldr.w	r1, [r7], #4
  41598a:	6828      	ldr	r0, [r5, #0]
  41598c:	b28a      	uxth	r2, r1
  41598e:	1a9a      	subs	r2, r3, r2
  415990:	0c0b      	lsrs	r3, r1, #16
  415992:	fa12 f280 	uxtah	r2, r2, r0
  415996:	ebc3 4310 	rsb	r3, r3, r0, lsr #16
  41599a:	eb03 4322 	add.w	r3, r3, r2, asr #16
  41599e:	b292      	uxth	r2, r2
  4159a0:	ea42 4203 	orr.w	r2, r2, r3, lsl #16
  4159a4:	45ba      	cmp	sl, r7
  4159a6:	f845 2b04 	str.w	r2, [r5], #4
  4159aa:	ea4f 4323 	mov.w	r3, r3, asr #16
  4159ae:	d2ea      	bcs.n	415986 <quorem+0xc6>
  4159b0:	f85b 2028 	ldr.w	r2, [fp, r8, lsl #2]
  4159b4:	eb0b 0388 	add.w	r3, fp, r8, lsl #2
  4159b8:	b982      	cbnz	r2, 4159dc <quorem+0x11c>
  4159ba:	1f1a      	subs	r2, r3, #4
  4159bc:	4593      	cmp	fp, r2
  4159be:	d20b      	bcs.n	4159d8 <quorem+0x118>
  4159c0:	f853 2c04 	ldr.w	r2, [r3, #-4]
  4159c4:	b942      	cbnz	r2, 4159d8 <quorem+0x118>
  4159c6:	3b08      	subs	r3, #8
  4159c8:	e002      	b.n	4159d0 <quorem+0x110>
  4159ca:	681a      	ldr	r2, [r3, #0]
  4159cc:	3b04      	subs	r3, #4
  4159ce:	b91a      	cbnz	r2, 4159d8 <quorem+0x118>
  4159d0:	459b      	cmp	fp, r3
  4159d2:	f108 38ff 	add.w	r8, r8, #4294967295
  4159d6:	d3f8      	bcc.n	4159ca <quorem+0x10a>
  4159d8:	f8c4 8010 	str.w	r8, [r4, #16]
  4159dc:	4648      	mov	r0, r9
  4159de:	b003      	add	sp, #12
  4159e0:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  4159e4:	2000      	movs	r0, #0
  4159e6:	4770      	bx	lr

004159e8 <_dtoa_r>:
  4159e8:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  4159ec:	ec57 6b10 	vmov	r6, r7, d0
  4159f0:	b097      	sub	sp, #92	; 0x5c
  4159f2:	6c05      	ldr	r5, [r0, #64]	; 0x40
  4159f4:	9102      	str	r1, [sp, #8]
  4159f6:	4604      	mov	r4, r0
  4159f8:	4693      	mov	fp, r2
  4159fa:	9303      	str	r3, [sp, #12]
  4159fc:	e9cd 6700 	strd	r6, r7, [sp]
  415a00:	b14d      	cbz	r5, 415a16 <_dtoa_r+0x2e>
  415a02:	6c42      	ldr	r2, [r0, #68]	; 0x44
  415a04:	606a      	str	r2, [r5, #4]
  415a06:	2301      	movs	r3, #1
  415a08:	4093      	lsls	r3, r2
  415a0a:	60ab      	str	r3, [r5, #8]
  415a0c:	4629      	mov	r1, r5
  415a0e:	f001 fa71 	bl	416ef4 <_Bfree>
  415a12:	2300      	movs	r3, #0
  415a14:	6423      	str	r3, [r4, #64]	; 0x40
  415a16:	e9dd 2300 	ldrd	r2, r3, [sp]
  415a1a:	2b00      	cmp	r3, #0
  415a1c:	4699      	mov	r9, r3
  415a1e:	db38      	blt.n	415a92 <_dtoa_r+0xaa>
  415a20:	9a20      	ldr	r2, [sp, #128]	; 0x80
  415a22:	2300      	movs	r3, #0
  415a24:	6013      	str	r3, [r2, #0]
  415a26:	4ba0      	ldr	r3, [pc, #640]	; (415ca8 <_dtoa_r+0x2c0>)
  415a28:	ea33 0309 	bics.w	r3, r3, r9
  415a2c:	d017      	beq.n	415a5e <_dtoa_r+0x76>
  415a2e:	e9dd 6700 	ldrd	r6, r7, [sp]
  415a32:	2200      	movs	r2, #0
  415a34:	2300      	movs	r3, #0
  415a36:	4630      	mov	r0, r6
  415a38:	4639      	mov	r1, r7
  415a3a:	f002 fa35 	bl	417ea8 <__aeabi_dcmpeq>
  415a3e:	4680      	mov	r8, r0
  415a40:	2800      	cmp	r0, #0
  415a42:	d02f      	beq.n	415aa4 <_dtoa_r+0xbc>
  415a44:	9a03      	ldr	r2, [sp, #12]
  415a46:	2301      	movs	r3, #1
  415a48:	6013      	str	r3, [r2, #0]
  415a4a:	9b21      	ldr	r3, [sp, #132]	; 0x84
  415a4c:	2b00      	cmp	r3, #0
  415a4e:	f000 80c4 	beq.w	415bda <_dtoa_r+0x1f2>
  415a52:	4896      	ldr	r0, [pc, #600]	; (415cac <_dtoa_r+0x2c4>)
  415a54:	6018      	str	r0, [r3, #0]
  415a56:	3801      	subs	r0, #1
  415a58:	b017      	add	sp, #92	; 0x5c
  415a5a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  415a5e:	9a03      	ldr	r2, [sp, #12]
  415a60:	f242 730f 	movw	r3, #9999	; 0x270f
  415a64:	6013      	str	r3, [r2, #0]
  415a66:	9b00      	ldr	r3, [sp, #0]
  415a68:	b96b      	cbnz	r3, 415a86 <_dtoa_r+0x9e>
  415a6a:	f3c9 0313 	ubfx	r3, r9, #0, #20
  415a6e:	b953      	cbnz	r3, 415a86 <_dtoa_r+0x9e>
  415a70:	9b21      	ldr	r3, [sp, #132]	; 0x84
  415a72:	488f      	ldr	r0, [pc, #572]	; (415cb0 <_dtoa_r+0x2c8>)
  415a74:	2b00      	cmp	r3, #0
  415a76:	d0ef      	beq.n	415a58 <_dtoa_r+0x70>
  415a78:	f100 0308 	add.w	r3, r0, #8
  415a7c:	9a21      	ldr	r2, [sp, #132]	; 0x84
  415a7e:	6013      	str	r3, [r2, #0]
  415a80:	b017      	add	sp, #92	; 0x5c
  415a82:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  415a86:	9b21      	ldr	r3, [sp, #132]	; 0x84
  415a88:	488a      	ldr	r0, [pc, #552]	; (415cb4 <_dtoa_r+0x2cc>)
  415a8a:	2b00      	cmp	r3, #0
  415a8c:	d0e4      	beq.n	415a58 <_dtoa_r+0x70>
  415a8e:	1cc3      	adds	r3, r0, #3
  415a90:	e7f4      	b.n	415a7c <_dtoa_r+0x94>
  415a92:	9a01      	ldr	r2, [sp, #4]
  415a94:	f022 4900 	bic.w	r9, r2, #2147483648	; 0x80000000
  415a98:	9a20      	ldr	r2, [sp, #128]	; 0x80
  415a9a:	f8cd 9004 	str.w	r9, [sp, #4]
  415a9e:	2301      	movs	r3, #1
  415aa0:	6013      	str	r3, [r2, #0]
  415aa2:	e7c0      	b.n	415a26 <_dtoa_r+0x3e>
  415aa4:	aa14      	add	r2, sp, #80	; 0x50
  415aa6:	a915      	add	r1, sp, #84	; 0x54
  415aa8:	ec47 6b10 	vmov	d0, r6, r7
  415aac:	4620      	mov	r0, r4
  415aae:	f001 fc99 	bl	4173e4 <__d2b>
  415ab2:	ea5f 5519 	movs.w	r5, r9, lsr #20
  415ab6:	4682      	mov	sl, r0
  415ab8:	d073      	beq.n	415ba2 <_dtoa_r+0x1ba>
  415aba:	f3c7 0313 	ubfx	r3, r7, #0, #20
  415abe:	f043 517f 	orr.w	r1, r3, #1069547520	; 0x3fc00000
  415ac2:	f8cd 8040 	str.w	r8, [sp, #64]	; 0x40
  415ac6:	f8dd 8050 	ldr.w	r8, [sp, #80]	; 0x50
  415aca:	4630      	mov	r0, r6
  415acc:	f2a5 35ff 	subw	r5, r5, #1023	; 0x3ff
  415ad0:	f441 1140 	orr.w	r1, r1, #3145728	; 0x300000
  415ad4:	2200      	movs	r2, #0
  415ad6:	4b78      	ldr	r3, [pc, #480]	; (415cb8 <_dtoa_r+0x2d0>)
  415ad8:	f7fd fcb8 	bl	41344c <__aeabi_dsub>
  415adc:	a36c      	add	r3, pc, #432	; (adr r3, 415c90 <_dtoa_r+0x2a8>)
  415ade:	e9d3 2300 	ldrd	r2, r3, [r3]
  415ae2:	f7fd fe67 	bl	4137b4 <__aeabi_dmul>
  415ae6:	a36c      	add	r3, pc, #432	; (adr r3, 415c98 <_dtoa_r+0x2b0>)
  415ae8:	e9d3 2300 	ldrd	r2, r3, [r3]
  415aec:	f7fd fcb0 	bl	413450 <__adddf3>
  415af0:	4606      	mov	r6, r0
  415af2:	4628      	mov	r0, r5
  415af4:	460f      	mov	r7, r1
  415af6:	f7fd fdf7 	bl	4136e8 <__aeabi_i2d>
  415afa:	a369      	add	r3, pc, #420	; (adr r3, 415ca0 <_dtoa_r+0x2b8>)
  415afc:	e9d3 2300 	ldrd	r2, r3, [r3]
  415b00:	f7fd fe58 	bl	4137b4 <__aeabi_dmul>
  415b04:	4602      	mov	r2, r0
  415b06:	460b      	mov	r3, r1
  415b08:	4630      	mov	r0, r6
  415b0a:	4639      	mov	r1, r7
  415b0c:	f7fd fca0 	bl	413450 <__adddf3>
  415b10:	4606      	mov	r6, r0
  415b12:	460f      	mov	r7, r1
  415b14:	f002 fa10 	bl	417f38 <__aeabi_d2iz>
  415b18:	2200      	movs	r2, #0
  415b1a:	9004      	str	r0, [sp, #16]
  415b1c:	2300      	movs	r3, #0
  415b1e:	4630      	mov	r0, r6
  415b20:	4639      	mov	r1, r7
  415b22:	f002 f9cb 	bl	417ebc <__aeabi_dcmplt>
  415b26:	2800      	cmp	r0, #0
  415b28:	f040 816f 	bne.w	415e0a <_dtoa_r+0x422>
  415b2c:	9e04      	ldr	r6, [sp, #16]
  415b2e:	2e16      	cmp	r6, #22
  415b30:	f200 8159 	bhi.w	415de6 <_dtoa_r+0x3fe>
  415b34:	4b61      	ldr	r3, [pc, #388]	; (415cbc <_dtoa_r+0x2d4>)
  415b36:	eb03 03c6 	add.w	r3, r3, r6, lsl #3
  415b3a:	e9d3 0100 	ldrd	r0, r1, [r3]
  415b3e:	e9dd 2300 	ldrd	r2, r3, [sp]
  415b42:	f002 f9d9 	bl	417ef8 <__aeabi_dcmpgt>
  415b46:	2800      	cmp	r0, #0
  415b48:	f000 81c4 	beq.w	415ed4 <_dtoa_r+0x4ec>
  415b4c:	1e73      	subs	r3, r6, #1
  415b4e:	9304      	str	r3, [sp, #16]
  415b50:	2300      	movs	r3, #0
  415b52:	930c      	str	r3, [sp, #48]	; 0x30
  415b54:	eba8 0505 	sub.w	r5, r8, r5
  415b58:	1e6b      	subs	r3, r5, #1
  415b5a:	9305      	str	r3, [sp, #20]
  415b5c:	f100 814f 	bmi.w	415dfe <_dtoa_r+0x416>
  415b60:	2300      	movs	r3, #0
  415b62:	9306      	str	r3, [sp, #24]
  415b64:	9b04      	ldr	r3, [sp, #16]
  415b66:	2b00      	cmp	r3, #0
  415b68:	f2c0 8140 	blt.w	415dec <_dtoa_r+0x404>
  415b6c:	9a05      	ldr	r2, [sp, #20]
  415b6e:	930b      	str	r3, [sp, #44]	; 0x2c
  415b70:	4611      	mov	r1, r2
  415b72:	4419      	add	r1, r3
  415b74:	2300      	movs	r3, #0
  415b76:	9105      	str	r1, [sp, #20]
  415b78:	930a      	str	r3, [sp, #40]	; 0x28
  415b7a:	9b02      	ldr	r3, [sp, #8]
  415b7c:	2b09      	cmp	r3, #9
  415b7e:	d82e      	bhi.n	415bde <_dtoa_r+0x1f6>
  415b80:	2b05      	cmp	r3, #5
  415b82:	f340 8651 	ble.w	416828 <_dtoa_r+0xe40>
  415b86:	3b04      	subs	r3, #4
  415b88:	9302      	str	r3, [sp, #8]
  415b8a:	2700      	movs	r7, #0
  415b8c:	9b02      	ldr	r3, [sp, #8]
  415b8e:	3b02      	subs	r3, #2
  415b90:	2b03      	cmp	r3, #3
  415b92:	f200 8633 	bhi.w	4167fc <_dtoa_r+0xe14>
  415b96:	e8df f013 	tbh	[pc, r3, lsl #1]
  415b9a:	03d6      	.short	0x03d6
  415b9c:	03e302cb 	.word	0x03e302cb
  415ba0:	0464      	.short	0x0464
  415ba2:	f8dd 8050 	ldr.w	r8, [sp, #80]	; 0x50
  415ba6:	9d15      	ldr	r5, [sp, #84]	; 0x54
  415ba8:	4445      	add	r5, r8
  415baa:	f205 4332 	addw	r3, r5, #1074	; 0x432
  415bae:	2b20      	cmp	r3, #32
  415bb0:	f340 818a 	ble.w	415ec8 <_dtoa_r+0x4e0>
  415bb4:	f1c3 0340 	rsb	r3, r3, #64	; 0x40
  415bb8:	fa09 f903 	lsl.w	r9, r9, r3
  415bbc:	9b00      	ldr	r3, [sp, #0]
  415bbe:	f205 4012 	addw	r0, r5, #1042	; 0x412
  415bc2:	fa23 f000 	lsr.w	r0, r3, r0
  415bc6:	ea40 0009 	orr.w	r0, r0, r9
  415bca:	f7fd fd7d 	bl	4136c8 <__aeabi_ui2d>
  415bce:	2301      	movs	r3, #1
  415bd0:	3d01      	subs	r5, #1
  415bd2:	f1a1 71f8 	sub.w	r1, r1, #32505856	; 0x1f00000
  415bd6:	9310      	str	r3, [sp, #64]	; 0x40
  415bd8:	e77c      	b.n	415ad4 <_dtoa_r+0xec>
  415bda:	4839      	ldr	r0, [pc, #228]	; (415cc0 <_dtoa_r+0x2d8>)
  415bdc:	e73c      	b.n	415a58 <_dtoa_r+0x70>
  415bde:	2100      	movs	r1, #0
  415be0:	6461      	str	r1, [r4, #68]	; 0x44
  415be2:	4620      	mov	r0, r4
  415be4:	468b      	mov	fp, r1
  415be6:	f001 f95f 	bl	416ea8 <_Balloc>
  415bea:	f04f 33ff 	mov.w	r3, #4294967295
  415bee:	9308      	str	r3, [sp, #32]
  415bf0:	930d      	str	r3, [sp, #52]	; 0x34
  415bf2:	2301      	movs	r3, #1
  415bf4:	9007      	str	r0, [sp, #28]
  415bf6:	6420      	str	r0, [r4, #64]	; 0x40
  415bf8:	f8cd b008 	str.w	fp, [sp, #8]
  415bfc:	9309      	str	r3, [sp, #36]	; 0x24
  415bfe:	9b15      	ldr	r3, [sp, #84]	; 0x54
  415c00:	2b00      	cmp	r3, #0
  415c02:	f2c0 80d0 	blt.w	415da6 <_dtoa_r+0x3be>
  415c06:	9a04      	ldr	r2, [sp, #16]
  415c08:	2a0e      	cmp	r2, #14
  415c0a:	f300 80cc 	bgt.w	415da6 <_dtoa_r+0x3be>
  415c0e:	4b2b      	ldr	r3, [pc, #172]	; (415cbc <_dtoa_r+0x2d4>)
  415c10:	f1bb 0f00 	cmp.w	fp, #0
  415c14:	eb03 03c2 	add.w	r3, r3, r2, lsl #3
  415c18:	e9d3 8900 	ldrd	r8, r9, [r3]
  415c1c:	f2c0 83be 	blt.w	41639c <_dtoa_r+0x9b4>
  415c20:	e9dd 6700 	ldrd	r6, r7, [sp]
  415c24:	4642      	mov	r2, r8
  415c26:	464b      	mov	r3, r9
  415c28:	4630      	mov	r0, r6
  415c2a:	4639      	mov	r1, r7
  415c2c:	f7fd feec 	bl	413a08 <__aeabi_ddiv>
  415c30:	f002 f982 	bl	417f38 <__aeabi_d2iz>
  415c34:	4683      	mov	fp, r0
  415c36:	f7fd fd57 	bl	4136e8 <__aeabi_i2d>
  415c3a:	4642      	mov	r2, r8
  415c3c:	464b      	mov	r3, r9
  415c3e:	f7fd fdb9 	bl	4137b4 <__aeabi_dmul>
  415c42:	460b      	mov	r3, r1
  415c44:	4602      	mov	r2, r0
  415c46:	4639      	mov	r1, r7
  415c48:	4630      	mov	r0, r6
  415c4a:	f7fd fbff 	bl	41344c <__aeabi_dsub>
  415c4e:	9d07      	ldr	r5, [sp, #28]
  415c50:	f10b 0330 	add.w	r3, fp, #48	; 0x30
  415c54:	702b      	strb	r3, [r5, #0]
  415c56:	9b08      	ldr	r3, [sp, #32]
  415c58:	2b01      	cmp	r3, #1
  415c5a:	4606      	mov	r6, r0
  415c5c:	460f      	mov	r7, r1
  415c5e:	f105 0501 	add.w	r5, r5, #1
  415c62:	d061      	beq.n	415d28 <_dtoa_r+0x340>
  415c64:	2200      	movs	r2, #0
  415c66:	4b17      	ldr	r3, [pc, #92]	; (415cc4 <_dtoa_r+0x2dc>)
  415c68:	f7fd fda4 	bl	4137b4 <__aeabi_dmul>
  415c6c:	2200      	movs	r2, #0
  415c6e:	2300      	movs	r3, #0
  415c70:	4606      	mov	r6, r0
  415c72:	460f      	mov	r7, r1
  415c74:	f002 f918 	bl	417ea8 <__aeabi_dcmpeq>
  415c78:	2800      	cmp	r0, #0
  415c7a:	f040 8081 	bne.w	415d80 <_dtoa_r+0x398>
  415c7e:	f8cd a000 	str.w	sl, [sp]
  415c82:	9402      	str	r4, [sp, #8]
  415c84:	f8dd a01c 	ldr.w	sl, [sp, #28]
  415c88:	9c08      	ldr	r4, [sp, #32]
  415c8a:	e028      	b.n	415cde <_dtoa_r+0x2f6>
  415c8c:	f3af 8000 	nop.w
  415c90:	636f4361 	.word	0x636f4361
  415c94:	3fd287a7 	.word	0x3fd287a7
  415c98:	8b60c8b3 	.word	0x8b60c8b3
  415c9c:	3fc68a28 	.word	0x3fc68a28
  415ca0:	509f79fb 	.word	0x509f79fb
  415ca4:	3fd34413 	.word	0x3fd34413
  415ca8:	7ff00000 	.word	0x7ff00000
  415cac:	0041d669 	.word	0x0041d669
  415cb0:	0041d68c 	.word	0x0041d68c
  415cb4:	0041d698 	.word	0x0041d698
  415cb8:	3ff80000 	.word	0x3ff80000
  415cbc:	0041d6c8 	.word	0x0041d6c8
  415cc0:	0041d668 	.word	0x0041d668
  415cc4:	40240000 	.word	0x40240000
  415cc8:	f7fd fd74 	bl	4137b4 <__aeabi_dmul>
  415ccc:	2200      	movs	r2, #0
  415cce:	2300      	movs	r3, #0
  415cd0:	4606      	mov	r6, r0
  415cd2:	460f      	mov	r7, r1
  415cd4:	f002 f8e8 	bl	417ea8 <__aeabi_dcmpeq>
  415cd8:	2800      	cmp	r0, #0
  415cda:	f040 83c5 	bne.w	416468 <_dtoa_r+0xa80>
  415cde:	4642      	mov	r2, r8
  415ce0:	464b      	mov	r3, r9
  415ce2:	4630      	mov	r0, r6
  415ce4:	4639      	mov	r1, r7
  415ce6:	f7fd fe8f 	bl	413a08 <__aeabi_ddiv>
  415cea:	f002 f925 	bl	417f38 <__aeabi_d2iz>
  415cee:	4683      	mov	fp, r0
  415cf0:	f7fd fcfa 	bl	4136e8 <__aeabi_i2d>
  415cf4:	4642      	mov	r2, r8
  415cf6:	464b      	mov	r3, r9
  415cf8:	f7fd fd5c 	bl	4137b4 <__aeabi_dmul>
  415cfc:	4602      	mov	r2, r0
  415cfe:	460b      	mov	r3, r1
  415d00:	4630      	mov	r0, r6
  415d02:	4639      	mov	r1, r7
  415d04:	f7fd fba2 	bl	41344c <__aeabi_dsub>
  415d08:	f10b 0e30 	add.w	lr, fp, #48	; 0x30
  415d0c:	f805 eb01 	strb.w	lr, [r5], #1
  415d10:	eba5 0e0a 	sub.w	lr, r5, sl
  415d14:	45a6      	cmp	lr, r4
  415d16:	4606      	mov	r6, r0
  415d18:	460f      	mov	r7, r1
  415d1a:	f04f 0200 	mov.w	r2, #0
  415d1e:	4b6e      	ldr	r3, [pc, #440]	; (415ed8 <_dtoa_r+0x4f0>)
  415d20:	d1d2      	bne.n	415cc8 <_dtoa_r+0x2e0>
  415d22:	f8dd a000 	ldr.w	sl, [sp]
  415d26:	9c02      	ldr	r4, [sp, #8]
  415d28:	4632      	mov	r2, r6
  415d2a:	463b      	mov	r3, r7
  415d2c:	4630      	mov	r0, r6
  415d2e:	4639      	mov	r1, r7
  415d30:	f7fd fb8e 	bl	413450 <__adddf3>
  415d34:	4606      	mov	r6, r0
  415d36:	460f      	mov	r7, r1
  415d38:	4602      	mov	r2, r0
  415d3a:	460b      	mov	r3, r1
  415d3c:	4640      	mov	r0, r8
  415d3e:	4649      	mov	r1, r9
  415d40:	f002 f8bc 	bl	417ebc <__aeabi_dcmplt>
  415d44:	b948      	cbnz	r0, 415d5a <_dtoa_r+0x372>
  415d46:	4632      	mov	r2, r6
  415d48:	463b      	mov	r3, r7
  415d4a:	4640      	mov	r0, r8
  415d4c:	4649      	mov	r1, r9
  415d4e:	f002 f8ab 	bl	417ea8 <__aeabi_dcmpeq>
  415d52:	b1a8      	cbz	r0, 415d80 <_dtoa_r+0x398>
  415d54:	f01b 0f01 	tst.w	fp, #1
  415d58:	d012      	beq.n	415d80 <_dtoa_r+0x398>
  415d5a:	f815 8c01 	ldrb.w	r8, [r5, #-1]
  415d5e:	9a07      	ldr	r2, [sp, #28]
  415d60:	1e6b      	subs	r3, r5, #1
  415d62:	e004      	b.n	415d6e <_dtoa_r+0x386>
  415d64:	429a      	cmp	r2, r3
  415d66:	f000 842d 	beq.w	4165c4 <_dtoa_r+0xbdc>
  415d6a:	f813 8d01 	ldrb.w	r8, [r3, #-1]!
  415d6e:	f1b8 0f39 	cmp.w	r8, #57	; 0x39
  415d72:	f103 0501 	add.w	r5, r3, #1
  415d76:	d0f5      	beq.n	415d64 <_dtoa_r+0x37c>
  415d78:	f108 0801 	add.w	r8, r8, #1
  415d7c:	f883 8000 	strb.w	r8, [r3]
  415d80:	4651      	mov	r1, sl
  415d82:	4620      	mov	r0, r4
  415d84:	f001 f8b6 	bl	416ef4 <_Bfree>
  415d88:	2200      	movs	r2, #0
  415d8a:	9b04      	ldr	r3, [sp, #16]
  415d8c:	702a      	strb	r2, [r5, #0]
  415d8e:	9a03      	ldr	r2, [sp, #12]
  415d90:	3301      	adds	r3, #1
  415d92:	6013      	str	r3, [r2, #0]
  415d94:	9b21      	ldr	r3, [sp, #132]	; 0x84
  415d96:	2b00      	cmp	r3, #0
  415d98:	f000 83a3 	beq.w	4164e2 <_dtoa_r+0xafa>
  415d9c:	9807      	ldr	r0, [sp, #28]
  415d9e:	601d      	str	r5, [r3, #0]
  415da0:	b017      	add	sp, #92	; 0x5c
  415da2:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  415da6:	9a09      	ldr	r2, [sp, #36]	; 0x24
  415da8:	2a00      	cmp	r2, #0
  415daa:	d040      	beq.n	415e2e <_dtoa_r+0x446>
  415dac:	9a02      	ldr	r2, [sp, #8]
  415dae:	2a01      	cmp	r2, #1
  415db0:	f340 831c 	ble.w	4163ec <_dtoa_r+0xa04>
  415db4:	9b08      	ldr	r3, [sp, #32]
  415db6:	9a0a      	ldr	r2, [sp, #40]	; 0x28
  415db8:	1e5f      	subs	r7, r3, #1
  415dba:	42ba      	cmp	r2, r7
  415dbc:	f2c0 8394 	blt.w	4164e8 <_dtoa_r+0xb00>
  415dc0:	1bd7      	subs	r7, r2, r7
  415dc2:	9b08      	ldr	r3, [sp, #32]
  415dc4:	2b00      	cmp	r3, #0
  415dc6:	f2c0 847e 	blt.w	4166c6 <_dtoa_r+0xcde>
  415dca:	9d06      	ldr	r5, [sp, #24]
  415dcc:	9b08      	ldr	r3, [sp, #32]
  415dce:	9a06      	ldr	r2, [sp, #24]
  415dd0:	441a      	add	r2, r3
  415dd2:	9206      	str	r2, [sp, #24]
  415dd4:	9a05      	ldr	r2, [sp, #20]
  415dd6:	2101      	movs	r1, #1
  415dd8:	441a      	add	r2, r3
  415dda:	4620      	mov	r0, r4
  415ddc:	9205      	str	r2, [sp, #20]
  415dde:	f001 f923 	bl	417028 <__i2b>
  415de2:	4606      	mov	r6, r0
  415de4:	e026      	b.n	415e34 <_dtoa_r+0x44c>
  415de6:	2301      	movs	r3, #1
  415de8:	930c      	str	r3, [sp, #48]	; 0x30
  415dea:	e6b3      	b.n	415b54 <_dtoa_r+0x16c>
  415dec:	9a06      	ldr	r2, [sp, #24]
  415dee:	9b04      	ldr	r3, [sp, #16]
  415df0:	1ad2      	subs	r2, r2, r3
  415df2:	425b      	negs	r3, r3
  415df4:	930a      	str	r3, [sp, #40]	; 0x28
  415df6:	2300      	movs	r3, #0
  415df8:	9206      	str	r2, [sp, #24]
  415dfa:	930b      	str	r3, [sp, #44]	; 0x2c
  415dfc:	e6bd      	b.n	415b7a <_dtoa_r+0x192>
  415dfe:	f1c5 0301 	rsb	r3, r5, #1
  415e02:	9306      	str	r3, [sp, #24]
  415e04:	2300      	movs	r3, #0
  415e06:	9305      	str	r3, [sp, #20]
  415e08:	e6ac      	b.n	415b64 <_dtoa_r+0x17c>
  415e0a:	f8dd 9010 	ldr.w	r9, [sp, #16]
  415e0e:	4648      	mov	r0, r9
  415e10:	f7fd fc6a 	bl	4136e8 <__aeabi_i2d>
  415e14:	4602      	mov	r2, r0
  415e16:	460b      	mov	r3, r1
  415e18:	4630      	mov	r0, r6
  415e1a:	4639      	mov	r1, r7
  415e1c:	f002 f844 	bl	417ea8 <__aeabi_dcmpeq>
  415e20:	2800      	cmp	r0, #0
  415e22:	f47f ae83 	bne.w	415b2c <_dtoa_r+0x144>
  415e26:	f109 33ff 	add.w	r3, r9, #4294967295
  415e2a:	9304      	str	r3, [sp, #16]
  415e2c:	e67e      	b.n	415b2c <_dtoa_r+0x144>
  415e2e:	9f0a      	ldr	r7, [sp, #40]	; 0x28
  415e30:	9d06      	ldr	r5, [sp, #24]
  415e32:	9e09      	ldr	r6, [sp, #36]	; 0x24
  415e34:	2d00      	cmp	r5, #0
  415e36:	dd0c      	ble.n	415e52 <_dtoa_r+0x46a>
  415e38:	9905      	ldr	r1, [sp, #20]
  415e3a:	2900      	cmp	r1, #0
  415e3c:	460b      	mov	r3, r1
  415e3e:	dd08      	ble.n	415e52 <_dtoa_r+0x46a>
  415e40:	42a9      	cmp	r1, r5
  415e42:	9a06      	ldr	r2, [sp, #24]
  415e44:	bfa8      	it	ge
  415e46:	462b      	movge	r3, r5
  415e48:	1ad2      	subs	r2, r2, r3
  415e4a:	1aed      	subs	r5, r5, r3
  415e4c:	1acb      	subs	r3, r1, r3
  415e4e:	9206      	str	r2, [sp, #24]
  415e50:	9305      	str	r3, [sp, #20]
  415e52:	9b0a      	ldr	r3, [sp, #40]	; 0x28
  415e54:	b1d3      	cbz	r3, 415e8c <_dtoa_r+0x4a4>
  415e56:	9b09      	ldr	r3, [sp, #36]	; 0x24
  415e58:	2b00      	cmp	r3, #0
  415e5a:	f000 82c0 	beq.w	4163de <_dtoa_r+0x9f6>
  415e5e:	2f00      	cmp	r7, #0
  415e60:	dd10      	ble.n	415e84 <_dtoa_r+0x49c>
  415e62:	4631      	mov	r1, r6
  415e64:	463a      	mov	r2, r7
  415e66:	4620      	mov	r0, r4
  415e68:	f001 f97a 	bl	417160 <__pow5mult>
  415e6c:	4652      	mov	r2, sl
  415e6e:	4601      	mov	r1, r0
  415e70:	4606      	mov	r6, r0
  415e72:	4620      	mov	r0, r4
  415e74:	f001 f8e2 	bl	41703c <__multiply>
  415e78:	4651      	mov	r1, sl
  415e7a:	4680      	mov	r8, r0
  415e7c:	4620      	mov	r0, r4
  415e7e:	f001 f839 	bl	416ef4 <_Bfree>
  415e82:	46c2      	mov	sl, r8
  415e84:	9b0a      	ldr	r3, [sp, #40]	; 0x28
  415e86:	1bda      	subs	r2, r3, r7
  415e88:	f040 82aa 	bne.w	4163e0 <_dtoa_r+0x9f8>
  415e8c:	2101      	movs	r1, #1
  415e8e:	4620      	mov	r0, r4
  415e90:	f001 f8ca 	bl	417028 <__i2b>
  415e94:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
  415e96:	2b00      	cmp	r3, #0
  415e98:	4681      	mov	r9, r0
  415e9a:	dd1f      	ble.n	415edc <_dtoa_r+0x4f4>
  415e9c:	4601      	mov	r1, r0
  415e9e:	461a      	mov	r2, r3
  415ea0:	4620      	mov	r0, r4
  415ea2:	f001 f95d 	bl	417160 <__pow5mult>
  415ea6:	9b02      	ldr	r3, [sp, #8]
  415ea8:	2b01      	cmp	r3, #1
  415eaa:	4681      	mov	r9, r0
  415eac:	f340 825b 	ble.w	416366 <_dtoa_r+0x97e>
  415eb0:	f04f 0800 	mov.w	r8, #0
  415eb4:	f8d9 3010 	ldr.w	r3, [r9, #16]
  415eb8:	eb09 0383 	add.w	r3, r9, r3, lsl #2
  415ebc:	6918      	ldr	r0, [r3, #16]
  415ebe:	f001 f863 	bl	416f88 <__hi0bits>
  415ec2:	f1c0 0020 	rsb	r0, r0, #32
  415ec6:	e013      	b.n	415ef0 <_dtoa_r+0x508>
  415ec8:	f1c3 0920 	rsb	r9, r3, #32
  415ecc:	9b00      	ldr	r3, [sp, #0]
  415ece:	fa03 f009 	lsl.w	r0, r3, r9
  415ed2:	e67a      	b.n	415bca <_dtoa_r+0x1e2>
  415ed4:	900c      	str	r0, [sp, #48]	; 0x30
  415ed6:	e63d      	b.n	415b54 <_dtoa_r+0x16c>
  415ed8:	40240000 	.word	0x40240000
  415edc:	9b02      	ldr	r3, [sp, #8]
  415ede:	2b01      	cmp	r3, #1
  415ee0:	f340 828d 	ble.w	4163fe <_dtoa_r+0xa16>
  415ee4:	f04f 0800 	mov.w	r8, #0
  415ee8:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
  415eea:	2001      	movs	r0, #1
  415eec:	2b00      	cmp	r3, #0
  415eee:	d1e1      	bne.n	415eb4 <_dtoa_r+0x4cc>
  415ef0:	9a05      	ldr	r2, [sp, #20]
  415ef2:	4410      	add	r0, r2
  415ef4:	f010 001f 	ands.w	r0, r0, #31
  415ef8:	f000 80a1 	beq.w	41603e <_dtoa_r+0x656>
  415efc:	f1c0 0320 	rsb	r3, r0, #32
  415f00:	2b04      	cmp	r3, #4
  415f02:	f340 848c 	ble.w	41681e <_dtoa_r+0xe36>
  415f06:	9b06      	ldr	r3, [sp, #24]
  415f08:	f1c0 001c 	rsb	r0, r0, #28
  415f0c:	4403      	add	r3, r0
  415f0e:	9306      	str	r3, [sp, #24]
  415f10:	4613      	mov	r3, r2
  415f12:	4403      	add	r3, r0
  415f14:	4405      	add	r5, r0
  415f16:	9305      	str	r3, [sp, #20]
  415f18:	9b06      	ldr	r3, [sp, #24]
  415f1a:	2b00      	cmp	r3, #0
  415f1c:	dd05      	ble.n	415f2a <_dtoa_r+0x542>
  415f1e:	4651      	mov	r1, sl
  415f20:	461a      	mov	r2, r3
  415f22:	4620      	mov	r0, r4
  415f24:	f001 f96c 	bl	417200 <__lshift>
  415f28:	4682      	mov	sl, r0
  415f2a:	9b05      	ldr	r3, [sp, #20]
  415f2c:	2b00      	cmp	r3, #0
  415f2e:	dd05      	ble.n	415f3c <_dtoa_r+0x554>
  415f30:	4649      	mov	r1, r9
  415f32:	461a      	mov	r2, r3
  415f34:	4620      	mov	r0, r4
  415f36:	f001 f963 	bl	417200 <__lshift>
  415f3a:	4681      	mov	r9, r0
  415f3c:	9b0c      	ldr	r3, [sp, #48]	; 0x30
  415f3e:	2b00      	cmp	r3, #0
  415f40:	f040 8086 	bne.w	416050 <_dtoa_r+0x668>
  415f44:	9b08      	ldr	r3, [sp, #32]
  415f46:	2b00      	cmp	r3, #0
  415f48:	f340 8269 	ble.w	41641e <_dtoa_r+0xa36>
  415f4c:	9b09      	ldr	r3, [sp, #36]	; 0x24
  415f4e:	2b00      	cmp	r3, #0
  415f50:	f000 8098 	beq.w	416084 <_dtoa_r+0x69c>
  415f54:	2d00      	cmp	r5, #0
  415f56:	dd05      	ble.n	415f64 <_dtoa_r+0x57c>
  415f58:	4631      	mov	r1, r6
  415f5a:	462a      	mov	r2, r5
  415f5c:	4620      	mov	r0, r4
  415f5e:	f001 f94f 	bl	417200 <__lshift>
  415f62:	4606      	mov	r6, r0
  415f64:	f1b8 0f00 	cmp.w	r8, #0
  415f68:	f040 8336 	bne.w	4165d8 <_dtoa_r+0xbf0>
  415f6c:	46b0      	mov	r8, r6
  415f6e:	9b08      	ldr	r3, [sp, #32]
  415f70:	9a07      	ldr	r2, [sp, #28]
  415f72:	3b01      	subs	r3, #1
  415f74:	18d3      	adds	r3, r2, r3
  415f76:	9308      	str	r3, [sp, #32]
  415f78:	9b00      	ldr	r3, [sp, #0]
  415f7a:	f003 0301 	and.w	r3, r3, #1
  415f7e:	9309      	str	r3, [sp, #36]	; 0x24
  415f80:	4617      	mov	r7, r2
  415f82:	4649      	mov	r1, r9
  415f84:	4650      	mov	r0, sl
  415f86:	f7ff fc9b 	bl	4158c0 <quorem>
  415f8a:	4631      	mov	r1, r6
  415f8c:	4605      	mov	r5, r0
  415f8e:	4650      	mov	r0, sl
  415f90:	f001 f988 	bl	4172a4 <__mcmp>
  415f94:	4642      	mov	r2, r8
  415f96:	4649      	mov	r1, r9
  415f98:	4683      	mov	fp, r0
  415f9a:	4620      	mov	r0, r4
  415f9c:	f001 f99e 	bl	4172dc <__mdiff>
  415fa0:	f105 0230 	add.w	r2, r5, #48	; 0x30
  415fa4:	9200      	str	r2, [sp, #0]
  415fa6:	68c2      	ldr	r2, [r0, #12]
  415fa8:	4601      	mov	r1, r0
  415faa:	2a00      	cmp	r2, #0
  415fac:	f040 8232 	bne.w	416414 <_dtoa_r+0xa2c>
  415fb0:	9006      	str	r0, [sp, #24]
  415fb2:	4650      	mov	r0, sl
  415fb4:	f001 f976 	bl	4172a4 <__mcmp>
  415fb8:	9b06      	ldr	r3, [sp, #24]
  415fba:	9005      	str	r0, [sp, #20]
  415fbc:	4619      	mov	r1, r3
  415fbe:	4620      	mov	r0, r4
  415fc0:	f000 ff98 	bl	416ef4 <_Bfree>
  415fc4:	9a05      	ldr	r2, [sp, #20]
  415fc6:	b932      	cbnz	r2, 415fd6 <_dtoa_r+0x5ee>
  415fc8:	9b02      	ldr	r3, [sp, #8]
  415fca:	b923      	cbnz	r3, 415fd6 <_dtoa_r+0x5ee>
  415fcc:	9b09      	ldr	r3, [sp, #36]	; 0x24
  415fce:	2b00      	cmp	r3, #0
  415fd0:	f000 83de 	beq.w	416790 <_dtoa_r+0xda8>
  415fd4:	9a02      	ldr	r2, [sp, #8]
  415fd6:	f1bb 0f00 	cmp.w	fp, #0
  415fda:	f2c0 82a2 	blt.w	416522 <_dtoa_r+0xb3a>
  415fde:	d105      	bne.n	415fec <_dtoa_r+0x604>
  415fe0:	9b02      	ldr	r3, [sp, #8]
  415fe2:	b91b      	cbnz	r3, 415fec <_dtoa_r+0x604>
  415fe4:	9b09      	ldr	r3, [sp, #36]	; 0x24
  415fe6:	2b00      	cmp	r3, #0
  415fe8:	f000 829b 	beq.w	416522 <_dtoa_r+0xb3a>
  415fec:	2a00      	cmp	r2, #0
  415fee:	f300 8307 	bgt.w	416600 <_dtoa_r+0xc18>
  415ff2:	f89d 3000 	ldrb.w	r3, [sp]
  415ff6:	703b      	strb	r3, [r7, #0]
  415ff8:	9b08      	ldr	r3, [sp, #32]
  415ffa:	f107 0b01 	add.w	fp, r7, #1
  415ffe:	429f      	cmp	r7, r3
  416000:	465d      	mov	r5, fp
  416002:	f000 8308 	beq.w	416616 <_dtoa_r+0xc2e>
  416006:	4651      	mov	r1, sl
  416008:	2300      	movs	r3, #0
  41600a:	220a      	movs	r2, #10
  41600c:	4620      	mov	r0, r4
  41600e:	f000 ff7b 	bl	416f08 <__multadd>
  416012:	4546      	cmp	r6, r8
  416014:	4682      	mov	sl, r0
  416016:	4631      	mov	r1, r6
  416018:	f04f 0300 	mov.w	r3, #0
  41601c:	f04f 020a 	mov.w	r2, #10
  416020:	4620      	mov	r0, r4
  416022:	f000 81f1 	beq.w	416408 <_dtoa_r+0xa20>
  416026:	f000 ff6f 	bl	416f08 <__multadd>
  41602a:	4641      	mov	r1, r8
  41602c:	4606      	mov	r6, r0
  41602e:	2300      	movs	r3, #0
  416030:	220a      	movs	r2, #10
  416032:	4620      	mov	r0, r4
  416034:	f000 ff68 	bl	416f08 <__multadd>
  416038:	465f      	mov	r7, fp
  41603a:	4680      	mov	r8, r0
  41603c:	e7a1      	b.n	415f82 <_dtoa_r+0x59a>
  41603e:	201c      	movs	r0, #28
  416040:	9b06      	ldr	r3, [sp, #24]
  416042:	4403      	add	r3, r0
  416044:	9306      	str	r3, [sp, #24]
  416046:	9b05      	ldr	r3, [sp, #20]
  416048:	4403      	add	r3, r0
  41604a:	4405      	add	r5, r0
  41604c:	9305      	str	r3, [sp, #20]
  41604e:	e763      	b.n	415f18 <_dtoa_r+0x530>
  416050:	4649      	mov	r1, r9
  416052:	4650      	mov	r0, sl
  416054:	f001 f926 	bl	4172a4 <__mcmp>
  416058:	2800      	cmp	r0, #0
  41605a:	f6bf af73 	bge.w	415f44 <_dtoa_r+0x55c>
  41605e:	9f04      	ldr	r7, [sp, #16]
  416060:	4651      	mov	r1, sl
  416062:	2300      	movs	r3, #0
  416064:	220a      	movs	r2, #10
  416066:	4620      	mov	r0, r4
  416068:	3f01      	subs	r7, #1
  41606a:	9704      	str	r7, [sp, #16]
  41606c:	f000 ff4c 	bl	416f08 <__multadd>
  416070:	9b09      	ldr	r3, [sp, #36]	; 0x24
  416072:	4682      	mov	sl, r0
  416074:	2b00      	cmp	r3, #0
  416076:	f040 83a7 	bne.w	4167c8 <_dtoa_r+0xde0>
  41607a:	9b0d      	ldr	r3, [sp, #52]	; 0x34
  41607c:	2b00      	cmp	r3, #0
  41607e:	f340 83b0 	ble.w	4167e2 <_dtoa_r+0xdfa>
  416082:	9308      	str	r3, [sp, #32]
  416084:	f8dd b01c 	ldr.w	fp, [sp, #28]
  416088:	f8dd 8020 	ldr.w	r8, [sp, #32]
  41608c:	465d      	mov	r5, fp
  41608e:	e002      	b.n	416096 <_dtoa_r+0x6ae>
  416090:	f000 ff3a 	bl	416f08 <__multadd>
  416094:	4682      	mov	sl, r0
  416096:	4649      	mov	r1, r9
  416098:	4650      	mov	r0, sl
  41609a:	f7ff fc11 	bl	4158c0 <quorem>
  41609e:	f100 0730 	add.w	r7, r0, #48	; 0x30
  4160a2:	f805 7b01 	strb.w	r7, [r5], #1
  4160a6:	eba5 030b 	sub.w	r3, r5, fp
  4160aa:	4543      	cmp	r3, r8
  4160ac:	f04f 020a 	mov.w	r2, #10
  4160b0:	f04f 0300 	mov.w	r3, #0
  4160b4:	4651      	mov	r1, sl
  4160b6:	4620      	mov	r0, r4
  4160b8:	dbea      	blt.n	416090 <_dtoa_r+0x6a8>
  4160ba:	9b07      	ldr	r3, [sp, #28]
  4160bc:	9a08      	ldr	r2, [sp, #32]
  4160be:	9700      	str	r7, [sp, #0]
  4160c0:	2a01      	cmp	r2, #1
  4160c2:	bfac      	ite	ge
  4160c4:	189b      	addge	r3, r3, r2
  4160c6:	3301      	addlt	r3, #1
  4160c8:	461d      	mov	r5, r3
  4160ca:	f04f 0b00 	mov.w	fp, #0
  4160ce:	4651      	mov	r1, sl
  4160d0:	2201      	movs	r2, #1
  4160d2:	4620      	mov	r0, r4
  4160d4:	f001 f894 	bl	417200 <__lshift>
  4160d8:	4649      	mov	r1, r9
  4160da:	4682      	mov	sl, r0
  4160dc:	f001 f8e2 	bl	4172a4 <__mcmp>
  4160e0:	2800      	cmp	r0, #0
  4160e2:	f340 823a 	ble.w	41655a <_dtoa_r+0xb72>
  4160e6:	f815 2c01 	ldrb.w	r2, [r5, #-1]
  4160ea:	9907      	ldr	r1, [sp, #28]
  4160ec:	1e6b      	subs	r3, r5, #1
  4160ee:	e004      	b.n	4160fa <_dtoa_r+0x712>
  4160f0:	428b      	cmp	r3, r1
  4160f2:	f000 81af 	beq.w	416454 <_dtoa_r+0xa6c>
  4160f6:	f813 2d01 	ldrb.w	r2, [r3, #-1]!
  4160fa:	2a39      	cmp	r2, #57	; 0x39
  4160fc:	f103 0501 	add.w	r5, r3, #1
  416100:	d0f6      	beq.n	4160f0 <_dtoa_r+0x708>
  416102:	3201      	adds	r2, #1
  416104:	701a      	strb	r2, [r3, #0]
  416106:	4649      	mov	r1, r9
  416108:	4620      	mov	r0, r4
  41610a:	f000 fef3 	bl	416ef4 <_Bfree>
  41610e:	2e00      	cmp	r6, #0
  416110:	f43f ae36 	beq.w	415d80 <_dtoa_r+0x398>
  416114:	f1bb 0f00 	cmp.w	fp, #0
  416118:	d005      	beq.n	416126 <_dtoa_r+0x73e>
  41611a:	45b3      	cmp	fp, r6
  41611c:	d003      	beq.n	416126 <_dtoa_r+0x73e>
  41611e:	4659      	mov	r1, fp
  416120:	4620      	mov	r0, r4
  416122:	f000 fee7 	bl	416ef4 <_Bfree>
  416126:	4631      	mov	r1, r6
  416128:	4620      	mov	r0, r4
  41612a:	f000 fee3 	bl	416ef4 <_Bfree>
  41612e:	e627      	b.n	415d80 <_dtoa_r+0x398>
  416130:	2300      	movs	r3, #0
  416132:	9309      	str	r3, [sp, #36]	; 0x24
  416134:	9b04      	ldr	r3, [sp, #16]
  416136:	445b      	add	r3, fp
  416138:	930d      	str	r3, [sp, #52]	; 0x34
  41613a:	3301      	adds	r3, #1
  41613c:	2b01      	cmp	r3, #1
  41613e:	461e      	mov	r6, r3
  416140:	461d      	mov	r5, r3
  416142:	9308      	str	r3, [sp, #32]
  416144:	bfb8      	it	lt
  416146:	2601      	movlt	r6, #1
  416148:	2100      	movs	r1, #0
  41614a:	2e17      	cmp	r6, #23
  41614c:	6461      	str	r1, [r4, #68]	; 0x44
  41614e:	d90a      	bls.n	416166 <_dtoa_r+0x77e>
  416150:	2201      	movs	r2, #1
  416152:	2304      	movs	r3, #4
  416154:	005b      	lsls	r3, r3, #1
  416156:	f103 0014 	add.w	r0, r3, #20
  41615a:	4286      	cmp	r6, r0
  41615c:	4611      	mov	r1, r2
  41615e:	f102 0201 	add.w	r2, r2, #1
  416162:	d2f7      	bcs.n	416154 <_dtoa_r+0x76c>
  416164:	6461      	str	r1, [r4, #68]	; 0x44
  416166:	4620      	mov	r0, r4
  416168:	f000 fe9e 	bl	416ea8 <_Balloc>
  41616c:	2d0e      	cmp	r5, #14
  41616e:	9007      	str	r0, [sp, #28]
  416170:	6420      	str	r0, [r4, #64]	; 0x40
  416172:	f63f ad44 	bhi.w	415bfe <_dtoa_r+0x216>
  416176:	2f00      	cmp	r7, #0
  416178:	f43f ad41 	beq.w	415bfe <_dtoa_r+0x216>
  41617c:	9904      	ldr	r1, [sp, #16]
  41617e:	2900      	cmp	r1, #0
  416180:	ed9d 7b00 	vldr	d7, [sp]
  416184:	f340 81f6 	ble.w	416574 <_dtoa_r+0xb8c>
  416188:	4bb9      	ldr	r3, [pc, #740]	; (416470 <_dtoa_r+0xa88>)
  41618a:	f001 020f 	and.w	r2, r1, #15
  41618e:	eb03 03c2 	add.w	r3, r3, r2, lsl #3
  416192:	110d      	asrs	r5, r1, #4
  416194:	e9d3 6700 	ldrd	r6, r7, [r3]
  416198:	06eb      	lsls	r3, r5, #27
  41619a:	f140 81ad 	bpl.w	4164f8 <_dtoa_r+0xb10>
  41619e:	4bb5      	ldr	r3, [pc, #724]	; (416474 <_dtoa_r+0xa8c>)
  4161a0:	ec51 0b17 	vmov	r0, r1, d7
  4161a4:	e9d3 2308 	ldrd	r2, r3, [r3, #32]
  4161a8:	f7fd fc2e 	bl	413a08 <__aeabi_ddiv>
  4161ac:	e9cd 010e 	strd	r0, r1, [sp, #56]	; 0x38
  4161b0:	f005 050f 	and.w	r5, r5, #15
  4161b4:	f04f 0903 	mov.w	r9, #3
  4161b8:	b18d      	cbz	r5, 4161de <_dtoa_r+0x7f6>
  4161ba:	f8df 82b8 	ldr.w	r8, [pc, #696]	; 416474 <_dtoa_r+0xa8c>
  4161be:	07e8      	lsls	r0, r5, #31
  4161c0:	d509      	bpl.n	4161d6 <_dtoa_r+0x7ee>
  4161c2:	4630      	mov	r0, r6
  4161c4:	4639      	mov	r1, r7
  4161c6:	e9d8 2300 	ldrd	r2, r3, [r8]
  4161ca:	f7fd faf3 	bl	4137b4 <__aeabi_dmul>
  4161ce:	f109 0901 	add.w	r9, r9, #1
  4161d2:	4606      	mov	r6, r0
  4161d4:	460f      	mov	r7, r1
  4161d6:	106d      	asrs	r5, r5, #1
  4161d8:	f108 0808 	add.w	r8, r8, #8
  4161dc:	d1ef      	bne.n	4161be <_dtoa_r+0x7d6>
  4161de:	463b      	mov	r3, r7
  4161e0:	4632      	mov	r2, r6
  4161e2:	e9dd 010e 	ldrd	r0, r1, [sp, #56]	; 0x38
  4161e6:	f7fd fc0f 	bl	413a08 <__aeabi_ddiv>
  4161ea:	4607      	mov	r7, r0
  4161ec:	4688      	mov	r8, r1
  4161ee:	9b0c      	ldr	r3, [sp, #48]	; 0x30
  4161f0:	b143      	cbz	r3, 416204 <_dtoa_r+0x81c>
  4161f2:	2200      	movs	r2, #0
  4161f4:	4ba0      	ldr	r3, [pc, #640]	; (416478 <_dtoa_r+0xa90>)
  4161f6:	4638      	mov	r0, r7
  4161f8:	4641      	mov	r1, r8
  4161fa:	f001 fe5f 	bl	417ebc <__aeabi_dcmplt>
  4161fe:	2800      	cmp	r0, #0
  416200:	f040 8273 	bne.w	4166ea <_dtoa_r+0xd02>
  416204:	4648      	mov	r0, r9
  416206:	f7fd fa6f 	bl	4136e8 <__aeabi_i2d>
  41620a:	463a      	mov	r2, r7
  41620c:	4643      	mov	r3, r8
  41620e:	f7fd fad1 	bl	4137b4 <__aeabi_dmul>
  416212:	4b9a      	ldr	r3, [pc, #616]	; (41647c <_dtoa_r+0xa94>)
  416214:	2200      	movs	r2, #0
  416216:	f7fd f91b 	bl	413450 <__adddf3>
  41621a:	9b08      	ldr	r3, [sp, #32]
  41621c:	4605      	mov	r5, r0
  41621e:	f1a1 7650 	sub.w	r6, r1, #54525952	; 0x3400000
  416222:	2b00      	cmp	r3, #0
  416224:	f000 8140 	beq.w	4164a8 <_dtoa_r+0xac0>
  416228:	9b04      	ldr	r3, [sp, #16]
  41622a:	f8dd 9020 	ldr.w	r9, [sp, #32]
  41622e:	9311      	str	r3, [sp, #68]	; 0x44
  416230:	9b09      	ldr	r3, [sp, #36]	; 0x24
  416232:	2b00      	cmp	r3, #0
  416234:	f000 81f6 	beq.w	416624 <_dtoa_r+0xc3c>
  416238:	4b8d      	ldr	r3, [pc, #564]	; (416470 <_dtoa_r+0xa88>)
  41623a:	4991      	ldr	r1, [pc, #580]	; (416480 <_dtoa_r+0xa98>)
  41623c:	eb03 03c9 	add.w	r3, r3, r9, lsl #3
  416240:	e953 2302 	ldrd	r2, r3, [r3, #-8]
  416244:	2000      	movs	r0, #0
  416246:	f7fd fbdf 	bl	413a08 <__aeabi_ddiv>
  41624a:	462a      	mov	r2, r5
  41624c:	4633      	mov	r3, r6
  41624e:	f7fd f8fd 	bl	41344c <__aeabi_dsub>
  416252:	e9cd 010e 	strd	r0, r1, [sp, #56]	; 0x38
  416256:	4641      	mov	r1, r8
  416258:	4638      	mov	r0, r7
  41625a:	f001 fe6d 	bl	417f38 <__aeabi_d2iz>
  41625e:	4605      	mov	r5, r0
  416260:	f7fd fa42 	bl	4136e8 <__aeabi_i2d>
  416264:	4602      	mov	r2, r0
  416266:	460b      	mov	r3, r1
  416268:	4638      	mov	r0, r7
  41626a:	4641      	mov	r1, r8
  41626c:	f7fd f8ee 	bl	41344c <__aeabi_dsub>
  416270:	3530      	adds	r5, #48	; 0x30
  416272:	fa5f f885 	uxtb.w	r8, r5
  416276:	9d07      	ldr	r5, [sp, #28]
  416278:	4606      	mov	r6, r0
  41627a:	460f      	mov	r7, r1
  41627c:	f885 8000 	strb.w	r8, [r5]
  416280:	4602      	mov	r2, r0
  416282:	460b      	mov	r3, r1
  416284:	e9dd 010e 	ldrd	r0, r1, [sp, #56]	; 0x38
  416288:	3501      	adds	r5, #1
  41628a:	f001 fe35 	bl	417ef8 <__aeabi_dcmpgt>
  41628e:	2800      	cmp	r0, #0
  416290:	d156      	bne.n	416340 <_dtoa_r+0x958>
  416292:	4632      	mov	r2, r6
  416294:	463b      	mov	r3, r7
  416296:	2000      	movs	r0, #0
  416298:	4977      	ldr	r1, [pc, #476]	; (416478 <_dtoa_r+0xa90>)
  41629a:	f7fd f8d7 	bl	41344c <__aeabi_dsub>
  41629e:	4602      	mov	r2, r0
  4162a0:	460b      	mov	r3, r1
  4162a2:	e9dd 010e 	ldrd	r0, r1, [sp, #56]	; 0x38
  4162a6:	f001 fe27 	bl	417ef8 <__aeabi_dcmpgt>
  4162aa:	2800      	cmp	r0, #0
  4162ac:	f040 8262 	bne.w	416774 <_dtoa_r+0xd8c>
  4162b0:	f1b9 0f01 	cmp.w	r9, #1
  4162b4:	f43f aca3 	beq.w	415bfe <_dtoa_r+0x216>
  4162b8:	9b07      	ldr	r3, [sp, #28]
  4162ba:	f8cd a048 	str.w	sl, [sp, #72]	; 0x48
  4162be:	f8cd b04c 	str.w	fp, [sp, #76]	; 0x4c
  4162c2:	4499      	add	r9, r3
  4162c4:	46a0      	mov	r8, r4
  4162c6:	e9dd ab0e 	ldrd	sl, fp, [sp, #56]	; 0x38
  4162ca:	e00d      	b.n	4162e8 <_dtoa_r+0x900>
  4162cc:	2000      	movs	r0, #0
  4162ce:	496a      	ldr	r1, [pc, #424]	; (416478 <_dtoa_r+0xa90>)
  4162d0:	f7fd f8bc 	bl	41344c <__aeabi_dsub>
  4162d4:	4652      	mov	r2, sl
  4162d6:	465b      	mov	r3, fp
  4162d8:	f001 fdf0 	bl	417ebc <__aeabi_dcmplt>
  4162dc:	2800      	cmp	r0, #0
  4162de:	f040 8244 	bne.w	41676a <_dtoa_r+0xd82>
  4162e2:	454d      	cmp	r5, r9
  4162e4:	f000 824a 	beq.w	41677c <_dtoa_r+0xd94>
  4162e8:	4650      	mov	r0, sl
  4162ea:	4659      	mov	r1, fp
  4162ec:	2200      	movs	r2, #0
  4162ee:	4b65      	ldr	r3, [pc, #404]	; (416484 <_dtoa_r+0xa9c>)
  4162f0:	f7fd fa60 	bl	4137b4 <__aeabi_dmul>
  4162f4:	2200      	movs	r2, #0
  4162f6:	4b63      	ldr	r3, [pc, #396]	; (416484 <_dtoa_r+0xa9c>)
  4162f8:	4682      	mov	sl, r0
  4162fa:	468b      	mov	fp, r1
  4162fc:	4630      	mov	r0, r6
  4162fe:	4639      	mov	r1, r7
  416300:	f7fd fa58 	bl	4137b4 <__aeabi_dmul>
  416304:	460f      	mov	r7, r1
  416306:	4606      	mov	r6, r0
  416308:	f001 fe16 	bl	417f38 <__aeabi_d2iz>
  41630c:	4604      	mov	r4, r0
  41630e:	f7fd f9eb 	bl	4136e8 <__aeabi_i2d>
  416312:	4602      	mov	r2, r0
  416314:	460b      	mov	r3, r1
  416316:	4630      	mov	r0, r6
  416318:	4639      	mov	r1, r7
  41631a:	f7fd f897 	bl	41344c <__aeabi_dsub>
  41631e:	3430      	adds	r4, #48	; 0x30
  416320:	b2e4      	uxtb	r4, r4
  416322:	4652      	mov	r2, sl
  416324:	465b      	mov	r3, fp
  416326:	f805 4b01 	strb.w	r4, [r5], #1
  41632a:	4606      	mov	r6, r0
  41632c:	460f      	mov	r7, r1
  41632e:	f001 fdc5 	bl	417ebc <__aeabi_dcmplt>
  416332:	4632      	mov	r2, r6
  416334:	463b      	mov	r3, r7
  416336:	2800      	cmp	r0, #0
  416338:	d0c8      	beq.n	4162cc <_dtoa_r+0x8e4>
  41633a:	f8dd a048 	ldr.w	sl, [sp, #72]	; 0x48
  41633e:	4644      	mov	r4, r8
  416340:	9b11      	ldr	r3, [sp, #68]	; 0x44
  416342:	9304      	str	r3, [sp, #16]
  416344:	e51c      	b.n	415d80 <_dtoa_r+0x398>
  416346:	2300      	movs	r3, #0
  416348:	9309      	str	r3, [sp, #36]	; 0x24
  41634a:	f1bb 0f00 	cmp.w	fp, #0
  41634e:	f340 80da 	ble.w	416506 <_dtoa_r+0xb1e>
  416352:	465e      	mov	r6, fp
  416354:	465d      	mov	r5, fp
  416356:	f8cd b034 	str.w	fp, [sp, #52]	; 0x34
  41635a:	f8cd b020 	str.w	fp, [sp, #32]
  41635e:	e6f3      	b.n	416148 <_dtoa_r+0x760>
  416360:	2301      	movs	r3, #1
  416362:	9309      	str	r3, [sp, #36]	; 0x24
  416364:	e7f1      	b.n	41634a <_dtoa_r+0x962>
  416366:	9b00      	ldr	r3, [sp, #0]
  416368:	2b00      	cmp	r3, #0
  41636a:	f47f ada1 	bne.w	415eb0 <_dtoa_r+0x4c8>
  41636e:	e9dd 1200 	ldrd	r1, r2, [sp]
  416372:	f3c2 0313 	ubfx	r3, r2, #0, #20
  416376:	2b00      	cmp	r3, #0
  416378:	f47f adb4 	bne.w	415ee4 <_dtoa_r+0x4fc>
  41637c:	f022 4700 	bic.w	r7, r2, #2147483648	; 0x80000000
  416380:	0d3f      	lsrs	r7, r7, #20
  416382:	053f      	lsls	r7, r7, #20
  416384:	2f00      	cmp	r7, #0
  416386:	f000 8200 	beq.w	41678a <_dtoa_r+0xda2>
  41638a:	9b06      	ldr	r3, [sp, #24]
  41638c:	3301      	adds	r3, #1
  41638e:	9306      	str	r3, [sp, #24]
  416390:	9b05      	ldr	r3, [sp, #20]
  416392:	3301      	adds	r3, #1
  416394:	9305      	str	r3, [sp, #20]
  416396:	f04f 0801 	mov.w	r8, #1
  41639a:	e5a5      	b.n	415ee8 <_dtoa_r+0x500>
  41639c:	9b08      	ldr	r3, [sp, #32]
  41639e:	2b00      	cmp	r3, #0
  4163a0:	f73f ac3e 	bgt.w	415c20 <_dtoa_r+0x238>
  4163a4:	f040 8099 	bne.w	4164da <_dtoa_r+0xaf2>
  4163a8:	4649      	mov	r1, r9
  4163aa:	2200      	movs	r2, #0
  4163ac:	4b36      	ldr	r3, [pc, #216]	; (416488 <_dtoa_r+0xaa0>)
  4163ae:	4640      	mov	r0, r8
  4163b0:	f7fd fa00 	bl	4137b4 <__aeabi_dmul>
  4163b4:	e9dd 2300 	ldrd	r2, r3, [sp]
  4163b8:	f001 fd94 	bl	417ee4 <__aeabi_dcmpge>
  4163bc:	f8dd 9020 	ldr.w	r9, [sp, #32]
  4163c0:	464e      	mov	r6, r9
  4163c2:	2800      	cmp	r0, #0
  4163c4:	d03e      	beq.n	416444 <_dtoa_r+0xa5c>
  4163c6:	ea6f 030b 	mvn.w	r3, fp
  4163ca:	9d07      	ldr	r5, [sp, #28]
  4163cc:	9304      	str	r3, [sp, #16]
  4163ce:	4649      	mov	r1, r9
  4163d0:	4620      	mov	r0, r4
  4163d2:	f000 fd8f 	bl	416ef4 <_Bfree>
  4163d6:	2e00      	cmp	r6, #0
  4163d8:	f43f acd2 	beq.w	415d80 <_dtoa_r+0x398>
  4163dc:	e6a3      	b.n	416126 <_dtoa_r+0x73e>
  4163de:	9a0a      	ldr	r2, [sp, #40]	; 0x28
  4163e0:	4651      	mov	r1, sl
  4163e2:	4620      	mov	r0, r4
  4163e4:	f000 febc 	bl	417160 <__pow5mult>
  4163e8:	4682      	mov	sl, r0
  4163ea:	e54f      	b.n	415e8c <_dtoa_r+0x4a4>
  4163ec:	9a10      	ldr	r2, [sp, #64]	; 0x40
  4163ee:	2a00      	cmp	r2, #0
  4163f0:	f000 816f 	beq.w	4166d2 <_dtoa_r+0xcea>
  4163f4:	f203 4333 	addw	r3, r3, #1075	; 0x433
  4163f8:	9f0a      	ldr	r7, [sp, #40]	; 0x28
  4163fa:	9d06      	ldr	r5, [sp, #24]
  4163fc:	e4e7      	b.n	415dce <_dtoa_r+0x3e6>
  4163fe:	9b00      	ldr	r3, [sp, #0]
  416400:	2b00      	cmp	r3, #0
  416402:	f47f ad6f 	bne.w	415ee4 <_dtoa_r+0x4fc>
  416406:	e7b2      	b.n	41636e <_dtoa_r+0x986>
  416408:	f000 fd7e 	bl	416f08 <__multadd>
  41640c:	465f      	mov	r7, fp
  41640e:	4606      	mov	r6, r0
  416410:	4680      	mov	r8, r0
  416412:	e5b6      	b.n	415f82 <_dtoa_r+0x59a>
  416414:	4620      	mov	r0, r4
  416416:	f000 fd6d 	bl	416ef4 <_Bfree>
  41641a:	2201      	movs	r2, #1
  41641c:	e5db      	b.n	415fd6 <_dtoa_r+0x5ee>
  41641e:	9b02      	ldr	r3, [sp, #8]
  416420:	2b02      	cmp	r3, #2
  416422:	f77f ad93 	ble.w	415f4c <_dtoa_r+0x564>
  416426:	9b08      	ldr	r3, [sp, #32]
  416428:	2b00      	cmp	r3, #0
  41642a:	d1cc      	bne.n	4163c6 <_dtoa_r+0x9de>
  41642c:	4649      	mov	r1, r9
  41642e:	2205      	movs	r2, #5
  416430:	4620      	mov	r0, r4
  416432:	f000 fd69 	bl	416f08 <__multadd>
  416436:	4601      	mov	r1, r0
  416438:	4681      	mov	r9, r0
  41643a:	4650      	mov	r0, sl
  41643c:	f000 ff32 	bl	4172a4 <__mcmp>
  416440:	2800      	cmp	r0, #0
  416442:	ddc0      	ble.n	4163c6 <_dtoa_r+0x9de>
  416444:	9a04      	ldr	r2, [sp, #16]
  416446:	9907      	ldr	r1, [sp, #28]
  416448:	2331      	movs	r3, #49	; 0x31
  41644a:	3201      	adds	r2, #1
  41644c:	9204      	str	r2, [sp, #16]
  41644e:	700b      	strb	r3, [r1, #0]
  416450:	1c4d      	adds	r5, r1, #1
  416452:	e7bc      	b.n	4163ce <_dtoa_r+0x9e6>
  416454:	9a04      	ldr	r2, [sp, #16]
  416456:	3201      	adds	r2, #1
  416458:	9204      	str	r2, [sp, #16]
  41645a:	9a07      	ldr	r2, [sp, #28]
  41645c:	2331      	movs	r3, #49	; 0x31
  41645e:	7013      	strb	r3, [r2, #0]
  416460:	e651      	b.n	416106 <_dtoa_r+0x71e>
  416462:	2301      	movs	r3, #1
  416464:	9309      	str	r3, [sp, #36]	; 0x24
  416466:	e665      	b.n	416134 <_dtoa_r+0x74c>
  416468:	f8dd a000 	ldr.w	sl, [sp]
  41646c:	9c02      	ldr	r4, [sp, #8]
  41646e:	e487      	b.n	415d80 <_dtoa_r+0x398>
  416470:	0041d6c8 	.word	0x0041d6c8
  416474:	0041d6a0 	.word	0x0041d6a0
  416478:	3ff00000 	.word	0x3ff00000
  41647c:	401c0000 	.word	0x401c0000
  416480:	3fe00000 	.word	0x3fe00000
  416484:	40240000 	.word	0x40240000
  416488:	40140000 	.word	0x40140000
  41648c:	4648      	mov	r0, r9
  41648e:	f7fd f92b 	bl	4136e8 <__aeabi_i2d>
  416492:	463a      	mov	r2, r7
  416494:	4643      	mov	r3, r8
  416496:	f7fd f98d 	bl	4137b4 <__aeabi_dmul>
  41649a:	2200      	movs	r2, #0
  41649c:	4bc4      	ldr	r3, [pc, #784]	; (4167b0 <_dtoa_r+0xdc8>)
  41649e:	f7fc ffd7 	bl	413450 <__adddf3>
  4164a2:	4605      	mov	r5, r0
  4164a4:	f1a1 7650 	sub.w	r6, r1, #54525952	; 0x3400000
  4164a8:	4641      	mov	r1, r8
  4164aa:	2200      	movs	r2, #0
  4164ac:	4bc1      	ldr	r3, [pc, #772]	; (4167b4 <_dtoa_r+0xdcc>)
  4164ae:	4638      	mov	r0, r7
  4164b0:	f7fc ffcc 	bl	41344c <__aeabi_dsub>
  4164b4:	462a      	mov	r2, r5
  4164b6:	4633      	mov	r3, r6
  4164b8:	4680      	mov	r8, r0
  4164ba:	4689      	mov	r9, r1
  4164bc:	f001 fd1c 	bl	417ef8 <__aeabi_dcmpgt>
  4164c0:	2800      	cmp	r0, #0
  4164c2:	f040 80ab 	bne.w	41661c <_dtoa_r+0xc34>
  4164c6:	462a      	mov	r2, r5
  4164c8:	f106 4300 	add.w	r3, r6, #2147483648	; 0x80000000
  4164cc:	4640      	mov	r0, r8
  4164ce:	4649      	mov	r1, r9
  4164d0:	f001 fcf4 	bl	417ebc <__aeabi_dcmplt>
  4164d4:	2800      	cmp	r0, #0
  4164d6:	f43f ab92 	beq.w	415bfe <_dtoa_r+0x216>
  4164da:	f04f 0900 	mov.w	r9, #0
  4164de:	464e      	mov	r6, r9
  4164e0:	e771      	b.n	4163c6 <_dtoa_r+0x9de>
  4164e2:	9807      	ldr	r0, [sp, #28]
  4164e4:	f7ff bab8 	b.w	415a58 <_dtoa_r+0x70>
  4164e8:	9b0a      	ldr	r3, [sp, #40]	; 0x28
  4164ea:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
  4164ec:	970a      	str	r7, [sp, #40]	; 0x28
  4164ee:	1afb      	subs	r3, r7, r3
  4164f0:	441a      	add	r2, r3
  4164f2:	920b      	str	r2, [sp, #44]	; 0x2c
  4164f4:	2700      	movs	r7, #0
  4164f6:	e464      	b.n	415dc2 <_dtoa_r+0x3da>
  4164f8:	ed9d 7b00 	vldr	d7, [sp]
  4164fc:	f04f 0902 	mov.w	r9, #2
  416500:	ed8d 7b0e 	vstr	d7, [sp, #56]	; 0x38
  416504:	e658      	b.n	4161b8 <_dtoa_r+0x7d0>
  416506:	2100      	movs	r1, #0
  416508:	6461      	str	r1, [r4, #68]	; 0x44
  41650a:	4620      	mov	r0, r4
  41650c:	f000 fccc 	bl	416ea8 <_Balloc>
  416510:	f04f 0b01 	mov.w	fp, #1
  416514:	9007      	str	r0, [sp, #28]
  416516:	6420      	str	r0, [r4, #64]	; 0x40
  416518:	f8cd b020 	str.w	fp, [sp, #32]
  41651c:	f8cd b034 	str.w	fp, [sp, #52]	; 0x34
  416520:	e629      	b.n	416176 <_dtoa_r+0x78e>
  416522:	2a00      	cmp	r2, #0
  416524:	dd12      	ble.n	41654c <_dtoa_r+0xb64>
  416526:	4651      	mov	r1, sl
  416528:	2201      	movs	r2, #1
  41652a:	4620      	mov	r0, r4
  41652c:	f000 fe68 	bl	417200 <__lshift>
  416530:	4649      	mov	r1, r9
  416532:	4682      	mov	sl, r0
  416534:	f000 feb6 	bl	4172a4 <__mcmp>
  416538:	2800      	cmp	r0, #0
  41653a:	f340 8131 	ble.w	4167a0 <_dtoa_r+0xdb8>
  41653e:	9b00      	ldr	r3, [sp, #0]
  416540:	2b39      	cmp	r3, #57	; 0x39
  416542:	f000 80f7 	beq.w	416734 <_dtoa_r+0xd4c>
  416546:	f105 0331 	add.w	r3, r5, #49	; 0x31
  41654a:	9300      	str	r3, [sp, #0]
  41654c:	f89d 3000 	ldrb.w	r3, [sp]
  416550:	703b      	strb	r3, [r7, #0]
  416552:	46b3      	mov	fp, r6
  416554:	1c7d      	adds	r5, r7, #1
  416556:	4646      	mov	r6, r8
  416558:	e5d5      	b.n	416106 <_dtoa_r+0x71e>
  41655a:	d104      	bne.n	416566 <_dtoa_r+0xb7e>
  41655c:	9b00      	ldr	r3, [sp, #0]
  41655e:	07db      	lsls	r3, r3, #31
  416560:	d501      	bpl.n	416566 <_dtoa_r+0xb7e>
  416562:	e5c0      	b.n	4160e6 <_dtoa_r+0x6fe>
  416564:	4615      	mov	r5, r2
  416566:	f815 3c01 	ldrb.w	r3, [r5, #-1]
  41656a:	2b30      	cmp	r3, #48	; 0x30
  41656c:	f105 32ff 	add.w	r2, r5, #4294967295
  416570:	d0f8      	beq.n	416564 <_dtoa_r+0xb7c>
  416572:	e5c8      	b.n	416106 <_dtoa_r+0x71e>
  416574:	f000 80b4 	beq.w	4166e0 <_dtoa_r+0xcf8>
  416578:	9b04      	ldr	r3, [sp, #16]
  41657a:	425d      	negs	r5, r3
  41657c:	4b8e      	ldr	r3, [pc, #568]	; (4167b8 <_dtoa_r+0xdd0>)
  41657e:	f005 020f 	and.w	r2, r5, #15
  416582:	eb03 03c2 	add.w	r3, r3, r2, lsl #3
  416586:	e9d3 2300 	ldrd	r2, r3, [r3]
  41658a:	e9dd 0100 	ldrd	r0, r1, [sp]
  41658e:	f7fd f911 	bl	4137b4 <__aeabi_dmul>
  416592:	112d      	asrs	r5, r5, #4
  416594:	4607      	mov	r7, r0
  416596:	4688      	mov	r8, r1
  416598:	f000 8128 	beq.w	4167ec <_dtoa_r+0xe04>
  41659c:	4e87      	ldr	r6, [pc, #540]	; (4167bc <_dtoa_r+0xdd4>)
  41659e:	f04f 0902 	mov.w	r9, #2
  4165a2:	07e9      	lsls	r1, r5, #31
  4165a4:	d509      	bpl.n	4165ba <_dtoa_r+0xbd2>
  4165a6:	4638      	mov	r0, r7
  4165a8:	4641      	mov	r1, r8
  4165aa:	e9d6 2300 	ldrd	r2, r3, [r6]
  4165ae:	f7fd f901 	bl	4137b4 <__aeabi_dmul>
  4165b2:	f109 0901 	add.w	r9, r9, #1
  4165b6:	4607      	mov	r7, r0
  4165b8:	4688      	mov	r8, r1
  4165ba:	106d      	asrs	r5, r5, #1
  4165bc:	f106 0608 	add.w	r6, r6, #8
  4165c0:	d1ef      	bne.n	4165a2 <_dtoa_r+0xbba>
  4165c2:	e614      	b.n	4161ee <_dtoa_r+0x806>
  4165c4:	9907      	ldr	r1, [sp, #28]
  4165c6:	2230      	movs	r2, #48	; 0x30
  4165c8:	700a      	strb	r2, [r1, #0]
  4165ca:	9a04      	ldr	r2, [sp, #16]
  4165cc:	f815 8c01 	ldrb.w	r8, [r5, #-1]
  4165d0:	3201      	adds	r2, #1
  4165d2:	9204      	str	r2, [sp, #16]
  4165d4:	f7ff bbd0 	b.w	415d78 <_dtoa_r+0x390>
  4165d8:	6871      	ldr	r1, [r6, #4]
  4165da:	4620      	mov	r0, r4
  4165dc:	f000 fc64 	bl	416ea8 <_Balloc>
  4165e0:	6933      	ldr	r3, [r6, #16]
  4165e2:	3302      	adds	r3, #2
  4165e4:	009a      	lsls	r2, r3, #2
  4165e6:	4605      	mov	r5, r0
  4165e8:	f106 010c 	add.w	r1, r6, #12
  4165ec:	300c      	adds	r0, #12
  4165ee:	f7fd fd29 	bl	414044 <memcpy>
  4165f2:	4629      	mov	r1, r5
  4165f4:	2201      	movs	r2, #1
  4165f6:	4620      	mov	r0, r4
  4165f8:	f000 fe02 	bl	417200 <__lshift>
  4165fc:	4680      	mov	r8, r0
  4165fe:	e4b6      	b.n	415f6e <_dtoa_r+0x586>
  416600:	9b00      	ldr	r3, [sp, #0]
  416602:	2b39      	cmp	r3, #57	; 0x39
  416604:	f000 8096 	beq.w	416734 <_dtoa_r+0xd4c>
  416608:	9b00      	ldr	r3, [sp, #0]
  41660a:	3301      	adds	r3, #1
  41660c:	46b3      	mov	fp, r6
  41660e:	703b      	strb	r3, [r7, #0]
  416610:	1c7d      	adds	r5, r7, #1
  416612:	4646      	mov	r6, r8
  416614:	e577      	b.n	416106 <_dtoa_r+0x71e>
  416616:	46b3      	mov	fp, r6
  416618:	4646      	mov	r6, r8
  41661a:	e558      	b.n	4160ce <_dtoa_r+0x6e6>
  41661c:	f04f 0900 	mov.w	r9, #0
  416620:	464e      	mov	r6, r9
  416622:	e70f      	b.n	416444 <_dtoa_r+0xa5c>
  416624:	4964      	ldr	r1, [pc, #400]	; (4167b8 <_dtoa_r+0xdd0>)
  416626:	eb01 01c9 	add.w	r1, r1, r9, lsl #3
  41662a:	462a      	mov	r2, r5
  41662c:	4633      	mov	r3, r6
  41662e:	e951 0102 	ldrd	r0, r1, [r1, #-8]
  416632:	f7fd f8bf 	bl	4137b4 <__aeabi_dmul>
  416636:	e9cd 010e 	strd	r0, r1, [sp, #56]	; 0x38
  41663a:	4638      	mov	r0, r7
  41663c:	4641      	mov	r1, r8
  41663e:	f001 fc7b 	bl	417f38 <__aeabi_d2iz>
  416642:	4605      	mov	r5, r0
  416644:	f7fd f850 	bl	4136e8 <__aeabi_i2d>
  416648:	4602      	mov	r2, r0
  41664a:	460b      	mov	r3, r1
  41664c:	4638      	mov	r0, r7
  41664e:	4641      	mov	r1, r8
  416650:	f7fc fefc 	bl	41344c <__aeabi_dsub>
  416654:	9a07      	ldr	r2, [sp, #28]
  416656:	3530      	adds	r5, #48	; 0x30
  416658:	f1b9 0f01 	cmp.w	r9, #1
  41665c:	7015      	strb	r5, [r2, #0]
  41665e:	4606      	mov	r6, r0
  416660:	460f      	mov	r7, r1
  416662:	f102 0501 	add.w	r5, r2, #1
  416666:	d01c      	beq.n	4166a2 <_dtoa_r+0xcba>
  416668:	9b07      	ldr	r3, [sp, #28]
  41666a:	4499      	add	r9, r3
  41666c:	2200      	movs	r2, #0
  41666e:	4b54      	ldr	r3, [pc, #336]	; (4167c0 <_dtoa_r+0xdd8>)
  416670:	4630      	mov	r0, r6
  416672:	4639      	mov	r1, r7
  416674:	f7fd f89e 	bl	4137b4 <__aeabi_dmul>
  416678:	460f      	mov	r7, r1
  41667a:	4606      	mov	r6, r0
  41667c:	f001 fc5c 	bl	417f38 <__aeabi_d2iz>
  416680:	4680      	mov	r8, r0
  416682:	f7fd f831 	bl	4136e8 <__aeabi_i2d>
  416686:	f108 0830 	add.w	r8, r8, #48	; 0x30
  41668a:	4602      	mov	r2, r0
  41668c:	460b      	mov	r3, r1
  41668e:	4630      	mov	r0, r6
  416690:	4639      	mov	r1, r7
  416692:	f7fc fedb 	bl	41344c <__aeabi_dsub>
  416696:	f805 8b01 	strb.w	r8, [r5], #1
  41669a:	454d      	cmp	r5, r9
  41669c:	4606      	mov	r6, r0
  41669e:	460f      	mov	r7, r1
  4166a0:	d1e4      	bne.n	41666c <_dtoa_r+0xc84>
  4166a2:	2200      	movs	r2, #0
  4166a4:	4b47      	ldr	r3, [pc, #284]	; (4167c4 <_dtoa_r+0xddc>)
  4166a6:	e9dd 010e 	ldrd	r0, r1, [sp, #56]	; 0x38
  4166aa:	f7fc fed1 	bl	413450 <__adddf3>
  4166ae:	4632      	mov	r2, r6
  4166b0:	463b      	mov	r3, r7
  4166b2:	f001 fc03 	bl	417ebc <__aeabi_dcmplt>
  4166b6:	2800      	cmp	r0, #0
  4166b8:	d042      	beq.n	416740 <_dtoa_r+0xd58>
  4166ba:	9b11      	ldr	r3, [sp, #68]	; 0x44
  4166bc:	9304      	str	r3, [sp, #16]
  4166be:	f815 8c01 	ldrb.w	r8, [r5, #-1]
  4166c2:	f7ff bb4c 	b.w	415d5e <_dtoa_r+0x376>
  4166c6:	9b06      	ldr	r3, [sp, #24]
  4166c8:	9a08      	ldr	r2, [sp, #32]
  4166ca:	1a9d      	subs	r5, r3, r2
  4166cc:	2300      	movs	r3, #0
  4166ce:	f7ff bb7e 	b.w	415dce <_dtoa_r+0x3e6>
  4166d2:	9b14      	ldr	r3, [sp, #80]	; 0x50
  4166d4:	9f0a      	ldr	r7, [sp, #40]	; 0x28
  4166d6:	9d06      	ldr	r5, [sp, #24]
  4166d8:	f1c3 0336 	rsb	r3, r3, #54	; 0x36
  4166dc:	f7ff bb77 	b.w	415dce <_dtoa_r+0x3e6>
  4166e0:	e9dd 7800 	ldrd	r7, r8, [sp]
  4166e4:	f04f 0902 	mov.w	r9, #2
  4166e8:	e581      	b.n	4161ee <_dtoa_r+0x806>
  4166ea:	9b08      	ldr	r3, [sp, #32]
  4166ec:	2b00      	cmp	r3, #0
  4166ee:	f43f aecd 	beq.w	41648c <_dtoa_r+0xaa4>
  4166f2:	9b0d      	ldr	r3, [sp, #52]	; 0x34
  4166f4:	2b00      	cmp	r3, #0
  4166f6:	f77f aa82 	ble.w	415bfe <_dtoa_r+0x216>
  4166fa:	2200      	movs	r2, #0
  4166fc:	4b30      	ldr	r3, [pc, #192]	; (4167c0 <_dtoa_r+0xdd8>)
  4166fe:	4638      	mov	r0, r7
  416700:	4641      	mov	r1, r8
  416702:	f7fd f857 	bl	4137b4 <__aeabi_dmul>
  416706:	4607      	mov	r7, r0
  416708:	4688      	mov	r8, r1
  41670a:	f109 0001 	add.w	r0, r9, #1
  41670e:	f7fc ffeb 	bl	4136e8 <__aeabi_i2d>
  416712:	463a      	mov	r2, r7
  416714:	4643      	mov	r3, r8
  416716:	f7fd f84d 	bl	4137b4 <__aeabi_dmul>
  41671a:	2200      	movs	r2, #0
  41671c:	4b24      	ldr	r3, [pc, #144]	; (4167b0 <_dtoa_r+0xdc8>)
  41671e:	f7fc fe97 	bl	413450 <__adddf3>
  416722:	9a04      	ldr	r2, [sp, #16]
  416724:	f8dd 9034 	ldr.w	r9, [sp, #52]	; 0x34
  416728:	3a01      	subs	r2, #1
  41672a:	4605      	mov	r5, r0
  41672c:	f1a1 7650 	sub.w	r6, r1, #54525952	; 0x3400000
  416730:	9211      	str	r2, [sp, #68]	; 0x44
  416732:	e57d      	b.n	416230 <_dtoa_r+0x848>
  416734:	2239      	movs	r2, #57	; 0x39
  416736:	46b3      	mov	fp, r6
  416738:	703a      	strb	r2, [r7, #0]
  41673a:	4646      	mov	r6, r8
  41673c:	1c7d      	adds	r5, r7, #1
  41673e:	e4d4      	b.n	4160ea <_dtoa_r+0x702>
  416740:	e9dd 230e 	ldrd	r2, r3, [sp, #56]	; 0x38
  416744:	2000      	movs	r0, #0
  416746:	491f      	ldr	r1, [pc, #124]	; (4167c4 <_dtoa_r+0xddc>)
  416748:	f7fc fe80 	bl	41344c <__aeabi_dsub>
  41674c:	4632      	mov	r2, r6
  41674e:	463b      	mov	r3, r7
  416750:	f001 fbd2 	bl	417ef8 <__aeabi_dcmpgt>
  416754:	b910      	cbnz	r0, 41675c <_dtoa_r+0xd74>
  416756:	f7ff ba52 	b.w	415bfe <_dtoa_r+0x216>
  41675a:	4615      	mov	r5, r2
  41675c:	f815 3c01 	ldrb.w	r3, [r5, #-1]
  416760:	2b30      	cmp	r3, #48	; 0x30
  416762:	f105 32ff 	add.w	r2, r5, #4294967295
  416766:	d0f8      	beq.n	41675a <_dtoa_r+0xd72>
  416768:	e5ea      	b.n	416340 <_dtoa_r+0x958>
  41676a:	4643      	mov	r3, r8
  41676c:	f8dd a048 	ldr.w	sl, [sp, #72]	; 0x48
  416770:	46a0      	mov	r8, r4
  416772:	461c      	mov	r4, r3
  416774:	9b11      	ldr	r3, [sp, #68]	; 0x44
  416776:	9304      	str	r3, [sp, #16]
  416778:	f7ff baf1 	b.w	415d5e <_dtoa_r+0x376>
  41677c:	f8dd a048 	ldr.w	sl, [sp, #72]	; 0x48
  416780:	f8dd b04c 	ldr.w	fp, [sp, #76]	; 0x4c
  416784:	4644      	mov	r4, r8
  416786:	f7ff ba3a 	b.w	415bfe <_dtoa_r+0x216>
  41678a:	46b8      	mov	r8, r7
  41678c:	f7ff bbac 	b.w	415ee8 <_dtoa_r+0x500>
  416790:	9b00      	ldr	r3, [sp, #0]
  416792:	2b39      	cmp	r3, #57	; 0x39
  416794:	d0ce      	beq.n	416734 <_dtoa_r+0xd4c>
  416796:	f1bb 0f00 	cmp.w	fp, #0
  41679a:	f73f aed4 	bgt.w	416546 <_dtoa_r+0xb5e>
  41679e:	e6d5      	b.n	41654c <_dtoa_r+0xb64>
  4167a0:	f47f aed4 	bne.w	41654c <_dtoa_r+0xb64>
  4167a4:	9b00      	ldr	r3, [sp, #0]
  4167a6:	07da      	lsls	r2, r3, #31
  4167a8:	f57f aed0 	bpl.w	41654c <_dtoa_r+0xb64>
  4167ac:	e6c7      	b.n	41653e <_dtoa_r+0xb56>
  4167ae:	bf00      	nop
  4167b0:	401c0000 	.word	0x401c0000
  4167b4:	40140000 	.word	0x40140000
  4167b8:	0041d6c8 	.word	0x0041d6c8
  4167bc:	0041d6a0 	.word	0x0041d6a0
  4167c0:	40240000 	.word	0x40240000
  4167c4:	3fe00000 	.word	0x3fe00000
  4167c8:	4631      	mov	r1, r6
  4167ca:	2300      	movs	r3, #0
  4167cc:	220a      	movs	r2, #10
  4167ce:	4620      	mov	r0, r4
  4167d0:	f000 fb9a 	bl	416f08 <__multadd>
  4167d4:	9b0d      	ldr	r3, [sp, #52]	; 0x34
  4167d6:	2b00      	cmp	r3, #0
  4167d8:	4606      	mov	r6, r0
  4167da:	dd0a      	ble.n	4167f2 <_dtoa_r+0xe0a>
  4167dc:	9308      	str	r3, [sp, #32]
  4167de:	f7ff bbb9 	b.w	415f54 <_dtoa_r+0x56c>
  4167e2:	9b02      	ldr	r3, [sp, #8]
  4167e4:	2b02      	cmp	r3, #2
  4167e6:	dc22      	bgt.n	41682e <_dtoa_r+0xe46>
  4167e8:	9b0d      	ldr	r3, [sp, #52]	; 0x34
  4167ea:	e44a      	b.n	416082 <_dtoa_r+0x69a>
  4167ec:	f04f 0902 	mov.w	r9, #2
  4167f0:	e4fd      	b.n	4161ee <_dtoa_r+0x806>
  4167f2:	9b02      	ldr	r3, [sp, #8]
  4167f4:	2b02      	cmp	r3, #2
  4167f6:	dc1a      	bgt.n	41682e <_dtoa_r+0xe46>
  4167f8:	9b0d      	ldr	r3, [sp, #52]	; 0x34
  4167fa:	e7ef      	b.n	4167dc <_dtoa_r+0xdf4>
  4167fc:	2500      	movs	r5, #0
  4167fe:	6465      	str	r5, [r4, #68]	; 0x44
  416800:	4629      	mov	r1, r5
  416802:	4620      	mov	r0, r4
  416804:	f000 fb50 	bl	416ea8 <_Balloc>
  416808:	f04f 33ff 	mov.w	r3, #4294967295
  41680c:	9308      	str	r3, [sp, #32]
  41680e:	930d      	str	r3, [sp, #52]	; 0x34
  416810:	2301      	movs	r3, #1
  416812:	9007      	str	r0, [sp, #28]
  416814:	46ab      	mov	fp, r5
  416816:	6420      	str	r0, [r4, #64]	; 0x40
  416818:	9309      	str	r3, [sp, #36]	; 0x24
  41681a:	f7ff b9f0 	b.w	415bfe <_dtoa_r+0x216>
  41681e:	f43f ab7b 	beq.w	415f18 <_dtoa_r+0x530>
  416822:	f1c0 003c 	rsb	r0, r0, #60	; 0x3c
  416826:	e40b      	b.n	416040 <_dtoa_r+0x658>
  416828:	2701      	movs	r7, #1
  41682a:	f7ff b9af 	b.w	415b8c <_dtoa_r+0x1a4>
  41682e:	9b0d      	ldr	r3, [sp, #52]	; 0x34
  416830:	9308      	str	r3, [sp, #32]
  416832:	e5f8      	b.n	416426 <_dtoa_r+0xa3e>

00416834 <__libc_fini_array>:
  416834:	b538      	push	{r3, r4, r5, lr}
  416836:	4c0a      	ldr	r4, [pc, #40]	; (416860 <__libc_fini_array+0x2c>)
  416838:	4d0a      	ldr	r5, [pc, #40]	; (416864 <__libc_fini_array+0x30>)
  41683a:	1b64      	subs	r4, r4, r5
  41683c:	10a4      	asrs	r4, r4, #2
  41683e:	d00a      	beq.n	416856 <__libc_fini_array+0x22>
  416840:	f104 4380 	add.w	r3, r4, #1073741824	; 0x40000000
  416844:	3b01      	subs	r3, #1
  416846:	eb05 0583 	add.w	r5, r5, r3, lsl #2
  41684a:	3c01      	subs	r4, #1
  41684c:	f855 3904 	ldr.w	r3, [r5], #-4
  416850:	4798      	blx	r3
  416852:	2c00      	cmp	r4, #0
  416854:	d1f9      	bne.n	41684a <__libc_fini_array+0x16>
  416856:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
  41685a:	f007 b833 	b.w	41d8c4 <_fini>
  41685e:	bf00      	nop
  416860:	0041d8d4 	.word	0x0041d8d4
  416864:	0041d8d0 	.word	0x0041d8d0

00416868 <_localeconv_r>:
  416868:	4a04      	ldr	r2, [pc, #16]	; (41687c <_localeconv_r+0x14>)
  41686a:	4b05      	ldr	r3, [pc, #20]	; (416880 <_localeconv_r+0x18>)
  41686c:	6812      	ldr	r2, [r2, #0]
  41686e:	6b50      	ldr	r0, [r2, #52]	; 0x34
  416870:	2800      	cmp	r0, #0
  416872:	bf08      	it	eq
  416874:	4618      	moveq	r0, r3
  416876:	30f0      	adds	r0, #240	; 0xf0
  416878:	4770      	bx	lr
  41687a:	bf00      	nop
  41687c:	20000358 	.word	0x20000358
  416880:	20000b9c 	.word	0x20000b9c

00416884 <__retarget_lock_acquire_recursive>:
  416884:	4770      	bx	lr
  416886:	bf00      	nop

00416888 <__retarget_lock_release_recursive>:
  416888:	4770      	bx	lr
  41688a:	bf00      	nop

0041688c <_malloc_r>:
  41688c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  416890:	f101 060b 	add.w	r6, r1, #11
  416894:	2e16      	cmp	r6, #22
  416896:	b083      	sub	sp, #12
  416898:	4605      	mov	r5, r0
  41689a:	f240 809e 	bls.w	4169da <_malloc_r+0x14e>
  41689e:	f036 0607 	bics.w	r6, r6, #7
  4168a2:	f100 80bd 	bmi.w	416a20 <_malloc_r+0x194>
  4168a6:	42b1      	cmp	r1, r6
  4168a8:	f200 80ba 	bhi.w	416a20 <_malloc_r+0x194>
  4168ac:	f000 faf0 	bl	416e90 <__malloc_lock>
  4168b0:	f5b6 7ffc 	cmp.w	r6, #504	; 0x1f8
  4168b4:	f0c0 8293 	bcc.w	416dde <_malloc_r+0x552>
  4168b8:	0a73      	lsrs	r3, r6, #9
  4168ba:	f000 80b8 	beq.w	416a2e <_malloc_r+0x1a2>
  4168be:	2b04      	cmp	r3, #4
  4168c0:	f200 8179 	bhi.w	416bb6 <_malloc_r+0x32a>
  4168c4:	09b3      	lsrs	r3, r6, #6
  4168c6:	f103 0039 	add.w	r0, r3, #57	; 0x39
  4168ca:	f103 0e38 	add.w	lr, r3, #56	; 0x38
  4168ce:	00c3      	lsls	r3, r0, #3
  4168d0:	4fbf      	ldr	r7, [pc, #764]	; (416bd0 <_malloc_r+0x344>)
  4168d2:	443b      	add	r3, r7
  4168d4:	f1a3 0108 	sub.w	r1, r3, #8
  4168d8:	685c      	ldr	r4, [r3, #4]
  4168da:	42a1      	cmp	r1, r4
  4168dc:	d106      	bne.n	4168ec <_malloc_r+0x60>
  4168de:	e00c      	b.n	4168fa <_malloc_r+0x6e>
  4168e0:	2a00      	cmp	r2, #0
  4168e2:	f280 80aa 	bge.w	416a3a <_malloc_r+0x1ae>
  4168e6:	68e4      	ldr	r4, [r4, #12]
  4168e8:	42a1      	cmp	r1, r4
  4168ea:	d006      	beq.n	4168fa <_malloc_r+0x6e>
  4168ec:	6863      	ldr	r3, [r4, #4]
  4168ee:	f023 0303 	bic.w	r3, r3, #3
  4168f2:	1b9a      	subs	r2, r3, r6
  4168f4:	2a0f      	cmp	r2, #15
  4168f6:	ddf3      	ble.n	4168e0 <_malloc_r+0x54>
  4168f8:	4670      	mov	r0, lr
  4168fa:	693c      	ldr	r4, [r7, #16]
  4168fc:	f8df e2e4 	ldr.w	lr, [pc, #740]	; 416be4 <_malloc_r+0x358>
  416900:	4574      	cmp	r4, lr
  416902:	f000 81ab 	beq.w	416c5c <_malloc_r+0x3d0>
  416906:	6863      	ldr	r3, [r4, #4]
  416908:	f023 0303 	bic.w	r3, r3, #3
  41690c:	1b9a      	subs	r2, r3, r6
  41690e:	2a0f      	cmp	r2, #15
  416910:	f300 8190 	bgt.w	416c34 <_malloc_r+0x3a8>
  416914:	2a00      	cmp	r2, #0
  416916:	f8c7 e014 	str.w	lr, [r7, #20]
  41691a:	f8c7 e010 	str.w	lr, [r7, #16]
  41691e:	f280 809d 	bge.w	416a5c <_malloc_r+0x1d0>
  416922:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
  416926:	f080 8161 	bcs.w	416bec <_malloc_r+0x360>
  41692a:	08db      	lsrs	r3, r3, #3
  41692c:	f103 0c01 	add.w	ip, r3, #1
  416930:	1099      	asrs	r1, r3, #2
  416932:	687a      	ldr	r2, [r7, #4]
  416934:	f857 803c 	ldr.w	r8, [r7, ip, lsl #3]
  416938:	f8c4 8008 	str.w	r8, [r4, #8]
  41693c:	2301      	movs	r3, #1
  41693e:	408b      	lsls	r3, r1
  416940:	eb07 01cc 	add.w	r1, r7, ip, lsl #3
  416944:	4313      	orrs	r3, r2
  416946:	3908      	subs	r1, #8
  416948:	60e1      	str	r1, [r4, #12]
  41694a:	607b      	str	r3, [r7, #4]
  41694c:	f847 403c 	str.w	r4, [r7, ip, lsl #3]
  416950:	f8c8 400c 	str.w	r4, [r8, #12]
  416954:	1082      	asrs	r2, r0, #2
  416956:	2401      	movs	r4, #1
  416958:	4094      	lsls	r4, r2
  41695a:	429c      	cmp	r4, r3
  41695c:	f200 808b 	bhi.w	416a76 <_malloc_r+0x1ea>
  416960:	421c      	tst	r4, r3
  416962:	d106      	bne.n	416972 <_malloc_r+0xe6>
  416964:	f020 0003 	bic.w	r0, r0, #3
  416968:	0064      	lsls	r4, r4, #1
  41696a:	421c      	tst	r4, r3
  41696c:	f100 0004 	add.w	r0, r0, #4
  416970:	d0fa      	beq.n	416968 <_malloc_r+0xdc>
  416972:	eb07 09c0 	add.w	r9, r7, r0, lsl #3
  416976:	46cc      	mov	ip, r9
  416978:	4680      	mov	r8, r0
  41697a:	f8dc 300c 	ldr.w	r3, [ip, #12]
  41697e:	459c      	cmp	ip, r3
  416980:	d107      	bne.n	416992 <_malloc_r+0x106>
  416982:	e16d      	b.n	416c60 <_malloc_r+0x3d4>
  416984:	2a00      	cmp	r2, #0
  416986:	f280 817b 	bge.w	416c80 <_malloc_r+0x3f4>
  41698a:	68db      	ldr	r3, [r3, #12]
  41698c:	459c      	cmp	ip, r3
  41698e:	f000 8167 	beq.w	416c60 <_malloc_r+0x3d4>
  416992:	6859      	ldr	r1, [r3, #4]
  416994:	f021 0103 	bic.w	r1, r1, #3
  416998:	1b8a      	subs	r2, r1, r6
  41699a:	2a0f      	cmp	r2, #15
  41699c:	ddf2      	ble.n	416984 <_malloc_r+0xf8>
  41699e:	f8d3 c00c 	ldr.w	ip, [r3, #12]
  4169a2:	f8d3 8008 	ldr.w	r8, [r3, #8]
  4169a6:	9300      	str	r3, [sp, #0]
  4169a8:	199c      	adds	r4, r3, r6
  4169aa:	4628      	mov	r0, r5
  4169ac:	f046 0601 	orr.w	r6, r6, #1
  4169b0:	f042 0501 	orr.w	r5, r2, #1
  4169b4:	605e      	str	r6, [r3, #4]
  4169b6:	f8c8 c00c 	str.w	ip, [r8, #12]
  4169ba:	f8cc 8008 	str.w	r8, [ip, #8]
  4169be:	617c      	str	r4, [r7, #20]
  4169c0:	613c      	str	r4, [r7, #16]
  4169c2:	f8c4 e00c 	str.w	lr, [r4, #12]
  4169c6:	f8c4 e008 	str.w	lr, [r4, #8]
  4169ca:	6065      	str	r5, [r4, #4]
  4169cc:	505a      	str	r2, [r3, r1]
  4169ce:	f000 fa65 	bl	416e9c <__malloc_unlock>
  4169d2:	9b00      	ldr	r3, [sp, #0]
  4169d4:	f103 0408 	add.w	r4, r3, #8
  4169d8:	e01e      	b.n	416a18 <_malloc_r+0x18c>
  4169da:	2910      	cmp	r1, #16
  4169dc:	d820      	bhi.n	416a20 <_malloc_r+0x194>
  4169de:	f000 fa57 	bl	416e90 <__malloc_lock>
  4169e2:	2610      	movs	r6, #16
  4169e4:	2318      	movs	r3, #24
  4169e6:	2002      	movs	r0, #2
  4169e8:	4f79      	ldr	r7, [pc, #484]	; (416bd0 <_malloc_r+0x344>)
  4169ea:	443b      	add	r3, r7
  4169ec:	f1a3 0208 	sub.w	r2, r3, #8
  4169f0:	685c      	ldr	r4, [r3, #4]
  4169f2:	4294      	cmp	r4, r2
  4169f4:	f000 813d 	beq.w	416c72 <_malloc_r+0x3e6>
  4169f8:	6863      	ldr	r3, [r4, #4]
  4169fa:	68e1      	ldr	r1, [r4, #12]
  4169fc:	68a6      	ldr	r6, [r4, #8]
  4169fe:	f023 0303 	bic.w	r3, r3, #3
  416a02:	4423      	add	r3, r4
  416a04:	4628      	mov	r0, r5
  416a06:	685a      	ldr	r2, [r3, #4]
  416a08:	60f1      	str	r1, [r6, #12]
  416a0a:	f042 0201 	orr.w	r2, r2, #1
  416a0e:	608e      	str	r6, [r1, #8]
  416a10:	605a      	str	r2, [r3, #4]
  416a12:	f000 fa43 	bl	416e9c <__malloc_unlock>
  416a16:	3408      	adds	r4, #8
  416a18:	4620      	mov	r0, r4
  416a1a:	b003      	add	sp, #12
  416a1c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  416a20:	2400      	movs	r4, #0
  416a22:	230c      	movs	r3, #12
  416a24:	4620      	mov	r0, r4
  416a26:	602b      	str	r3, [r5, #0]
  416a28:	b003      	add	sp, #12
  416a2a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  416a2e:	2040      	movs	r0, #64	; 0x40
  416a30:	f44f 7300 	mov.w	r3, #512	; 0x200
  416a34:	f04f 0e3f 	mov.w	lr, #63	; 0x3f
  416a38:	e74a      	b.n	4168d0 <_malloc_r+0x44>
  416a3a:	4423      	add	r3, r4
  416a3c:	68e1      	ldr	r1, [r4, #12]
  416a3e:	685a      	ldr	r2, [r3, #4]
  416a40:	68a6      	ldr	r6, [r4, #8]
  416a42:	f042 0201 	orr.w	r2, r2, #1
  416a46:	60f1      	str	r1, [r6, #12]
  416a48:	4628      	mov	r0, r5
  416a4a:	608e      	str	r6, [r1, #8]
  416a4c:	605a      	str	r2, [r3, #4]
  416a4e:	f000 fa25 	bl	416e9c <__malloc_unlock>
  416a52:	3408      	adds	r4, #8
  416a54:	4620      	mov	r0, r4
  416a56:	b003      	add	sp, #12
  416a58:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  416a5c:	4423      	add	r3, r4
  416a5e:	4628      	mov	r0, r5
  416a60:	685a      	ldr	r2, [r3, #4]
  416a62:	f042 0201 	orr.w	r2, r2, #1
  416a66:	605a      	str	r2, [r3, #4]
  416a68:	f000 fa18 	bl	416e9c <__malloc_unlock>
  416a6c:	3408      	adds	r4, #8
  416a6e:	4620      	mov	r0, r4
  416a70:	b003      	add	sp, #12
  416a72:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  416a76:	68bc      	ldr	r4, [r7, #8]
  416a78:	6863      	ldr	r3, [r4, #4]
  416a7a:	f023 0803 	bic.w	r8, r3, #3
  416a7e:	45b0      	cmp	r8, r6
  416a80:	d304      	bcc.n	416a8c <_malloc_r+0x200>
  416a82:	eba8 0306 	sub.w	r3, r8, r6
  416a86:	2b0f      	cmp	r3, #15
  416a88:	f300 8085 	bgt.w	416b96 <_malloc_r+0x30a>
  416a8c:	f8df 9158 	ldr.w	r9, [pc, #344]	; 416be8 <_malloc_r+0x35c>
  416a90:	4b50      	ldr	r3, [pc, #320]	; (416bd4 <_malloc_r+0x348>)
  416a92:	f8d9 2000 	ldr.w	r2, [r9]
  416a96:	681b      	ldr	r3, [r3, #0]
  416a98:	3201      	adds	r2, #1
  416a9a:	4433      	add	r3, r6
  416a9c:	eb04 0a08 	add.w	sl, r4, r8
  416aa0:	f000 8155 	beq.w	416d4e <_malloc_r+0x4c2>
  416aa4:	f503 5380 	add.w	r3, r3, #4096	; 0x1000
  416aa8:	330f      	adds	r3, #15
  416aaa:	f423 6b7f 	bic.w	fp, r3, #4080	; 0xff0
  416aae:	f02b 0b0f 	bic.w	fp, fp, #15
  416ab2:	4659      	mov	r1, fp
  416ab4:	4628      	mov	r0, r5
  416ab6:	f000 fcf3 	bl	4174a0 <_sbrk_r>
  416aba:	1c41      	adds	r1, r0, #1
  416abc:	4602      	mov	r2, r0
  416abe:	f000 80fc 	beq.w	416cba <_malloc_r+0x42e>
  416ac2:	4582      	cmp	sl, r0
  416ac4:	f200 80f7 	bhi.w	416cb6 <_malloc_r+0x42a>
  416ac8:	4b43      	ldr	r3, [pc, #268]	; (416bd8 <_malloc_r+0x34c>)
  416aca:	6819      	ldr	r1, [r3, #0]
  416acc:	4459      	add	r1, fp
  416ace:	6019      	str	r1, [r3, #0]
  416ad0:	f000 814d 	beq.w	416d6e <_malloc_r+0x4e2>
  416ad4:	f8d9 0000 	ldr.w	r0, [r9]
  416ad8:	3001      	adds	r0, #1
  416ada:	bf1b      	ittet	ne
  416adc:	eba2 0a0a 	subne.w	sl, r2, sl
  416ae0:	4451      	addne	r1, sl
  416ae2:	f8c9 2000 	streq.w	r2, [r9]
  416ae6:	6019      	strne	r1, [r3, #0]
  416ae8:	f012 0107 	ands.w	r1, r2, #7
  416aec:	f000 8115 	beq.w	416d1a <_malloc_r+0x48e>
  416af0:	f1c1 0008 	rsb	r0, r1, #8
  416af4:	f5c1 5180 	rsb	r1, r1, #4096	; 0x1000
  416af8:	4402      	add	r2, r0
  416afa:	3108      	adds	r1, #8
  416afc:	eb02 090b 	add.w	r9, r2, fp
  416b00:	f3c9 090b 	ubfx	r9, r9, #0, #12
  416b04:	eba1 0909 	sub.w	r9, r1, r9
  416b08:	4649      	mov	r1, r9
  416b0a:	4628      	mov	r0, r5
  416b0c:	9301      	str	r3, [sp, #4]
  416b0e:	9200      	str	r2, [sp, #0]
  416b10:	f000 fcc6 	bl	4174a0 <_sbrk_r>
  416b14:	1c43      	adds	r3, r0, #1
  416b16:	e89d 000c 	ldmia.w	sp, {r2, r3}
  416b1a:	f000 8143 	beq.w	416da4 <_malloc_r+0x518>
  416b1e:	1a80      	subs	r0, r0, r2
  416b20:	4448      	add	r0, r9
  416b22:	f040 0001 	orr.w	r0, r0, #1
  416b26:	6819      	ldr	r1, [r3, #0]
  416b28:	60ba      	str	r2, [r7, #8]
  416b2a:	4449      	add	r1, r9
  416b2c:	42bc      	cmp	r4, r7
  416b2e:	6050      	str	r0, [r2, #4]
  416b30:	6019      	str	r1, [r3, #0]
  416b32:	d017      	beq.n	416b64 <_malloc_r+0x2d8>
  416b34:	f1b8 0f0f 	cmp.w	r8, #15
  416b38:	f240 80fb 	bls.w	416d32 <_malloc_r+0x4a6>
  416b3c:	6860      	ldr	r0, [r4, #4]
  416b3e:	f1a8 020c 	sub.w	r2, r8, #12
  416b42:	f022 0207 	bic.w	r2, r2, #7
  416b46:	eb04 0e02 	add.w	lr, r4, r2
  416b4a:	f000 0001 	and.w	r0, r0, #1
  416b4e:	f04f 0c05 	mov.w	ip, #5
  416b52:	4310      	orrs	r0, r2
  416b54:	2a0f      	cmp	r2, #15
  416b56:	6060      	str	r0, [r4, #4]
  416b58:	f8ce c004 	str.w	ip, [lr, #4]
  416b5c:	f8ce c008 	str.w	ip, [lr, #8]
  416b60:	f200 8117 	bhi.w	416d92 <_malloc_r+0x506>
  416b64:	4b1d      	ldr	r3, [pc, #116]	; (416bdc <_malloc_r+0x350>)
  416b66:	68bc      	ldr	r4, [r7, #8]
  416b68:	681a      	ldr	r2, [r3, #0]
  416b6a:	4291      	cmp	r1, r2
  416b6c:	bf88      	it	hi
  416b6e:	6019      	strhi	r1, [r3, #0]
  416b70:	4b1b      	ldr	r3, [pc, #108]	; (416be0 <_malloc_r+0x354>)
  416b72:	681a      	ldr	r2, [r3, #0]
  416b74:	4291      	cmp	r1, r2
  416b76:	6862      	ldr	r2, [r4, #4]
  416b78:	bf88      	it	hi
  416b7a:	6019      	strhi	r1, [r3, #0]
  416b7c:	f022 0203 	bic.w	r2, r2, #3
  416b80:	4296      	cmp	r6, r2
  416b82:	eba2 0306 	sub.w	r3, r2, r6
  416b86:	d801      	bhi.n	416b8c <_malloc_r+0x300>
  416b88:	2b0f      	cmp	r3, #15
  416b8a:	dc04      	bgt.n	416b96 <_malloc_r+0x30a>
  416b8c:	4628      	mov	r0, r5
  416b8e:	f000 f985 	bl	416e9c <__malloc_unlock>
  416b92:	2400      	movs	r4, #0
  416b94:	e740      	b.n	416a18 <_malloc_r+0x18c>
  416b96:	19a2      	adds	r2, r4, r6
  416b98:	f043 0301 	orr.w	r3, r3, #1
  416b9c:	f046 0601 	orr.w	r6, r6, #1
  416ba0:	6066      	str	r6, [r4, #4]
  416ba2:	4628      	mov	r0, r5
  416ba4:	60ba      	str	r2, [r7, #8]
  416ba6:	6053      	str	r3, [r2, #4]
  416ba8:	f000 f978 	bl	416e9c <__malloc_unlock>
  416bac:	3408      	adds	r4, #8
  416bae:	4620      	mov	r0, r4
  416bb0:	b003      	add	sp, #12
  416bb2:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  416bb6:	2b14      	cmp	r3, #20
  416bb8:	d971      	bls.n	416c9e <_malloc_r+0x412>
  416bba:	2b54      	cmp	r3, #84	; 0x54
  416bbc:	f200 80a3 	bhi.w	416d06 <_malloc_r+0x47a>
  416bc0:	0b33      	lsrs	r3, r6, #12
  416bc2:	f103 006f 	add.w	r0, r3, #111	; 0x6f
  416bc6:	f103 0e6e 	add.w	lr, r3, #110	; 0x6e
  416bca:	00c3      	lsls	r3, r0, #3
  416bcc:	e680      	b.n	4168d0 <_malloc_r+0x44>
  416bce:	bf00      	nop
  416bd0:	2000078c 	.word	0x2000078c
  416bd4:	20001878 	.word	0x20001878
  416bd8:	20001848 	.word	0x20001848
  416bdc:	20001870 	.word	0x20001870
  416be0:	20001874 	.word	0x20001874
  416be4:	20000794 	.word	0x20000794
  416be8:	20000b94 	.word	0x20000b94
  416bec:	0a5a      	lsrs	r2, r3, #9
  416bee:	2a04      	cmp	r2, #4
  416bf0:	d95b      	bls.n	416caa <_malloc_r+0x41e>
  416bf2:	2a14      	cmp	r2, #20
  416bf4:	f200 80ae 	bhi.w	416d54 <_malloc_r+0x4c8>
  416bf8:	f102 015c 	add.w	r1, r2, #92	; 0x5c
  416bfc:	00c9      	lsls	r1, r1, #3
  416bfe:	325b      	adds	r2, #91	; 0x5b
  416c00:	eb07 0c01 	add.w	ip, r7, r1
  416c04:	5879      	ldr	r1, [r7, r1]
  416c06:	f1ac 0c08 	sub.w	ip, ip, #8
  416c0a:	458c      	cmp	ip, r1
  416c0c:	f000 8088 	beq.w	416d20 <_malloc_r+0x494>
  416c10:	684a      	ldr	r2, [r1, #4]
  416c12:	f022 0203 	bic.w	r2, r2, #3
  416c16:	4293      	cmp	r3, r2
  416c18:	d273      	bcs.n	416d02 <_malloc_r+0x476>
  416c1a:	6889      	ldr	r1, [r1, #8]
  416c1c:	458c      	cmp	ip, r1
  416c1e:	d1f7      	bne.n	416c10 <_malloc_r+0x384>
  416c20:	f8dc 200c 	ldr.w	r2, [ip, #12]
  416c24:	687b      	ldr	r3, [r7, #4]
  416c26:	60e2      	str	r2, [r4, #12]
  416c28:	f8c4 c008 	str.w	ip, [r4, #8]
  416c2c:	6094      	str	r4, [r2, #8]
  416c2e:	f8cc 400c 	str.w	r4, [ip, #12]
  416c32:	e68f      	b.n	416954 <_malloc_r+0xc8>
  416c34:	19a1      	adds	r1, r4, r6
  416c36:	f046 0c01 	orr.w	ip, r6, #1
  416c3a:	f042 0601 	orr.w	r6, r2, #1
  416c3e:	f8c4 c004 	str.w	ip, [r4, #4]
  416c42:	4628      	mov	r0, r5
  416c44:	6179      	str	r1, [r7, #20]
  416c46:	6139      	str	r1, [r7, #16]
  416c48:	f8c1 e00c 	str.w	lr, [r1, #12]
  416c4c:	f8c1 e008 	str.w	lr, [r1, #8]
  416c50:	604e      	str	r6, [r1, #4]
  416c52:	50e2      	str	r2, [r4, r3]
  416c54:	f000 f922 	bl	416e9c <__malloc_unlock>
  416c58:	3408      	adds	r4, #8
  416c5a:	e6dd      	b.n	416a18 <_malloc_r+0x18c>
  416c5c:	687b      	ldr	r3, [r7, #4]
  416c5e:	e679      	b.n	416954 <_malloc_r+0xc8>
  416c60:	f108 0801 	add.w	r8, r8, #1
  416c64:	f018 0f03 	tst.w	r8, #3
  416c68:	f10c 0c08 	add.w	ip, ip, #8
  416c6c:	f47f ae85 	bne.w	41697a <_malloc_r+0xee>
  416c70:	e02d      	b.n	416cce <_malloc_r+0x442>
  416c72:	68dc      	ldr	r4, [r3, #12]
  416c74:	42a3      	cmp	r3, r4
  416c76:	bf08      	it	eq
  416c78:	3002      	addeq	r0, #2
  416c7a:	f43f ae3e 	beq.w	4168fa <_malloc_r+0x6e>
  416c7e:	e6bb      	b.n	4169f8 <_malloc_r+0x16c>
  416c80:	4419      	add	r1, r3
  416c82:	461c      	mov	r4, r3
  416c84:	684a      	ldr	r2, [r1, #4]
  416c86:	68db      	ldr	r3, [r3, #12]
  416c88:	f854 6f08 	ldr.w	r6, [r4, #8]!
  416c8c:	f042 0201 	orr.w	r2, r2, #1
  416c90:	604a      	str	r2, [r1, #4]
  416c92:	4628      	mov	r0, r5
  416c94:	60f3      	str	r3, [r6, #12]
  416c96:	609e      	str	r6, [r3, #8]
  416c98:	f000 f900 	bl	416e9c <__malloc_unlock>
  416c9c:	e6bc      	b.n	416a18 <_malloc_r+0x18c>
  416c9e:	f103 005c 	add.w	r0, r3, #92	; 0x5c
  416ca2:	f103 0e5b 	add.w	lr, r3, #91	; 0x5b
  416ca6:	00c3      	lsls	r3, r0, #3
  416ca8:	e612      	b.n	4168d0 <_malloc_r+0x44>
  416caa:	099a      	lsrs	r2, r3, #6
  416cac:	f102 0139 	add.w	r1, r2, #57	; 0x39
  416cb0:	00c9      	lsls	r1, r1, #3
  416cb2:	3238      	adds	r2, #56	; 0x38
  416cb4:	e7a4      	b.n	416c00 <_malloc_r+0x374>
  416cb6:	42bc      	cmp	r4, r7
  416cb8:	d054      	beq.n	416d64 <_malloc_r+0x4d8>
  416cba:	68bc      	ldr	r4, [r7, #8]
  416cbc:	6862      	ldr	r2, [r4, #4]
  416cbe:	f022 0203 	bic.w	r2, r2, #3
  416cc2:	e75d      	b.n	416b80 <_malloc_r+0x2f4>
  416cc4:	f859 3908 	ldr.w	r3, [r9], #-8
  416cc8:	4599      	cmp	r9, r3
  416cca:	f040 8086 	bne.w	416dda <_malloc_r+0x54e>
  416cce:	f010 0f03 	tst.w	r0, #3
  416cd2:	f100 30ff 	add.w	r0, r0, #4294967295
  416cd6:	d1f5      	bne.n	416cc4 <_malloc_r+0x438>
  416cd8:	687b      	ldr	r3, [r7, #4]
  416cda:	ea23 0304 	bic.w	r3, r3, r4
  416cde:	607b      	str	r3, [r7, #4]
  416ce0:	0064      	lsls	r4, r4, #1
  416ce2:	429c      	cmp	r4, r3
  416ce4:	f63f aec7 	bhi.w	416a76 <_malloc_r+0x1ea>
  416ce8:	2c00      	cmp	r4, #0
  416cea:	f43f aec4 	beq.w	416a76 <_malloc_r+0x1ea>
  416cee:	421c      	tst	r4, r3
  416cf0:	4640      	mov	r0, r8
  416cf2:	f47f ae3e 	bne.w	416972 <_malloc_r+0xe6>
  416cf6:	0064      	lsls	r4, r4, #1
  416cf8:	421c      	tst	r4, r3
  416cfa:	f100 0004 	add.w	r0, r0, #4
  416cfe:	d0fa      	beq.n	416cf6 <_malloc_r+0x46a>
  416d00:	e637      	b.n	416972 <_malloc_r+0xe6>
  416d02:	468c      	mov	ip, r1
  416d04:	e78c      	b.n	416c20 <_malloc_r+0x394>
  416d06:	f5b3 7faa 	cmp.w	r3, #340	; 0x154
  416d0a:	d815      	bhi.n	416d38 <_malloc_r+0x4ac>
  416d0c:	0bf3      	lsrs	r3, r6, #15
  416d0e:	f103 0078 	add.w	r0, r3, #120	; 0x78
  416d12:	f103 0e77 	add.w	lr, r3, #119	; 0x77
  416d16:	00c3      	lsls	r3, r0, #3
  416d18:	e5da      	b.n	4168d0 <_malloc_r+0x44>
  416d1a:	f44f 5180 	mov.w	r1, #4096	; 0x1000
  416d1e:	e6ed      	b.n	416afc <_malloc_r+0x270>
  416d20:	687b      	ldr	r3, [r7, #4]
  416d22:	1092      	asrs	r2, r2, #2
  416d24:	2101      	movs	r1, #1
  416d26:	fa01 f202 	lsl.w	r2, r1, r2
  416d2a:	4313      	orrs	r3, r2
  416d2c:	607b      	str	r3, [r7, #4]
  416d2e:	4662      	mov	r2, ip
  416d30:	e779      	b.n	416c26 <_malloc_r+0x39a>
  416d32:	2301      	movs	r3, #1
  416d34:	6053      	str	r3, [r2, #4]
  416d36:	e729      	b.n	416b8c <_malloc_r+0x300>
  416d38:	f240 5254 	movw	r2, #1364	; 0x554
  416d3c:	4293      	cmp	r3, r2
  416d3e:	d822      	bhi.n	416d86 <_malloc_r+0x4fa>
  416d40:	0cb3      	lsrs	r3, r6, #18
  416d42:	f103 007d 	add.w	r0, r3, #125	; 0x7d
  416d46:	f103 0e7c 	add.w	lr, r3, #124	; 0x7c
  416d4a:	00c3      	lsls	r3, r0, #3
  416d4c:	e5c0      	b.n	4168d0 <_malloc_r+0x44>
  416d4e:	f103 0b10 	add.w	fp, r3, #16
  416d52:	e6ae      	b.n	416ab2 <_malloc_r+0x226>
  416d54:	2a54      	cmp	r2, #84	; 0x54
  416d56:	d829      	bhi.n	416dac <_malloc_r+0x520>
  416d58:	0b1a      	lsrs	r2, r3, #12
  416d5a:	f102 016f 	add.w	r1, r2, #111	; 0x6f
  416d5e:	00c9      	lsls	r1, r1, #3
  416d60:	326e      	adds	r2, #110	; 0x6e
  416d62:	e74d      	b.n	416c00 <_malloc_r+0x374>
  416d64:	4b20      	ldr	r3, [pc, #128]	; (416de8 <_malloc_r+0x55c>)
  416d66:	6819      	ldr	r1, [r3, #0]
  416d68:	4459      	add	r1, fp
  416d6a:	6019      	str	r1, [r3, #0]
  416d6c:	e6b2      	b.n	416ad4 <_malloc_r+0x248>
  416d6e:	f3ca 000b 	ubfx	r0, sl, #0, #12
  416d72:	2800      	cmp	r0, #0
  416d74:	f47f aeae 	bne.w	416ad4 <_malloc_r+0x248>
  416d78:	eb08 030b 	add.w	r3, r8, fp
  416d7c:	68ba      	ldr	r2, [r7, #8]
  416d7e:	f043 0301 	orr.w	r3, r3, #1
  416d82:	6053      	str	r3, [r2, #4]
  416d84:	e6ee      	b.n	416b64 <_malloc_r+0x2d8>
  416d86:	207f      	movs	r0, #127	; 0x7f
  416d88:	f44f 737e 	mov.w	r3, #1016	; 0x3f8
  416d8c:	f04f 0e7e 	mov.w	lr, #126	; 0x7e
  416d90:	e59e      	b.n	4168d0 <_malloc_r+0x44>
  416d92:	f104 0108 	add.w	r1, r4, #8
  416d96:	4628      	mov	r0, r5
  416d98:	9300      	str	r3, [sp, #0]
  416d9a:	f000 fd7f 	bl	41789c <_free_r>
  416d9e:	9b00      	ldr	r3, [sp, #0]
  416da0:	6819      	ldr	r1, [r3, #0]
  416da2:	e6df      	b.n	416b64 <_malloc_r+0x2d8>
  416da4:	2001      	movs	r0, #1
  416da6:	f04f 0900 	mov.w	r9, #0
  416daa:	e6bc      	b.n	416b26 <_malloc_r+0x29a>
  416dac:	f5b2 7faa 	cmp.w	r2, #340	; 0x154
  416db0:	d805      	bhi.n	416dbe <_malloc_r+0x532>
  416db2:	0bda      	lsrs	r2, r3, #15
  416db4:	f102 0178 	add.w	r1, r2, #120	; 0x78
  416db8:	00c9      	lsls	r1, r1, #3
  416dba:	3277      	adds	r2, #119	; 0x77
  416dbc:	e720      	b.n	416c00 <_malloc_r+0x374>
  416dbe:	f240 5154 	movw	r1, #1364	; 0x554
  416dc2:	428a      	cmp	r2, r1
  416dc4:	d805      	bhi.n	416dd2 <_malloc_r+0x546>
  416dc6:	0c9a      	lsrs	r2, r3, #18
  416dc8:	f102 017d 	add.w	r1, r2, #125	; 0x7d
  416dcc:	00c9      	lsls	r1, r1, #3
  416dce:	327c      	adds	r2, #124	; 0x7c
  416dd0:	e716      	b.n	416c00 <_malloc_r+0x374>
  416dd2:	f44f 717e 	mov.w	r1, #1016	; 0x3f8
  416dd6:	227e      	movs	r2, #126	; 0x7e
  416dd8:	e712      	b.n	416c00 <_malloc_r+0x374>
  416dda:	687b      	ldr	r3, [r7, #4]
  416ddc:	e780      	b.n	416ce0 <_malloc_r+0x454>
  416dde:	08f0      	lsrs	r0, r6, #3
  416de0:	f106 0308 	add.w	r3, r6, #8
  416de4:	e600      	b.n	4169e8 <_malloc_r+0x15c>
  416de6:	bf00      	nop
  416de8:	20001848 	.word	0x20001848
  416dec:	00000000 	.word	0x00000000

00416df0 <memchr>:
  416df0:	f001 01ff 	and.w	r1, r1, #255	; 0xff
  416df4:	2a10      	cmp	r2, #16
  416df6:	db2b      	blt.n	416e50 <memchr+0x60>
  416df8:	f010 0f07 	tst.w	r0, #7
  416dfc:	d008      	beq.n	416e10 <memchr+0x20>
  416dfe:	f810 3b01 	ldrb.w	r3, [r0], #1
  416e02:	3a01      	subs	r2, #1
  416e04:	428b      	cmp	r3, r1
  416e06:	d02d      	beq.n	416e64 <memchr+0x74>
  416e08:	f010 0f07 	tst.w	r0, #7
  416e0c:	b342      	cbz	r2, 416e60 <memchr+0x70>
  416e0e:	d1f6      	bne.n	416dfe <memchr+0xe>
  416e10:	b4f0      	push	{r4, r5, r6, r7}
  416e12:	ea41 2101 	orr.w	r1, r1, r1, lsl #8
  416e16:	ea41 4101 	orr.w	r1, r1, r1, lsl #16
  416e1a:	f022 0407 	bic.w	r4, r2, #7
  416e1e:	f07f 0700 	mvns.w	r7, #0
  416e22:	2300      	movs	r3, #0
  416e24:	e8f0 5602 	ldrd	r5, r6, [r0], #8
  416e28:	3c08      	subs	r4, #8
  416e2a:	ea85 0501 	eor.w	r5, r5, r1
  416e2e:	ea86 0601 	eor.w	r6, r6, r1
  416e32:	fa85 f547 	uadd8	r5, r5, r7
  416e36:	faa3 f587 	sel	r5, r3, r7
  416e3a:	fa86 f647 	uadd8	r6, r6, r7
  416e3e:	faa5 f687 	sel	r6, r5, r7
  416e42:	b98e      	cbnz	r6, 416e68 <memchr+0x78>
  416e44:	d1ee      	bne.n	416e24 <memchr+0x34>
  416e46:	bcf0      	pop	{r4, r5, r6, r7}
  416e48:	f001 01ff 	and.w	r1, r1, #255	; 0xff
  416e4c:	f002 0207 	and.w	r2, r2, #7
  416e50:	b132      	cbz	r2, 416e60 <memchr+0x70>
  416e52:	f810 3b01 	ldrb.w	r3, [r0], #1
  416e56:	3a01      	subs	r2, #1
  416e58:	ea83 0301 	eor.w	r3, r3, r1
  416e5c:	b113      	cbz	r3, 416e64 <memchr+0x74>
  416e5e:	d1f8      	bne.n	416e52 <memchr+0x62>
  416e60:	2000      	movs	r0, #0
  416e62:	4770      	bx	lr
  416e64:	3801      	subs	r0, #1
  416e66:	4770      	bx	lr
  416e68:	2d00      	cmp	r5, #0
  416e6a:	bf06      	itte	eq
  416e6c:	4635      	moveq	r5, r6
  416e6e:	3803      	subeq	r0, #3
  416e70:	3807      	subne	r0, #7
  416e72:	f015 0f01 	tst.w	r5, #1
  416e76:	d107      	bne.n	416e88 <memchr+0x98>
  416e78:	3001      	adds	r0, #1
  416e7a:	f415 7f80 	tst.w	r5, #256	; 0x100
  416e7e:	bf02      	ittt	eq
  416e80:	3001      	addeq	r0, #1
  416e82:	f415 3fc0 	tsteq.w	r5, #98304	; 0x18000
  416e86:	3001      	addeq	r0, #1
  416e88:	bcf0      	pop	{r4, r5, r6, r7}
  416e8a:	3801      	subs	r0, #1
  416e8c:	4770      	bx	lr
  416e8e:	bf00      	nop

00416e90 <__malloc_lock>:
  416e90:	4801      	ldr	r0, [pc, #4]	; (416e98 <__malloc_lock+0x8>)
  416e92:	f7ff bcf7 	b.w	416884 <__retarget_lock_acquire_recursive>
  416e96:	bf00      	nop
  416e98:	2000212c 	.word	0x2000212c

00416e9c <__malloc_unlock>:
  416e9c:	4801      	ldr	r0, [pc, #4]	; (416ea4 <__malloc_unlock+0x8>)
  416e9e:	f7ff bcf3 	b.w	416888 <__retarget_lock_release_recursive>
  416ea2:	bf00      	nop
  416ea4:	2000212c 	.word	0x2000212c

00416ea8 <_Balloc>:
  416ea8:	6cc3      	ldr	r3, [r0, #76]	; 0x4c
  416eaa:	b570      	push	{r4, r5, r6, lr}
  416eac:	4605      	mov	r5, r0
  416eae:	460c      	mov	r4, r1
  416eb0:	b14b      	cbz	r3, 416ec6 <_Balloc+0x1e>
  416eb2:	f853 0024 	ldr.w	r0, [r3, r4, lsl #2]
  416eb6:	b180      	cbz	r0, 416eda <_Balloc+0x32>
  416eb8:	6802      	ldr	r2, [r0, #0]
  416eba:	f843 2024 	str.w	r2, [r3, r4, lsl #2]
  416ebe:	2300      	movs	r3, #0
  416ec0:	6103      	str	r3, [r0, #16]
  416ec2:	60c3      	str	r3, [r0, #12]
  416ec4:	bd70      	pop	{r4, r5, r6, pc}
  416ec6:	2221      	movs	r2, #33	; 0x21
  416ec8:	2104      	movs	r1, #4
  416eca:	f000 fc67 	bl	41779c <_calloc_r>
  416ece:	64e8      	str	r0, [r5, #76]	; 0x4c
  416ed0:	4603      	mov	r3, r0
  416ed2:	2800      	cmp	r0, #0
  416ed4:	d1ed      	bne.n	416eb2 <_Balloc+0xa>
  416ed6:	2000      	movs	r0, #0
  416ed8:	bd70      	pop	{r4, r5, r6, pc}
  416eda:	2101      	movs	r1, #1
  416edc:	fa01 f604 	lsl.w	r6, r1, r4
  416ee0:	1d72      	adds	r2, r6, #5
  416ee2:	4628      	mov	r0, r5
  416ee4:	0092      	lsls	r2, r2, #2
  416ee6:	f000 fc59 	bl	41779c <_calloc_r>
  416eea:	2800      	cmp	r0, #0
  416eec:	d0f3      	beq.n	416ed6 <_Balloc+0x2e>
  416eee:	6044      	str	r4, [r0, #4]
  416ef0:	6086      	str	r6, [r0, #8]
  416ef2:	e7e4      	b.n	416ebe <_Balloc+0x16>

00416ef4 <_Bfree>:
  416ef4:	b131      	cbz	r1, 416f04 <_Bfree+0x10>
  416ef6:	6cc3      	ldr	r3, [r0, #76]	; 0x4c
  416ef8:	684a      	ldr	r2, [r1, #4]
  416efa:	f853 0022 	ldr.w	r0, [r3, r2, lsl #2]
  416efe:	6008      	str	r0, [r1, #0]
  416f00:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
  416f04:	4770      	bx	lr
  416f06:	bf00      	nop

00416f08 <__multadd>:
  416f08:	b5f0      	push	{r4, r5, r6, r7, lr}
  416f0a:	690c      	ldr	r4, [r1, #16]
  416f0c:	b083      	sub	sp, #12
  416f0e:	460d      	mov	r5, r1
  416f10:	4606      	mov	r6, r0
  416f12:	f101 0e14 	add.w	lr, r1, #20
  416f16:	2700      	movs	r7, #0
  416f18:	f8de 0000 	ldr.w	r0, [lr]
  416f1c:	b281      	uxth	r1, r0
  416f1e:	fb02 3301 	mla	r3, r2, r1, r3
  416f22:	0c01      	lsrs	r1, r0, #16
  416f24:	0c18      	lsrs	r0, r3, #16
  416f26:	fb02 0101 	mla	r1, r2, r1, r0
  416f2a:	b29b      	uxth	r3, r3
  416f2c:	3701      	adds	r7, #1
  416f2e:	eb03 4301 	add.w	r3, r3, r1, lsl #16
  416f32:	42bc      	cmp	r4, r7
  416f34:	f84e 3b04 	str.w	r3, [lr], #4
  416f38:	ea4f 4311 	mov.w	r3, r1, lsr #16
  416f3c:	dcec      	bgt.n	416f18 <__multadd+0x10>
  416f3e:	b13b      	cbz	r3, 416f50 <__multadd+0x48>
  416f40:	68aa      	ldr	r2, [r5, #8]
  416f42:	4294      	cmp	r4, r2
  416f44:	da07      	bge.n	416f56 <__multadd+0x4e>
  416f46:	eb05 0284 	add.w	r2, r5, r4, lsl #2
  416f4a:	3401      	adds	r4, #1
  416f4c:	6153      	str	r3, [r2, #20]
  416f4e:	612c      	str	r4, [r5, #16]
  416f50:	4628      	mov	r0, r5
  416f52:	b003      	add	sp, #12
  416f54:	bdf0      	pop	{r4, r5, r6, r7, pc}
  416f56:	6869      	ldr	r1, [r5, #4]
  416f58:	9301      	str	r3, [sp, #4]
  416f5a:	3101      	adds	r1, #1
  416f5c:	4630      	mov	r0, r6
  416f5e:	f7ff ffa3 	bl	416ea8 <_Balloc>
  416f62:	692a      	ldr	r2, [r5, #16]
  416f64:	3202      	adds	r2, #2
  416f66:	f105 010c 	add.w	r1, r5, #12
  416f6a:	4607      	mov	r7, r0
  416f6c:	0092      	lsls	r2, r2, #2
  416f6e:	300c      	adds	r0, #12
  416f70:	f7fd f868 	bl	414044 <memcpy>
  416f74:	6cf2      	ldr	r2, [r6, #76]	; 0x4c
  416f76:	6869      	ldr	r1, [r5, #4]
  416f78:	9b01      	ldr	r3, [sp, #4]
  416f7a:	f852 0021 	ldr.w	r0, [r2, r1, lsl #2]
  416f7e:	6028      	str	r0, [r5, #0]
  416f80:	f842 5021 	str.w	r5, [r2, r1, lsl #2]
  416f84:	463d      	mov	r5, r7
  416f86:	e7de      	b.n	416f46 <__multadd+0x3e>

00416f88 <__hi0bits>:
  416f88:	0c02      	lsrs	r2, r0, #16
  416f8a:	0412      	lsls	r2, r2, #16
  416f8c:	4603      	mov	r3, r0
  416f8e:	b9b2      	cbnz	r2, 416fbe <__hi0bits+0x36>
  416f90:	0403      	lsls	r3, r0, #16
  416f92:	2010      	movs	r0, #16
  416f94:	f013 4f7f 	tst.w	r3, #4278190080	; 0xff000000
  416f98:	bf04      	itt	eq
  416f9a:	021b      	lsleq	r3, r3, #8
  416f9c:	3008      	addeq	r0, #8
  416f9e:	f013 4f70 	tst.w	r3, #4026531840	; 0xf0000000
  416fa2:	bf04      	itt	eq
  416fa4:	011b      	lsleq	r3, r3, #4
  416fa6:	3004      	addeq	r0, #4
  416fa8:	f013 4f40 	tst.w	r3, #3221225472	; 0xc0000000
  416fac:	bf04      	itt	eq
  416fae:	009b      	lsleq	r3, r3, #2
  416fb0:	3002      	addeq	r0, #2
  416fb2:	2b00      	cmp	r3, #0
  416fb4:	db02      	blt.n	416fbc <__hi0bits+0x34>
  416fb6:	005b      	lsls	r3, r3, #1
  416fb8:	d403      	bmi.n	416fc2 <__hi0bits+0x3a>
  416fba:	2020      	movs	r0, #32
  416fbc:	4770      	bx	lr
  416fbe:	2000      	movs	r0, #0
  416fc0:	e7e8      	b.n	416f94 <__hi0bits+0xc>
  416fc2:	3001      	adds	r0, #1
  416fc4:	4770      	bx	lr
  416fc6:	bf00      	nop

00416fc8 <__lo0bits>:
  416fc8:	6803      	ldr	r3, [r0, #0]
  416fca:	f013 0207 	ands.w	r2, r3, #7
  416fce:	4601      	mov	r1, r0
  416fd0:	d007      	beq.n	416fe2 <__lo0bits+0x1a>
  416fd2:	07da      	lsls	r2, r3, #31
  416fd4:	d421      	bmi.n	41701a <__lo0bits+0x52>
  416fd6:	0798      	lsls	r0, r3, #30
  416fd8:	d421      	bmi.n	41701e <__lo0bits+0x56>
  416fda:	089b      	lsrs	r3, r3, #2
  416fdc:	600b      	str	r3, [r1, #0]
  416fde:	2002      	movs	r0, #2
  416fe0:	4770      	bx	lr
  416fe2:	b298      	uxth	r0, r3
  416fe4:	b198      	cbz	r0, 41700e <__lo0bits+0x46>
  416fe6:	4610      	mov	r0, r2
  416fe8:	f013 0fff 	tst.w	r3, #255	; 0xff
  416fec:	bf04      	itt	eq
  416fee:	0a1b      	lsreq	r3, r3, #8
  416ff0:	3008      	addeq	r0, #8
  416ff2:	071a      	lsls	r2, r3, #28
  416ff4:	bf04      	itt	eq
  416ff6:	091b      	lsreq	r3, r3, #4
  416ff8:	3004      	addeq	r0, #4
  416ffa:	079a      	lsls	r2, r3, #30
  416ffc:	bf04      	itt	eq
  416ffe:	089b      	lsreq	r3, r3, #2
  417000:	3002      	addeq	r0, #2
  417002:	07da      	lsls	r2, r3, #31
  417004:	d407      	bmi.n	417016 <__lo0bits+0x4e>
  417006:	085b      	lsrs	r3, r3, #1
  417008:	d104      	bne.n	417014 <__lo0bits+0x4c>
  41700a:	2020      	movs	r0, #32
  41700c:	4770      	bx	lr
  41700e:	0c1b      	lsrs	r3, r3, #16
  417010:	2010      	movs	r0, #16
  417012:	e7e9      	b.n	416fe8 <__lo0bits+0x20>
  417014:	3001      	adds	r0, #1
  417016:	600b      	str	r3, [r1, #0]
  417018:	4770      	bx	lr
  41701a:	2000      	movs	r0, #0
  41701c:	4770      	bx	lr
  41701e:	085b      	lsrs	r3, r3, #1
  417020:	600b      	str	r3, [r1, #0]
  417022:	2001      	movs	r0, #1
  417024:	4770      	bx	lr
  417026:	bf00      	nop

00417028 <__i2b>:
  417028:	b510      	push	{r4, lr}
  41702a:	460c      	mov	r4, r1
  41702c:	2101      	movs	r1, #1
  41702e:	f7ff ff3b 	bl	416ea8 <_Balloc>
  417032:	2201      	movs	r2, #1
  417034:	6144      	str	r4, [r0, #20]
  417036:	6102      	str	r2, [r0, #16]
  417038:	bd10      	pop	{r4, pc}
  41703a:	bf00      	nop

0041703c <__multiply>:
  41703c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  417040:	690c      	ldr	r4, [r1, #16]
  417042:	6915      	ldr	r5, [r2, #16]
  417044:	42ac      	cmp	r4, r5
  417046:	b083      	sub	sp, #12
  417048:	468b      	mov	fp, r1
  41704a:	4616      	mov	r6, r2
  41704c:	da04      	bge.n	417058 <__multiply+0x1c>
  41704e:	4622      	mov	r2, r4
  417050:	46b3      	mov	fp, r6
  417052:	462c      	mov	r4, r5
  417054:	460e      	mov	r6, r1
  417056:	4615      	mov	r5, r2
  417058:	f8db 3008 	ldr.w	r3, [fp, #8]
  41705c:	f8db 1004 	ldr.w	r1, [fp, #4]
  417060:	eb04 0805 	add.w	r8, r4, r5
  417064:	4598      	cmp	r8, r3
  417066:	bfc8      	it	gt
  417068:	3101      	addgt	r1, #1
  41706a:	f7ff ff1d 	bl	416ea8 <_Balloc>
  41706e:	f100 0914 	add.w	r9, r0, #20
  417072:	eb09 0a88 	add.w	sl, r9, r8, lsl #2
  417076:	45d1      	cmp	r9, sl
  417078:	9000      	str	r0, [sp, #0]
  41707a:	d205      	bcs.n	417088 <__multiply+0x4c>
  41707c:	464b      	mov	r3, r9
  41707e:	2100      	movs	r1, #0
  417080:	f843 1b04 	str.w	r1, [r3], #4
  417084:	459a      	cmp	sl, r3
  417086:	d8fb      	bhi.n	417080 <__multiply+0x44>
  417088:	f106 0c14 	add.w	ip, r6, #20
  41708c:	eb0c 0385 	add.w	r3, ip, r5, lsl #2
  417090:	f10b 0b14 	add.w	fp, fp, #20
  417094:	459c      	cmp	ip, r3
  417096:	eb0b 0e84 	add.w	lr, fp, r4, lsl #2
  41709a:	d24c      	bcs.n	417136 <__multiply+0xfa>
  41709c:	f8cd a004 	str.w	sl, [sp, #4]
  4170a0:	469a      	mov	sl, r3
  4170a2:	f8dc 5000 	ldr.w	r5, [ip]
  4170a6:	b2af      	uxth	r7, r5
  4170a8:	b1ef      	cbz	r7, 4170e6 <__multiply+0xaa>
  4170aa:	2100      	movs	r1, #0
  4170ac:	464d      	mov	r5, r9
  4170ae:	465e      	mov	r6, fp
  4170b0:	460c      	mov	r4, r1
  4170b2:	f856 2b04 	ldr.w	r2, [r6], #4
  4170b6:	6828      	ldr	r0, [r5, #0]
  4170b8:	b293      	uxth	r3, r2
  4170ba:	b281      	uxth	r1, r0
  4170bc:	fb07 1303 	mla	r3, r7, r3, r1
  4170c0:	0c12      	lsrs	r2, r2, #16
  4170c2:	0c01      	lsrs	r1, r0, #16
  4170c4:	4423      	add	r3, r4
  4170c6:	fb07 1102 	mla	r1, r7, r2, r1
  4170ca:	eb01 4113 	add.w	r1, r1, r3, lsr #16
  4170ce:	b29b      	uxth	r3, r3
  4170d0:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
  4170d4:	45b6      	cmp	lr, r6
  4170d6:	f845 3b04 	str.w	r3, [r5], #4
  4170da:	ea4f 4411 	mov.w	r4, r1, lsr #16
  4170de:	d8e8      	bhi.n	4170b2 <__multiply+0x76>
  4170e0:	602c      	str	r4, [r5, #0]
  4170e2:	f8dc 5000 	ldr.w	r5, [ip]
  4170e6:	0c2d      	lsrs	r5, r5, #16
  4170e8:	d01d      	beq.n	417126 <__multiply+0xea>
  4170ea:	f8d9 3000 	ldr.w	r3, [r9]
  4170ee:	4648      	mov	r0, r9
  4170f0:	461c      	mov	r4, r3
  4170f2:	4659      	mov	r1, fp
  4170f4:	2200      	movs	r2, #0
  4170f6:	880e      	ldrh	r6, [r1, #0]
  4170f8:	0c24      	lsrs	r4, r4, #16
  4170fa:	fb05 4406 	mla	r4, r5, r6, r4
  4170fe:	4422      	add	r2, r4
  417100:	b29b      	uxth	r3, r3
  417102:	ea43 4302 	orr.w	r3, r3, r2, lsl #16
  417106:	f840 3b04 	str.w	r3, [r0], #4
  41710a:	f851 3b04 	ldr.w	r3, [r1], #4
  41710e:	6804      	ldr	r4, [r0, #0]
  417110:	0c1b      	lsrs	r3, r3, #16
  417112:	b2a6      	uxth	r6, r4
  417114:	fb05 6303 	mla	r3, r5, r3, r6
  417118:	eb03 4312 	add.w	r3, r3, r2, lsr #16
  41711c:	458e      	cmp	lr, r1
  41711e:	ea4f 4213 	mov.w	r2, r3, lsr #16
  417122:	d8e8      	bhi.n	4170f6 <__multiply+0xba>
  417124:	6003      	str	r3, [r0, #0]
  417126:	f10c 0c04 	add.w	ip, ip, #4
  41712a:	45e2      	cmp	sl, ip
  41712c:	f109 0904 	add.w	r9, r9, #4
  417130:	d8b7      	bhi.n	4170a2 <__multiply+0x66>
  417132:	f8dd a004 	ldr.w	sl, [sp, #4]
  417136:	f1b8 0f00 	cmp.w	r8, #0
  41713a:	dd0b      	ble.n	417154 <__multiply+0x118>
  41713c:	f85a 3c04 	ldr.w	r3, [sl, #-4]
  417140:	f1aa 0a04 	sub.w	sl, sl, #4
  417144:	b11b      	cbz	r3, 41714e <__multiply+0x112>
  417146:	e005      	b.n	417154 <__multiply+0x118>
  417148:	f85a 3d04 	ldr.w	r3, [sl, #-4]!
  41714c:	b913      	cbnz	r3, 417154 <__multiply+0x118>
  41714e:	f1b8 0801 	subs.w	r8, r8, #1
  417152:	d1f9      	bne.n	417148 <__multiply+0x10c>
  417154:	9800      	ldr	r0, [sp, #0]
  417156:	f8c0 8010 	str.w	r8, [r0, #16]
  41715a:	b003      	add	sp, #12
  41715c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}

00417160 <__pow5mult>:
  417160:	f012 0303 	ands.w	r3, r2, #3
  417164:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  417168:	4614      	mov	r4, r2
  41716a:	4607      	mov	r7, r0
  41716c:	d12e      	bne.n	4171cc <__pow5mult+0x6c>
  41716e:	460d      	mov	r5, r1
  417170:	10a4      	asrs	r4, r4, #2
  417172:	d01c      	beq.n	4171ae <__pow5mult+0x4e>
  417174:	6cbe      	ldr	r6, [r7, #72]	; 0x48
  417176:	b396      	cbz	r6, 4171de <__pow5mult+0x7e>
  417178:	07e3      	lsls	r3, r4, #31
  41717a:	f04f 0800 	mov.w	r8, #0
  41717e:	d406      	bmi.n	41718e <__pow5mult+0x2e>
  417180:	1064      	asrs	r4, r4, #1
  417182:	d014      	beq.n	4171ae <__pow5mult+0x4e>
  417184:	6830      	ldr	r0, [r6, #0]
  417186:	b1a8      	cbz	r0, 4171b4 <__pow5mult+0x54>
  417188:	4606      	mov	r6, r0
  41718a:	07e3      	lsls	r3, r4, #31
  41718c:	d5f8      	bpl.n	417180 <__pow5mult+0x20>
  41718e:	4632      	mov	r2, r6
  417190:	4629      	mov	r1, r5
  417192:	4638      	mov	r0, r7
  417194:	f7ff ff52 	bl	41703c <__multiply>
  417198:	b1b5      	cbz	r5, 4171c8 <__pow5mult+0x68>
  41719a:	686a      	ldr	r2, [r5, #4]
  41719c:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
  41719e:	1064      	asrs	r4, r4, #1
  4171a0:	f853 1022 	ldr.w	r1, [r3, r2, lsl #2]
  4171a4:	6029      	str	r1, [r5, #0]
  4171a6:	f843 5022 	str.w	r5, [r3, r2, lsl #2]
  4171aa:	4605      	mov	r5, r0
  4171ac:	d1ea      	bne.n	417184 <__pow5mult+0x24>
  4171ae:	4628      	mov	r0, r5
  4171b0:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  4171b4:	4632      	mov	r2, r6
  4171b6:	4631      	mov	r1, r6
  4171b8:	4638      	mov	r0, r7
  4171ba:	f7ff ff3f 	bl	41703c <__multiply>
  4171be:	6030      	str	r0, [r6, #0]
  4171c0:	f8c0 8000 	str.w	r8, [r0]
  4171c4:	4606      	mov	r6, r0
  4171c6:	e7e0      	b.n	41718a <__pow5mult+0x2a>
  4171c8:	4605      	mov	r5, r0
  4171ca:	e7d9      	b.n	417180 <__pow5mult+0x20>
  4171cc:	1e5a      	subs	r2, r3, #1
  4171ce:	4d0b      	ldr	r5, [pc, #44]	; (4171fc <__pow5mult+0x9c>)
  4171d0:	2300      	movs	r3, #0
  4171d2:	f855 2022 	ldr.w	r2, [r5, r2, lsl #2]
  4171d6:	f7ff fe97 	bl	416f08 <__multadd>
  4171da:	4605      	mov	r5, r0
  4171dc:	e7c8      	b.n	417170 <__pow5mult+0x10>
  4171de:	2101      	movs	r1, #1
  4171e0:	4638      	mov	r0, r7
  4171e2:	f7ff fe61 	bl	416ea8 <_Balloc>
  4171e6:	f240 2171 	movw	r1, #625	; 0x271
  4171ea:	2201      	movs	r2, #1
  4171ec:	2300      	movs	r3, #0
  4171ee:	6141      	str	r1, [r0, #20]
  4171f0:	6102      	str	r2, [r0, #16]
  4171f2:	4606      	mov	r6, r0
  4171f4:	64b8      	str	r0, [r7, #72]	; 0x48
  4171f6:	6003      	str	r3, [r0, #0]
  4171f8:	e7be      	b.n	417178 <__pow5mult+0x18>
  4171fa:	bf00      	nop
  4171fc:	0041d790 	.word	0x0041d790

00417200 <__lshift>:
  417200:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
  417204:	4691      	mov	r9, r2
  417206:	690a      	ldr	r2, [r1, #16]
  417208:	688b      	ldr	r3, [r1, #8]
  41720a:	ea4f 1469 	mov.w	r4, r9, asr #5
  41720e:	eb04 0802 	add.w	r8, r4, r2
  417212:	f108 0501 	add.w	r5, r8, #1
  417216:	429d      	cmp	r5, r3
  417218:	460e      	mov	r6, r1
  41721a:	4607      	mov	r7, r0
  41721c:	6849      	ldr	r1, [r1, #4]
  41721e:	dd04      	ble.n	41722a <__lshift+0x2a>
  417220:	005b      	lsls	r3, r3, #1
  417222:	429d      	cmp	r5, r3
  417224:	f101 0101 	add.w	r1, r1, #1
  417228:	dcfa      	bgt.n	417220 <__lshift+0x20>
  41722a:	4638      	mov	r0, r7
  41722c:	f7ff fe3c 	bl	416ea8 <_Balloc>
  417230:	2c00      	cmp	r4, #0
  417232:	f100 0314 	add.w	r3, r0, #20
  417236:	dd06      	ble.n	417246 <__lshift+0x46>
  417238:	eb03 0284 	add.w	r2, r3, r4, lsl #2
  41723c:	2100      	movs	r1, #0
  41723e:	f843 1b04 	str.w	r1, [r3], #4
  417242:	429a      	cmp	r2, r3
  417244:	d1fb      	bne.n	41723e <__lshift+0x3e>
  417246:	6934      	ldr	r4, [r6, #16]
  417248:	f106 0114 	add.w	r1, r6, #20
  41724c:	f019 091f 	ands.w	r9, r9, #31
  417250:	eb01 0e84 	add.w	lr, r1, r4, lsl #2
  417254:	d01d      	beq.n	417292 <__lshift+0x92>
  417256:	f1c9 0c20 	rsb	ip, r9, #32
  41725a:	2200      	movs	r2, #0
  41725c:	680c      	ldr	r4, [r1, #0]
  41725e:	fa04 f409 	lsl.w	r4, r4, r9
  417262:	4314      	orrs	r4, r2
  417264:	f843 4b04 	str.w	r4, [r3], #4
  417268:	f851 2b04 	ldr.w	r2, [r1], #4
  41726c:	458e      	cmp	lr, r1
  41726e:	fa22 f20c 	lsr.w	r2, r2, ip
  417272:	d8f3      	bhi.n	41725c <__lshift+0x5c>
  417274:	601a      	str	r2, [r3, #0]
  417276:	b10a      	cbz	r2, 41727c <__lshift+0x7c>
  417278:	f108 0502 	add.w	r5, r8, #2
  41727c:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
  41727e:	6872      	ldr	r2, [r6, #4]
  417280:	3d01      	subs	r5, #1
  417282:	f853 1022 	ldr.w	r1, [r3, r2, lsl #2]
  417286:	6105      	str	r5, [r0, #16]
  417288:	6031      	str	r1, [r6, #0]
  41728a:	f843 6022 	str.w	r6, [r3, r2, lsl #2]
  41728e:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
  417292:	3b04      	subs	r3, #4
  417294:	f851 2b04 	ldr.w	r2, [r1], #4
  417298:	f843 2f04 	str.w	r2, [r3, #4]!
  41729c:	458e      	cmp	lr, r1
  41729e:	d8f9      	bhi.n	417294 <__lshift+0x94>
  4172a0:	e7ec      	b.n	41727c <__lshift+0x7c>
  4172a2:	bf00      	nop

004172a4 <__mcmp>:
  4172a4:	b430      	push	{r4, r5}
  4172a6:	690b      	ldr	r3, [r1, #16]
  4172a8:	4605      	mov	r5, r0
  4172aa:	6900      	ldr	r0, [r0, #16]
  4172ac:	1ac0      	subs	r0, r0, r3
  4172ae:	d10f      	bne.n	4172d0 <__mcmp+0x2c>
  4172b0:	009b      	lsls	r3, r3, #2
  4172b2:	3514      	adds	r5, #20
  4172b4:	3114      	adds	r1, #20
  4172b6:	4419      	add	r1, r3
  4172b8:	442b      	add	r3, r5
  4172ba:	e001      	b.n	4172c0 <__mcmp+0x1c>
  4172bc:	429d      	cmp	r5, r3
  4172be:	d207      	bcs.n	4172d0 <__mcmp+0x2c>
  4172c0:	f853 4d04 	ldr.w	r4, [r3, #-4]!
  4172c4:	f851 2d04 	ldr.w	r2, [r1, #-4]!
  4172c8:	4294      	cmp	r4, r2
  4172ca:	d0f7      	beq.n	4172bc <__mcmp+0x18>
  4172cc:	d302      	bcc.n	4172d4 <__mcmp+0x30>
  4172ce:	2001      	movs	r0, #1
  4172d0:	bc30      	pop	{r4, r5}
  4172d2:	4770      	bx	lr
  4172d4:	f04f 30ff 	mov.w	r0, #4294967295
  4172d8:	e7fa      	b.n	4172d0 <__mcmp+0x2c>
  4172da:	bf00      	nop

004172dc <__mdiff>:
  4172dc:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  4172e0:	690f      	ldr	r7, [r1, #16]
  4172e2:	460e      	mov	r6, r1
  4172e4:	6911      	ldr	r1, [r2, #16]
  4172e6:	1a7f      	subs	r7, r7, r1
  4172e8:	2f00      	cmp	r7, #0
  4172ea:	4690      	mov	r8, r2
  4172ec:	d117      	bne.n	41731e <__mdiff+0x42>
  4172ee:	0089      	lsls	r1, r1, #2
  4172f0:	f106 0514 	add.w	r5, r6, #20
  4172f4:	f102 0e14 	add.w	lr, r2, #20
  4172f8:	186b      	adds	r3, r5, r1
  4172fa:	4471      	add	r1, lr
  4172fc:	e001      	b.n	417302 <__mdiff+0x26>
  4172fe:	429d      	cmp	r5, r3
  417300:	d25c      	bcs.n	4173bc <__mdiff+0xe0>
  417302:	f853 2d04 	ldr.w	r2, [r3, #-4]!
  417306:	f851 4d04 	ldr.w	r4, [r1, #-4]!
  41730a:	42a2      	cmp	r2, r4
  41730c:	d0f7      	beq.n	4172fe <__mdiff+0x22>
  41730e:	d25e      	bcs.n	4173ce <__mdiff+0xf2>
  417310:	4633      	mov	r3, r6
  417312:	462c      	mov	r4, r5
  417314:	4646      	mov	r6, r8
  417316:	4675      	mov	r5, lr
  417318:	4698      	mov	r8, r3
  41731a:	2701      	movs	r7, #1
  41731c:	e005      	b.n	41732a <__mdiff+0x4e>
  41731e:	db58      	blt.n	4173d2 <__mdiff+0xf6>
  417320:	f106 0514 	add.w	r5, r6, #20
  417324:	f108 0414 	add.w	r4, r8, #20
  417328:	2700      	movs	r7, #0
  41732a:	6871      	ldr	r1, [r6, #4]
  41732c:	f7ff fdbc 	bl	416ea8 <_Balloc>
  417330:	f8d8 3010 	ldr.w	r3, [r8, #16]
  417334:	6936      	ldr	r6, [r6, #16]
  417336:	60c7      	str	r7, [r0, #12]
  417338:	eb04 0c83 	add.w	ip, r4, r3, lsl #2
  41733c:	46a6      	mov	lr, r4
  41733e:	eb05 0786 	add.w	r7, r5, r6, lsl #2
  417342:	f100 0414 	add.w	r4, r0, #20
  417346:	2300      	movs	r3, #0
  417348:	f85e 1b04 	ldr.w	r1, [lr], #4
  41734c:	f855 8b04 	ldr.w	r8, [r5], #4
  417350:	b28a      	uxth	r2, r1
  417352:	fa13 f388 	uxtah	r3, r3, r8
  417356:	0c09      	lsrs	r1, r1, #16
  417358:	1a9a      	subs	r2, r3, r2
  41735a:	ebc1 4318 	rsb	r3, r1, r8, lsr #16
  41735e:	eb03 4322 	add.w	r3, r3, r2, asr #16
  417362:	b292      	uxth	r2, r2
  417364:	ea42 4203 	orr.w	r2, r2, r3, lsl #16
  417368:	45f4      	cmp	ip, lr
  41736a:	f844 2b04 	str.w	r2, [r4], #4
  41736e:	ea4f 4323 	mov.w	r3, r3, asr #16
  417372:	d8e9      	bhi.n	417348 <__mdiff+0x6c>
  417374:	42af      	cmp	r7, r5
  417376:	d917      	bls.n	4173a8 <__mdiff+0xcc>
  417378:	46a4      	mov	ip, r4
  41737a:	46ae      	mov	lr, r5
  41737c:	f85e 2b04 	ldr.w	r2, [lr], #4
  417380:	fa13 f382 	uxtah	r3, r3, r2
  417384:	1419      	asrs	r1, r3, #16
  417386:	eb01 4112 	add.w	r1, r1, r2, lsr #16
  41738a:	b29b      	uxth	r3, r3
  41738c:	ea43 4201 	orr.w	r2, r3, r1, lsl #16
  417390:	4577      	cmp	r7, lr
  417392:	f84c 2b04 	str.w	r2, [ip], #4
  417396:	ea4f 4321 	mov.w	r3, r1, asr #16
  41739a:	d8ef      	bhi.n	41737c <__mdiff+0xa0>
  41739c:	43ed      	mvns	r5, r5
  41739e:	442f      	add	r7, r5
  4173a0:	f027 0703 	bic.w	r7, r7, #3
  4173a4:	3704      	adds	r7, #4
  4173a6:	443c      	add	r4, r7
  4173a8:	3c04      	subs	r4, #4
  4173aa:	b922      	cbnz	r2, 4173b6 <__mdiff+0xda>
  4173ac:	f854 3d04 	ldr.w	r3, [r4, #-4]!
  4173b0:	3e01      	subs	r6, #1
  4173b2:	2b00      	cmp	r3, #0
  4173b4:	d0fa      	beq.n	4173ac <__mdiff+0xd0>
  4173b6:	6106      	str	r6, [r0, #16]
  4173b8:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  4173bc:	2100      	movs	r1, #0
  4173be:	f7ff fd73 	bl	416ea8 <_Balloc>
  4173c2:	2201      	movs	r2, #1
  4173c4:	2300      	movs	r3, #0
  4173c6:	6102      	str	r2, [r0, #16]
  4173c8:	6143      	str	r3, [r0, #20]
  4173ca:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  4173ce:	4674      	mov	r4, lr
  4173d0:	e7ab      	b.n	41732a <__mdiff+0x4e>
  4173d2:	4633      	mov	r3, r6
  4173d4:	f106 0414 	add.w	r4, r6, #20
  4173d8:	f102 0514 	add.w	r5, r2, #20
  4173dc:	4616      	mov	r6, r2
  4173de:	2701      	movs	r7, #1
  4173e0:	4698      	mov	r8, r3
  4173e2:	e7a2      	b.n	41732a <__mdiff+0x4e>

004173e4 <__d2b>:
  4173e4:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
  4173e8:	ec57 6b10 	vmov	r6, r7, d0
  4173ec:	b083      	sub	sp, #12
  4173ee:	4688      	mov	r8, r1
  4173f0:	2101      	movs	r1, #1
  4173f2:	463c      	mov	r4, r7
  4173f4:	f3c7 550a 	ubfx	r5, r7, #20, #11
  4173f8:	4617      	mov	r7, r2
  4173fa:	f7ff fd55 	bl	416ea8 <_Balloc>
  4173fe:	f3c4 0413 	ubfx	r4, r4, #0, #20
  417402:	4681      	mov	r9, r0
  417404:	b10d      	cbz	r5, 41740a <__d2b+0x26>
  417406:	f444 1480 	orr.w	r4, r4, #1048576	; 0x100000
  41740a:	9401      	str	r4, [sp, #4]
  41740c:	b31e      	cbz	r6, 417456 <__d2b+0x72>
  41740e:	a802      	add	r0, sp, #8
  417410:	f840 6d08 	str.w	r6, [r0, #-8]!
  417414:	f7ff fdd8 	bl	416fc8 <__lo0bits>
  417418:	2800      	cmp	r0, #0
  41741a:	d134      	bne.n	417486 <__d2b+0xa2>
  41741c:	e89d 000c 	ldmia.w	sp, {r2, r3}
  417420:	f8c9 2014 	str.w	r2, [r9, #20]
  417424:	2b00      	cmp	r3, #0
  417426:	bf0c      	ite	eq
  417428:	2101      	moveq	r1, #1
  41742a:	2102      	movne	r1, #2
  41742c:	f8c9 3018 	str.w	r3, [r9, #24]
  417430:	f8c9 1010 	str.w	r1, [r9, #16]
  417434:	b9dd      	cbnz	r5, 41746e <__d2b+0x8a>
  417436:	eb09 0381 	add.w	r3, r9, r1, lsl #2
  41743a:	f2a0 4032 	subw	r0, r0, #1074	; 0x432
  41743e:	f8c8 0000 	str.w	r0, [r8]
  417442:	6918      	ldr	r0, [r3, #16]
  417444:	f7ff fda0 	bl	416f88 <__hi0bits>
  417448:	ebc0 1041 	rsb	r0, r0, r1, lsl #5
  41744c:	6038      	str	r0, [r7, #0]
  41744e:	4648      	mov	r0, r9
  417450:	b003      	add	sp, #12
  417452:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
  417456:	a801      	add	r0, sp, #4
  417458:	f7ff fdb6 	bl	416fc8 <__lo0bits>
  41745c:	9b01      	ldr	r3, [sp, #4]
  41745e:	f8c9 3014 	str.w	r3, [r9, #20]
  417462:	2101      	movs	r1, #1
  417464:	3020      	adds	r0, #32
  417466:	f8c9 1010 	str.w	r1, [r9, #16]
  41746a:	2d00      	cmp	r5, #0
  41746c:	d0e3      	beq.n	417436 <__d2b+0x52>
  41746e:	f2a5 4533 	subw	r5, r5, #1075	; 0x433
  417472:	4405      	add	r5, r0
  417474:	f1c0 0035 	rsb	r0, r0, #53	; 0x35
  417478:	f8c8 5000 	str.w	r5, [r8]
  41747c:	6038      	str	r0, [r7, #0]
  41747e:	4648      	mov	r0, r9
  417480:	b003      	add	sp, #12
  417482:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
  417486:	e89d 000a 	ldmia.w	sp, {r1, r3}
  41748a:	f1c0 0220 	rsb	r2, r0, #32
  41748e:	fa03 f202 	lsl.w	r2, r3, r2
  417492:	430a      	orrs	r2, r1
  417494:	40c3      	lsrs	r3, r0
  417496:	9301      	str	r3, [sp, #4]
  417498:	f8c9 2014 	str.w	r2, [r9, #20]
  41749c:	e7c2      	b.n	417424 <__d2b+0x40>
  41749e:	bf00      	nop

004174a0 <_sbrk_r>:
  4174a0:	b538      	push	{r3, r4, r5, lr}
  4174a2:	4c07      	ldr	r4, [pc, #28]	; (4174c0 <_sbrk_r+0x20>)
  4174a4:	2300      	movs	r3, #0
  4174a6:	4605      	mov	r5, r0
  4174a8:	4608      	mov	r0, r1
  4174aa:	6023      	str	r3, [r4, #0]
  4174ac:	f7ed f9e8 	bl	404880 <_sbrk>
  4174b0:	1c43      	adds	r3, r0, #1
  4174b2:	d000      	beq.n	4174b6 <_sbrk_r+0x16>
  4174b4:	bd38      	pop	{r3, r4, r5, pc}
  4174b6:	6823      	ldr	r3, [r4, #0]
  4174b8:	2b00      	cmp	r3, #0
  4174ba:	d0fb      	beq.n	4174b4 <_sbrk_r+0x14>
  4174bc:	602b      	str	r3, [r5, #0]
  4174be:	bd38      	pop	{r3, r4, r5, pc}
  4174c0:	20002140 	.word	0x20002140
	...

00417500 <strlen>:
  417500:	f890 f000 	pld	[r0]
  417504:	e96d 4502 	strd	r4, r5, [sp, #-8]!
  417508:	f020 0107 	bic.w	r1, r0, #7
  41750c:	f06f 0c00 	mvn.w	ip, #0
  417510:	f010 0407 	ands.w	r4, r0, #7
  417514:	f891 f020 	pld	[r1, #32]
  417518:	f040 8049 	bne.w	4175ae <strlen+0xae>
  41751c:	f04f 0400 	mov.w	r4, #0
  417520:	f06f 0007 	mvn.w	r0, #7
  417524:	e9d1 2300 	ldrd	r2, r3, [r1]
  417528:	f891 f040 	pld	[r1, #64]	; 0x40
  41752c:	f100 0008 	add.w	r0, r0, #8
  417530:	fa82 f24c 	uadd8	r2, r2, ip
  417534:	faa4 f28c 	sel	r2, r4, ip
  417538:	fa83 f34c 	uadd8	r3, r3, ip
  41753c:	faa2 f38c 	sel	r3, r2, ip
  417540:	bb4b      	cbnz	r3, 417596 <strlen+0x96>
  417542:	e9d1 2302 	ldrd	r2, r3, [r1, #8]
  417546:	fa82 f24c 	uadd8	r2, r2, ip
  41754a:	f100 0008 	add.w	r0, r0, #8
  41754e:	faa4 f28c 	sel	r2, r4, ip
  417552:	fa83 f34c 	uadd8	r3, r3, ip
  417556:	faa2 f38c 	sel	r3, r2, ip
  41755a:	b9e3      	cbnz	r3, 417596 <strlen+0x96>
  41755c:	e9d1 2304 	ldrd	r2, r3, [r1, #16]
  417560:	fa82 f24c 	uadd8	r2, r2, ip
  417564:	f100 0008 	add.w	r0, r0, #8
  417568:	faa4 f28c 	sel	r2, r4, ip
  41756c:	fa83 f34c 	uadd8	r3, r3, ip
  417570:	faa2 f38c 	sel	r3, r2, ip
  417574:	b97b      	cbnz	r3, 417596 <strlen+0x96>
  417576:	e9d1 2306 	ldrd	r2, r3, [r1, #24]
  41757a:	f101 0120 	add.w	r1, r1, #32
  41757e:	fa82 f24c 	uadd8	r2, r2, ip
  417582:	f100 0008 	add.w	r0, r0, #8
  417586:	faa4 f28c 	sel	r2, r4, ip
  41758a:	fa83 f34c 	uadd8	r3, r3, ip
  41758e:	faa2 f38c 	sel	r3, r2, ip
  417592:	2b00      	cmp	r3, #0
  417594:	d0c6      	beq.n	417524 <strlen+0x24>
  417596:	2a00      	cmp	r2, #0
  417598:	bf04      	itt	eq
  41759a:	3004      	addeq	r0, #4
  41759c:	461a      	moveq	r2, r3
  41759e:	ba12      	rev	r2, r2
  4175a0:	fab2 f282 	clz	r2, r2
  4175a4:	e8fd 4502 	ldrd	r4, r5, [sp], #8
  4175a8:	eb00 00d2 	add.w	r0, r0, r2, lsr #3
  4175ac:	4770      	bx	lr
  4175ae:	e9d1 2300 	ldrd	r2, r3, [r1]
  4175b2:	f004 0503 	and.w	r5, r4, #3
  4175b6:	f1c4 0000 	rsb	r0, r4, #0
  4175ba:	ea4f 05c5 	mov.w	r5, r5, lsl #3
  4175be:	f014 0f04 	tst.w	r4, #4
  4175c2:	f891 f040 	pld	[r1, #64]	; 0x40
  4175c6:	fa0c f505 	lsl.w	r5, ip, r5
  4175ca:	ea62 0205 	orn	r2, r2, r5
  4175ce:	bf1c      	itt	ne
  4175d0:	ea63 0305 	ornne	r3, r3, r5
  4175d4:	4662      	movne	r2, ip
  4175d6:	f04f 0400 	mov.w	r4, #0
  4175da:	e7a9      	b.n	417530 <strlen+0x30>

004175dc <__ssprint_r>:
  4175dc:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  4175e0:	6893      	ldr	r3, [r2, #8]
  4175e2:	b083      	sub	sp, #12
  4175e4:	4690      	mov	r8, r2
  4175e6:	2b00      	cmp	r3, #0
  4175e8:	d070      	beq.n	4176cc <__ssprint_r+0xf0>
  4175ea:	4682      	mov	sl, r0
  4175ec:	460c      	mov	r4, r1
  4175ee:	6817      	ldr	r7, [r2, #0]
  4175f0:	688d      	ldr	r5, [r1, #8]
  4175f2:	6808      	ldr	r0, [r1, #0]
  4175f4:	e042      	b.n	41767c <__ssprint_r+0xa0>
  4175f6:	89a3      	ldrh	r3, [r4, #12]
  4175f8:	f413 6f90 	tst.w	r3, #1152	; 0x480
  4175fc:	d02e      	beq.n	41765c <__ssprint_r+0x80>
  4175fe:	6965      	ldr	r5, [r4, #20]
  417600:	6921      	ldr	r1, [r4, #16]
  417602:	eb05 0545 	add.w	r5, r5, r5, lsl #1
  417606:	eba0 0b01 	sub.w	fp, r0, r1
  41760a:	eb05 75d5 	add.w	r5, r5, r5, lsr #31
  41760e:	f10b 0001 	add.w	r0, fp, #1
  417612:	106d      	asrs	r5, r5, #1
  417614:	4430      	add	r0, r6
  417616:	42a8      	cmp	r0, r5
  417618:	462a      	mov	r2, r5
  41761a:	bf84      	itt	hi
  41761c:	4605      	movhi	r5, r0
  41761e:	462a      	movhi	r2, r5
  417620:	055b      	lsls	r3, r3, #21
  417622:	d538      	bpl.n	417696 <__ssprint_r+0xba>
  417624:	4611      	mov	r1, r2
  417626:	4650      	mov	r0, sl
  417628:	f7ff f930 	bl	41688c <_malloc_r>
  41762c:	2800      	cmp	r0, #0
  41762e:	d03c      	beq.n	4176aa <__ssprint_r+0xce>
  417630:	465a      	mov	r2, fp
  417632:	6921      	ldr	r1, [r4, #16]
  417634:	9001      	str	r0, [sp, #4]
  417636:	f7fc fd05 	bl	414044 <memcpy>
  41763a:	89a2      	ldrh	r2, [r4, #12]
  41763c:	9b01      	ldr	r3, [sp, #4]
  41763e:	f422 6290 	bic.w	r2, r2, #1152	; 0x480
  417642:	f042 0280 	orr.w	r2, r2, #128	; 0x80
  417646:	81a2      	strh	r2, [r4, #12]
  417648:	eba5 020b 	sub.w	r2, r5, fp
  41764c:	eb03 000b 	add.w	r0, r3, fp
  417650:	6165      	str	r5, [r4, #20]
  417652:	6123      	str	r3, [r4, #16]
  417654:	6020      	str	r0, [r4, #0]
  417656:	60a2      	str	r2, [r4, #8]
  417658:	4635      	mov	r5, r6
  41765a:	46b3      	mov	fp, r6
  41765c:	465a      	mov	r2, fp
  41765e:	4649      	mov	r1, r9
  417660:	f7fc fd8a 	bl	414178 <memmove>
  417664:	f8d8 3008 	ldr.w	r3, [r8, #8]
  417668:	68a2      	ldr	r2, [r4, #8]
  41766a:	6820      	ldr	r0, [r4, #0]
  41766c:	1b55      	subs	r5, r2, r5
  41766e:	4458      	add	r0, fp
  417670:	1b9e      	subs	r6, r3, r6
  417672:	60a5      	str	r5, [r4, #8]
  417674:	6020      	str	r0, [r4, #0]
  417676:	f8c8 6008 	str.w	r6, [r8, #8]
  41767a:	b33e      	cbz	r6, 4176cc <__ssprint_r+0xf0>
  41767c:	687e      	ldr	r6, [r7, #4]
  41767e:	463b      	mov	r3, r7
  417680:	3708      	adds	r7, #8
  417682:	2e00      	cmp	r6, #0
  417684:	d0fa      	beq.n	41767c <__ssprint_r+0xa0>
  417686:	42ae      	cmp	r6, r5
  417688:	f8d3 9000 	ldr.w	r9, [r3]
  41768c:	46ab      	mov	fp, r5
  41768e:	d2b2      	bcs.n	4175f6 <__ssprint_r+0x1a>
  417690:	4635      	mov	r5, r6
  417692:	46b3      	mov	fp, r6
  417694:	e7e2      	b.n	41765c <__ssprint_r+0x80>
  417696:	4650      	mov	r0, sl
  417698:	f000 f9fc 	bl	417a94 <_realloc_r>
  41769c:	4603      	mov	r3, r0
  41769e:	2800      	cmp	r0, #0
  4176a0:	d1d2      	bne.n	417648 <__ssprint_r+0x6c>
  4176a2:	6921      	ldr	r1, [r4, #16]
  4176a4:	4650      	mov	r0, sl
  4176a6:	f000 f8f9 	bl	41789c <_free_r>
  4176aa:	230c      	movs	r3, #12
  4176ac:	f8ca 3000 	str.w	r3, [sl]
  4176b0:	89a3      	ldrh	r3, [r4, #12]
  4176b2:	2200      	movs	r2, #0
  4176b4:	f043 0340 	orr.w	r3, r3, #64	; 0x40
  4176b8:	f04f 30ff 	mov.w	r0, #4294967295
  4176bc:	81a3      	strh	r3, [r4, #12]
  4176be:	f8c8 2008 	str.w	r2, [r8, #8]
  4176c2:	f8c8 2004 	str.w	r2, [r8, #4]
  4176c6:	b003      	add	sp, #12
  4176c8:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  4176cc:	2000      	movs	r0, #0
  4176ce:	f8c8 0004 	str.w	r0, [r8, #4]
  4176d2:	b003      	add	sp, #12
  4176d4:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}

004176d8 <__register_exitproc>:
  4176d8:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
  4176dc:	4d2c      	ldr	r5, [pc, #176]	; (417790 <__register_exitproc+0xb8>)
  4176de:	4606      	mov	r6, r0
  4176e0:	6828      	ldr	r0, [r5, #0]
  4176e2:	4698      	mov	r8, r3
  4176e4:	460f      	mov	r7, r1
  4176e6:	4691      	mov	r9, r2
  4176e8:	f7ff f8cc 	bl	416884 <__retarget_lock_acquire_recursive>
  4176ec:	4b29      	ldr	r3, [pc, #164]	; (417794 <__register_exitproc+0xbc>)
  4176ee:	681c      	ldr	r4, [r3, #0]
  4176f0:	f8d4 3148 	ldr.w	r3, [r4, #328]	; 0x148
  4176f4:	2b00      	cmp	r3, #0
  4176f6:	d03e      	beq.n	417776 <__register_exitproc+0x9e>
  4176f8:	685a      	ldr	r2, [r3, #4]
  4176fa:	2a1f      	cmp	r2, #31
  4176fc:	dc1c      	bgt.n	417738 <__register_exitproc+0x60>
  4176fe:	f102 0e01 	add.w	lr, r2, #1
  417702:	b176      	cbz	r6, 417722 <__register_exitproc+0x4a>
  417704:	eb03 0182 	add.w	r1, r3, r2, lsl #2
  417708:	2401      	movs	r4, #1
  41770a:	f8c1 9088 	str.w	r9, [r1, #136]	; 0x88
  41770e:	f8d3 0188 	ldr.w	r0, [r3, #392]	; 0x188
  417712:	4094      	lsls	r4, r2
  417714:	4320      	orrs	r0, r4
  417716:	2e02      	cmp	r6, #2
  417718:	f8c3 0188 	str.w	r0, [r3, #392]	; 0x188
  41771c:	f8c1 8108 	str.w	r8, [r1, #264]	; 0x108
  417720:	d023      	beq.n	41776a <__register_exitproc+0x92>
  417722:	3202      	adds	r2, #2
  417724:	f8c3 e004 	str.w	lr, [r3, #4]
  417728:	6828      	ldr	r0, [r5, #0]
  41772a:	f843 7022 	str.w	r7, [r3, r2, lsl #2]
  41772e:	f7ff f8ab 	bl	416888 <__retarget_lock_release_recursive>
  417732:	2000      	movs	r0, #0
  417734:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
  417738:	4b17      	ldr	r3, [pc, #92]	; (417798 <__register_exitproc+0xc0>)
  41773a:	b30b      	cbz	r3, 417780 <__register_exitproc+0xa8>
  41773c:	f44f 70c8 	mov.w	r0, #400	; 0x190
  417740:	f3af 8000 	nop.w
  417744:	4603      	mov	r3, r0
  417746:	b1d8      	cbz	r0, 417780 <__register_exitproc+0xa8>
  417748:	f8d4 2148 	ldr.w	r2, [r4, #328]	; 0x148
  41774c:	6002      	str	r2, [r0, #0]
  41774e:	2100      	movs	r1, #0
  417750:	6041      	str	r1, [r0, #4]
  417752:	460a      	mov	r2, r1
  417754:	f8c4 0148 	str.w	r0, [r4, #328]	; 0x148
  417758:	f04f 0e01 	mov.w	lr, #1
  41775c:	f8c0 1188 	str.w	r1, [r0, #392]	; 0x188
  417760:	f8c0 118c 	str.w	r1, [r0, #396]	; 0x18c
  417764:	2e00      	cmp	r6, #0
  417766:	d0dc      	beq.n	417722 <__register_exitproc+0x4a>
  417768:	e7cc      	b.n	417704 <__register_exitproc+0x2c>
  41776a:	f8d3 118c 	ldr.w	r1, [r3, #396]	; 0x18c
  41776e:	430c      	orrs	r4, r1
  417770:	f8c3 418c 	str.w	r4, [r3, #396]	; 0x18c
  417774:	e7d5      	b.n	417722 <__register_exitproc+0x4a>
  417776:	f504 73a6 	add.w	r3, r4, #332	; 0x14c
  41777a:	f8c4 3148 	str.w	r3, [r4, #328]	; 0x148
  41777e:	e7bb      	b.n	4176f8 <__register_exitproc+0x20>
  417780:	6828      	ldr	r0, [r5, #0]
  417782:	f7ff f881 	bl	416888 <__retarget_lock_release_recursive>
  417786:	f04f 30ff 	mov.w	r0, #4294967295
  41778a:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
  41778e:	bf00      	nop
  417790:	20000788 	.word	0x20000788
  417794:	0041d624 	.word	0x0041d624
  417798:	00000000 	.word	0x00000000

0041779c <_calloc_r>:
  41779c:	b510      	push	{r4, lr}
  41779e:	fb02 f101 	mul.w	r1, r2, r1
  4177a2:	f7ff f873 	bl	41688c <_malloc_r>
  4177a6:	4604      	mov	r4, r0
  4177a8:	b1d8      	cbz	r0, 4177e2 <_calloc_r+0x46>
  4177aa:	f850 2c04 	ldr.w	r2, [r0, #-4]
  4177ae:	f022 0203 	bic.w	r2, r2, #3
  4177b2:	3a04      	subs	r2, #4
  4177b4:	2a24      	cmp	r2, #36	; 0x24
  4177b6:	d818      	bhi.n	4177ea <_calloc_r+0x4e>
  4177b8:	2a13      	cmp	r2, #19
  4177ba:	d914      	bls.n	4177e6 <_calloc_r+0x4a>
  4177bc:	2300      	movs	r3, #0
  4177be:	2a1b      	cmp	r2, #27
  4177c0:	6003      	str	r3, [r0, #0]
  4177c2:	6043      	str	r3, [r0, #4]
  4177c4:	d916      	bls.n	4177f4 <_calloc_r+0x58>
  4177c6:	2a24      	cmp	r2, #36	; 0x24
  4177c8:	6083      	str	r3, [r0, #8]
  4177ca:	60c3      	str	r3, [r0, #12]
  4177cc:	bf11      	iteee	ne
  4177ce:	f100 0210 	addne.w	r2, r0, #16
  4177d2:	6103      	streq	r3, [r0, #16]
  4177d4:	6143      	streq	r3, [r0, #20]
  4177d6:	f100 0218 	addeq.w	r2, r0, #24
  4177da:	2300      	movs	r3, #0
  4177dc:	6013      	str	r3, [r2, #0]
  4177de:	6053      	str	r3, [r2, #4]
  4177e0:	6093      	str	r3, [r2, #8]
  4177e2:	4620      	mov	r0, r4
  4177e4:	bd10      	pop	{r4, pc}
  4177e6:	4602      	mov	r2, r0
  4177e8:	e7f7      	b.n	4177da <_calloc_r+0x3e>
  4177ea:	2100      	movs	r1, #0
  4177ec:	f7fc fd28 	bl	414240 <memset>
  4177f0:	4620      	mov	r0, r4
  4177f2:	bd10      	pop	{r4, pc}
  4177f4:	f100 0208 	add.w	r2, r0, #8
  4177f8:	e7ef      	b.n	4177da <_calloc_r+0x3e>
  4177fa:	bf00      	nop

004177fc <_malloc_trim_r>:
  4177fc:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  4177fe:	4f24      	ldr	r7, [pc, #144]	; (417890 <_malloc_trim_r+0x94>)
  417800:	460c      	mov	r4, r1
  417802:	4606      	mov	r6, r0
  417804:	f7ff fb44 	bl	416e90 <__malloc_lock>
  417808:	68bb      	ldr	r3, [r7, #8]
  41780a:	685d      	ldr	r5, [r3, #4]
  41780c:	f5c4 617e 	rsb	r1, r4, #4064	; 0xfe0
  417810:	310f      	adds	r1, #15
  417812:	f025 0503 	bic.w	r5, r5, #3
  417816:	4429      	add	r1, r5
  417818:	f421 617f 	bic.w	r1, r1, #4080	; 0xff0
  41781c:	f021 010f 	bic.w	r1, r1, #15
  417820:	f5a1 5480 	sub.w	r4, r1, #4096	; 0x1000
  417824:	f5b4 5f80 	cmp.w	r4, #4096	; 0x1000
  417828:	db07      	blt.n	41783a <_malloc_trim_r+0x3e>
  41782a:	2100      	movs	r1, #0
  41782c:	4630      	mov	r0, r6
  41782e:	f7ff fe37 	bl	4174a0 <_sbrk_r>
  417832:	68bb      	ldr	r3, [r7, #8]
  417834:	442b      	add	r3, r5
  417836:	4298      	cmp	r0, r3
  417838:	d004      	beq.n	417844 <_malloc_trim_r+0x48>
  41783a:	4630      	mov	r0, r6
  41783c:	f7ff fb2e 	bl	416e9c <__malloc_unlock>
  417840:	2000      	movs	r0, #0
  417842:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  417844:	4261      	negs	r1, r4
  417846:	4630      	mov	r0, r6
  417848:	f7ff fe2a 	bl	4174a0 <_sbrk_r>
  41784c:	3001      	adds	r0, #1
  41784e:	d00d      	beq.n	41786c <_malloc_trim_r+0x70>
  417850:	4b10      	ldr	r3, [pc, #64]	; (417894 <_malloc_trim_r+0x98>)
  417852:	68ba      	ldr	r2, [r7, #8]
  417854:	6819      	ldr	r1, [r3, #0]
  417856:	1b2d      	subs	r5, r5, r4
  417858:	f045 0501 	orr.w	r5, r5, #1
  41785c:	4630      	mov	r0, r6
  41785e:	1b09      	subs	r1, r1, r4
  417860:	6055      	str	r5, [r2, #4]
  417862:	6019      	str	r1, [r3, #0]
  417864:	f7ff fb1a 	bl	416e9c <__malloc_unlock>
  417868:	2001      	movs	r0, #1
  41786a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  41786c:	2100      	movs	r1, #0
  41786e:	4630      	mov	r0, r6
  417870:	f7ff fe16 	bl	4174a0 <_sbrk_r>
  417874:	68ba      	ldr	r2, [r7, #8]
  417876:	1a83      	subs	r3, r0, r2
  417878:	2b0f      	cmp	r3, #15
  41787a:	ddde      	ble.n	41783a <_malloc_trim_r+0x3e>
  41787c:	4c06      	ldr	r4, [pc, #24]	; (417898 <_malloc_trim_r+0x9c>)
  41787e:	4905      	ldr	r1, [pc, #20]	; (417894 <_malloc_trim_r+0x98>)
  417880:	6824      	ldr	r4, [r4, #0]
  417882:	f043 0301 	orr.w	r3, r3, #1
  417886:	1b00      	subs	r0, r0, r4
  417888:	6053      	str	r3, [r2, #4]
  41788a:	6008      	str	r0, [r1, #0]
  41788c:	e7d5      	b.n	41783a <_malloc_trim_r+0x3e>
  41788e:	bf00      	nop
  417890:	2000078c 	.word	0x2000078c
  417894:	20001848 	.word	0x20001848
  417898:	20000b94 	.word	0x20000b94

0041789c <_free_r>:
  41789c:	2900      	cmp	r1, #0
  41789e:	d044      	beq.n	41792a <_free_r+0x8e>
  4178a0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  4178a4:	460d      	mov	r5, r1
  4178a6:	4680      	mov	r8, r0
  4178a8:	f7ff faf2 	bl	416e90 <__malloc_lock>
  4178ac:	f855 7c04 	ldr.w	r7, [r5, #-4]
  4178b0:	4969      	ldr	r1, [pc, #420]	; (417a58 <_free_r+0x1bc>)
  4178b2:	f027 0301 	bic.w	r3, r7, #1
  4178b6:	f1a5 0408 	sub.w	r4, r5, #8
  4178ba:	18e2      	adds	r2, r4, r3
  4178bc:	688e      	ldr	r6, [r1, #8]
  4178be:	6850      	ldr	r0, [r2, #4]
  4178c0:	42b2      	cmp	r2, r6
  4178c2:	f020 0003 	bic.w	r0, r0, #3
  4178c6:	d05e      	beq.n	417986 <_free_r+0xea>
  4178c8:	07fe      	lsls	r6, r7, #31
  4178ca:	6050      	str	r0, [r2, #4]
  4178cc:	d40b      	bmi.n	4178e6 <_free_r+0x4a>
  4178ce:	f855 7c08 	ldr.w	r7, [r5, #-8]
  4178d2:	1be4      	subs	r4, r4, r7
  4178d4:	f101 0e08 	add.w	lr, r1, #8
  4178d8:	68a5      	ldr	r5, [r4, #8]
  4178da:	4575      	cmp	r5, lr
  4178dc:	443b      	add	r3, r7
  4178de:	d06d      	beq.n	4179bc <_free_r+0x120>
  4178e0:	68e7      	ldr	r7, [r4, #12]
  4178e2:	60ef      	str	r7, [r5, #12]
  4178e4:	60bd      	str	r5, [r7, #8]
  4178e6:	1815      	adds	r5, r2, r0
  4178e8:	686d      	ldr	r5, [r5, #4]
  4178ea:	07ed      	lsls	r5, r5, #31
  4178ec:	d53e      	bpl.n	41796c <_free_r+0xd0>
  4178ee:	f043 0201 	orr.w	r2, r3, #1
  4178f2:	6062      	str	r2, [r4, #4]
  4178f4:	50e3      	str	r3, [r4, r3]
  4178f6:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
  4178fa:	d217      	bcs.n	41792c <_free_r+0x90>
  4178fc:	08db      	lsrs	r3, r3, #3
  4178fe:	1c58      	adds	r0, r3, #1
  417900:	109a      	asrs	r2, r3, #2
  417902:	684d      	ldr	r5, [r1, #4]
  417904:	f851 7030 	ldr.w	r7, [r1, r0, lsl #3]
  417908:	60a7      	str	r7, [r4, #8]
  41790a:	2301      	movs	r3, #1
  41790c:	4093      	lsls	r3, r2
  41790e:	eb01 02c0 	add.w	r2, r1, r0, lsl #3
  417912:	432b      	orrs	r3, r5
  417914:	3a08      	subs	r2, #8
  417916:	60e2      	str	r2, [r4, #12]
  417918:	604b      	str	r3, [r1, #4]
  41791a:	f841 4030 	str.w	r4, [r1, r0, lsl #3]
  41791e:	60fc      	str	r4, [r7, #12]
  417920:	4640      	mov	r0, r8
  417922:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
  417926:	f7ff bab9 	b.w	416e9c <__malloc_unlock>
  41792a:	4770      	bx	lr
  41792c:	0a5a      	lsrs	r2, r3, #9
  41792e:	2a04      	cmp	r2, #4
  417930:	d852      	bhi.n	4179d8 <_free_r+0x13c>
  417932:	099a      	lsrs	r2, r3, #6
  417934:	f102 0739 	add.w	r7, r2, #57	; 0x39
  417938:	00ff      	lsls	r7, r7, #3
  41793a:	f102 0538 	add.w	r5, r2, #56	; 0x38
  41793e:	19c8      	adds	r0, r1, r7
  417940:	59ca      	ldr	r2, [r1, r7]
  417942:	3808      	subs	r0, #8
  417944:	4290      	cmp	r0, r2
  417946:	d04f      	beq.n	4179e8 <_free_r+0x14c>
  417948:	6851      	ldr	r1, [r2, #4]
  41794a:	f021 0103 	bic.w	r1, r1, #3
  41794e:	428b      	cmp	r3, r1
  417950:	d232      	bcs.n	4179b8 <_free_r+0x11c>
  417952:	6892      	ldr	r2, [r2, #8]
  417954:	4290      	cmp	r0, r2
  417956:	d1f7      	bne.n	417948 <_free_r+0xac>
  417958:	68c3      	ldr	r3, [r0, #12]
  41795a:	60a0      	str	r0, [r4, #8]
  41795c:	60e3      	str	r3, [r4, #12]
  41795e:	609c      	str	r4, [r3, #8]
  417960:	60c4      	str	r4, [r0, #12]
  417962:	4640      	mov	r0, r8
  417964:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
  417968:	f7ff ba98 	b.w	416e9c <__malloc_unlock>
  41796c:	6895      	ldr	r5, [r2, #8]
  41796e:	4f3b      	ldr	r7, [pc, #236]	; (417a5c <_free_r+0x1c0>)
  417970:	42bd      	cmp	r5, r7
  417972:	4403      	add	r3, r0
  417974:	d040      	beq.n	4179f8 <_free_r+0x15c>
  417976:	68d0      	ldr	r0, [r2, #12]
  417978:	60e8      	str	r0, [r5, #12]
  41797a:	f043 0201 	orr.w	r2, r3, #1
  41797e:	6085      	str	r5, [r0, #8]
  417980:	6062      	str	r2, [r4, #4]
  417982:	50e3      	str	r3, [r4, r3]
  417984:	e7b7      	b.n	4178f6 <_free_r+0x5a>
  417986:	07ff      	lsls	r7, r7, #31
  417988:	4403      	add	r3, r0
  41798a:	d407      	bmi.n	41799c <_free_r+0x100>
  41798c:	f855 2c08 	ldr.w	r2, [r5, #-8]
  417990:	1aa4      	subs	r4, r4, r2
  417992:	4413      	add	r3, r2
  417994:	68a0      	ldr	r0, [r4, #8]
  417996:	68e2      	ldr	r2, [r4, #12]
  417998:	60c2      	str	r2, [r0, #12]
  41799a:	6090      	str	r0, [r2, #8]
  41799c:	4a30      	ldr	r2, [pc, #192]	; (417a60 <_free_r+0x1c4>)
  41799e:	6812      	ldr	r2, [r2, #0]
  4179a0:	f043 0001 	orr.w	r0, r3, #1
  4179a4:	4293      	cmp	r3, r2
  4179a6:	6060      	str	r0, [r4, #4]
  4179a8:	608c      	str	r4, [r1, #8]
  4179aa:	d3b9      	bcc.n	417920 <_free_r+0x84>
  4179ac:	4b2d      	ldr	r3, [pc, #180]	; (417a64 <_free_r+0x1c8>)
  4179ae:	4640      	mov	r0, r8
  4179b0:	6819      	ldr	r1, [r3, #0]
  4179b2:	f7ff ff23 	bl	4177fc <_malloc_trim_r>
  4179b6:	e7b3      	b.n	417920 <_free_r+0x84>
  4179b8:	4610      	mov	r0, r2
  4179ba:	e7cd      	b.n	417958 <_free_r+0xbc>
  4179bc:	1811      	adds	r1, r2, r0
  4179be:	6849      	ldr	r1, [r1, #4]
  4179c0:	07c9      	lsls	r1, r1, #31
  4179c2:	d444      	bmi.n	417a4e <_free_r+0x1b2>
  4179c4:	6891      	ldr	r1, [r2, #8]
  4179c6:	68d2      	ldr	r2, [r2, #12]
  4179c8:	60ca      	str	r2, [r1, #12]
  4179ca:	4403      	add	r3, r0
  4179cc:	f043 0001 	orr.w	r0, r3, #1
  4179d0:	6091      	str	r1, [r2, #8]
  4179d2:	6060      	str	r0, [r4, #4]
  4179d4:	50e3      	str	r3, [r4, r3]
  4179d6:	e7a3      	b.n	417920 <_free_r+0x84>
  4179d8:	2a14      	cmp	r2, #20
  4179da:	d816      	bhi.n	417a0a <_free_r+0x16e>
  4179dc:	f102 075c 	add.w	r7, r2, #92	; 0x5c
  4179e0:	00ff      	lsls	r7, r7, #3
  4179e2:	f102 055b 	add.w	r5, r2, #91	; 0x5b
  4179e6:	e7aa      	b.n	41793e <_free_r+0xa2>
  4179e8:	10aa      	asrs	r2, r5, #2
  4179ea:	2301      	movs	r3, #1
  4179ec:	684d      	ldr	r5, [r1, #4]
  4179ee:	4093      	lsls	r3, r2
  4179f0:	432b      	orrs	r3, r5
  4179f2:	604b      	str	r3, [r1, #4]
  4179f4:	4603      	mov	r3, r0
  4179f6:	e7b0      	b.n	41795a <_free_r+0xbe>
  4179f8:	f043 0201 	orr.w	r2, r3, #1
  4179fc:	614c      	str	r4, [r1, #20]
  4179fe:	610c      	str	r4, [r1, #16]
  417a00:	60e5      	str	r5, [r4, #12]
  417a02:	60a5      	str	r5, [r4, #8]
  417a04:	6062      	str	r2, [r4, #4]
  417a06:	50e3      	str	r3, [r4, r3]
  417a08:	e78a      	b.n	417920 <_free_r+0x84>
  417a0a:	2a54      	cmp	r2, #84	; 0x54
  417a0c:	d806      	bhi.n	417a1c <_free_r+0x180>
  417a0e:	0b1a      	lsrs	r2, r3, #12
  417a10:	f102 076f 	add.w	r7, r2, #111	; 0x6f
  417a14:	00ff      	lsls	r7, r7, #3
  417a16:	f102 056e 	add.w	r5, r2, #110	; 0x6e
  417a1a:	e790      	b.n	41793e <_free_r+0xa2>
  417a1c:	f5b2 7faa 	cmp.w	r2, #340	; 0x154
  417a20:	d806      	bhi.n	417a30 <_free_r+0x194>
  417a22:	0bda      	lsrs	r2, r3, #15
  417a24:	f102 0778 	add.w	r7, r2, #120	; 0x78
  417a28:	00ff      	lsls	r7, r7, #3
  417a2a:	f102 0577 	add.w	r5, r2, #119	; 0x77
  417a2e:	e786      	b.n	41793e <_free_r+0xa2>
  417a30:	f240 5054 	movw	r0, #1364	; 0x554
  417a34:	4282      	cmp	r2, r0
  417a36:	d806      	bhi.n	417a46 <_free_r+0x1aa>
  417a38:	0c9a      	lsrs	r2, r3, #18
  417a3a:	f102 077d 	add.w	r7, r2, #125	; 0x7d
  417a3e:	00ff      	lsls	r7, r7, #3
  417a40:	f102 057c 	add.w	r5, r2, #124	; 0x7c
  417a44:	e77b      	b.n	41793e <_free_r+0xa2>
  417a46:	f44f 777e 	mov.w	r7, #1016	; 0x3f8
  417a4a:	257e      	movs	r5, #126	; 0x7e
  417a4c:	e777      	b.n	41793e <_free_r+0xa2>
  417a4e:	f043 0101 	orr.w	r1, r3, #1
  417a52:	6061      	str	r1, [r4, #4]
  417a54:	6013      	str	r3, [r2, #0]
  417a56:	e763      	b.n	417920 <_free_r+0x84>
  417a58:	2000078c 	.word	0x2000078c
  417a5c:	20000794 	.word	0x20000794
  417a60:	20000b98 	.word	0x20000b98
  417a64:	20001878 	.word	0x20001878

00417a68 <__ascii_mbtowc>:
  417a68:	b082      	sub	sp, #8
  417a6a:	b149      	cbz	r1, 417a80 <__ascii_mbtowc+0x18>
  417a6c:	b15a      	cbz	r2, 417a86 <__ascii_mbtowc+0x1e>
  417a6e:	b16b      	cbz	r3, 417a8c <__ascii_mbtowc+0x24>
  417a70:	7813      	ldrb	r3, [r2, #0]
  417a72:	600b      	str	r3, [r1, #0]
  417a74:	7812      	ldrb	r2, [r2, #0]
  417a76:	1c10      	adds	r0, r2, #0
  417a78:	bf18      	it	ne
  417a7a:	2001      	movne	r0, #1
  417a7c:	b002      	add	sp, #8
  417a7e:	4770      	bx	lr
  417a80:	a901      	add	r1, sp, #4
  417a82:	2a00      	cmp	r2, #0
  417a84:	d1f3      	bne.n	417a6e <__ascii_mbtowc+0x6>
  417a86:	4610      	mov	r0, r2
  417a88:	b002      	add	sp, #8
  417a8a:	4770      	bx	lr
  417a8c:	f06f 0001 	mvn.w	r0, #1
  417a90:	e7f4      	b.n	417a7c <__ascii_mbtowc+0x14>
  417a92:	bf00      	nop

00417a94 <_realloc_r>:
  417a94:	2900      	cmp	r1, #0
  417a96:	f000 8095 	beq.w	417bc4 <_realloc_r+0x130>
  417a9a:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  417a9e:	460d      	mov	r5, r1
  417aa0:	4616      	mov	r6, r2
  417aa2:	b083      	sub	sp, #12
  417aa4:	4680      	mov	r8, r0
  417aa6:	f106 070b 	add.w	r7, r6, #11
  417aaa:	f7ff f9f1 	bl	416e90 <__malloc_lock>
  417aae:	f855 ec04 	ldr.w	lr, [r5, #-4]
  417ab2:	2f16      	cmp	r7, #22
  417ab4:	f02e 0403 	bic.w	r4, lr, #3
  417ab8:	f1a5 0908 	sub.w	r9, r5, #8
  417abc:	d83c      	bhi.n	417b38 <_realloc_r+0xa4>
  417abe:	2210      	movs	r2, #16
  417ac0:	4617      	mov	r7, r2
  417ac2:	42be      	cmp	r6, r7
  417ac4:	d83d      	bhi.n	417b42 <_realloc_r+0xae>
  417ac6:	4294      	cmp	r4, r2
  417ac8:	da43      	bge.n	417b52 <_realloc_r+0xbe>
  417aca:	4bc4      	ldr	r3, [pc, #784]	; (417ddc <_realloc_r+0x348>)
  417acc:	6899      	ldr	r1, [r3, #8]
  417ace:	eb09 0004 	add.w	r0, r9, r4
  417ad2:	4288      	cmp	r0, r1
  417ad4:	f000 80b4 	beq.w	417c40 <_realloc_r+0x1ac>
  417ad8:	6843      	ldr	r3, [r0, #4]
  417ada:	f023 0101 	bic.w	r1, r3, #1
  417ade:	4401      	add	r1, r0
  417ae0:	6849      	ldr	r1, [r1, #4]
  417ae2:	07c9      	lsls	r1, r1, #31
  417ae4:	d54c      	bpl.n	417b80 <_realloc_r+0xec>
  417ae6:	f01e 0f01 	tst.w	lr, #1
  417aea:	f000 809b 	beq.w	417c24 <_realloc_r+0x190>
  417aee:	4631      	mov	r1, r6
  417af0:	4640      	mov	r0, r8
  417af2:	f7fe fecb 	bl	41688c <_malloc_r>
  417af6:	4606      	mov	r6, r0
  417af8:	2800      	cmp	r0, #0
  417afa:	d03a      	beq.n	417b72 <_realloc_r+0xde>
  417afc:	f855 3c04 	ldr.w	r3, [r5, #-4]
  417b00:	f023 0301 	bic.w	r3, r3, #1
  417b04:	444b      	add	r3, r9
  417b06:	f1a0 0208 	sub.w	r2, r0, #8
  417b0a:	429a      	cmp	r2, r3
  417b0c:	f000 8121 	beq.w	417d52 <_realloc_r+0x2be>
  417b10:	1f22      	subs	r2, r4, #4
  417b12:	2a24      	cmp	r2, #36	; 0x24
  417b14:	f200 8107 	bhi.w	417d26 <_realloc_r+0x292>
  417b18:	2a13      	cmp	r2, #19
  417b1a:	f200 80db 	bhi.w	417cd4 <_realloc_r+0x240>
  417b1e:	4603      	mov	r3, r0
  417b20:	462a      	mov	r2, r5
  417b22:	6811      	ldr	r1, [r2, #0]
  417b24:	6019      	str	r1, [r3, #0]
  417b26:	6851      	ldr	r1, [r2, #4]
  417b28:	6059      	str	r1, [r3, #4]
  417b2a:	6892      	ldr	r2, [r2, #8]
  417b2c:	609a      	str	r2, [r3, #8]
  417b2e:	4629      	mov	r1, r5
  417b30:	4640      	mov	r0, r8
  417b32:	f7ff feb3 	bl	41789c <_free_r>
  417b36:	e01c      	b.n	417b72 <_realloc_r+0xde>
  417b38:	f027 0707 	bic.w	r7, r7, #7
  417b3c:	2f00      	cmp	r7, #0
  417b3e:	463a      	mov	r2, r7
  417b40:	dabf      	bge.n	417ac2 <_realloc_r+0x2e>
  417b42:	2600      	movs	r6, #0
  417b44:	230c      	movs	r3, #12
  417b46:	4630      	mov	r0, r6
  417b48:	f8c8 3000 	str.w	r3, [r8]
  417b4c:	b003      	add	sp, #12
  417b4e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  417b52:	462e      	mov	r6, r5
  417b54:	1be3      	subs	r3, r4, r7
  417b56:	2b0f      	cmp	r3, #15
  417b58:	d81e      	bhi.n	417b98 <_realloc_r+0x104>
  417b5a:	f8d9 3004 	ldr.w	r3, [r9, #4]
  417b5e:	f003 0301 	and.w	r3, r3, #1
  417b62:	4323      	orrs	r3, r4
  417b64:	444c      	add	r4, r9
  417b66:	f8c9 3004 	str.w	r3, [r9, #4]
  417b6a:	6863      	ldr	r3, [r4, #4]
  417b6c:	f043 0301 	orr.w	r3, r3, #1
  417b70:	6063      	str	r3, [r4, #4]
  417b72:	4640      	mov	r0, r8
  417b74:	f7ff f992 	bl	416e9c <__malloc_unlock>
  417b78:	4630      	mov	r0, r6
  417b7a:	b003      	add	sp, #12
  417b7c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  417b80:	f023 0303 	bic.w	r3, r3, #3
  417b84:	18e1      	adds	r1, r4, r3
  417b86:	4291      	cmp	r1, r2
  417b88:	db1f      	blt.n	417bca <_realloc_r+0x136>
  417b8a:	68c3      	ldr	r3, [r0, #12]
  417b8c:	6882      	ldr	r2, [r0, #8]
  417b8e:	462e      	mov	r6, r5
  417b90:	60d3      	str	r3, [r2, #12]
  417b92:	460c      	mov	r4, r1
  417b94:	609a      	str	r2, [r3, #8]
  417b96:	e7dd      	b.n	417b54 <_realloc_r+0xc0>
  417b98:	f8d9 2004 	ldr.w	r2, [r9, #4]
  417b9c:	eb09 0107 	add.w	r1, r9, r7
  417ba0:	f002 0201 	and.w	r2, r2, #1
  417ba4:	444c      	add	r4, r9
  417ba6:	f043 0301 	orr.w	r3, r3, #1
  417baa:	4317      	orrs	r7, r2
  417bac:	f8c9 7004 	str.w	r7, [r9, #4]
  417bb0:	604b      	str	r3, [r1, #4]
  417bb2:	6863      	ldr	r3, [r4, #4]
  417bb4:	f043 0301 	orr.w	r3, r3, #1
  417bb8:	3108      	adds	r1, #8
  417bba:	6063      	str	r3, [r4, #4]
  417bbc:	4640      	mov	r0, r8
  417bbe:	f7ff fe6d 	bl	41789c <_free_r>
  417bc2:	e7d6      	b.n	417b72 <_realloc_r+0xde>
  417bc4:	4611      	mov	r1, r2
  417bc6:	f7fe be61 	b.w	41688c <_malloc_r>
  417bca:	f01e 0f01 	tst.w	lr, #1
  417bce:	d18e      	bne.n	417aee <_realloc_r+0x5a>
  417bd0:	f855 1c08 	ldr.w	r1, [r5, #-8]
  417bd4:	eba9 0a01 	sub.w	sl, r9, r1
  417bd8:	f8da 1004 	ldr.w	r1, [sl, #4]
  417bdc:	f021 0103 	bic.w	r1, r1, #3
  417be0:	440b      	add	r3, r1
  417be2:	4423      	add	r3, r4
  417be4:	4293      	cmp	r3, r2
  417be6:	db25      	blt.n	417c34 <_realloc_r+0x1a0>
  417be8:	68c2      	ldr	r2, [r0, #12]
  417bea:	6881      	ldr	r1, [r0, #8]
  417bec:	4656      	mov	r6, sl
  417bee:	60ca      	str	r2, [r1, #12]
  417bf0:	6091      	str	r1, [r2, #8]
  417bf2:	f8da 100c 	ldr.w	r1, [sl, #12]
  417bf6:	f856 0f08 	ldr.w	r0, [r6, #8]!
  417bfa:	1f22      	subs	r2, r4, #4
  417bfc:	2a24      	cmp	r2, #36	; 0x24
  417bfe:	60c1      	str	r1, [r0, #12]
  417c00:	6088      	str	r0, [r1, #8]
  417c02:	f200 8094 	bhi.w	417d2e <_realloc_r+0x29a>
  417c06:	2a13      	cmp	r2, #19
  417c08:	d96f      	bls.n	417cea <_realloc_r+0x256>
  417c0a:	6829      	ldr	r1, [r5, #0]
  417c0c:	f8ca 1008 	str.w	r1, [sl, #8]
  417c10:	6869      	ldr	r1, [r5, #4]
  417c12:	f8ca 100c 	str.w	r1, [sl, #12]
  417c16:	2a1b      	cmp	r2, #27
  417c18:	f200 80a2 	bhi.w	417d60 <_realloc_r+0x2cc>
  417c1c:	3508      	adds	r5, #8
  417c1e:	f10a 0210 	add.w	r2, sl, #16
  417c22:	e063      	b.n	417cec <_realloc_r+0x258>
  417c24:	f855 3c08 	ldr.w	r3, [r5, #-8]
  417c28:	eba9 0a03 	sub.w	sl, r9, r3
  417c2c:	f8da 1004 	ldr.w	r1, [sl, #4]
  417c30:	f021 0103 	bic.w	r1, r1, #3
  417c34:	1863      	adds	r3, r4, r1
  417c36:	4293      	cmp	r3, r2
  417c38:	f6ff af59 	blt.w	417aee <_realloc_r+0x5a>
  417c3c:	4656      	mov	r6, sl
  417c3e:	e7d8      	b.n	417bf2 <_realloc_r+0x15e>
  417c40:	6841      	ldr	r1, [r0, #4]
  417c42:	f021 0b03 	bic.w	fp, r1, #3
  417c46:	44a3      	add	fp, r4
  417c48:	f107 0010 	add.w	r0, r7, #16
  417c4c:	4583      	cmp	fp, r0
  417c4e:	da56      	bge.n	417cfe <_realloc_r+0x26a>
  417c50:	f01e 0f01 	tst.w	lr, #1
  417c54:	f47f af4b 	bne.w	417aee <_realloc_r+0x5a>
  417c58:	f855 1c08 	ldr.w	r1, [r5, #-8]
  417c5c:	eba9 0a01 	sub.w	sl, r9, r1
  417c60:	f8da 1004 	ldr.w	r1, [sl, #4]
  417c64:	f021 0103 	bic.w	r1, r1, #3
  417c68:	448b      	add	fp, r1
  417c6a:	4558      	cmp	r0, fp
  417c6c:	dce2      	bgt.n	417c34 <_realloc_r+0x1a0>
  417c6e:	4656      	mov	r6, sl
  417c70:	f8da 100c 	ldr.w	r1, [sl, #12]
  417c74:	f856 0f08 	ldr.w	r0, [r6, #8]!
  417c78:	1f22      	subs	r2, r4, #4
  417c7a:	2a24      	cmp	r2, #36	; 0x24
  417c7c:	60c1      	str	r1, [r0, #12]
  417c7e:	6088      	str	r0, [r1, #8]
  417c80:	f200 808f 	bhi.w	417da2 <_realloc_r+0x30e>
  417c84:	2a13      	cmp	r2, #19
  417c86:	f240 808a 	bls.w	417d9e <_realloc_r+0x30a>
  417c8a:	6829      	ldr	r1, [r5, #0]
  417c8c:	f8ca 1008 	str.w	r1, [sl, #8]
  417c90:	6869      	ldr	r1, [r5, #4]
  417c92:	f8ca 100c 	str.w	r1, [sl, #12]
  417c96:	2a1b      	cmp	r2, #27
  417c98:	f200 808a 	bhi.w	417db0 <_realloc_r+0x31c>
  417c9c:	3508      	adds	r5, #8
  417c9e:	f10a 0210 	add.w	r2, sl, #16
  417ca2:	6829      	ldr	r1, [r5, #0]
  417ca4:	6011      	str	r1, [r2, #0]
  417ca6:	6869      	ldr	r1, [r5, #4]
  417ca8:	6051      	str	r1, [r2, #4]
  417caa:	68a9      	ldr	r1, [r5, #8]
  417cac:	6091      	str	r1, [r2, #8]
  417cae:	eb0a 0107 	add.w	r1, sl, r7
  417cb2:	ebab 0207 	sub.w	r2, fp, r7
  417cb6:	f042 0201 	orr.w	r2, r2, #1
  417cba:	6099      	str	r1, [r3, #8]
  417cbc:	604a      	str	r2, [r1, #4]
  417cbe:	f8da 3004 	ldr.w	r3, [sl, #4]
  417cc2:	f003 0301 	and.w	r3, r3, #1
  417cc6:	431f      	orrs	r7, r3
  417cc8:	4640      	mov	r0, r8
  417cca:	f8ca 7004 	str.w	r7, [sl, #4]
  417cce:	f7ff f8e5 	bl	416e9c <__malloc_unlock>
  417cd2:	e751      	b.n	417b78 <_realloc_r+0xe4>
  417cd4:	682b      	ldr	r3, [r5, #0]
  417cd6:	6003      	str	r3, [r0, #0]
  417cd8:	686b      	ldr	r3, [r5, #4]
  417cda:	6043      	str	r3, [r0, #4]
  417cdc:	2a1b      	cmp	r2, #27
  417cde:	d82d      	bhi.n	417d3c <_realloc_r+0x2a8>
  417ce0:	f100 0308 	add.w	r3, r0, #8
  417ce4:	f105 0208 	add.w	r2, r5, #8
  417ce8:	e71b      	b.n	417b22 <_realloc_r+0x8e>
  417cea:	4632      	mov	r2, r6
  417cec:	6829      	ldr	r1, [r5, #0]
  417cee:	6011      	str	r1, [r2, #0]
  417cf0:	6869      	ldr	r1, [r5, #4]
  417cf2:	6051      	str	r1, [r2, #4]
  417cf4:	68a9      	ldr	r1, [r5, #8]
  417cf6:	6091      	str	r1, [r2, #8]
  417cf8:	461c      	mov	r4, r3
  417cfa:	46d1      	mov	r9, sl
  417cfc:	e72a      	b.n	417b54 <_realloc_r+0xc0>
  417cfe:	eb09 0107 	add.w	r1, r9, r7
  417d02:	ebab 0b07 	sub.w	fp, fp, r7
  417d06:	f04b 0201 	orr.w	r2, fp, #1
  417d0a:	6099      	str	r1, [r3, #8]
  417d0c:	604a      	str	r2, [r1, #4]
  417d0e:	f855 3c04 	ldr.w	r3, [r5, #-4]
  417d12:	f003 0301 	and.w	r3, r3, #1
  417d16:	431f      	orrs	r7, r3
  417d18:	4640      	mov	r0, r8
  417d1a:	f845 7c04 	str.w	r7, [r5, #-4]
  417d1e:	f7ff f8bd 	bl	416e9c <__malloc_unlock>
  417d22:	462e      	mov	r6, r5
  417d24:	e728      	b.n	417b78 <_realloc_r+0xe4>
  417d26:	4629      	mov	r1, r5
  417d28:	f7fc fa26 	bl	414178 <memmove>
  417d2c:	e6ff      	b.n	417b2e <_realloc_r+0x9a>
  417d2e:	4629      	mov	r1, r5
  417d30:	4630      	mov	r0, r6
  417d32:	461c      	mov	r4, r3
  417d34:	46d1      	mov	r9, sl
  417d36:	f7fc fa1f 	bl	414178 <memmove>
  417d3a:	e70b      	b.n	417b54 <_realloc_r+0xc0>
  417d3c:	68ab      	ldr	r3, [r5, #8]
  417d3e:	6083      	str	r3, [r0, #8]
  417d40:	68eb      	ldr	r3, [r5, #12]
  417d42:	60c3      	str	r3, [r0, #12]
  417d44:	2a24      	cmp	r2, #36	; 0x24
  417d46:	d017      	beq.n	417d78 <_realloc_r+0x2e4>
  417d48:	f100 0310 	add.w	r3, r0, #16
  417d4c:	f105 0210 	add.w	r2, r5, #16
  417d50:	e6e7      	b.n	417b22 <_realloc_r+0x8e>
  417d52:	f850 3c04 	ldr.w	r3, [r0, #-4]
  417d56:	f023 0303 	bic.w	r3, r3, #3
  417d5a:	441c      	add	r4, r3
  417d5c:	462e      	mov	r6, r5
  417d5e:	e6f9      	b.n	417b54 <_realloc_r+0xc0>
  417d60:	68a9      	ldr	r1, [r5, #8]
  417d62:	f8ca 1010 	str.w	r1, [sl, #16]
  417d66:	68e9      	ldr	r1, [r5, #12]
  417d68:	f8ca 1014 	str.w	r1, [sl, #20]
  417d6c:	2a24      	cmp	r2, #36	; 0x24
  417d6e:	d00c      	beq.n	417d8a <_realloc_r+0x2f6>
  417d70:	3510      	adds	r5, #16
  417d72:	f10a 0218 	add.w	r2, sl, #24
  417d76:	e7b9      	b.n	417cec <_realloc_r+0x258>
  417d78:	692b      	ldr	r3, [r5, #16]
  417d7a:	6103      	str	r3, [r0, #16]
  417d7c:	696b      	ldr	r3, [r5, #20]
  417d7e:	6143      	str	r3, [r0, #20]
  417d80:	f105 0218 	add.w	r2, r5, #24
  417d84:	f100 0318 	add.w	r3, r0, #24
  417d88:	e6cb      	b.n	417b22 <_realloc_r+0x8e>
  417d8a:	692a      	ldr	r2, [r5, #16]
  417d8c:	f8ca 2018 	str.w	r2, [sl, #24]
  417d90:	696a      	ldr	r2, [r5, #20]
  417d92:	f8ca 201c 	str.w	r2, [sl, #28]
  417d96:	3518      	adds	r5, #24
  417d98:	f10a 0220 	add.w	r2, sl, #32
  417d9c:	e7a6      	b.n	417cec <_realloc_r+0x258>
  417d9e:	4632      	mov	r2, r6
  417da0:	e77f      	b.n	417ca2 <_realloc_r+0x20e>
  417da2:	4629      	mov	r1, r5
  417da4:	4630      	mov	r0, r6
  417da6:	9301      	str	r3, [sp, #4]
  417da8:	f7fc f9e6 	bl	414178 <memmove>
  417dac:	9b01      	ldr	r3, [sp, #4]
  417dae:	e77e      	b.n	417cae <_realloc_r+0x21a>
  417db0:	68a9      	ldr	r1, [r5, #8]
  417db2:	f8ca 1010 	str.w	r1, [sl, #16]
  417db6:	68e9      	ldr	r1, [r5, #12]
  417db8:	f8ca 1014 	str.w	r1, [sl, #20]
  417dbc:	2a24      	cmp	r2, #36	; 0x24
  417dbe:	d003      	beq.n	417dc8 <_realloc_r+0x334>
  417dc0:	3510      	adds	r5, #16
  417dc2:	f10a 0218 	add.w	r2, sl, #24
  417dc6:	e76c      	b.n	417ca2 <_realloc_r+0x20e>
  417dc8:	692a      	ldr	r2, [r5, #16]
  417dca:	f8ca 2018 	str.w	r2, [sl, #24]
  417dce:	696a      	ldr	r2, [r5, #20]
  417dd0:	f8ca 201c 	str.w	r2, [sl, #28]
  417dd4:	3518      	adds	r5, #24
  417dd6:	f10a 0220 	add.w	r2, sl, #32
  417dda:	e762      	b.n	417ca2 <_realloc_r+0x20e>
  417ddc:	2000078c 	.word	0x2000078c

00417de0 <__ascii_wctomb>:
  417de0:	b121      	cbz	r1, 417dec <__ascii_wctomb+0xc>
  417de2:	2aff      	cmp	r2, #255	; 0xff
  417de4:	d804      	bhi.n	417df0 <__ascii_wctomb+0x10>
  417de6:	700a      	strb	r2, [r1, #0]
  417de8:	2001      	movs	r0, #1
  417dea:	4770      	bx	lr
  417dec:	4608      	mov	r0, r1
  417dee:	4770      	bx	lr
  417df0:	238a      	movs	r3, #138	; 0x8a
  417df2:	6003      	str	r3, [r0, #0]
  417df4:	f04f 30ff 	mov.w	r0, #4294967295
  417df8:	4770      	bx	lr
  417dfa:	bf00      	nop

00417dfc <__gedf2>:
  417dfc:	f04f 3cff 	mov.w	ip, #4294967295
  417e00:	e006      	b.n	417e10 <__cmpdf2+0x4>
  417e02:	bf00      	nop

00417e04 <__ledf2>:
  417e04:	f04f 0c01 	mov.w	ip, #1
  417e08:	e002      	b.n	417e10 <__cmpdf2+0x4>
  417e0a:	bf00      	nop

00417e0c <__cmpdf2>:
  417e0c:	f04f 0c01 	mov.w	ip, #1
  417e10:	f84d cd04 	str.w	ip, [sp, #-4]!
  417e14:	ea4f 0c41 	mov.w	ip, r1, lsl #1
  417e18:	ea7f 5c6c 	mvns.w	ip, ip, asr #21
  417e1c:	ea4f 0c43 	mov.w	ip, r3, lsl #1
  417e20:	bf18      	it	ne
  417e22:	ea7f 5c6c 	mvnsne.w	ip, ip, asr #21
  417e26:	d01b      	beq.n	417e60 <__cmpdf2+0x54>
  417e28:	b001      	add	sp, #4
  417e2a:	ea50 0c41 	orrs.w	ip, r0, r1, lsl #1
  417e2e:	bf0c      	ite	eq
  417e30:	ea52 0c43 	orrseq.w	ip, r2, r3, lsl #1
  417e34:	ea91 0f03 	teqne	r1, r3
  417e38:	bf02      	ittt	eq
  417e3a:	ea90 0f02 	teqeq	r0, r2
  417e3e:	2000      	moveq	r0, #0
  417e40:	4770      	bxeq	lr
  417e42:	f110 0f00 	cmn.w	r0, #0
  417e46:	ea91 0f03 	teq	r1, r3
  417e4a:	bf58      	it	pl
  417e4c:	4299      	cmppl	r1, r3
  417e4e:	bf08      	it	eq
  417e50:	4290      	cmpeq	r0, r2
  417e52:	bf2c      	ite	cs
  417e54:	17d8      	asrcs	r0, r3, #31
  417e56:	ea6f 70e3 	mvncc.w	r0, r3, asr #31
  417e5a:	f040 0001 	orr.w	r0, r0, #1
  417e5e:	4770      	bx	lr
  417e60:	ea4f 0c41 	mov.w	ip, r1, lsl #1
  417e64:	ea7f 5c6c 	mvns.w	ip, ip, asr #21
  417e68:	d102      	bne.n	417e70 <__cmpdf2+0x64>
  417e6a:	ea50 3c01 	orrs.w	ip, r0, r1, lsl #12
  417e6e:	d107      	bne.n	417e80 <__cmpdf2+0x74>
  417e70:	ea4f 0c43 	mov.w	ip, r3, lsl #1
  417e74:	ea7f 5c6c 	mvns.w	ip, ip, asr #21
  417e78:	d1d6      	bne.n	417e28 <__cmpdf2+0x1c>
  417e7a:	ea52 3c03 	orrs.w	ip, r2, r3, lsl #12
  417e7e:	d0d3      	beq.n	417e28 <__cmpdf2+0x1c>
  417e80:	f85d 0b04 	ldr.w	r0, [sp], #4
  417e84:	4770      	bx	lr
  417e86:	bf00      	nop

00417e88 <__aeabi_cdrcmple>:
  417e88:	4684      	mov	ip, r0
  417e8a:	4610      	mov	r0, r2
  417e8c:	4662      	mov	r2, ip
  417e8e:	468c      	mov	ip, r1
  417e90:	4619      	mov	r1, r3
  417e92:	4663      	mov	r3, ip
  417e94:	e000      	b.n	417e98 <__aeabi_cdcmpeq>
  417e96:	bf00      	nop

00417e98 <__aeabi_cdcmpeq>:
  417e98:	b501      	push	{r0, lr}
  417e9a:	f7ff ffb7 	bl	417e0c <__cmpdf2>
  417e9e:	2800      	cmp	r0, #0
  417ea0:	bf48      	it	mi
  417ea2:	f110 0f00 	cmnmi.w	r0, #0
  417ea6:	bd01      	pop	{r0, pc}

00417ea8 <__aeabi_dcmpeq>:
  417ea8:	f84d ed08 	str.w	lr, [sp, #-8]!
  417eac:	f7ff fff4 	bl	417e98 <__aeabi_cdcmpeq>
  417eb0:	bf0c      	ite	eq
  417eb2:	2001      	moveq	r0, #1
  417eb4:	2000      	movne	r0, #0
  417eb6:	f85d fb08 	ldr.w	pc, [sp], #8
  417eba:	bf00      	nop

00417ebc <__aeabi_dcmplt>:
  417ebc:	f84d ed08 	str.w	lr, [sp, #-8]!
  417ec0:	f7ff ffea 	bl	417e98 <__aeabi_cdcmpeq>
  417ec4:	bf34      	ite	cc
  417ec6:	2001      	movcc	r0, #1
  417ec8:	2000      	movcs	r0, #0
  417eca:	f85d fb08 	ldr.w	pc, [sp], #8
  417ece:	bf00      	nop

00417ed0 <__aeabi_dcmple>:
  417ed0:	f84d ed08 	str.w	lr, [sp, #-8]!
  417ed4:	f7ff ffe0 	bl	417e98 <__aeabi_cdcmpeq>
  417ed8:	bf94      	ite	ls
  417eda:	2001      	movls	r0, #1
  417edc:	2000      	movhi	r0, #0
  417ede:	f85d fb08 	ldr.w	pc, [sp], #8
  417ee2:	bf00      	nop

00417ee4 <__aeabi_dcmpge>:
  417ee4:	f84d ed08 	str.w	lr, [sp, #-8]!
  417ee8:	f7ff ffce 	bl	417e88 <__aeabi_cdrcmple>
  417eec:	bf94      	ite	ls
  417eee:	2001      	movls	r0, #1
  417ef0:	2000      	movhi	r0, #0
  417ef2:	f85d fb08 	ldr.w	pc, [sp], #8
  417ef6:	bf00      	nop

00417ef8 <__aeabi_dcmpgt>:
  417ef8:	f84d ed08 	str.w	lr, [sp, #-8]!
  417efc:	f7ff ffc4 	bl	417e88 <__aeabi_cdrcmple>
  417f00:	bf34      	ite	cc
  417f02:	2001      	movcc	r0, #1
  417f04:	2000      	movcs	r0, #0
  417f06:	f85d fb08 	ldr.w	pc, [sp], #8
  417f0a:	bf00      	nop

00417f0c <__aeabi_dcmpun>:
  417f0c:	ea4f 0c41 	mov.w	ip, r1, lsl #1
  417f10:	ea7f 5c6c 	mvns.w	ip, ip, asr #21
  417f14:	d102      	bne.n	417f1c <__aeabi_dcmpun+0x10>
  417f16:	ea50 3c01 	orrs.w	ip, r0, r1, lsl #12
  417f1a:	d10a      	bne.n	417f32 <__aeabi_dcmpun+0x26>
  417f1c:	ea4f 0c43 	mov.w	ip, r3, lsl #1
  417f20:	ea7f 5c6c 	mvns.w	ip, ip, asr #21
  417f24:	d102      	bne.n	417f2c <__aeabi_dcmpun+0x20>
  417f26:	ea52 3c03 	orrs.w	ip, r2, r3, lsl #12
  417f2a:	d102      	bne.n	417f32 <__aeabi_dcmpun+0x26>
  417f2c:	f04f 0000 	mov.w	r0, #0
  417f30:	4770      	bx	lr
  417f32:	f04f 0001 	mov.w	r0, #1
  417f36:	4770      	bx	lr

00417f38 <__aeabi_d2iz>:
  417f38:	ea4f 0241 	mov.w	r2, r1, lsl #1
  417f3c:	f512 1200 	adds.w	r2, r2, #2097152	; 0x200000
  417f40:	d215      	bcs.n	417f6e <__aeabi_d2iz+0x36>
  417f42:	d511      	bpl.n	417f68 <__aeabi_d2iz+0x30>
  417f44:	f46f 7378 	mvn.w	r3, #992	; 0x3e0
  417f48:	ebb3 5262 	subs.w	r2, r3, r2, asr #21
  417f4c:	d912      	bls.n	417f74 <__aeabi_d2iz+0x3c>
  417f4e:	ea4f 23c1 	mov.w	r3, r1, lsl #11
  417f52:	f043 4300 	orr.w	r3, r3, #2147483648	; 0x80000000
  417f56:	ea43 5350 	orr.w	r3, r3, r0, lsr #21
  417f5a:	f011 4f00 	tst.w	r1, #2147483648	; 0x80000000
  417f5e:	fa23 f002 	lsr.w	r0, r3, r2
  417f62:	bf18      	it	ne
  417f64:	4240      	negne	r0, r0
  417f66:	4770      	bx	lr
  417f68:	f04f 0000 	mov.w	r0, #0
  417f6c:	4770      	bx	lr
  417f6e:	ea50 3001 	orrs.w	r0, r0, r1, lsl #12
  417f72:	d105      	bne.n	417f80 <__aeabi_d2iz+0x48>
  417f74:	f011 4000 	ands.w	r0, r1, #2147483648	; 0x80000000
  417f78:	bf08      	it	eq
  417f7a:	f06f 4000 	mvneq.w	r0, #2147483648	; 0x80000000
  417f7e:	4770      	bx	lr
  417f80:	f04f 0000 	mov.w	r0, #0
  417f84:	4770      	bx	lr
  417f86:	bf00      	nop
  417f88:	23232323 	.word	0x23232323
  417f8c:	23232323 	.word	0x23232323
  417f90:	23232323 	.word	0x23232323
  417f94:	23232323 	.word	0x23232323
  417f98:	23232323 	.word	0x23232323
  417f9c:	23232323 	.word	0x23232323
  417fa0:	00002323 	.word	0x00002323
  417fa4:	20202020 	.word	0x20202020
  417fa8:	4d434920 	.word	0x4d434920
  417fac:	34393032 	.word	0x34393032
  417fb0:	78652038 	.word	0x78652038
  417fb4:	6c706d61 	.word	0x6c706d61
  417fb8:	20202065 	.word	0x20202065
  417fbc:	00002020 	.word	0x00002020
  417fc0:	2e312e31 	.word	0x2e312e31
  417fc4:	00000031 	.word	0x00000031
  417fc8:	20202020 	.word	0x20202020
  417fcc:	72655620 	.word	0x72655620
  417fd0:	7325203a 	.word	0x7325203a
  417fd4:	00000000 	.word	0x00000000
  417fd8:	6f727245 	.word	0x6f727245
  417fdc:	65732072 	.word	0x65732072
  417fe0:	726f736e 	.word	0x726f736e
  417fe4:	7465735f 	.word	0x7465735f
  417fe8:	442f7075 	.word	0x442f7075
  417fec:	6c20504d 	.word	0x6c20504d
  417ff0:	6964616f 	.word	0x6964616f
  417ff4:	002e676e 	.word	0x002e676e
  417ff8:	6d6d6f63 	.word	0x6d6d6f63
  417ffc:	48646e61 	.word	0x48646e61
  418000:	6c646e61 	.word	0x6c646e61
  418004:	61547265 	.word	0x61547265
  418008:	00006b73 	.word	0x00006b73
  41800c:	6e696c62 	.word	0x6e696c62
  418010:	4c72656b 	.word	0x4c72656b
  418014:	61546465 	.word	0x61546465
  418018:	00006b73 	.word	0x00006b73
  41801c:	00007325 	.word	0x00007325
  418020:	00000a0d 	.word	0x00000a0d
  418024:	00000000 	.word	0x00000000
  418028:	205d455b 	.word	0x205d455b
  41802c:	00000000 	.word	0x00000000
  418030:	205d575b 	.word	0x205d575b
  418034:	00000000 	.word	0x00000000
  418038:	205d495b 	.word	0x205d495b
  41803c:	00000000 	.word	0x00000000
  418040:	205d565b 	.word	0x205d565b
  418044:	00000000 	.word	0x00000000
  418048:	205d445b 	.word	0x205d445b
  41804c:	00000000 	.word	0x00000000
  418050:	00418024 	.word	0x00418024
  418054:	00418028 	.word	0x00418028
  418058:	00418030 	.word	0x00418030
  41805c:	00418038 	.word	0x00418038
  418060:	00418040 	.word	0x00418040
  418064:	00418048 	.word	0x00418048

00418068 <dmp3_image>:
  418068:	00000100 00000000 00000000 00000000     ................
  418078:	00000500 00000500 01000500 ff000500     ................
  418088:	0500f7ff 05000500 05000500 05000500     ................
  418098:	00800080 00400040 00200020 00100010     ....@.@. . .....
  4180a8:	00080008 00040004 00020002 00010001     ................
  4180b8:	80008000 40004000 20002000 10001000     .....@.@. . ....
  4180c8:	08000800 04000400 02000200 01000100     ................
  4180d8:	84030000 409c0000 00000000 00000004     .......@........
  4180e8:	66666636 00000f00 f6285c13 8fc2f50c     6fff.....\(.....
	...
  418104:	3800f8ff e8d1ed09 00680000 c7ff0100     ...8......h.....
	...
  41811c:	14ae4701 ec51b83e 00000f00 00000000     .G..>.Q.........
	...
  418148:	00000040 00000000 00000000 00000000     @...............
  418158:	00000040 00000000 00000000 00000000     @...............
  418168:	00000040 00000000 00010000 000c0100     @...............
	...
  418190:	55555515 aaaaaa0a 00000000 e1000000     .UUU............
  4181a0:	01000000 01000600 00000000 00000000     ................
  4181b0:	59d14800 a72eb73f 00000002 00000000     .H.Y?...........
	...
  4181c8:	0700178e 00000000 00000000 20030000     ............... 
  4181d8:	00000040 00000000 0000ff7f e9210500     @.............!.
  4181e8:	00000040 00000000 00000000 00000000     @...............
  4181f8:	30033e00 00000000 00000000 00000000     .>.0............
  418208:	02000000 00000000 00000000 00000000     ................
	...
  418244:	00000060 00000000 00000000 00000000     `...............
	...
  418270:	00000040 00000000 00000000 00000000     @...............
	...
  41828c:	01000000 0a000300 ee4a2b01 11ad5406     .........+J..T..
  41829c:	155c07e3 26d02b36 a4498cd0 11ad5406     ..\.6+.&..I..T..
  4182ac:	55b50b1e 5017ee38 033f3631 00000000     ...U8..P16?.....
	...
  4182d8:	01000000 00000000 01000000 00800000     ................
	...
  4182f0:	00000700 75350e00 00000000 00000000     ......5u........
  418300:	10000700 3c009600 00000000 00000000     .......<........
	...
  418318:	29aa720d 4e6c3dc9 7f4c1655 977442c4     .r.).=lNU.L..Bt.
	...
  41833c:	00000010 00000000 08000000 00000000     ................
	...
  418358:	10000000 3d000000 00000000 00000000     .......=........
	...
  418370:	88312000 40a3e315 00000000 00000000     . 1....@........
	...
  418388:	8c4b700e be920ac5 d291965a 0de7eec1     .pK.....Z.......
	...
  4183a4:	02000700 14000000 00002d00 00000000     .........-......
	...
  4183d8:	a3000000 02000000 3a000000 0000e803     ...........:....
	...
  418400:	26000000 02000000 00000000 00000000     ...&............
	...
  418420:	03000000 68a7c13f 00000040 00000000     ....?..h@.......
	...
  418440:	33333333 cdcccc0c 00ffff00 00000000     3333............
  418450:	00000000 18010000 00000000 ffffffff     ................
  418460:	00000000 00000010 00000000 00000000     ................
	...
  418478:	01000000 00000000 00000000 03000000     ................
	...
  418490:	00000010 51ed8764 00000000 00000000     ....d..Q........
  4184a0:	00000000 64000000 00000000 00000000     .......d........
  4184b0:	00000040 6af41d01 00000000 00000000     @......j........
	...
  4184c8:	00000200 00000800 ff7f0000 00200000     .............. .
  4184d8:	409c0000 cdcccc0c 80070000 00000200     ...@............
	...
  4184f0:	ec51b83e 14ae4701 5e010000 00000000     >.Q..G.....^....
  418500:	00000060 00000000 00800000 00000000     `...............
  418510:	00800000 00001000 a8610000 10000000     ..........a.....
  418520:	00010000 00100000 00000100 00000004     ................
  418530:	00004000 00000400 00000000 00200000     .@............ .
  418540:	e02e0000 00400600 01000000 00000000     ......@.........
	...
  418558:	00000002 00000000 00000000 00000000     ................
	...
  418570:	00000040 01000000 ffffff03 00000000     @...............
	...
  418588:	33333333 00000000 00000000 00000000     3333............
  418598:	cdcccc0c 00000000 00000000 00000000     ................
  4185a8:	9d000000 00000000 00000000 00000000     ................
  4185b8:	00000100 00000100 00000000 07000000     ................
	...
  4185e8:	01000000 00000000 00000000 00000000     ................
  4185f8:	00003200 00003200 00003200 00003200     .2...2...2...2..
	...
  418658:	00003200 00003200 00003200 00003200     .2...2...2...2..
	...
  418698:	10000000 00000000 00000000 751b4901     .............I.u
  4186a8:	10000000 00000000 40060000 cd0c0000     ...........@....
  4186b8:	00000100 00000000 00000000 00000000     ................
	...
  4186d8:	00500000 01000000 00160000 46000000     ..P............F
  4186e8:	00000100 00000000 00000000 00000000     ................
  4186f8:	00000100 00000000 00000000 00000000     ................
	...
  418718:	00008000 00008000 00008000 00008000     ................
	...
  418784:	01000100 00000000 00000000 00000000     ................
  418794:	c0d40100 00000000 02000000 00008000     ................
  4187a4:	3c010000 00000000 00000000 00000000     ...<............
  4187b4:	00000000 00000001 00000000 00000000     ................
	...
  418808:	28000000 983a0000 00020000 4e010000     ...(..:........N
	...
  418834:	00040000 00000000 00000000 00000000     ................
	...
  418850:	c2f52800 0000404e 00000000 00000000     .(..N@..........
  418860:	0c000000 00200000 00000000 00000000     ...... .........
	...
  418878:	00000100 00000000 00000000 060d0000     ................
	...
  4188a8:	01000000 00000000 00000010 10270000     ..............'.
  4188b8:	00000000 0020404a 00000000 00000000     ....J@ .........
  4188c8:	00000000 d80e0000 18010000 d0070000     ................
	...
  4188f4:	10270000 00000000 00000000 00000000     ..'.............
  418904:	1b130600 00b80b00 0fbf3c00 75ce5500     .........<...U.u
  418914:	10270000 055bb005 faa44f3a 00000000     ..'...[.:O......
	...
  418930:	3c000000 3c000000 00000000 5a000000     ...<...<.......Z
  418940:	8a201d00 69936100 3c010000 f04d0000     .. ..a.i...<..M.
  418950:	75ce5500 76020000 66666606 99999939     .U.u...v.fff9...
  418960:	00000010 00000030 00000000 cccccc0c     ....0...........
  418970:	33333333 45900e00 00000000 411dd401     3333...E.......A
  418980:	bfe22b3e bb6ff13f 00000000 00000000     >+..?.o.........
  418990:	00879303 49922401 00000000 88130000     .....$.I........
  4189a0:	80969800 003b5808 00000020 af0e0000     .....X;. .......
  4189b0:	70170000 01000000 00000020 50000000     ...p.... ......P
  4189c0:	00000000 01000000 00000000 00000000     ................
	...
  4189e0:	00004000 00000400 0000803f 00008000     .@......?.......
  4189f0:	33333300 77fa1c00 e6396d0c a6da6fcb     .333...w.m9..o..
  418a00:	97d3cf53 467453c4 00000000 00000000     S....StF........
	...
  418a70:	0e74da00 f28b253f 00000000 00000000     ..t.?%..........
	...
  418a88:	00000020 00000000 00000000 00000000      ...............
	...
  418ab0:	01000000 4c1d0000 00000000 00000000     .......L........
  418ac0:	00000038 00000008 00000000 00000000     8...............
	...
  418ad8:	00000020 bfe22b3e e27a143e 00000030      ...>+..>.z.0...
	...
  418af0:	88130000 d0070000 00000000 00000000     ................
	...
  418b10:	88130000 84ec233c 00000020 411dd401     ....<#.. ......A
  418b20:	1e85eb01 00000010 01000000 88130000     ................
  418b30:	00000000 b2fc6c34 00000000 00000000     ....4l..........
	...
  418b74:	10000000 70170000 88130000 28230000     .......p......#(
  418b84:	26000000 2f000000 00000000 00000040     ...&.../....@...
  418b94:	c4090000 00000000 23000000 1e85eb01     ...........#....
  418ba4:	e27a143e 00000000 2d000000 22222202     >.z........-."""
  418bb4:	dedddd3d 00000000 00000000 b8240000     =.............$.
  418bc4:	8ebad13d 00000000 00000000 00000000     =...............
	...
  418be0:	d6830000 d6830000 00000000 00000000     ................
  418bf0:	0e000000 21000000 00002000 f9fc3000     .......!. ...0..
  418c00:	00000040 00800a00 00008000 00000000     @...............
	...
  418c40:	02000000 0a000000 00000000 00000000     ................
  418c50:	33333300 00000c00 00000000 00000000     .333............
  418c60:	88312000 00000700 00000000 00000000     . 1.............
  418c70:	00000000 f89adef0 00000000 00000000     ................
  418c80:	00000000 83b2900f 00000000 00000000     ................
  418c90:	00000000 00000008 00000000 00000000     ................
  418ca0:	00000000 d58c21f7 00000000 00000000     .....!..........
  418cb0:	00000000 95396f0c 00000000 00000000     .....o9.........
	...
  418cd8:	00000040 00000000 00000000 00000000     @...............
  418ce8:	00000040 00000000 00000000 00000000     @...............
  418cf8:	00000040 00000000 00000000 00000000     @...............
	...
  418d44:	00080000 00445300 00445300 00009a01     .....SD..SD.....
  418d54:	00009a01 46050000 46050000 15000000     .......F...F....
  418d64:	19000000 58020000 58020000 12000000     .......X...X....
  418d74:	03000000 32000000 96000000 2c010000     .......2.......,
  418d84:	96000000 a450cf00 a450cf00 a4d03501     ......P...P..5..
  418d94:	a4d03501 00000000 00000000 00800200     .5..............
  418da4:	00800100 00800c00 00800c00 00000000     ................
  418db4:	00800000 00800c00 00000000 00000000     ................
	...
  418de4:	00000004 00000040 00000000 00000000     ....@...........
  418df4:	00000000 50ab7b01 48b62d01 ac160000     .....{.P.-.H....
  418e04:	60822200 8b110000 b0cc4c04 14000000     .".`.....L......
  418e14:	81160000 e0fe7802 b03a9403 90b41000     .....x....:.....
  418e24:	2a030000 f6250000 00000000 00000000     ...*..%.........
  418e34:	00100020 89df5208 06958c05 41256301      ....R.......c%A
  418e44:	00000060 00000000 00000000 00000000     `...............
  418e54:	00000000 69477b00 aedbe502 7885f106     .....{Gi.......x
  418e64:	88abdf07 00000000 00000000 00000000     ................
	...
  418ee0:	0a000000 00000000 00000000 00000002     ................
  418ef0:	4cfe0000 00000000 00000000 00000000     ...L............
  418f00:	03000000 66666608 00000000 00000000     .....fff........
  418f10:	9a999903 66666600 f4010000 01000000     .....fff........
  418f20:	0a000000 1e000000 00000002 00000000     ................
  418f30:	66666606 5ed40400 00000000 04000000     .fff...^........
  418f40:	28000000 1e000000 00000000 00000000     ...(............
  418f50:	66666600 00000000 02000000 00000000     .fff............
  418f60:	96000000 00000000 00000000 f8ffffff     ................
	...
  418fd8:	b0b8dcd8 f8aaf3b4 88d9d1f9 3ef7f89a     ...............>
  418fe8:	9a8af3d8 d9d131a7 d83610f4 f9399ff3     .....1....6...9.
  418ff8:	10f4d9d1 8ff3d836 6097089f d9d1218a     ....6......`.!..
  419008:	da3610f4 f1d8fff1 bcbcbebe b2babdbd     ..6.............
  419018:	9080a0b6 bebe1832 bdbdbcbc a4b4b0b8     ....2...........
  419028:	f3dea5df dfd0dea8 249f84a4 f9f8a9f2     ...........$....
  419038:	a8dedad1 dfdfdfde 8db1f4d8 b0d0a8f3     ................
  419048:	b9f48fb4 bec7d0af d0aeb8be b2759ff3     ..............u.
  419058:	bebef486 c3d0afb9 b0b8bef1 dfdfdea3     ................
  419068:	81a3f2df c7cd80c0 b4bdbccf 938da3f1     ................
  419078:	883ffd20 8d7e766e 20a2be93 2ca031fd      .?.nv~.... .1.,
  419088:	fd3432fd 32fd3c32 8dacb9be bebeb820     .24.2<.2.... ...
  419098:	9d86a2bc bc0ffd08 82a3bcbc 83a90193     ................
  4190a8:	1e160e9e bcbebebe 2c998ba5 bcbc7c54     ...........,T|..
  4190b8:	a5ba9385 b87d552d fd2c9da5 37fd4c37     ....-U}...,.7L.7
  4190c8:	f537fd6c 349f85a5 bdbd7454 bab6b1bd     l.7....4Tt......
  4190d8:	f1a59583 b21e160e 2a9585a7 877850f0     ...........*.Px.
  4190e8:	da01f193 dfdfdfa5 dfdfa4d8 f280b0df     ................
  4190f8:	c5cbc3a4 948eb1f1 1e160ea4 a0be86b2     ................
  419108:	bd3c342c b896b4bd 3c342ca1 94b6bdbd     ,4<......,4<....
  419118:	fd2ca6be 35fd3435 bc35fd3c b8948eb2     ..,.54.5<.5.....
  419128:	2da6bebe a4ba7d55 b87d552d 8fa6b4b0     ...-U}..-U}.....
  419138:	3e362e96 bdbcbcbc f59f86a6 bc745434     ..6>........4Tt.
  419148:	fc90f1be f4d900c3 f3d8df11 bcf1dfa0     ................
  419158:	2da99186 bcbc7d55 9080a9bc 100051fc     ...-U}.......Q..
  419168:	100051fc 100051fc d904c1fc f4dfa0f2     .Q...Q..........
  419178:	f6d8df11 9080faa0 dadef338 df11f4f8     ........8.......
  419188:	95bdf1d8 d904c1fc f4bdbdbd f6d8df11     ................
  419198:	bdbcbcbc bebebebd 9284a7b5 d1f9f81a     ................
  4191a8:	f79384db 9687b66a daff09f3 d8bebdbc     ....j...........
  4191b8:	bcbcbcf1 b482b0f6 02a9b897 bcf102f7     ................
  4191c8:	04a79989 dfa837fd fca79887 f850003d     .....7......=.P.
  4191d8:	a8d9d1f9 f6d8f9df bdbcbcbc bebebdbd     ................
  4191e8:	81a7b7be 87b40b9a f9f81a9f aa81bbd1     ................
  4191f8:	12f4d9c1 b8f6d847 d9f91aa7 d84712f4     ....G.........G.
  419208:	aabbf38a aab3c3c0 fd1a9d8a 089ab71e     ................
  419218:	a5b4b0b8 d8009d85 a9b2b9f3 c4f2cd80     ................
  419228:	a0f3bac5 b4b1ded0 9189a7f7 47918972     ............r..G
  419238:	b94a97b6 fad0a9f2 f4d9d1f9 f3d87512     ..J..........u..
  419248:	dbf9a7ba b9f1d9fb c3a981b0 baf3c5f2     ................
  419258:	d8f8d0a0 a789b1f1 f2dfdfdf c5cbc3a7     ................
  419268:	b887b2f1 abbebebe bec7c5c2 a597b9b5     ................
  419278:	7048f022 6840983c 60995834 8eb3bcf1     ".Hp<.@h4X.`....
  419288:	4d25aa95 bcbcbc75 a7b4b0b8 5af79f88     ..%Mu..........Z
  419298:	a8f3daf9 d09d88f8 a7f7d87c f9529f88     ........|.....R.
  4192a8:	88a8f3da 60dfd09c 9d787068 78706860     .......`hpx.`hpx
  4192b8:	9f78709e a7f7d870 f9429f88 f3d0a0ba     .px.p.....B.....
  4192c8:	f8d8ded9 dab8d1f9 d09e88a8 609f6864     ............dh.`
  4192d8:	9884a8d8 f17ef7d0 85bab6b2 75f4a791     ......~........u
  4192e8:	c075f4a8 a79184f1 f0a875f4 200d87a2     ..u......u..... 
  4192f8:	38157059 f1a46940 3119f062 b4b1b848     Yp.8@i..b..1H...
  419308:	c680a6f1 f381b0f4 8fb1c6a7 f902f797     ................
  419318:	7f13f4da a7f7b0d8 f9529f88 7813f4d9     ..........R....x
  419328:	b6b2f1d8 2a9282a6 08fd50f0 9484a7f1     .......*.P......
  419338:	b008fd02 009786b4 81a7bab1 13f4d961     ............a...
  419348:	41f1d897 9713f4da b2b8f1d8 d8c082a6     ...A............
  419358:	86b6b0f1 fd16a792 04fd0f04 a79187ba     ................
  419368:	b2b675f4 d8c075f4 bebebef1 b2bdbdbd     .u...u..........
  419378:	c3a784ba bcb2c7c5 87b6bcbc 75f4af91     ...............u
  419388:	f18fa0a8 5920f00b 40381570 31196469     ...... Yp.8@id.1
  419398:	9080f148 04fd6eaf 8f04fd67 75f4a791     H....n..g......u
  4193a8:	c075f4b6 bdbcbef1 b4b0bef7 a39e88ba     ..u.............
  4193b8:	f0669f6a 8ab9b5b1 502ca29a 8ab9b278     j.f.......,Px...
  4193c8:	c5c3c0af d0ad89c7 a183c7c4 bcbac5c2     ................
  4193d8:	81b2bcbc c5c3c0a2 bdbcbcc7 f39c74f4     .............t..
  4193e8:	f9faa3ba 14f4d9d1 ad74d833 babebebe     ........3.t.....
  4193f8:	d0a382b1 8dd0a9c7 81a3c7c4 a6f3c3c1     ................
  419408:	d8bec28d bebebef1 8faab1ba c7c5c3c0     ................
  419418:	bcbcbcbe af88b9b2 c7c5c3c0 c0d0ad80     ................
  419428:	c0a189c3 a281bac3 c7c5c3c0 9c74f4bc     ..............t.
  419438:	f8a3baf3 f4d9d1f9 74d88414 bebebead     ...........t....
  419448:	a782b1b8 a0bac7d0 a9c7c48d f3c3c081     ................
  419458:	bec28da5 bebef1d8 a8b1babe c5c3c08f     ................
  419468:	baf3bec7 83a3b6b2 d9f90893 d80215f4     ................
  419478:	a3b0b8f0 28049485 b4f17850 d9699384     .......(Px....i.
  419488:	948da5b6 3c342c20 dfdea4b4 cc14f4f8     .... ,4<........
  419498:	f8a4f1d8 419484a3 f8dfa4d9 fc94f1d8     .......A........
  4194a8:	a4d904c1 c086a3fb 069e82b1 81a61efd     ................
  4194b8:	f0934296 f1a3b068 f5019683 a6009383     .B..h...........
  4194c8:	34f09686 a1f11883 81a3688d 8b19db9b     ...4.....h......
  4194d8:	f1d8c6a1 bcbebebe bdbdbcbc b8f7d8bd     ................
  4194e8:	9da7b0b4 bcf97288 f4d9bebd f2d8a117     .....r..........
  4194f8:	f9f8adb8 badedad1 deaedea1 81b2d8f8     ................
  419508:	afb9bebe bcbcc1d0 b4b1bdbd 928cacf1     ................
  419518:	afb5180a db419d8c ad8e119c babebec0     ......A.........
  419528:	c7c5c3ae c7c6a88d dea6c7c7 a5dfdfdf     ................
  419538:	bedfded0 acb9d8be 9c8dafdf c58cd911     ................
  419548:	afd8c1da 9ff5218f 9c8cf100 ac8fd945     .....!......E...
  419558:	aff2d8c1 dff8f8df aff8f8f8 d1599f8f     ..............Y.
  419568:	9c8cf1db af8ff231 afd8c3d0 d1399f8f     ....1.........9.
  419578:	9c8cf1db af8ff269 8fd8c5d0 a1babebe     ....i...........
  419588:	bdbcbcc6 b5b1f2bd daf9aeb9 d87417f4     ..............t.
  419598:	f1c28ef2 f59a80b2 f4d924af f5d87417     .........$...t..
  4195a8:	17f4d944 64f5d874 7417f4d9 b6b1f1d8     D...t..d...t....
  4195b8:	2daf908b 8cb57d55 160ead9f ab9d8b1e     ...-U}..........
  4195c8:	8d7c542c 562eaa9f aa9c8a7e 9b7c542c     ,T|....V~...,T|.
  4195d8:	664626ac 009d8daf 11db0d9c 16f4198f     .&Ff............
  4195e8:	7417d814 81b2f1d8 2daf90b6 8fb17d55     ...t.......-U}..
  4195f8:	f5af9fb5 f17c542c ad9f8cb2 7971db6d     ....,T|.....m.qy
  419608:	d84216f4 dea1baf3 a180f1f8 f4c7c5c3     ..B.............
  419618:	f3d85116 fc91bab6 a1da28c0 17f4d9f8     .Q.......(......
  419628:	b9f3d874 d1f9f8ae 17f4f8d9 baf1d874     t...........t...
  419638:	8ba0b5b1 7e5e3e93 c5c083ab 87a3b6b2     .....>^~........
  419648:	c7c5c3c0 c3c088a2 86a4c7c5 c7c5c3c0     ................
  419658:	c7c485a5 bec08dac bdbcbcbe b5b1b9bd     ................
  419668:	afded0ad d9419c8c d8c016f4 d1f9f8f1     ......A.........
  419678:	d916f4d9 8daff1d8 8cda319c d8c3d9c5     .........1......
  419688:	f5218faf adf1009f 9f82b0d0 d916f402     ..!.............
  419698:	8daff1d8 8cd9319c d8c3dac5 f5218faf     .....1........!.
  4196a8:	adf1009f 9f83b0d0 b1f1d802 bec1ad8c     ................
  4196b8:	babdbdbe 9c8dacb6 b2bcbc40 f8f8dea0     ........@.......
  4196c8:	fdf8f8f8 88aff50f 542c0098 80aff17c     ..........,T|...
  4196d8:	09db019f 17f41911 a1f2d813 dad1f9f8     ................
  4196e8:	d8deacf1 f8deaef3 d88e1af4 c083a7f1     ................
  4196f8:	a8c7c5c3 c5c3c082 c084a6c7 a5c7c5c3     ................
  419708:	c3c0d085 39af9d8d 7417f4d9 b583f1d8     .......9...t....
  419718:	fd34ae9e 0afd540a f20afd74 f8f8dea1     ..4..T..t.......
  419728:	bebef1f8 bdbdbcbc 8cb5b1b9 9cafc0ad     ................
  419738:	c0aed911 8eb2bcbc bcc7c5c3 bebed8bc     ................
  419748:	bdbdbcbc b2baf2d8 9781afb5 a7b9d101     ................
  419758:	17f4dac0 baf2d88c d1f9f8ae bebef3da     ................
  419768:	bcbcbcbe b8bdbdbd 85a5b4b0 bcbe089c     ................
  419778:	bcf7d8bd bdbdbcbc b0b4bbbd 62889eaf     ...............b
  419788:	d9bdbcf9 d8e719f4 bcbcbcf1 b5ba85b1     ................
  419798:	260698a0 b3b9bc46 81aff1b6 7d552d90     ...&F........-U}
  4197a8:	8fafb5b1 542cf59f afbbf17c db699f86     ......,T|.....i.
  4197b8:	f3da7971 f1f8dfa0 f8f2dea1 f1b7b3d8     qy..............
  4197c8:	19af9b8c f3deacd9 d8f8dfa0 699080af     ...............i
  4197d8:	f1faa0d9 c3a180b2 a0f2c7c5 f4f8dfd0     ................
  4197e8:	f2d8d119 f1dfd0a0 b1bcbcbc 269e8aad     ...............&
  4197f8:	b3bc6646 f8dea2f3 d8171af4 c18daaf1     Ff..............
  419808:	f9f8a1f2 18f4dad1 aff1d85c 8f219a8a     ........\.....!.
  419818:	da10f590 d85c18f4 c0fc91f1 18f4d904     ......\.........
  419828:	a1f3d8a3 dfa0f8de d119f4f8 c0fc91f3     ................
  419838:	18f4d907 aff1d8a3 019c84b1 9780b5b3     ................
  419848:	b921f3db f4f8d9a7 f3d8a318 f8dea7b9     ..!.............
  419858:	87a3f1bb c7c5c3c0 c3c088a4 89a5c7c5     ................
  419868:	c7c5c3c0 c7c486a6 c5c382a1 dea1f3c7     ................
  419878:	d8e719f4 b7b3bbf1 d1f9f8a1 d0a0f2da     ................
  419888:	f1d8f8df a8b6b1b9 552d9087 a8b5f57d     ..........-U}...
  419898:	542c9888 86aff17c 31db2998 e719f439     ..,T|....).19...
  4198a8:	b6b3f1d8 4c908aa7 a0ba5c54 552d9081     .......LT\....-U
  4198b8:	a2f2bb7d dad1f9f8 e719f4de b0baf1d8     }...............
  4198c8:	c7c08fab c083a3b3 a2c7c5c3 c5c3c084     ................
  4198d8:	c085a4c7 a5c7c5c3 acc3c086 aef3c28c     ................
  4198e8:	f4f8f8de f1d88e1a 83a3bbb2 c7c5c3c0     ................
  4198f8:	c3c082a4 84a5c7c5 c7c5c3c0 c3c085a6     ................
  419908:	b3c48cac 9585afb7 860ffd56 0ffd0696     ........V.......
  419918:	af9f84f0 0ffd704c 2e9686f1 9f840ffd     ....Lp..........
  419928:	df0ffd72 7c542caf db698caf 9c8b7971     r....,T|..i.qy..
  419938:	6719f461 d8e719da 9183abf1 5405fd28     a..g........(..T
  419948:	fd7c05fd bdbdb805 8ba3b5bd 552d0595     ..|...........-U
  419958:	adbbb4bd 160e938e a2f3b71e f4f8f8de     ................
  419968:	f2d8171a d1f9f8a1 8daff1d9 8ff5019a     ................
  419978:	f400db90 f1dae719 aec08daa c5c3c18b     ................
  419988:	83a7dea1 c7c5c3c0 c3c084a8 85a9c7c5     ................
  419998:	c7c5c3c0 c0d086a6 c381a2c3 19f4c7c5     ................
  4199a8:	b3bbf1e7 dfdfdea3 c48ca4df a5c5c5c5     ................
  4199b8:	dfdfdfde d8dfdea6 dfaeb9f3 bbdeaeba     ................
  4199c8:	bcbedea2 afb7bdb3 d1019c8e aed9c0ac     ................
  4199d8:	b1f1d8de d0a7b983 deaeb8c4 bbbebebe     ................
  4199e8:	b3bcbcbc d8bdbdbd f9f8a2f3 1af4d9d1     ................
  4199f8:	adf5d88c 542c9d8d 49aff17c d9c5c3da     ......,T|..I....
  419a08:	afd8c3c5 dad0699f c38fd9c7 d8c7af8d     .....i..........
  419a18:	9f8fa9b9 f17854f0 b1a60ffd afb3c289     .....Tx.........
  419a28:	fd2e9f8f a9b5b111 f32c9f89 f8f8dfae     ..........,.....
  419a38:	d8431cf4 9986adf1 df10fd06 ad0ffdf8     ..C.............
  419a48:	bb4c9d8d 9d8fadb3 b70ffd2a 04c0fc92     ..L.....*.......
  419a58:	2b18f4d9 08c0fcd8 9219f4d9 f3d8f1d8     ...+............
  419a68:	aeb6b2ba d9d1f9f8 d8411cf4 f9deaff1     ..........A.....
  419a78:	90800ffd a07c542c 7850f02a a2f10ffd     ....,T|.*.Px....
  419a88:	24009c82 8fa96444 fd04f094 fd300c0f     ...$Dd........0.
  419a98:	20951c0f f10ffd48 542cc199 9982aa7c     ... H.....,T|...
  419aa8:	2e0ffd02 fd560ffd 0ffd7e0f f09f83ac     ......V..~......
  419ab8:	78502804 908c0ffd 8cf521f1 aff12c9c     .(Px.....!...,..
  419ac8:	af89f1de 00c0fc9f c18ac1d9 fcd8c182     ................
  419ad8:	c3d904c0 c382c38a 08c0fcd8 c58ac5d9     ................
  419ae8:	fcd8c582 c7d90cc0 c782c78a 10c0fcd8     ................
  419af8:	fb1bf4d9 ab8bf1d8 2e9fc0d0 dea00ffd     ................
  419b08:	6590d0ab 4a9f8fa0 8bab0ffd a9b90090     ...e...J........
  419b18:	dfaef3c1 431cf4f8 b1baf1d8 c1ab89b6     .......C........
  419b28:	8bd0afb2 0ffd3e9f 9f0ffd5a d900c0fc     .....>..Z.......
  419b38:	c6a28ff1 04c0fcd8 c7a28fd9 c0d0ab84     ................
  419b48:	1e9b8aaf fd360ffd 308fa40f d8409aaa     ......6....0..@.
  419b58:	08c0fc9f d0a28fd9 d0ab84c6 9b8aafc2     ................
  419b68:	560ffd1e 8fa40ffd 409aaa34 c4d0ab84     ...V....4..@....
  419b78:	3e9b8aaf fd560ffd 8fd0a40f 4c9aaa30     ...>..V.....0..L
  419b88:	c0fc9fd8 a28fd90c ab84c7d0 8aafc6d0     ................
  419b98:	0ffd1e9b a40ffd76 aa348fd0 ab85409a     ....v.....4..@..
  419ba8:	8aafc0d0 0ffd3e9b a50ffd76 9aaa308f     .....>..v....0..
  419bb8:	d0ab854c 9b8aafc2 760ffd5e 8fa50ffd     L.......^..v....
  419bc8:	9ad0aa34 f8afd850 f1f11af4 af9c8bd8     4...P...........
  419bd8:	8a0ffd2a 02afb99f fd260ffd 0ffd460f     *.........&..F..
  419be8:	830ffd66 a3ba9fb5 7c542c00 a09282b6     f........,T|....
  419bf8:	c3add931 d8c5adda da39a08d d8c7ad82     1.........9.....
  419c08:	c0fc9ef3 17f4d904 c0fcd81b 19f4d908     ................
  419c18:	d8f1d816 b5b1b9f1 89f8dea9 d931af99     ..............1.
  419c28:	d8971cf4 29af85f1 c2a984d9 49af85d8     .......).......I
  419c38:	c4a984d9 69af85d8 c6a984d9 39af89d8     .......i.......9
  419c48:	50a98eda d8971cf4 7caa89f1 689a02fd     ...P.......|...h
  419c58:	fbaaf1d8 af9989da 8f0ffd26 9f892595     ........&....%..
  419c68:	0ffd12a9 d8801cf4 c1fc9ef3 1bf4d904     ................
  419c78:	c1fcd848 1af4d908 bef1d863 bdbcbcbc     H.......c.......
  419c88:	b0b4b8f3 f9c0a88f f59784ac f9f8f11a     ................
  419c98:	dea8dad1 c1fc95d8 dea8d903 f1bcbcd8     ................
  419ca8:	1cc0fc98 c0fc95db a4dea503 88acd8de     ................
  419cb8:	d9d10095 a4d8f8a5 880480fc 08fca495     ................
  419cc8:	bcf72004 b5bdbdbc f69f84ac d1f9f802     . ..............
  419cd8:	f79384db f3d9f96a 88a8bcbc bcbc1892     ....j...........
  419ce8:	b4bcbcd8 089e88a8 a1bebef4 f7bcbcd0     ................
  419cf8:	acb5bebe f96a9384 d9b4bdbd 978cacf2     ......j.........
  419d08:	9c84f618 dbf9f802 dfa5f1d1 bebef7d8     ................
  419d18:	9da7bdbd d9f97a88 d8e11ef4 acbebef1     .....z..........
  419d28:	88acdfde 565af79f bdbcbcf1 c0fc95bd     ......ZV........
  419d38:	1ef4da07 fcf1d87c 9cdb00c0 f400c1fc     ....|...........
  419d48:	f1d8a11e c0fc95ac 1df4da08 82f1d8be     ................
  419d58:	552d7990 049c8cf5 f1542cac 80bcbcbc     .y-U.....,T.....
  419d68:	5149db5d 9c1dbcf4 781ebcda 9886f5d8     ].IQ.......x....
  419d78:	82f1d938 acd82d90 f59886d0 82f1d95c     8....-......\...
  419d88:	acd85590 00009c8c f4f8dfa5 f1d8c91d     .U..............
  419d98:	552d9682 349c8c7d 95acf118 f4d91cf5     ..-U}..4........
  419da8:	f1d8781e 459083ac acf8a0d9 d2069c8c     .x.....E........
  419db8:	2c0091a1 a1f0d681 289c8cd0 a7d487d3     ...,.......(....
  419dc8:	f1d3208c 2c9084a4 acd87c54 d9459083     . .....,T|....E.
  419dd8:	d8a11ef4 9181acf1 8514fd02 881dfd66     ............f...
  419de8:	871bfd4e ad54fdd4 81f04e8d fdd6ab9c     N.....T..N......
  419df8:	8c318d06 01011010 8bac3901 d908f598     ..1......9......
  419e08:	d8781ef4 9682a9f1 c1fc9501 1ef4da00     ..x.............
  419e18:	acf1db50 18f59389 f8dfa5f1 7c1ef4d8     P..............|
  419e28:	84a4f1d8 05fd3495 7405fd54 94a905fd     .....4..T..t....
  419e38:	7c542cf5 9987acf1 5951db49 c5c3ab84     .,T|....I.QY....
  419e48:	c0a682c7 f8dfaaf3 dfa5f1d8 dea0f1d8     ................
  419e58:	dfdfdea1 dfdea7df dfdfdfa4 c0fc95a2     ................
  419e68:	c380d901 83a8c7c5 c386dac1 83a8c7c5     ................
  419e78:	9af1d8c3 d904c1fc 019682ac f8deaaf3     ................
  419e88:	f5dbf8f8 189a8cac d8f9aaf3 419a8aac     ...............A
  419e98:	c0d0aad1 85acf2d9 d1db419a bdbdbcbc     .........A......
  419ea8:	1ef4bebe bcf3d8e1 bebdbdbc 9c85a5be     ................
  419eb8:	b8f1d810 88a7b4b0 f97af79e 1820f4d9     ..........z... .
  419ec8:	bebef1d8 f9a2bbbe 20f4beda bcf1d818     ........... ....
  419ed8:	80b3bcbc d0deafc6 84b2bcdf b7bdbdbd     ................
  419ee8:	bc60a09f 85b3bcbc 9f01af90 0ea28f46     ..`.........F...
  419ef8:	d0af9285 a5529f29 fba03408 29af9586     ....).R..4.....)
  419f08:	f4dea6da f1d84c1f daf9faa0 1ff4dea6     .....L..........
  419f18:	a6f1d84c 19af96f8 f8dea3d9 9485f1d8     L...............
  419f28:	a3d931af 80f8f8de 85d8c5a0 d931af96     .1............1.
  419f38:	f8f8dea3 c0a580f8 a8d8c386 85dea1df     ................
  419f48:	0d0caf91 af9f8ff5 97f1542c db04c0fc     ........,T......
  419f58:	a851af8f 98d8f8df d908c0fc d8b41ff4     ..Q.............
  419f68:	0cc0fcf1 dd1ff4d9 fc93f1d8 a4d909c0     ................
  419f78:	f8dea8de c0fcd8f8 a185d904 f8dea7c1     ................
  419f88:	f61ff4d8 f8a4f1d8 31af9182 92719fdb     ...........1..q.
  419f98:	d8dea741 19af9484 f8dea8d9 dfa3f8f8     A...............
  419fa8:	c0fc93d8 dea8d90a 1ff4d8f8 a4f1d8f6     ................
  419fb8:	f9faa3f8 9488dbd1 a18841af fc93d8c2     .........A......
  419fc8:	a8d90ac0 f1d8f8de 04c0fc91 a3faa7d9     ................
  419fd8:	dfd0affa afd8f8f8 d1f9fad0 bdb4bcb0     ................
  419fe8:	f3dabeb8 089d85a5 a7f1f1d8 9f84f7de     ................
  419ff8:	d4f1876a d9f93efd d84820f4 88a7f7f0     j....>... H.....
  41a008:	d9f9529f d84820f4 f9a0bbf2 4820f4da     .R... H....... H
  41a018:	80b3f2d8 dc75f4c4 b5b1f0d8 a79a8aba     ......u.........
  41a028:	78502cf0 f8dea5f2 b2b5f1f8 219087a7     .,Px...........!
  41a038:	80b1b6db f2d92997 bbd8f8a5 a1beb6b2     .....)..........
  41a048:	bed1f9f8 dababebe a7d8dea5 d1659582     ..............e.
  41a058:	c1d0a285 86a7b5d9 d1db3193 d89820f4     .........1... ..
  41a068:	b4b0b8f3 189c85a5 b2baf1d8 a19681b6     ................
  41a078:	a6b9f9f8 c7c5c3da 6d4d2dd9 aa8abad8     .........-Mm....
  41a088:	aeb9f9f8 c7c5c3da 6d4d2dd9 a888bad8     .........-Mm....
  41a098:	daa7f9f8 d9c7c5c3 d86d4d2d a3b9b0f2     ........-Mm.....
  41a0a8:	dad1f9fa c0a78fb8 9387b5f9 b4f20af6     ................
  41a0b8:	249784a4 3c9e84a4 bebef3d8 f9f8aebb     ...$...<........
  41a0c8:	b0bebed1 a5dab8b4 d8009e85 bdbcbcf1     ................
  41a0d8:	a79e8ebd bcbcd159 85dabdbd d808a59e     ....Y...........
  41a0e8:	8ebcbcf1 d0aebebe bebcbcc5 b0b9f7be     ................
  41a0f8:	9588a6b5 f1daf95a b8d8f8ab fc98f3b4     ....Z...........
  41a108:	f4da04c0 f2d88621 89f8d0a9 d951a79b     ....!.........Q.
  41a118:	a4ded0a9 d82c9e84 9a88faa8 a8d929a7     ......,......)..
  41a128:	9d84a4df d0a8d834 a79a88f8 d0a8d951     ....4.......Q...
  41a138:	9d84a4de d0a8d82c a79a88fa d0a8d979     ....,.......y...
  41a148:	9d84a4df a9f3d824 9b89f8d0 a9d951a7     ....$........Q..
  41a158:	84a4ded0 f7d82c9c 529f88a7 21f4d9f9     .....,.....R...!
  41a168:	b9f1d8b6 b8f3faa2 89fad0a9 d979a79b     ..............y.
  41a178:	a4dfd0a9 d8249c84 88f8a8f2 d901a79a     ......$.........
  41a188:	84a4dea8 f7d83c9d 429f88a7 21f4d9f9     .....<.....B...!
  41a198:	a9f3d8fd a79b89f8 dea9d901 3c9c84a4     ...............<
  41a1a8:	89faa9d8 d929a79b 84a4dfa9 f2d8349c     ......)......4..
  41a1b8:	9b89faa9 a9d929a7 9e84a4df d0a9d834     .....)......4...
  41a1c8:	a79b89fa d0a9d979 9e84a4df a7f1d824     ....y.......$...
  41a1d8:	ca84f2de a524a497 f70af694 f9f80285     ......$.........
  41a1e8:	9bf6d9d1 b1a7d802 f8629582 f4d9d1f9     ..........b.....
  41a1f8:	f0d8f223 d0a485b0 c0f2ddc0 9fa7f6dc     #...............
  41a208:	f3d9f902 f0dadea5 dcc8f2dd a59585d8     ................
  41a218:	f086d900 cccaf2dd 85d8dcce f080d900     ................
  41a228:	c6ccf2dd ccca85ce 85d8dcce 89b1d900     ................
  41a238:	c2f2ddf0 d8dcc4ca d90085b0 f2ddf081     ................
  41a248:	c082cec6 85d8dcc8 86d9b100 c2f1ddf0     ................
  41a258:	d8dcc6c4 0085f2b0 f087b2d9 c4c2f1dd     ................
  41a268:	b0bcf2c6 bcdcc081 b0d8bcbc d9b10085     ................
  41a278:	f2ddf08f dcc6c4c2 0085b0d8 f08eb1d9     ................
  41a288:	c4c2f1dd b0bcf2c6 bcdcc081 b0d8bcbc     ................
  41a298:	82d90085 c2f2ddf0 d8dcc4ca f2d80085     ................
  41a2a8:	b1d90085 f1ddf08a dcc6c4c2 85f2b0d8     ................
  41a2b8:	f0b1d900 c482f1dd f3b0d8dc d1f9f8a5     ................
  41a2c8:	7423f4d9 9585f3d8 d90000a5 aebaf2be     ..#t............
  41a2d8:	bebebede f081b2bc dcc8f3dd d8bcbcbc     ................
  41a2e8:	a585b8b0 bef2d900 bedeaabe 8abcbcbe     ................
  41a2f8:	c0f3ddf0 d8bcbcdc d900a585 d0a3f2b9     ................
  41a308:	f085b2de dcc8f3dd b885b0d8 b3d900a5     ................
  41a318:	f3ddf08a b0d8dcc0 8fd90085 c4f3ddf0     ................
  41a328:	0085d8dc bcd90000 f08eb3bc f1c0f3dd     ................
  41a338:	bcbcdcc2 85b0f3d8 bcbcd900 f3ddf08e     ................
  41a348:	bcbcdcc4 8eb0f3d8 d0a7b8f4 f387d8c0     ................
  41a358:	a6c6a2b9 8eb5f7c4 f9f80696 23f4dad1     ...............#
  41a368:	8ef3d87d 86b1f9c0 df0af796 08fd30f3     }............0..
  41a378:	f01082a2 c082f3dd a3b9f2dc 8cb1f4df     ................
  41a388:	c3c1aff3 9db48faf b51efd3e 39a6309f     ........>....0.9
  41a398:	ec23f4d9 b0b8f7d8 9d84a7b4 f4d9f91a     ..#.............
  41a3a8:	f1d8df23 a6b5b1b9 d9619b83 d8f223f4     #.........a..#..
  41a3b8:	b4b0b8f6 5a9484a7 dad1f9f8 b9f1e2f0     .......Z........
  41a3c8:	f2d8deab afb986b1 b8c7c5c3 88a7b4b0     ................
  41a3d8:	f96af79c 72d8ffd9 dff1abb9 f8f362f7     ..j....r.....b..
  41a3e8:	f1dad1f9 f7d8f8de 9d7aafbb 9f769e66     ..........z.f.v.
  41a3f8:	dfa1f176 ded0a6ba f9a0f3bb b3d8ffda     v...............
  41a408:	d0afc480 dad1f9fa f4bcbcbc f1d8ba25     ............%...
  41a418:	aebebeb8 84b0ded0 c1a7beba 9db488f7     ................
  41a428:	bcb2f96e bdbdbcbc 24f4dabd b8f1d88f     n..........$....
  41a438:	aebebebe c0fc91d0 95b6db00 d904c1fc     ................
  41a448:	f8f8f8f8 fc91b4d8 b6db04c0 00c1fc95     ................
  41a458:	f8f8f8d9 f8f8f8f8 bebad8f8 d8f624f4     .............$..
  41a468:	c0fc91f1 95b6db00 f504c1fc 3aa79587     ...............:
  41a478:	afd9f9f1 bebe8fde f1c1f4a1 f1c1f4a2     ................
  41a488:	b4d8bebe 04c0fc91 fc95b6db afd900c1     ................
  41a498:	07fdf8de df10958f a7f8f8f8 07fdf8de     ................
  41a4a8:	06fdf8df 04fdf8df d0af978f 504840de     .............@HP
  41a4b8:	8f60f8df d0a0bebe a1f1c1f4 f1c5c2f4     ..`.............
  41a4c8:	f1c7f4a2 f1d8bebe c1a581b0 beb884bc     ................
  41a4d8:	f7c1a9be 9dbdb488 bdbcf96e 4325f4da     ........n.....%C
  41a4e8:	dea9f1d8 df04fdf8 bc05fdf8 d0aebe8e     ................
  41a4f8:	00c0fc9a c0fc9bdb 4099d904 c0fc9ad8     ...........@....
  41a508:	fc9bdb04 99d900c0 bcbcd848 bebebebc     ........H.......
  41a518:	d8ad25f4 c0fc9af1 fc9bdb00 89f504c0     .%..............
  41a528:	d9f932a9 fdf8def1 fdf8df02 fdf8df07     .2..............
  41a538:	89dff807 c0f4a0ba d0a18bf1 89f1c3f4     ................
  41a548:	c5c2f4a2 f4a3f1c7 d8b8f1c7 04c0fc9a     ................
  41a558:	c0fc9bdb dea9d900 df02fdf8 df07fdf8     ................
  41a568:	f807fdf8 04fdf8df a0ba89f9 8bf1c0f4     ................
  41a578:	c3f4d0a1 f4a289f1 f1c7c5c2 8af1d8b8     ................
  41a588:	bcbcc0ab bebdbdbd f1d8bebe a7ba80b2     ................
  41a598:	8bb2bcc4 8f7575f4 75f49cb6 75f4af81     .....uu....u...u
  41a5a8:	75f48b87 9db68e75 ae8175f4 b38775f4     ...uu....u...u..
  41a5b8:	7575f481 75f49485 f4a5bb81 ba808775     ..uu...u....u...
  41a5c8:	b37575f4 75f49b8e f4aebb81 83b38775     .uu....u....u...
  41a5d8:	9375f4a3 b68fb2f1 b9bebe9f 9e8e7aaf     ..u..........z..
  41a5e8:	85b3f57e 8e7c95b7 bcf17c9e b1bdbdbc     ~.....|..|......
  41a5f8:	af9f8fb5 af8258d0 86552d01 764e42af     .....X...-U..BNv
  41a608:	2c00a282 b6bd8454 bd51af90 9fb5bdbd     ...,T.....Q.....
  41a618:	48d0a406 0ad0af8f d0a47484 af93803e     ...H.....t..>...
  41a628:	d9abd139 d8dfdafa 83faadba db69a79b     9.............i.
  41a638:	9db68db2 6d26f469 deadf1d8 bcf0d8df     ....i.&m........
  41a648:	b6bd81b2 3ca6bb91 2c580c11 bcbcf150     .......<..X,P...
  41a658:	bd86b3bc 96b7bdbd 7c542ca6 a597719b     .........,T|.q..
  41a668:	50f02ad0 b8d8f178 f5f8deac 93b78cb0     .*.Px...........
  41a678:	aff9f106 ded9f8da bab6b3d8 f4c2a786     ................
  41a688:	f0939b75 84607171 8175f492 75f4a4f1     u...qq`...u....u
  41a698:	f4a38387 86b39375 75f4c4a7 71f0959b     ....u......u...q
  41a6a8:	92866071 a68175f4 858775f4 9375f4a5     q`...u...u....u.
  41a6b8:	c6a786b3 9f9b75f4 607171f0 75f49288     .....u...qq`...u
  41a6c8:	75f4a881 f4af8f87 b2f59375 afb99484     ...u....u.......
  41a6d8:	7c96867c f17c9888 9fb58fb1 188530a5     |..|..|......0..
  41a6e8:	993c9af0 bcbcf118 afb984b2 bac7c5c3     ..<.............
  41a6f8:	a7bcbcb6 2d9fb58b a7f57d55 2c97b687     .......-U}.....,
  41a708:	acf07c54 970c9c81 97149c28 971c9c30     T|......(...0...
  41a718:	8fb1f138 c7c5c3ab 9c81b2a7 aa51db59     8...........Y.Q.
  41a728:	6a27f4de b1acf1d8 fd489c8e 028bb202     ..'j......H.....
  41a738:	8ca7deaa da19db11 f1d8f8aa 9bbdbdb5     ................
  41a748:	bd03c1fc 28f4d9bd b2f1d8ea b884bcbc     .......(........
  41a758:	c5c3aebe bcbcb0c7 f0bdb4bc 6caf9e8a     ...............l
  41a768:	198a6199 6999749e 7c9e398a 598a7199     .a...t.i.9.|.q.Y
  41a778:	aa9f8ff1 5401fd28 fd7c01fd c2a98e01     ....(..T..|.....
  41a788:	8af0c7c5 2804a79a 9787f150 b58f09af     .......(P.......
  41a798:	9bbdbdbd 97bdb41e ba8b20a7 c5c3c1a7     ......... ......
  41a7a8:	fc90b6bd bdbd00c2 28f4d9bd b2f1d877     ...........(w...
  41a7b8:	a797b686 75f4994a 75f49aa1 f4aa8a81     ....J..u...u....
  41a7c8:	86f19375 9b52a797 9ca175f4 8c8175f4     u.....R..u...u..
  41a7d8:	9375f4ac a79786f1 75f49d5a 75f49ea1     ..u.....Z..u...u
  41a7e8:	f4ae8e81 89f19375 c7c5c2a9 ab8bc387     ....u...........
  41a7f8:	87c7c5c2 c2ad8dc5 c787c7c5 8adeaeb8     ................
  41a808:	fd649eb4 fd648c01 fd648e01 8df0b001     ..d...d...d.....
  41a818:	9c6caf9e 9e198d61 8d699c74 9c7c9e39     ..l.a...t.i.9.|.
  41a828:	f1598d71 28ad9f8f fd5401fd 01fd7c01     q.Y....(..T..|..
  41a838:	c5c2ac8e 9d8df0c7 502804a8 af9888f1     ..........(P....
  41a848:	1e9b8f09 d820a898 b4b1b8f1 84bcbcbc     ...... .........
  41a858:	c187c7af bcc183b3 af9f8fb0 28f4da49     ............I..(
  41a868:	91f5d8a7 fc9ff17a 90db03c0 d900c0fc     ....z...........
  41a878:	d8f8dea1 d8b728f4 f17291f5 03c0fc9f     .....(....r.....
  41a888:	dfdea1d9 d8dfdea0 f9f8a1f1 f8daa0d1     ................
  41a898:	80d8fad9 db11af90 fc91dea1 a1d904c1     ................
  41a8a8:	dea0dff8 af9080d8 dea0d939 d8dfa1df     ........9.......
  41a8b8:	bcbcbcf1 bebdbdbd f1d8bebe a6b9b5b1     ................
  41a8c8:	a4bb8af8 b9c5a0c3 21af9686 3130f4d9     ...........!..01
  41a8d8:	dea6f1d8 dfdfdea1 dfdfdea0 acdeabdf     ................
  41a8e8:	bb8cb3de a0c4d0a4 beb8c6d0 a983bebe     ................
  41a8f8:	bcbcf2c1 c581c382 bcb0f1f8 fc9bbdbd     ................
  41a908:	bdb403c1 8429f4d9 deaaf1d8 00c1fc99     ......).........
  41a918:	dbfaaad9 39a99a8a d8f8deaa 9289a2f5     .......9........
  41a928:	fc92f13a dfda03c0 82a2fad9 aadf31db     :............1..
  41a938:	99d8f8de d903c1fc f2d8dfaa 71a99989     ...............q
  41a948:	f141dedb d8f8deaa 04c0fc9a 98dea8db     ..A.............
  41a958:	f800c1fc bcb1f1d8 beb9bdb5 19af9487     ................
  41a968:	c6a183d9 d87a2cf4 af9f82f1 03fd28df     .....,z......(..
  41a978:	04fd30df 82349f8f dea91d38 f4daf8d9     .0....4.8.......
  41a988:	f1d8eb2a 51af9782 c7a083d9 c2d0a783     *......Q........
  41a998:	d81c2af4 af9282f1 2af4da59 b3f5d81c     .*......Y..*....
  41a9a8:	1a99b783 d1f9f8f1 f4b5b1da f5d81c2a     ............*...
  41a9b8:	f9f8f13a b5b1dad1 d81c2af4 bcbcb0f1     :........*......
  41a9c8:	c1af88bc c7c589f2 bcb1f9f9 8ff2b9b5     ................
  41a9d8:	d971af9f c6a083f1 a4bb8cb3 d0a0c4d0     ..q.............
  41a9e8:	d8b9b1c6 c6ac83f1 c4d0a783 bcbcf1d8     ................
  41a9f8:	f3c3af81 b3f2c38b c581c282 bcb1f1f9     ................
  41aa08:	af9f83bc 9e8fdb09 c7a18331 ded0dfa0     ........1.......
  41aa18:	01c2fc9f deaff2d9 8ff8f8f8 f1d941db     .............A..
  41aa28:	bb91b78e fd5cd0a2 d8b9b53f 21af938f     ......\.?......!
  41aa38:	c7a083db dfa1ded0 01c2fc9f deaff2d9     ................
  41aa48:	8ff8f8f8 f1d941db bb91b78e fd5cd0a2     .....A........\.
  41aa58:	d8b9b53f c2fc9ff1 2af4d901 bcf3d8ba     ?..........*....
  41aa68:	b1d0afbc b0f1c48c c5af8abc 9380bcb1     ................
  41aa78:	d9d139af f9f8d0f3 9ff1d1db f204c1fc     .9..............
  41aa88:	59af9f8f 83dfa0f1 f1d8c6d0 83ded0a1     ...Y............
  41aa98:	db69af90 2af46991 8ff2d8d4 f1d9719f     ..i..i.*.....q..
  41aaa8:	c6d0a183 9380f1d8 d9d119af d85a2bf4     .............+Z.
  41aab8:	d9d179f1 d85a2bf4 d8bb2cf4 af9d82f1     .y...+Z..,......
  41aac8:	2bf4da31 83f1d81c b6c7d0a0 04c2fc9d     1..+............
  41aad8:	deadbad9 8ab3d8f8 afbb92b7 a488b119     ................
  41aae8:	c7a0c5d9 c3a0c1da 5a2bf4d8 f8a1f1d8     ..........+Z....
  41aaf8:	f4dad1f9 f1d85a2b f9f8adba b983d9d1     ....+Z..........
  41ab08:	c6abc6a0 a4bb8db3 d0a0c4d0 5a2bf4c6     ..............+Z
  41ab18:	b983f1d8 b3c7d0a0 bb92b78a a4b119af     ................
  41ab28:	a0c389d9 c188dac5 f1d8c3a0 beba85b1     ................
  41ab38:	c784c2af b2c3c182 a7bdb6bc 928fdfdf     ................
  41ab48:	f4d901a7 f1d89c2b 2bf4d909 faf1d883     ....+......+....
  41ab58:	d8cb2bf4 f4d951f1 f1d8902b cb2bf4fa     .+...Q..+.....+.
  41ab68:	d919f1d8 fadaf8d0 cb2bf4d8 2193f1d8     ..........+....!
  41ab78:	b02bf4d9 d909f1d8 fadaf8d0 cb2bf4d8     ..+...........+.
  41ab88:	d971f1d8 2bf4f8d0 59f1d8cb f4f8d0d9     ..q....+...Y....
  41ab98:	f1d8cb2b d0d90194 d8fadaf8 bcbcb0f1     +...............
  41aba8:	b1c0a788 c1d089bc c5d0af82 bdb5bcb2     ................
  41abb8:	00c1fc9b bdbdbdb6 c3fc97db 00c0fc04     ................
  41abc8:	d904c2fc dff8dfa7 948ff1d8 f4d971a7     .............q..
  41abd8:	f1d8142c f4d94195 f1d8142c 39db0994     ,....A..,......9
  41abe8:	f8dfdfd9 fc97f1d8 bcb104c1 b983bcbc     ................
  41abf8:	a0bebebe dedac6d9 04c2fcd8 dac7d9d0     ................
  41ac08:	b58ed8df 4caf9bbd fc9fbdbd f4d900c1     .......L........
  41ac18:	f0d8bb2c 9ab686b3 502cabbb aabaf178     ,.........,Px...
  41ac28:	b8c7c5c3 d1f9f8ad 8eb3deda d8c7abbb     ................
  41ac38:	9bb78eb3 d969a7ba 90b583b1 b9d1db79     ......i.....y...
  41ac48:	a1dfd0a0 f4d8c6d0 f1d8bb2c b981bcb0     ........,.......
  41ac58:	88b0c0af b1c187c1 b5bcbcbc fc9bbdbd     ................
  41ac68:	bdbd00c1 c0fc9fdb 2d9e8f04 d9319f8d     ...........-..1.
  41ac78:	a083dea1 f8deafc6 f59f83b3 fcdbf106     ................
  41ac88:	b8d904c1 f8dfa1be d8bebebe b789b3f5     ................
  41ac98:	66a9bb93 f102af8b 03c0fc9f d0a98fd9     ...f............
  41aca8:	9989d8c0 deaf34a3 9f83f5f8 c1fcf106     .....4..........
  41acb8:	7195db04 d8ded0a2 a1b98db0 b48fc7d0     ...q............
  41acc8:	d911af9f d8c7d0a1 bb89b3f1 f5f9c6af     ................
  41acd8:	0693b78f c1fc9ff1 a983db03 dea3d8c0     ................
  41ace8:	ded0a0b9 f9f8aaba 2df4dad1 b9f1d88e     ...........-....
  41acf8:	83afb5b1 69db6190 f4699179 f1d8852d     .....a.iy.i.-...
  41ad08:	faa0f8df afd9d1f9 8cafd8df dfd96995     .............i..
  41ad18:	9c85afd8 fc9fdb31 f4da00c1 f1d8622d     ....1.......-b..
  41ad28:	c6d0a083 119e8aaf d0a0d9f8 d8489c80     ..............H.
  41ad38:	f1d8deaa 95b785b3 b5b171af ded0a0d9     .........q......
  41ad48:	af83f1d8 948ff8c6 fc90db1d d0a000c0     ................
  41ad58:	2df4d8de 61f1d88e ded9aad1 f1d8f8da     ...-...a........
  41ad68:	a4bb88b1 d0a0c5d0 fc90b5c7 b2d900c2     ................
  41ad78:	d0a4c68e deaebac5 d8bd2df4 9fb484f1     .........-......
  41ad88:	da69a7ba 2df4f8ae aef1d8bd b1f1d8de     ..i....-........
  41ad98:	bb9eb581 94b702af b581b326 b702a19d     ........&.......
  41ada8:	918f2690 b12c00a1 12af9480 b36e5e26     .&....,.....&^n.
  41adb8:	42a29280 8f3e760e 542c00a2 f8deaf7c     ...B.v>...,T|...
  41adc8:	af998ff5 fc9ff106 8ad903c1 83d8c4aa     ................
  41add8:	d951af92 d84b2ef4 ded0a2f1 c0fc9eb6     ..Q...K.........
  41ade8:	c1fcdb09 aeb8d90a deaebade f4bbb7fa     ................
  41adf8:	f1d84b2e f8deaeb8 f3dfaeba bdbdbcbc     .K..............
  41ae08:	b4b0bebe dafbafbb 8dd0a4b8 e2f11d94     ................
  41ae18:	bcbcf1d8 bebebdbd d8bbb7b3 af928af1     ................
  41ae28:	2ef4d919 bcf3d88f c38bb1bc f8b3bcbc     ................
  41ae38:	f4d9d1f9 f1d87d2e d941918e d87d2ef4     .....}....A...}.
  41ae48:	a39389f1 a28160c6 2ff4c7d0 a3f1d80a     .....`...../....
  41ae58:	f8f8f8de f8f8f8f8 c6aa8bf8 d80a2ff4     ............./..
  41ae68:	c6aa81f1 b160609a af93b581 d1b7b359     .....``.....Y...
  41ae78:	0a2ff4d9 928af1d8 a3da21af d8deadf8     ../......!......
  41ae88:	85c5aa81 d921af91 d8e52ef4 a2dfa1f1     ......!.........
  41ae98:	9581dfdf 8968c7a5 60c6a393 deaff8ad     ......h....`....
  41aea8:	9f89f5f8 c1fcf106 9d8ddb03 dea321af     .............!..
  41aeb8:	2ff4d8f8 81f1d80a af92c5a5 f8a3da49     .../........I...
  41aec8:	af91d8f8 f8a3da49 d8f8f8f8 f9f8a3f1     ....I...........
  41aed8:	83b1d9d1 c6d0a1b9 f5d8bbb3 1aaf9a83     ................
  41aee8:	aeb8bef1 9eb589c1 bc3ffd74 348bb1bc     ........t.?....4
  41aef8:	c0fc9fb7 bcbcbc00 d9b4bdb0 d8642ff4     ............./d.
  41af08:	86f8a6f1 d911ae96 be88dfa6 c4d0a9bb     ................
  41af18:	c6d0a1f2 bec6d0a2 f1dbbebe 01c3fc9e     ................
  41af28:	a1bef2d9 f8f8f8d0 f8f8d0a2 bebebef8     ................
  41af38:	a22ff4d8 fc9ef1d8 f5d901c3 f132ae8e     ../...........2.
  41af48:	01c0fcdb a9bbbe88 a1f2c4d0 d0a2c6d0     ................
  41af58:	bebebec6 d8a22ff4 86faa6f1 d939ae96     ...../........9.
  41af68:	be87dea6 c4d0a9bb c6d0a1f2 bec6d0a2     ................
  41af78:	f1d8bebe b3bcbcbc b7bdbdbd bbbebebe     ................
  41af88:	d1f9f8a5 c3a786da dea5c7c5 c6d0a585     ................
  41af98:	af9585d8 2ff4da71 89f1d8e2 f360a393     ....q../......`.
  41afa8:	f8afbebe f3dad1f9 bef1d8e2 c3a786be     ................
  41afb8:	f1d8c7c5 89f9dfaf 0d832d9f 1aaf99f5     .........-......
  41afc8:	a89f7e8f f12e9912 dfafdfdf 4d9f89f9     .~.............M
  41afd8:	9bf50d83 668f02af c0fc9ff1 a8f5d903     .......f........
  41afe8:	369912d0 9888f1d8 38a710a6 deaf9f86     ...6.......8....
  41aff8:	8708fd00 aef38f00 bcbcf1c0 bcc382b1     ................
  41b008:	bcf3d8bc bebdbdbc b7b3bbbe f8f2f8a2     ................
  41b018:	ad9d80f1 a2f27cd0 f1d1f9fa ded9acb9     .....|..........
  41b028:	f5d8f8da a7babebe 8e789585 bcbc7c9e     ..........x..|..
  41b038:	b6b2bdbd 9989a9f1 4097f062 48976c99     ........b..@.l.H
  41b048:	f1b5b1b9 289180af 83009f8c 30f4d965     .......(....e..0
  41b058:	9df1d894 af04c3fc c3d989b2 c3c1dac1     ................
  41b068:	5575f4d8 bebef2d8 bdbdbcbc a6b7b3b9     ..uU............
  41b078:	f9499281 8cb1f1db d9219cb5 b785b3f5     ..I.......!.....
  41b088:	9e8e7895 8db1f17c 1aad9db5 9d4096f0     .x..|.........@.
  41b098:	d848963c b581b1f1 0aa6b99d d905968d     <.H.............
  41b0a8:	d8fb30f4 b781b3f2 49afbb92 f1dbf9f9     .0.........I....
  41b0b8:	9cb58cb1 f421a6b9 f1d8fb30 a8bb8eb3     ......!.0.......
  41b0c8:	f3c7c4d0 ded0acb9 d80c31f4 bb85b3f1     .........1......
  41b0d8:	c7c4d0a8 d0acb9f3 f8dff8de 9cb5f3d8     ................
  41b0e8:	db04c3fc d900c2fc ded0acf2 afbbf2d8     ................
  41b0f8:	82b392b7 dfa2db19 acc4d0a1 a7f3c5d0     ................
  41b108:	b9f1dfd0 dfa1deaa c1fc9bb5 a7beb800     ................
  41b118:	bebeded0 bbf1d8be 98b789af d980a919     ................
  41b128:	89afd838 da80a939 f8a1d83c f9dad1f9     8...9...<.......
  41b138:	75f4f8df d8fff13d f5882eaf d8ffda75     ...u=.......u...
  41b148:	fff1da71 f3a782d8 c280f2c1 498697f1     q..............I
  41b158:	50d0a62e 75af8696 d0a288d9 f1c3c0f3     ...P...u........
  41b168:	a2968fda c3c2f3d0 709bb682 b7d8f170     ...........pp...
  41b178:	89f9dfaf 8010af99 2eda219f af9989d8     .........!......
  41b188:	d8dfda31 f39282af dff1d941 f382afd8     1.......A.......
  41b198:	dff1d919 9089f1d8 8f09d0af db51af99     ..............Q.
  41b1a8:	82f33189 b1f21992 719cb58c f9dff1d9     .1.........q....
  41b1b8:	d0acb9f2 dff3f8f8 bbb7b3d8 c0f3ac82     ................
  41b1c8:	f12280a2 9f2622a9 acda29af a2d8ffde     ..".."&..)......
  41b1d8:	a9f1def2 b882f2df 81c3a9be f1bcb0c5     ................
  41b1e8:	c1fc9bb5 d9bdb403 d83332f4 a99989f2     .........23.....
  41b1f8:	32f4da49 9af1d833 a704c0fc 9788d9d0     I..23...........
  41b208:	d8deda30 80b1bcf1 bebebebb c18cc2af     0...............
  41b218:	c783c381 8fb3bcbc bdbdbdb7 61a7ba9f     ...............a
  41b228:	ff7169db adbbf1d8 b1f8ded0 ba96b684     .iq.............
  41b238:	b77ed0a7 b201a796 db059d87 97b68db3     ..~.............
  41b248:	8cb1f379 bbf14996 d8f8d0ad d0acb9f3     y....I..........
  41b258:	d9d1f9f8 d0adbbf1 b7b3d8f8 af8c97bb     ................
  41b268:	f4d979f3 f1d8a632 349d81a1 508ad0aa     .y..2......4...P
  41b278:	f43d75f4 f3d8c632 b5fad0a7 07c2fc9c     .u=.2...........
  41b288:	b7d8f8d9 79af8c97 9187f1da d0aa6ca1     .......y.....l..
  41b298:	f4bb709a f1d83d75 0ac1fc91 0733f4d9     .p..u=........3.
  41b2a8:	a181f1d8 f8dff9c2 a6ba9d80 31fd38d0     .............8.1
  41b2b8:	f3deafbb 8ff1ce82 0ffd0890 d9659f8d     ..............e.
  41b2c8:	d80733f4 f2deaff1 82f2ce8c f1d9259f     .3...........%..
  41b2d8:	ded0a6ba d8ce8df3 fc9bb5f1 bcd903c1     ................
  41b2e8:	33f4bebd b8f1d83b ded0aabe b781b3f2     ...3;...........
  41b2f8:	d949a992 33f4bdbc bcf1d83b 8db4b0bd     ..I....3;.......
  41b308:	f9f93197 d9f9f9f9 d8f8d0aa bdbcbcf1     .1..............
  41b318:	b0bebebd c3a5b884 a483c7c5 f0c7c5c3     ................
  41b328:	91b681b2 0c113ca3 f1502c58 93b483b0     .....<..X,P.....
  41b338:	7c542ca3 95f07192 78502cae aab9be8e     .,T|.q...,Px....
  41b348:	d8bdbcc2 b7b3bbf2 31af9182 df33f4da     ...........1..3.
  41b358:	b78df1d8 40a6bb96 0c9c8cac 9d8dba30     .......@....0...
  41b368:	f3db39a7 96b68cb1 84f1d949 a4b994b5     .9......I.......
  41b378:	b7f05ed0 f1d8389d a7ba8db3 fc9cb5c6     .^...8..........
  41b388:	b1d904c2 a797b681 816e8b25 da34a1b9     ........%.n...4.
  41b398:	97b687b2 b13efd00 4e8b2581 34a1b981     ......>..%.N...4
  41b3a8:	aabbf1d8 deacdfd0 d0added0 d8fff1df     ................
  41b3b8:	afb7b3f2 db399c82 099086f1 9d8ad0aa     ......9.........
  41b3c8:	33f474d9 aaf1dafa f3d8dfd0 f8d0acb9     .t.3............
  41b3d8:	f2d9d1f9 f8faa2bb a2bbf2da b3f2d8fa     ................
  41b3e8:	bb9bb682 f1db31af 619ab589 d0a1f2d9     .....1.....a....
  41b3f8:	f2d8f8f8 f8c4af82 8ff8f8f8 da1591b7     ................
  41b408:	d8c0d0a1 f9c2af82 b9f1d9d1 deaddeac     ................
  41b418:	dfa1b9df dfd0adbb 9182f2d8 f1da31af     .............1..
  41b428:	b99d81b1 f2d83ca1 9182bbb3 d9d131af     .....<.......1..
  41b438:	b581b1f1 3ea1b99b 8cb3f1d8 acbb9cb7     .......>........
  41b448:	deac10d0 92dfd0ad caf1af82 f13591f2     ..............5.
  41b458:	d9a68f96 8aafdb00 a6d96d90 8a01968f     .........m......
  41b468:	dfd0aa60 d0ac81f2 fff1d8c5 b1b9f0d8     `...............
  41b478:	928dafb6 6854714c 7944605c baf1d8e0     ....LqTh\`Dy....
  41b488:	c08fa4b1 b9c7c5c3 82aaf1b5 adf32590     .............%..
  41b498:	f8f8d9df 81a1f1d8 8234f091 2daaf138     ..........4.8..-
  41b4a8:	30908af5 faadf3d9 8faaf0d8 5128049f     ...0..........(Q
  41b4b8:	14301d79 bcbcbc38 9a8ad0a2 7850502c     y.0.8.......,PPx
  41b4c8:	9082bc78 f37cf5aa d8faadd9 82aeb8f1     x.....|.........
  41b4d8:	81a1b9c6 92810a90 81d0a218 fbadf3c1     ................
  41b4e8:	a2daf1f9 a2d8dfd0 d1f9fad0 9d82aada     ................
  41b4f8:	8aad767e f05c31d0 549d8daa f17ffd78     ~v...1\....Tx...
  41b508:	9d55928a 7e72d0ad 9c74f4d8 b1f1d8e0     ..U...r~..t.....
  41b518:	d0a282b9 faa3f2c2 f8a7b8f3 f2dad1f9     ................
  41b528:	b3bbd8e2 afb1f1e0 85319f8f c6dad0a5     ..........1.....
  41b538:	d87235f4 d1f9f8f1 adf5c6d9 7f9e8dd0     .5r.............
  41b548:	f1d8f9da 97b6f1e0 93b766a7 607171f0     .........f...qq`
  41b558:	2901f0e0 f1e07951 b2c7c5c2 2c97b687     ...)Qy.........,
  41b568:	f1e001fd b2c7c5c2 f1e0c187 669781b2     ...............f
  41b578:	1038f0e0 e0884028 597024f0 64386944     ..8.(@...$pYDi8d
  41b588:	512d3148 24f0e079 34403d58 e0512d49     H1-Qy..$X=@4I-Q.
  41b598:	00a187f1 f07c542c 2804a781 7ffd7850     ....,T|....(Px..
  41b5a8:	9687a7f1 02a19159 e01e160e bebef0d8     ....Y...........
  41b5b8:	bcbcbcbe b3bdbdbd f4ac8cbb ad8d5978     ............xY..
  41b5c8:	8e5978f4 5978f4ae ba80b0bc dfdef1af     .xY...xY........
  41b5d8:	c2f2d0df bcbcc5cb d08fb2bc f19eb5bd     ................
  41b5e8:	2603fd02 fd4603fd bdbdbd03 afbb90b5     ...&..F.........
  41b5f8:	5028f002 f0911ef1 16f14820 409238f0     ..(P.... H...8.@
  41b608:	f28fb7b3 c2adc0ac a9f1c4ae d9d1f9fa     ................
  41b618:	d84a36f4 f4faa9f1 f0d81c38 ba9c8cb7     .6J.....8.......
  41b628:	f12878f4 9d8db3c1 2878f4ba 8eb31cf1     .x(.......x(....
  41b638:	78f4ba9e b31cf128 3efdd78f 8ec18df2     ...x(......>....
  41b648:	d58ff1c1 d0d430fd d0f170fd 00f0d22a     .....0...p..*...
  41b658:	8fdea9d2 f5af97b5 a9f2d940 af97d8f8     ........@.......
  41b668:	f3d948f5 f2d8f8a9 d4f8deaf 8fb70cfd     .H..............
  41b678:	f4da059d f2d8c336 f8de97b5 0efd37d0     ....6........7..
  41b688:	8d0efd3f 05d09fb7 d8f8a9d9 a9d90daf     ?...............
  41b698:	d8d8f8f3 f8deaff2 8f0cfdd4 f4da059e     ................
  41b6a8:	f2d8ee36 f8de97b5 0efd37d0 8e0efd3f     6........7..?...
  41b6b8:	05d09fb7 d8f8a9d9 a9d90daf f1d8f8f3     ................
  41b6c8:	f2deaf8c d4f08fc0 f59f30fd 0488b100     .........0......
  41b6d8:	f8f2a9d9 24aff5d8 f8f3a9d9 b3aff0d8     .......$........
  41b6e8:	8fc7c489 40fdd4d0 b140fdd5 44f5d088     .......@..@....D
  41b6f8:	f8f2a9d9 6cf5afd8 f8f3a9d9 b58fb3d8     .......l........
  41b708:	60aff599 f4f8aad9 f1d84537 9fb78ab1     ...`....7E......
  41b718:	aad959af b3f5d8de af99b58f faaad968     .Y..........h...
  41b728:	d8dfaada d4af8af1 fdd500fd f5d08f40     ............@...
  41b738:	d9d0a914 d8f8dade d0a93caf fadadfd9     .........<......
  41b748:	af8af1d8 d700fdd6 9a8f40fd a904f5d0     .........@......
  41b758:	d8f8f2d9 a92cf5af d8f8f3d9 c0f2af8c     ......,.........
  41b768:	fdd48ff1 029fb730 10d01efd f8f8deaf     ....0...........
  41b778:	f8f8f8f8 93bdbdbd bdf102f5 dad1f9f8     ................
  41b788:	d8bd37f4 9f8ab1f1 37f4da59 b1f1d8d3     .7......Y..7....
  41b798:	51af9f8b d337f4da 9bb5f1d8 d9418fb3     ...Q..7.......A.
  41b7a8:	d8f8f2a9 9fb7aff1 da798ab1 d8f237f4     ..........y..7..
  41b7b8:	da718bf1 d8f237f4 b39bb5f1 a9d9498f     ..q..7.......I..
  41b7c8:	f0d8f8f3 f9f9f2a9 f9f9f9f9 f0d0aaf9     ................
  41b7d8:	e2f5deda d8f8d9f0 f9f9f3a9 f9f9f9f9     ................
  41b7e8:	f0d0aaf9 e2f6dfda d8fad9f0 b0bcf0d8     ................
  41b7f8:	90b4bd80 e0a0b8be 11f2aff0 3d15f33d     ............=..=
  41b808:	d08fb2f2 dff3cfcd f1dfdfdf d570fdd4     ..............p.
  41b818:	fdd670fd 70fdd770 100c9fb6 b500f518     .p..p..p........
  41b828:	bb18f596 9fb7d0af f3d0f0e0 d0ccf2cf     ................
  41b838:	caf2cdf3 f2cbf3d0 c9f3d0c8 000000e0     ................

0041b848 <cfg_mounting_matrix>:
  41b848:	3f800000 00000000 00000000 00000000     ...?............
  41b858:	3f800000 00000000 00000000 00000000     ...?............
  41b868:	3f800000 64616f4c 504d4420 6d692033     ...?Load DMP3 im
  41b878:	00656761 324d4349 38343930 4f485720     age.ICM20948 WHO
  41b888:	20494d41 756c6176 78303d65 78323025     AMI value=0x%02x
  41b898:	00000000 20646142 414f4857 7620494d     ....Bad WHOAMI v
  41b8a8:	65756c61 6f47202e 78302074 78323025     alue. Got 0x%02x
  41b8b8:	0000002e 74747550 20676e69 326d6349     ....Putting Icm2
  41b8c8:	38343930 206e6920 65656c73 6f6d2070     0948 in sleep mo
  41b8d8:	2e2e6564 0000002e 74696e49 696c6169     de......Initiali
  41b8e8:	6974617a 66206e6f 656c6961 45202e64     zation failed. E
  41b8f8:	726f7272 616f6c20 676e6964 504d4420     rror loading DMP
  41b908:	2e2e2e33 00000000 746f6f42 20676e69     3.......Booting 
  41b918:	69207075 30326d63 2e383439 00002e2e     up icm20948.....
  41b928:	706d6f43 20737361 20746f6e 65746564     Compass not dete
  41b938:	64657463 002e2e2e 72276557 6f672065     cted....We're go
  41b948:	7420646f 6f67206f 00002120 203a7325     od to go !..%s: 
  41b958:	6f727265 64252072 73252820 00000029     error %d (%s)...
  41b968:	69766544 6d456563 61725764 72657070     DeviceEmdWrapper
  41b978:	6e75203a 65707865 64657463 63617020     : unexpected pac
  41b988:	2074656b 65636572 64657669 6749202e     ket received. Ig
  41b998:	65726f6e 00002e64 77646469 70706172     nored...iddwrapp
  41b9a8:	705f7265 6f746f72 5f6c6f63 6e657665     er_protocol_even
  41b9b8:	62635f74 6e65203a 65646f63 72726520     t_cb: encode err
  41b9c8:	202c726f 70736572 65736e6f 6f726420     or, response dro
  41b9d8:	64657070 00000000 4f525245 76652052     pped....ERROR ev
  41b9e8:	20746e65 68746977 6c617620 25206575     ent with value %
  41b9f8:	65722064 76696563 66206465 206d6f72     d received from 
  41ba08:	57646449 70706172 74207265 736e6172     IddWrapper trans
  41ba18:	74726f70 00000000 506e7944 6f746f72     port....DynProto
  41ba28:	5f6c6f63 636f7270 50737365 7942746b     col_processPktBy
  41ba38:	25286574 29783230 74657220 656e7275     te(%02x) returne
  41ba48:	64252064 00000000 736e6573 655f726f     d %d....sensor_e
  41ba58:	746e6576 3a62635f 636e6520 2065646f     vent_cb: encode 
  41ba68:	6f727265 66202c72 656d6172 6f726420     error, frame dro
  41ba78:	64657070 00000000 69766544 6d456563     pped....DeviceEm
  41ba88:	61725764 72657070 6572203a 76696563     dWrapper: receiv
  41ba98:	63206465 616d6d6f 7320646e 70757465     ed command setup
  41baa8:	00000000 69766544 6d456563 61725764     ....DeviceEmdWra
  41bab8:	72657070 6572203a 76696563 63206465     pper: received c
  41bac8:	616d6d6f 7220646e 74657365 00000000     ommand reset....
  41bad8:	69766544 6d456563 61725764 72657070     DeviceEmdWrapper
  41bae8:	6572203a 76696563 63206465 616d6d6f     : received comma
  41baf8:	7020646e 28676e69 00297325 69766544     nd ping(%s).Devi
  41bb08:	6d456563 61725764 72657070 6572203a     ceEmdWrapper: re
  41bb18:	76696563 63206465 616d6d6f 7320646e     ceived command s
  41bb28:	5f666c65 74736574 29732528 00000000     elf_test(%s)....
  41bb38:	69766544 6d456563 61725764 72657070     DeviceEmdWrapper
  41bb48:	6572203a 76696563 63206465 616d6d6f     : received comma
  41bb58:	7320646e 74726174 29732528 00000000     nd start(%s)....
  41bb68:	69766544 6d456563 61725764 72657070     DeviceEmdWrapper
  41bb78:	6572203a 76696563 63206465 616d6d6f     : received comma
  41bb88:	7320646e 28706f74 00297325 69766544     nd stop(%s).Devi
  41bb98:	6d456563 61725764 72657070 6572203a     ceEmdWrapper: re
  41bba8:	76696563 63206465 616d6d6f 7320646e     ceived command s
  41bbb8:	705f7465 6f697265 64252864 29737520     et_period(%d us)
  41bbc8:	00000000 69766544 6d456563 61725764     ....DeviceEmdWra
  41bbd8:	72657070 6572203a 76696563 63206465     pper: received c
  41bbe8:	616d6d6f 7320646e 735f7465 6f736e65     ommand set_senso
  41bbf8:	6f635f72 6769666e 29732528 00000000     r_config(%s)....
  41bc08:	69766544 6d456563 61725764 72657070     DeviceEmdWrapper
  41bc18:	6572203a 76696563 63206465 616d6d6f     : received comma
  41bc28:	6320646e 6e61656c 00007075 666c6553     nd cleanup..Self
  41bc38:	7365742d 61682074 6c612073 64616572     -test has alread
  41bc48:	75722079 53202e6e 7070696b 2e676e69     y run. Skipping.
  41bc58:	00000000 6e6e7552 20676e69 666c6573     ....Running self
  41bc68:	7365742d 2e2e2e74 00000000 666c6553     -test.......Self
  41bc78:	7365742d 61662074 72756c69 00212065     -test failure !.
  41bc88:	20525947 73616962 53462820 3035323d     GYR bias (FS=250
  41bc98:	29737064 70642820 203a2973 66253d78     dps) (dps): x=%f
  41bca8:	3d79202c 202c6625 66253d7a 00000000     , y=%f, z=%f....
  41bcb8:	20434341 73616962 53462820 2967323d     ACC bias (FS=2g)
  41bcc8:	29672820 3d78203a 202c6625 66253d79      (g): x=%f, y=%f
  41bcd8:	3d7a202c 00006625 000e1000 000000c0     , z=%f..........
  41bce8:	00000800 00000000 001e8480 000000c0     ................
  41bcf8:	00000800 00000000                       ........

0041bd00 <AK09916_ST_Lower>:
  41bd00:	ff38ff38 0000fc18                       8.8.....

0041bd08 <AK09916_ST_Upper>:
  41bd08:	00c800c8 0000ff38                       ....8...

0041bd10 <sSelfTestEquation>:
  41bd10:	0a560a3c 0a8b0a70 0ac10aa6 0af80add     <.V.p...........
  41bd20:	0b310b15 0b6b0b4e 0ba50b88 0be10bc3     ..1.N.k.........
  41bd30:	0c1e0c00 0c5d0c3d 0c9c0c7c 0cdd0cbd     ....=.].|.......
  41bd40:	0d1f0cfe 0d630d41 0da80d85 0dee0dcb     ....A.c.........
  41bd50:	0e360e12 0e7f0e5a 0eca0ea4 0f160eef     ..6.Z...........
  41bd60:	0f630f3c 0fb30f8b 10030fdb 1056102c     <.c.........,.V.
  41bd70:	10aa1080 110010d4 1157112b 11b01183     ........+.W.....
  41bd80:	120b11de 12681239 12c71297 132712f7     ....9.h.......'.
  41bd90:	138a1359 13ef13bc 14551422 14be1489     Y.......".U.....
  41bda0:	152914f3 1595155f 160415cd 1676163d     ..)._.......=.v.
  41bdb0:	16e916af 175f1724 17d8179b 18521815     ....$._.......R.
  41bdc0:	18cf1891 194f190f 19d11990 1a561a13     ......O.......V.
  41bdd0:	1ade1a9a 1b681b22 1bf51bae 1c851c3d     ....".h.....=...
  41bde0:	1d181cce 1dad1d62 1e461df9 1ee21e94     ....b.....F.....
  41bdf0:	1f811f31 20231fd1 20c82075 2171211c     1.....# u . .!q!
  41be00:	221d21c7 22cd2274 23802326 243623da     .!."t"."&#.#.#6$
  41be10:	24f12493 25af254f 2671260f 273626d3     .$.$O%.%.&q&.&6'
  41be20:	2800279b 28ce2867 29a02936 2a762a0b     .'.(g(.(6).).*v*
  41be30:	2b512ae3 2c302bc0 2d132ca1 2dfb2d86     .*Q+.+0,.,.-.-.-
  41be40:	2ee82e71 2fd92f60 30cf3053 31ca314c     q...`/./S0.0L1.1
  41be50:	32ca324a 33d0334c 34da3454 35ea3562     J2.2L3.3T4.4b5.5
  41be60:	37003674 381b378d 393c38aa 3a6239ce     t6.7.7.8.8<9.9b:
  41be70:	3b8f3af8 3cc13c27 3dfa3d5d 3f383e98     .:.;'<.<]=.=.>8?
  41be80:	407e3fda 41ca4123 431c4272 447643c8     .?~@#A.ArB.C.CvD
  41be90:	45d64525 473d4689 48ac47f4 4a224966     %E.E.F=G.G.HfI"J
  41bea0:	4b9f4adf 4d244c61 4eb14dea 50464f7b     .J.KaL$M.M.N{OFP
  41beb0:	51e35114 538952b5 5536545e 56ed5611     .Q.Q.R.S^T6U.V.V
  41bec0:	58ac57cb 5a74598f 5c465b5c 5e215d32     .W.X.YtZ\[F\2]!^
  41bed0:	60055f12 61f360fb 63eb62ee 65ed64eb     ._.`.`.a.b.c.d.e
  41bee0:	67fa66f2 6a116904 6c336b20 6e5f6d48     .f.g.i.j k3lHm_n
  41bef0:	70976f7a 72db71b8 752a7401 77857656     zo.p.q.r.t*uVv.w
  41bf00:	79ec78b7 7c5f7b24 7edf7d9d 00008024     .x.y${_|.}.~$...
  41bf10:	02020101 04080304 05100620 00000000     ........ .......
  41bf20:	534e4553 525f524f 52455345 00444556     SENSOR_RESERVED.
  41bf30:	534e4553 525f524f 52455345 5f444556     SENSOR_RESERVED_
  41bf40:	00005557 534e4553 415f524f 4c454343     WU..SENSOR_ACCEL
  41bf50:	4d4f5245 52455445 00000000 534e4553     EROMETER....SENS
  41bf60:	415f524f 4c454343 4d4f5245 52455445     OR_ACCELEROMETER
  41bf70:	0055575f 534e4553 4d5f524f 454e4741     _WU.SENSOR_MAGNE
  41bf80:	454d4f54 00524554 534e4553 4d5f524f     TOMETER.SENSOR_M
  41bf90:	454e4741 454d4f54 5f524554 00005557     AGNETOMETER_WU..
  41bfa0:	534e4553 4f5f524f 4e454952 49544154     SENSOR_ORIENTATI
  41bfb0:	00004e4f 534e4553 4f5f524f 4e454952     ON..SENSOR_ORIEN
  41bfc0:	49544154 575f4e4f 00000055 534e4553     TATION_WU...SENS
  41bfd0:	475f524f 534f5259 45504f43 00000000     OR_GYROSCOPE....
  41bfe0:	534e4553 475f524f 534f5259 45504f43     SENSOR_GYROSCOPE
  41bff0:	0055575f 534e4553 4c5f524f 54484749     _WU.SENSOR_LIGHT
  41c000:	00000000 534e4553 4c5f524f 54484749     ....SENSOR_LIGHT
  41c010:	0055575f 534e4553 505f524f 53534552     _WU.SENSOR_PRESS
  41c020:	00455255 534e4553 505f524f 53534552     URE.SENSOR_PRESS
  41c030:	5f455255 00005557 534e4553 545f524f     URE_WU..SENSOR_T
  41c040:	45504d45 55544152 00004552 534e4553     EMPERATURE..SENS
  41c050:	545f524f 45504d45 55544152 575f4552     OR_TEMPERATURE_W
  41c060:	00000055 534e4553 505f524f 49584f52     U...SENSOR_PROXI
  41c070:	5954494d 00000000 534e4553 505f524f     MITY....SENSOR_P
  41c080:	49584f52 5954494d 0055575f 534e4553     ROXIMITY_WU.SENS
  41c090:	475f524f 49564152 00005954 534e4553     OR_GRAVITY..SENS
  41c0a0:	475f524f 49564152 575f5954 00000055     OR_GRAVITY_WU...
  41c0b0:	534e4553 4c5f524f 41454e49 43415f52     SENSOR_LINEAR_AC
  41c0c0:	454c4543 49544152 00004e4f 534e4553     CELERATION..SENS
  41c0d0:	4c5f524f 41454e49 43415f52 454c4543     OR_LINEAR_ACCELE
  41c0e0:	49544152 575f4e4f 00000055 534e4553     RATION_WU...SENS
  41c0f0:	525f524f 5441544f 5f4e4f49 54434556     OR_ROTATION_VECT
  41c100:	0000524f 534e4553 525f524f 5441544f     OR..SENSOR_ROTAT
  41c110:	5f4e4f49 54434556 575f524f 00000055     ION_VECTOR_WU...
  41c120:	534e4553 485f524f 44494d55 00595449     SENSOR_HUMIDITY.
  41c130:	534e4553 485f524f 44494d55 5f595449     SENSOR_HUMIDITY_
  41c140:	00005557 534e4553 415f524f 4549424d     WU..SENSOR_AMBIE
  41c150:	545f544e 45504d45 55544152 00004552     NT_TEMPERATURE..
  41c160:	534e4553 415f524f 4549424d 545f544e     SENSOR_AMBIENT_T
  41c170:	45504d45 55544152 575f4552 00000055     EMPERATURE_WU...
  41c180:	534e4553 555f524f 4c41434e 47414d5f     SENSOR_UNCAL_MAG
  41c190:	4f54454e 4554454d 00000052 534e4553     NETOMETER...SENS
  41c1a0:	555f524f 4c41434e 47414d5f 4f54454e     OR_UNCAL_MAGNETO
  41c1b0:	4554454d 55575f52 00000000 534e4553     METER_WU....SENS
  41c1c0:	475f524f 5f454d41 41544f52 4e4f4954     OR_GAME_ROTATION
  41c1d0:	4345565f 00524f54 534e4553 475f524f     _VECTOR.SENSOR_G
  41c1e0:	5f454d41 41544f52 4e4f4954 4345565f     AME_ROTATION_VEC
  41c1f0:	5f524f54 00005557 534e4553 555f524f     TOR_WU..SENSOR_U
  41c200:	4c41434e 5259475f 4f43534f 00004550     NCAL_GYROSCOPE..
  41c210:	534e4553 555f524f 4c41434e 5259475f     SENSOR_UNCAL_GYR
  41c220:	4f43534f 575f4550 00000055 534e4553     OSCOPE_WU...SENS
  41c230:	535f524f 0000444d 534e4553 535f524f     OR_SMD..SENSOR_S
  41c240:	575f444d 00000055 534e4553 535f524f     MD_WU...SENSOR_S
  41c250:	5f504554 45544544 524f5443 00000000     TEP_DETECTOR....
  41c260:	534e4553 535f524f 5f504554 45544544     SENSOR_STEP_DETE
  41c270:	524f5443 0055575f 534e4553 535f524f     CTOR_WU.SENSOR_S
  41c280:	5f504554 4e554f43 00524554 534e4553     TEP_COUNTER.SENS
  41c290:	535f524f 5f504554 4e554f43 5f524554     OR_STEP_COUNTER_
  41c2a0:	00005557 534e4553 475f524f 414d4f45     WU..SENSOR_GEOMA
  41c2b0:	4f525f47 49544154 565f4e4f 4f544345     G_ROTATION_VECTO
  41c2c0:	00000052 534e4553 475f524f 414d4f45     R...SENSOR_GEOMA
  41c2d0:	4f525f47 49544154 565f4e4f 4f544345     G_ROTATION_VECTO
  41c2e0:	55575f52 00000000 534e4553 485f524f     R_WU....SENSOR_H
  41c2f0:	54524145 5441525f 00000045 534e4553     EART_RATE...SENS
  41c300:	485f524f 54524145 5441525f 55575f45     OR_HEART_RATE_WU
  41c310:	00000000 534e4553 545f524f 5f544c49     ....SENSOR_TILT_
  41c320:	45544544 524f5443 00000000 534e4553     DETECTOR....SENS
  41c330:	545f524f 5f544c49 45544544 524f5443     OR_TILT_DETECTOR
  41c340:	0055575f 534e4553 575f524f 5f454b41     _WU.SENSOR_WAKE_
  41c350:	54534547 00455255 534e4553 575f524f     GESTURE.SENSOR_W
  41c360:	5f454b41 54534547 5f455255 00005557     AKE_GESTURE_WU..
  41c370:	534e4553 475f524f 434e414c 45475f45     SENSOR_GLANCE_GE
  41c380:	52555453 00000045 534e4553 475f524f     STURE...SENSOR_G
  41c390:	434e414c 45475f45 52555453 55575f45     LANCE_GESTURE_WU
  41c3a0:	00000000 534e4553 505f524f 5f4b4349     ....SENSOR_PICK_
  41c3b0:	475f5055 55545345 00004552 534e4553     UP_GESTURE..SENS
  41c3c0:	505f524f 5f4b4349 475f5055 55545345     OR_PICK_UP_GESTU
  41c3d0:	575f4552 00000055 534e4553 425f524f     RE_WU...SENSOR_B
  41c3e0:	00004341 534e4553 425f524f 575f4341     AC..SENSOR_BAC_W
  41c3f0:	00000055 534e4553 505f524f 00005244     U...SENSOR_PDR..
  41c400:	534e4553 505f524f 575f5244 00000055     SENSOR_PDR_WU...
  41c410:	534e4553 425f524f 00005332 534e4553     SENSOR_B2S..SENS
  41c420:	425f524f 575f5332 00000055 534e4553     OR_B2S_WU...SENS
  41c430:	335f524f 53495841 00000000 534e4553     OR_3AXIS....SENS
  41c440:	335f524f 53495841 0055575f 534e4553     OR_3AXIS_WU.SENS
  41c450:	455f524f 00005349 534e4553 455f524f     OR_EIS..SENSOR_E
  41c460:	575f5349 00000055 534e4553 4f5f524f     IS_WU...SENSOR_O
  41c470:	305f5349 00000000 534e4553 4f5f524f     IS_0....SENSOR_O
  41c480:	305f5349 0055575f 534e4553 525f524f     IS_0_WU.SENSOR_R
  41c490:	415f5741 4c454343 4d4f5245 52455445     AW_ACCELEROMETER
  41c4a0:	00000000 534e4553 525f524f 415f5741     ....SENSOR_RAW_A
  41c4b0:	4c454343 4d4f5245 52455445 0055575f     CCELEROMETER_WU.
  41c4c0:	534e4553 525f524f 475f5741 534f5259     SENSOR_RAW_GYROS
  41c4d0:	45504f43 00000000 534e4553 525f524f     COPE....SENSOR_R
  41c4e0:	475f5741 534f5259 45504f43 0055575f     AW_GYROSCOPE_WU.
  41c4f0:	534e4553 525f524f 4d5f5741 454e4741     SENSOR_RAW_MAGNE
  41c500:	454d4f54 00524554 534e4553 525f524f     TOMETER.SENSOR_R
  41c510:	4d5f5741 454e4741 454d4f54 5f524554     AW_MAGNETOMETER_
  41c520:	00005557 534e4553 525f524f 545f5741     WU..SENSOR_RAW_T
  41c530:	45504d45 55544152 00004552 534e4553     EMPERATURE..SENS
  41c540:	525f524f 545f5741 45504d45 55544152     OR_RAW_TEMPERATU
  41c550:	575f4552 00000055 534e4553 435f524f     RE_WU...SENSOR_C
  41c560:	4f545355 52505f4d 55535345 00004552     USTOM_PRESSURE..
  41c570:	534e4553 435f524f 4f545355 52505f4d     SENSOR_CUSTOM_PR
  41c580:	55535345 575f4552 00000055 534e4553     ESSURE_WU...SENS
  41c590:	4d5f524f 00004349 534e4553 4d5f524f     OR_MIC..SENSOR_M
  41c5a0:	575f4349 00000055 534e4553 545f524f     IC_WU...SENSOR_T
  41c5b0:	554d4953 00000000 534e4553 545f524f     SIMU....SENSOR_T
  41c5c0:	554d4953 0055575f 534e4553 525f524f     SIMU_WU.SENSOR_R
  41c5d0:	505f5741 00004750 534e4553 525f524f     AW_PPG..SENSOR_R
  41c5e0:	505f5741 575f4750 00000055 534e4553     AW_PPG_WU...SENS
  41c5f0:	485f524f 00005652 534e4553 485f524f     OR_HRV..SENSOR_H
  41c600:	575f5652 00000055 534e4553 535f524f     RV_WU...SENSOR_S
  41c610:	5045454c 414e415f 4953594c 00000053     LEEP_ANALYSIS...
  41c620:	534e4553 535f524f 5045454c 414e415f     SENSOR_SLEEP_ANA
  41c630:	4953594c 55575f53 00000000 534e4553     LYSIS_WU....SENS
  41c640:	425f524f 455f4341 4e455458 00444544     OR_BAC_EXTENDED.
  41c650:	534e4553 425f524f 455f4341 4e455458     SENSOR_BAC_EXTEN
  41c660:	5f444544 00005557 534e4553 425f524f     DED_WU..SENSOR_B
  41c670:	535f4341 49544154 43495453 00000053     AC_STATISTICS...
  41c680:	534e4553 425f524f 535f4341 49544154     SENSOR_BAC_STATI
  41c690:	43495453 55575f53 00000000 534e4553     STICS_WU....SENS
  41c6a0:	465f524f 524f4f4c 494c435f 435f424d     OR_FLOOR_CLIMB_C
  41c6b0:	544e554f 00005245 534e4553 465f524f     OUNTER..SENSOR_F
  41c6c0:	524f4f4c 494c435f 435f424d 544e554f     LOOR_CLIMB_COUNT
  41c6d0:	575f5245 00000055 534e4553 455f524f     ER_WU...SENSOR_E
  41c6e0:	4752454e 58455f59 444e4550 52555449     NERGY_EXPENDITUR
  41c6f0:	00000045 534e4553 455f524f 4752454e     E...SENSOR_ENERG
  41c700:	58455f59 444e4550 52555449 55575f45     Y_EXPENDITURE_WU
  41c710:	00000000 534e4553 445f524f 41545349     ....SENSOR_DISTA
  41c720:	0045434e 534e4553 445f524f 41545349     NCE.SENSOR_DISTA
  41c730:	5f45434e 00005557 534e4553 535f524f     NCE_WU..SENSOR_S
  41c740:	454b4148 00000000 534e4553 535f524f     HAKE....SENSOR_S
  41c750:	454b4148 0055575f 534e4553 445f524f     HAKE_WU.SENSOR_D
  41c760:	4c42554f 41545f45 00000050 534e4553     OUBLE_TAP...SENS
  41c770:	435f524f 4f545355 0000304d 534e4553     OR_CUSTOM0..SENS
  41c780:	435f524f 4f545355 575f304d 00000055     OR_CUSTOM0_WU...
  41c790:	534e4553 435f524f 4f545355 0000314d     SENSOR_CUSTOM1..
  41c7a0:	534e4553 435f524f 4f545355 575f314d     SENSOR_CUSTOM1_W
  41c7b0:	00000055 534e4553 435f524f 4f545355     U...SENSOR_CUSTO
  41c7c0:	0000324d 534e4553 435f524f 4f545355     M2..SENSOR_CUSTO
  41c7d0:	575f324d 00000055 534e4553 435f524f     M2_WU...SENSOR_C
  41c7e0:	4f545355 0000334d 534e4553 435f524f     USTOM3..SENSOR_C
  41c7f0:	4f545355 575f334d 00000055 534e4553     USTOM3_WU...SENS
  41c800:	435f524f 4f545355 0000344d 534e4553     OR_CUSTOM4..SENS
  41c810:	435f524f 4f545355 575f344d 00000055     OR_CUSTOM4_WU...
  41c820:	534e4553 435f524f 4f545355 0000354d     SENSOR_CUSTOM5..
  41c830:	534e4553 435f524f 4f545355 575f354d     SENSOR_CUSTOM5_W
  41c840:	00000055 534e4553 435f524f 4f545355     U...SENSOR_CUSTO
  41c850:	0000364d 534e4553 435f524f 4f545355     M6..SENSOR_CUSTO
  41c860:	575f364d 00000055 534e4553 435f524f     M6_WU...SENSOR_C
  41c870:	4f545355 0000374d 534e4553 435f524f     USTOM7..SENSOR_C
  41c880:	4f545355 575f374d 00000055 534e4553     USTOM7_WU...SENS
  41c890:	575f524f 00004d4f 534e4553 575f524f     OR_WOM..SENSOR_W
  41c8a0:	575f4d4f 00000055 534e4553 535f524f     OM_WU...SENSOR_S
  41c8b0:	4e454445 59524154 4d45525f 00444e49     EDENTARY_REMIND.
  41c8c0:	534e4553 535f524f 4e454445 59524154     SENSOR_SEDENTARY
  41c8d0:	4d45525f 5f444e49 00005557 534e4553     _REMIND_WU..SENS
  41c8e0:	445f524f 5f415441 52434e45 49545059     OR_DATA_ENCRYPTI
  41c8f0:	00004e4f 534e4553 445f524f 5f415441     ON..SENSOR_DATA_
  41c900:	52434e45 49545059 575f4e4f 00000055     ENCRYPTION_WU...
  41c910:	534e4553 465f524f 434e5953 4556455f     SENSOR_FSYNC_EVE
  41c920:	0000544e 534e4553 465f524f 434e5953     NT..SENSOR_FSYNC
  41c930:	4556455f 575f544e 00000055 534e4553     _EVENT_WU...SENS
  41c940:	485f524f 5f484749 45544152 5259475f     OR_HIGH_RATE_GYR
  41c950:	0000004f 534e4553 485f524f 5f484749     O...SENSOR_HIGH_
  41c960:	45544152 5259475f 55575f4f 00000000     RATE_GYRO_WU....
  41c970:	534e4553 435f524f 4f545355 41425f4d     SENSOR_CUSTOM_BA
  41c980:	43535f43 5f45455f 54534944 00000000     C_SC_EE_DIST....
  41c990:	534e4553 435f524f 4f545355 41425f4d     SENSOR_CUSTOM_BA
  41c9a0:	43535f43 5f45455f 54534944 0055575f     C_SC_EE_DIST_WU.
  41c9b0:	534e4553 485f524f 4c5f4d52 4547474f     SENSOR_HRM_LOGGE
  41c9c0:	00000052 534e4553 485f524f 4c5f4d52     R...SENSOR_HRM_L
  41c9d0:	4547474f 55575f52 00000000 534e4553     OGGER_WU....SENS
  41c9e0:	505f524f 5f444552 54415551 0000305f     OR_PRED_QUAT_0..
  41c9f0:	534e4553 505f524f 5f444552 54415551     SENSOR_PRED_QUAT
  41ca00:	575f305f 00000055 534e4553 505f524f     _0_WU...SENSOR_P
  41ca10:	5f444552 54415551 0000315f 534e4553     RED_QUAT_1..SENS
  41ca20:	505f524f 5f444552 54415551 575f315f     OR_PRED_QUAT_1_W
  41ca30:	00000055 534e4553 4f5f524f 315f5349     U...SENSOR_OIS_1
  41ca40:	00000000 534e4553 4f5f524f 315f5349     ....SENSOR_OIS_1
  41ca50:	0055575f 506e7944 6f746f72 3a6c6f63     _WU.DynProtocol:
  41ca60:	74657220 656e7275 61702064 616f6c79      returned payloa
  41ca70:	73692064 00312d20 506e7944 6f746f72     d is -1.DynProto
  41ca80:	3a6c6f63 656e5520 63657078 20646574     col: Unexpected 
  41ca90:	6b636170 74207465 00657079 506e7944     packet type.DynP
  41caa0:	6f746f72 3a6c6f63 656e5520 63657078     rotocol: Unexpec
  41cab0:	20646574 6b636170 72207465 69656365     ted packet recei
  41cac0:	2e646576 00000000 506e7944 6f746f72     ved.....DynProto
  41cad0:	3a6c6f63 6b6e5520 6e776f6e 61726620     col: Unknown fra
  41cae0:	0000656d 506e7944 6f746f72 3a6c6f63     me..DynProtocol:
  41caf0:	61724620 7320656d 20657a69 6f727265      Frame size erro
  41cb00:	73202e72 3d657a69 20426425 70786528     r. size=%dB (exp
  41cb10:	65746365 64252064 00002942 506e7944     ected %dB)..DynP
  41cb20:	6f746f72 3a6c6f63 766e4920 64696c61     rotocol: Invalid
  41cb30:	6f726720 49207075 00000044 506e7944      group ID...DynP
  41cb40:	6f746f72 3a6c6f63 746e6920 616e7265     rotocol: interna
  41cb50:	7562206c 72656666 7a697320 75662065     l buffer size fu
  41cb60:	00006c6c 506e7944 6f746f72 3a6c6f63     ll..DynProtocol:
  41cb70:	656e5520 63657078 20646574 75677261      Unexpected argu
  41cb80:	746e656d 726f6620 636e6520 5f65646f     ment for encode_
  41cb90:	6d6d6f63 28646e61 00000029 506e7944     command()...DynP
  41cba0:	6f746f72 3a6c6f63 74756f20 20747570     rotocol: output 
  41cbb0:	66667562 73207265 20657a69 206f6f74     buffer size too 
  41cbc0:	6c616d73 0000006c 506e7944 6f746f72     small...DynProto
  41cbd0:	3a6c6f63 656e5520 63657078 20646574     col: Unexpected 
  41cbe0:	75677261 746e656d 726f6620 6e794420     argument for Dyn
  41cbf0:	746f7250 6c6f636f 636e655f 5265646f     Protocol_encodeR
  41cc00:	6f707365 2865736e 00000029 506e7944     esponse()...DynP
  41cc10:	6f746f72 3a6c6f63 656e5520 63657078     rotocol: Unexpec
  41cc20:	20646574 75677261 746e656d 726f6620     ted argument for
  41cc30:	636e6520 5f65646f 6e797361 00292863      encode_async().
  41cc40:	45534552 44455652 00000000 45434341     RESERVED....ACCE
  41cc50:	4f52454c 4554454d 00000052 4e47414d     LEROMETER...MAGN
  41cc60:	4d4f5445 52455445 00000000 4549524f     ETOMETER....ORIE
  41cc70:	5441544e 004e4f49 4f525947 504f4353     NTATION.GYROSCOP
  41cc80:	00000045 4847494c 00000054 53455250     E...LIGHT...PRES
  41cc90:	45525553 00000000 504d4554 54415245     SURE....TEMPERAT
  41cca0:	00455255 584f5250 54494d49 00000059     URE.PROXIMITY...
  41ccb0:	56415247 00595449 454e494c 415f5241     GRAVITY.LINEAR_A
  41ccc0:	4c454343 54415245 004e4f49 41544f52     CCELERATION.ROTA
  41ccd0:	4e4f4954 4345565f 00524f54 494d5548     TION_VECTOR.HUMI
  41cce0:	59544944 00000000 49424d41 5f544e45     DITY....AMBIENT_
  41ccf0:	504d4554 54415245 00455255 41434e55     TEMPERATURE.UNCA
  41cd00:	414d5f4c 54454e47 54454d4f 00005245     L_MAGNETOMETER..
  41cd10:	454d4147 544f525f 4f495441 45565f4e     GAME_ROTATION_VE
  41cd20:	524f5443 00000000 41434e55 59475f4c     CTOR....UNCAL_GY
  41cd30:	43534f52 0045504f 00444d53 50455453     ROSCOPE.SMD.STEP
  41cd40:	5445445f 4f544345 00000052 50455453     _DETECTOR...STEP
  41cd50:	554f435f 5245544e 00000000 4d4f4547     _COUNTER....GEOM
  41cd60:	525f4741 5441544f 5f4e4f49 54434556     AG_ROTATION_VECT
  41cd70:	0000524f 52414548 41525f54 00004554     OR..HEART_RATE..
  41cd80:	544c4954 5445445f 4f544345 00000052     TILT_DETECTOR...
  41cd90:	454b4157 5345475f 45525554 00000000     WAKE_GESTURE....
  41cda0:	4e414c47 475f4543 55545345 00004552     GLANCE_GESTURE..
  41cdb0:	4b434950 5f50555f 54534547 00455255     PICK_UP_GESTURE.
  41cdc0:	00434142 00524450 00533242 49584133     BAC.PDR.B2S.3AXI
  41cdd0:	00000053 00534945 5f53494f 00000030     S...EIS.OIS_0...
  41cde0:	5f53494f 00000031 5f574152 45434341     OIS_1...RAW_ACCE
  41cdf0:	4f52454c 4554454d 00000052 5f574152     LEROMETER...RAW_
  41ce00:	4f525947 504f4353 00000045 5f574152     GYROSCOPE...RAW_
  41ce10:	4e47414d 4d4f5445 52455445 00000000     MAGNETOMETER....
  41ce20:	5f574152 504d4554 54415245 00455255     RAW_TEMPERATURE.
  41ce30:	54535543 505f4d4f 53534552 00455255     CUSTOM_PRESSURE.
  41ce40:	0043494d 4d495354 00000055 5f574152     MIC.TSIMU...RAW_
  41ce50:	00475050 00565248 45454c53 4e415f50     PPG.HRV.SLEEP_AN
  41ce60:	53594c41 00005349 5f434142 45545845     ALYSIS..BAC_EXTE
  41ce70:	4445444e 00000000 5f434142 54415453     NDED....BAC_STAT
  41ce80:	49545349 00005343 4f4f4c46 4c435f52     ISTICS..FLOOR_CL
  41ce90:	5f424d49 4e554f43 00524554 52454e45     IMB_COUNTER.ENER
  41cea0:	455f5947 4e455058 55544944 00004552     GY_EXPENDITURE..
  41ceb0:	54534944 45434e41 00000000 4b414853     DISTANCE....SHAK
  41cec0:	00000045 42554f44 545f454c 00005041     E...DOUBLE_TAP..
  41ced0:	54535543 00304d4f 54535543 00314d4f     CUSTOM0.CUSTOM1.
  41cee0:	54535543 00324d4f 54535543 00334d4f     CUSTOM2.CUSTOM3.
  41cef0:	54535543 00344d4f 54535543 00354d4f     CUSTOM4.CUSTOM5.
  41cf00:	54535543 00364d4f 54535543 00374d4f     CUSTOM6.CUSTOM7.
  41cf10:	004d4f57 45444553 5241544e 45525f59     WOM.SEDENTARY_RE
  41cf20:	444e494d 00000000 4e595346 56455f43     MIND....FSYNC_EV
  41cf30:	00544e45 44455250 4155515f 00305f54     ENT.PRED_QUAT_0.
  41cf40:	44455250 4155515f 00315f54 5f574f4c     PRED_QUAT_1.LOW_
  41cf50:	00000047 48474948 0000475f 00504154     G...HIGH_G..TAP.
  41cf60:	41544144 434e455f 54505952 004e4f49     DATA_ENCRYPTION.
  41cf70:	00000000 506e7944 72546f72 70736e61     ....DynProTransp
  41cf80:	5574726f 3a747261 656e7520 63657078     ortUart: unexpec
  41cf90:	20646574 434e5953 79622030 25206574     ted SYNC0 byte %
  41cfa0:	65722078 69766563 00006465 506e7944     x recevied..DynP
  41cfb0:	72546f72 70736e61 5574726f 3a747261     roTransportUart:
  41cfc0:	656e7520 63657078 20646574 434e5953      unexpected SYNC
  41cfd0:	79622031 25206574 65722078 69766563     1 byte %x recevi
  41cfe0:	00006465 63637553 00737365 70736e55     ed..Success.Unsp
  41cff0:	66696365 20646569 6f727265 00000072     ecified error...
  41d000:	20746f4e 6c706d69 6e656d65 00646574     Not implemented.
  41d010:	6e617254 726f7073 72652074 00726f72     Transport error.
  41d020:	656d6954 2c74756f 74636120 206e6f69     Timeout, action 
  41d030:	20646964 20746f6e 706d6f63 6574656c     did not complete
  41d040:	206e6920 656d6974 00000000 6e6f7257      in time....Wron
  41d050:	69732067 6520657a 726f7272 00000000     g size error....
  41d060:	7265704f 6e697461 79732067 6d657473     Operating system
  41d070:	69616620 6572756c 00000000 75706e49      failure....Inpu
  41d080:	754f2f74 74757074 72726520 0000726f     t/Output error..
  41d090:	20646142 6f6c6c61 69746163 00006e6f     Bad allocation..
  41d0a0:	64726148 65726177 72726520 0000726f     Hardware error..
  41d0b0:	61766e49 2064696c 75677261 746e656d     Invalid argument
  41d0c0:	00000073 78656e55 74636570 65206465     s...Unexpected e
  41d0d0:	726f7272 00000000 61766e49 2064696c     rror....Invalid 
  41d0e0:	656c6966 726f6620 0074616d 61766e49     file format.Inva
  41d0f0:	2064696c 656c6966 74617020 00000068     lid file path...
  41d100:	6e6b6e55 206e776f 67616d69 79742065     Unknown image ty
  41d110:	00006570 63746157 676f6468 72726520     pe..Watchdog err
  41d120:	0000726f 4f464946 65766f20 6f6c6672     or..FIFO overflo
  41d130:	72652077 00726f72 6e6b6e55 206e776f     w error.Unknown 
  41d140:	6f727265 00000072 002a0001 07141417     error.....*.....
  41d150:	0c121a27 1f250c13 1f111f26 10092029     '.....%.&...) ..
  41d160:	100a100f 2123211d 1103211e 2219110b     .....!#!.!....."
  41d170:	0000221f 15240110 012b0a04 05091d1a     ."....$...+.....
  41d180:	050a050f 1823181d 0603181e 1919060b     ......#.........
  41d190:	0000191f 1622030e 1e180b02 13031214     ......".........
  41d1a0:	2327130b 241f2419 1c1c0906 14170001     ..'#.$.$........
  41d1b0:	100a002a 0000211e 1a270714 0c130c12     *....!....'.....
  41d1c0:	1f261f25 00001f11 15240110 012b0a04     %.&.......$...+.
  41d1d0:	00001d1a 1d1a0a04 050f0509 181d050a     ................
  41d1e0:	181e1823 060b0603 191f1919 1622030e     #.............".
  41d1f0:	1e180b02 8008ffff 04080028 10084048     ........(...H@..
  41d200:	ffff0088 0808ffff 04088808 ffffffff     ................
  41d210:	08082008 00004008 00100018 ffff0108     . ...@..........
  41d220:	8008ffff 04080028 10084048 08080088     ....(...H@......
  41d230:	04088808 ffffffff 08082008 00184008     ......... ...@..
  41d240:	01080010 0000ffff 40488008 74727173     ..........H@sqrt
  41d250:	00000066                                f...

0041d254 <npio2_hw>:
  41d254:	3fc90f00 40490f00 4096cb00 40c90f00     ...?..I@...@...@
  41d264:	40fb5300 4116cb00 412fed00 41490f00     .S.@...A../A..IA
  41d274:	41623100 417b5300 418a3a00 4196cb00     .1bA.S{A.:.A...A
  41d284:	41a35c00 41afed00 41bc7e00 41c90f00     .\.A...A.~.A...A
  41d294:	41d5a000 41e23100 41eec200 41fb5300     ...A.1.A...A.S.A
  41d2a4:	4203f200 420a3a00 42108300 4216cb00     ...B.:.B...B...B
  41d2b4:	421d1400 42235c00 4229a500 422fed00     ...B.\#B..)B../B
  41d2c4:	42363600 423c7e00 4242c700 42490f00     .66B.~<B..BB..IB

0041d2d4 <two_over_pi>:
  41d2d4:	000000a2 000000f9 00000083 0000006e     ............n...
  41d2e4:	0000004e 00000044 00000015 00000029     N...D.......)...
  41d2f4:	000000fc 00000027 00000057 000000d1     ....'...W.......
  41d304:	000000f5 00000034 000000dd 000000c0     ....4...........
  41d314:	000000db 00000062 00000095 00000099     ....b...........
  41d324:	0000003c 00000043 00000090 00000041     <...C.......A...
  41d334:	000000fe 00000051 00000063 000000ab     ....Q...c.......
  41d344:	000000de 000000bb 000000c5 00000061     ............a...
  41d354:	000000b7 00000024 0000006e 0000003a     ....$...n...:...
  41d364:	00000042 0000004d 000000d2 000000e0     B...M...........
  41d374:	00000006 00000049 0000002e 000000ea     ....I...........
  41d384:	00000009 000000d1 00000092 0000001c     ................
  41d394:	000000fe 0000001d 000000eb 0000001c     ................
  41d3a4:	000000b1 00000029 000000a7 0000003e     ....).......>...
  41d3b4:	000000e8 00000082 00000035 000000f5     ........5.......
  41d3c4:	0000002e 000000bb 00000044 00000084     ........D.......
  41d3d4:	000000e9 0000009c 00000070 00000026     ........p...&...
  41d3e4:	000000b4 0000005f 0000007e 00000041     ...._...~...A...
  41d3f4:	00000039 00000091 000000d6 00000039     9...........9...
  41d404:	00000083 00000053 00000039 000000f4     ....S...9.......
  41d414:	0000009c 00000084 0000005f 0000008b     ........_.......
  41d424:	000000bd 000000f9 00000028 0000003b     ........(...;...
  41d434:	0000001f 000000f8 00000097 000000ff     ................
  41d444:	000000de 00000005 00000098 0000000f     ................
  41d454:	000000ef 0000002f 00000011 0000008b     ..../...........
  41d464:	0000005a 0000000a 0000006d 0000001f     Z.......m.......
  41d474:	0000006d 00000036 0000007e 000000cf     m...6...~.......
  41d484:	00000027 000000cb 00000009 000000b7     '...............
  41d494:	0000004f 00000046 0000003f 00000066     O...F...?...f...
  41d4a4:	0000009e 0000005f 000000ea 0000002d     ...._.......-...
  41d4b4:	00000075 00000027 000000ba 000000c7     u...'...........
  41d4c4:	000000eb 000000e5 000000f1 0000007b     ............{...
  41d4d4:	0000003d 00000007 00000039 000000f7     =.......9.......
  41d4e4:	0000008a 00000052 00000092 000000ea     ....R...........
  41d4f4:	0000006b 000000fb 0000005f 000000b1     k......._.......
  41d504:	0000001f 0000008d 0000005d 00000008     ........].......
  41d514:	00000056 00000003 00000030 00000046     V.......0...F...
  41d524:	000000fc 0000007b 0000006b 000000ab     ....{...k.......
  41d534:	000000f0 000000cf 000000bc 00000020     ............ ...
  41d544:	0000009a 000000f4 00000036 0000001d     ........6.......
  41d554:	000000a9 000000e3 00000091 00000061     ............a...
  41d564:	0000005e 000000e6 0000001b 00000008     ^...............
  41d574:	00000065 00000099 00000085 0000005f     e..........._...
  41d584:	00000014 000000a0 00000068 00000040     ........h...@...
  41d594:	0000008d 000000ff 000000d8 00000080     ................
  41d5a4:	0000004d 00000073 00000027 00000031     M...s...'...1...
  41d5b4:	00000006 00000006 00000015 00000056     ............V...
  41d5c4:	000000ca 00000073 000000a8 000000c9     ....s...........
  41d5d4:	00000060 000000e2 0000007b 000000c0     `.......{.......
  41d5e4:	0000008c 0000006b                       ....k...

0041d5ec <PIo2>:
  41d5ec:	3fc90000 39f00000 37da0000 33a20000     ...?...9...7...3
  41d5fc:	2e840000 2b500000 27c20000 22d00000     ......P+...'..."
  41d60c:	1fc40000 1bc60000 17440000              ..........D.

0041d618 <init_jk>:
  41d618:	00000004 00000007 00000009              ............

0041d624 <_global_impure_ptr>:
  41d624:	20000360 00464e49 00666e69 004e414e     `.. INF.inf.NAN.
  41d634:	006e616e 33323130 37363534 42413938     nan.0123456789AB
  41d644:	46454443 00000000 33323130 37363534     CDEF....01234567
  41d654:	62613938 66656463 00000000 6c756e28     89abcdef....(nul
  41d664:	0000296c 00000030                       l)..0...

0041d66c <blanks.8346>:
  41d66c:	20202020 20202020 20202020 20202020                     

0041d67c <zeroes.8347>:
  41d67c:	30303030 30303030 30303030 30303030     0000000000000000
  41d68c:	69666e49 7974696e 00000000 004e614e     Infinity....NaN.
  41d69c:	00000000                                ....

0041d6a0 <__mprec_bigtens>:
  41d6a0:	37e08000 4341c379 b5056e17 4693b8b5     ...7y.AC.n.....F
  41d6b0:	e93ff9f5 4d384f03 f9301d32 5a827748     ..?..O8M2.0.Hw.Z
  41d6c0:	7f73bf3c 75154fdd                       <.s..O.u

0041d6c8 <__mprec_tens>:
  41d6c8:	00000000 3ff00000 00000000 40240000     .......?......$@
  41d6d8:	00000000 40590000 00000000 408f4000     ......Y@.....@.@
  41d6e8:	00000000 40c38800 00000000 40f86a00     .......@.....j.@
  41d6f8:	00000000 412e8480 00000000 416312d0     .......A......cA
  41d708:	00000000 4197d784 00000000 41cdcd65     .......A....e..A
  41d718:	20000000 4202a05f e8000000 42374876     ... _..B....vH7B
  41d728:	a2000000 426d1a94 e5400000 42a2309c     ......mB..@..0.B
  41d738:	1e900000 42d6bcc4 26340000 430c6bf5     .......B..4&.k.C
  41d748:	37e08000 4341c379 85d8a000 43763457     ...7y.AC....W4vC
  41d758:	674ec800 43abc16d 60913d00 43e158e4     ..Ngm..C.=.`.X.C
  41d768:	78b58c40 4415af1d d6e2ef50 444b1ae4     @..x...DP.....KD
  41d778:	064dd592 4480f0cf c7e14af6 44b52d02     ..M....D.J...-.D
  41d788:	79d99db4 44ea7843                       ...yCx.D

0041d790 <p05.7178>:
  41d790:	00000005 00000019 0000007d 00000043     ........}...C...
  41d7a0:	49534f50 00000058 0000002e              POSIX.......

0041d7ac <_ctype_>:
  41d7ac:	20202000 20202020 28282020 20282828     .         ((((( 
  41d7bc:	20202020 20202020 20202020 20202020                     
  41d7cc:	10108820 10101010 10101010 10101010      ...............
  41d7dc:	04040410 04040404 10040404 10101010     ................
  41d7ec:	41411010 41414141 01010101 01010101     ..AAAAAA........
  41d7fc:	01010101 01010101 01010101 10101010     ................
  41d80c:	42421010 42424242 02020202 02020202     ..BBBBBB........
  41d81c:	02020202 02020202 02020202 10101010     ................
  41d82c:	00000020 00000000 00000000 00000000      ...............
	...

0041d8b0 <_init>:
  41d8b0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  41d8b2:	bf00      	nop
  41d8b4:	bcf8      	pop	{r3, r4, r5, r6, r7}
  41d8b6:	bc08      	pop	{r3}
  41d8b8:	469e      	mov	lr, r3
  41d8ba:	4770      	bx	lr

0041d8bc <__init_array_start>:
  41d8bc:	004158a1 	.word	0x004158a1

0041d8c0 <__frame_dummy_init_array_entry>:
  41d8c0:	0040016d                                m.@.

0041d8c4 <_fini>:
  41d8c4:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  41d8c6:	bf00      	nop
  41d8c8:	bcf8      	pop	{r3, r4, r5, r6, r7}
  41d8ca:	bc08      	pop	{r3}
  41d8cc:	469e      	mov	lr, r3
  41d8ce:	4770      	bx	lr

0041d8d0 <__fini_array_start>:
  41d8d0:	00400149 	.word	0x00400149

Disassembly of section .relocate:

20000000 <portable_delay_cycles>:
RAMFUNC
void portable_delay_cycles(unsigned long n)
{
	UNUSED(n);

	__asm (
20000000:	f3bf 8f5f 	dmb	sy
20000004:	3801      	subs	r0, #1
20000006:	d1fb      	bne.n	20000000 <portable_delay_cycles>
20000008:	4770      	bx	lr

2000000a <efc_perform_read_sequence>:
__no_inline
RAMFUNC
uint32_t efc_perform_read_sequence(Efc *p_efc,
		uint32_t ul_cmd_st, uint32_t ul_cmd_sp,
		uint32_t *p_ul_buf, uint32_t ul_size)
{
2000000a:	b480      	push	{r7}
2000000c:	b089      	sub	sp, #36	; 0x24
2000000e:	af00      	add	r7, sp, #0
20000010:	60f8      	str	r0, [r7, #12]
20000012:	60b9      	str	r1, [r7, #8]
20000014:	607a      	str	r2, [r7, #4]
20000016:	603b      	str	r3, [r7, #0]
	uint32_t *p_ul_data =
			(uint32_t *) ((p_efc == EFC0) ?
			READ_BUFF_ADDR0 : READ_BUFF_ADDR1);
#elif (SAM3S || SAM4S || SAM3N || SAM3U || SAM4E || SAM4N || SAM4C || SAMG || \
	   SAM4CP || SAM4CM || SAMV71 || SAMV70 || SAMS70 || SAME70)
	uint32_t *p_ul_data = (uint32_t *) READ_BUFF_ADDR;
20000018:	f44f 0380 	mov.w	r3, #4194304	; 0x400000
2000001c:	61bb      	str	r3, [r7, #24]
#else
	return EFC_RC_NOT_SUPPORT;
#endif

	if (p_ul_buf == NULL) {
2000001e:	683b      	ldr	r3, [r7, #0]
20000020:	2b00      	cmp	r3, #0
20000022:	d101      	bne.n	20000028 <efc_perform_read_sequence+0x1e>
		return EFC_RC_INVALID;
20000024:	2302      	movs	r3, #2
20000026:	e03c      	b.n	200000a2 <efc_perform_read_sequence+0x98>
	}

	p_efc->EEFC_FMR |= (0x1u << 16);
20000028:	68fb      	ldr	r3, [r7, #12]
2000002a:	681b      	ldr	r3, [r3, #0]
2000002c:	f443 3280 	orr.w	r2, r3, #65536	; 0x10000
20000030:	68fb      	ldr	r3, [r7, #12]
20000032:	601a      	str	r2, [r3, #0]

	/* Send the Start Read command */
#if (SAM4S || SAM4E || SAM4N || SAM4C || SAMG || SAM4CP || SAM4CM || \
	 SAMV71 || SAMV70 || SAMS70 || SAME70)
	p_efc->EEFC_FCR = EEFC_FCR_FKEY_PASSWD | EEFC_FCR_FARG(0)
			| EEFC_FCR_FCMD(ul_cmd_st);
20000034:	68bb      	ldr	r3, [r7, #8]
20000036:	b2db      	uxtb	r3, r3
20000038:	f043 42b4 	orr.w	r2, r3, #1509949440	; 0x5a000000
	p_efc->EEFC_FCR = EEFC_FCR_FKEY_PASSWD | EEFC_FCR_FARG(0)
2000003c:	68fb      	ldr	r3, [r7, #12]
2000003e:	605a      	str	r2, [r3, #4]
#endif
	/* Wait for the FRDY bit in the Flash Programming Status Register
	 * (EEFC_FSR) falls.
	 */
	do {
		ul_status = p_efc->EEFC_FSR;
20000040:	68fb      	ldr	r3, [r7, #12]
20000042:	689b      	ldr	r3, [r3, #8]
20000044:	617b      	str	r3, [r7, #20]
	} while ((ul_status & EEFC_FSR_FRDY) == EEFC_FSR_FRDY);
20000046:	697b      	ldr	r3, [r7, #20]
20000048:	f003 0301 	and.w	r3, r3, #1
2000004c:	2b01      	cmp	r3, #1
2000004e:	d0f7      	beq.n	20000040 <efc_perform_read_sequence+0x36>

	/* The data is located in the first address of the Flash
	 * memory mapping.
	 */
	for (ul_cnt = 0; ul_cnt < ul_size; ul_cnt++) {
20000050:	2300      	movs	r3, #0
20000052:	61fb      	str	r3, [r7, #28]
20000054:	e00c      	b.n	20000070 <efc_perform_read_sequence+0x66>
		p_ul_buf[ul_cnt] = p_ul_data[ul_cnt];
20000056:	69fb      	ldr	r3, [r7, #28]
20000058:	009b      	lsls	r3, r3, #2
2000005a:	683a      	ldr	r2, [r7, #0]
2000005c:	4413      	add	r3, r2
2000005e:	69fa      	ldr	r2, [r7, #28]
20000060:	0092      	lsls	r2, r2, #2
20000062:	69b9      	ldr	r1, [r7, #24]
20000064:	440a      	add	r2, r1
20000066:	6812      	ldr	r2, [r2, #0]
20000068:	601a      	str	r2, [r3, #0]
	for (ul_cnt = 0; ul_cnt < ul_size; ul_cnt++) {
2000006a:	69fb      	ldr	r3, [r7, #28]
2000006c:	3301      	adds	r3, #1
2000006e:	61fb      	str	r3, [r7, #28]
20000070:	69fa      	ldr	r2, [r7, #28]
20000072:	6abb      	ldr	r3, [r7, #40]	; 0x28
20000074:	429a      	cmp	r2, r3
20000076:	d3ee      	bcc.n	20000056 <efc_perform_read_sequence+0x4c>
	/* To stop the read mode */
	p_efc->EEFC_FCR =
#if (SAM4S || SAM4E || SAM4N || SAM4C || SAMG || SAM4CP || SAM4CM || \
	 SAMV71 || SAMV70 || SAMS70 || SAME70)
			EEFC_FCR_FKEY_PASSWD | EEFC_FCR_FARG(0) |
			EEFC_FCR_FCMD(ul_cmd_sp);
20000078:	687b      	ldr	r3, [r7, #4]
2000007a:	b2db      	uxtb	r3, r3
			EEFC_FCR_FKEY_PASSWD | EEFC_FCR_FARG(0) |
2000007c:	f043 42b4 	orr.w	r2, r3, #1509949440	; 0x5a000000
	p_efc->EEFC_FCR =
20000080:	68fb      	ldr	r3, [r7, #12]
20000082:	605a      	str	r2, [r3, #4]
#endif
	/* Wait for the FRDY bit in the Flash Programming Status Register (EEFC_FSR)
	 * rises.
	 */
	do {
		ul_status = p_efc->EEFC_FSR;
20000084:	68fb      	ldr	r3, [r7, #12]
20000086:	689b      	ldr	r3, [r3, #8]
20000088:	617b      	str	r3, [r7, #20]
	} while ((ul_status & EEFC_FSR_FRDY) != EEFC_FSR_FRDY);
2000008a:	697b      	ldr	r3, [r7, #20]
2000008c:	f003 0301 	and.w	r3, r3, #1
20000090:	2b01      	cmp	r3, #1
20000092:	d1f7      	bne.n	20000084 <efc_perform_read_sequence+0x7a>

	p_efc->EEFC_FMR &= ~(0x1u << 16);
20000094:	68fb      	ldr	r3, [r7, #12]
20000096:	681b      	ldr	r3, [r3, #0]
20000098:	f423 3280 	bic.w	r2, r3, #65536	; 0x10000
2000009c:	68fb      	ldr	r3, [r7, #12]
2000009e:	601a      	str	r2, [r3, #0]

	return EFC_RC_OK;
200000a0:	2300      	movs	r3, #0
}
200000a2:	4618      	mov	r0, r3
200000a4:	3724      	adds	r7, #36	; 0x24
200000a6:	46bd      	mov	sp, r7
200000a8:	f85d 7b04 	ldr.w	r7, [sp], #4
200000ac:	4770      	bx	lr

200000ae <efc_write_fmr>:
 * \param ul_fmr Value of mode register
 */
__no_inline
RAMFUNC
void efc_write_fmr(Efc *p_efc, uint32_t ul_fmr)
{
200000ae:	b480      	push	{r7}
200000b0:	b083      	sub	sp, #12
200000b2:	af00      	add	r7, sp, #0
200000b4:	6078      	str	r0, [r7, #4]
200000b6:	6039      	str	r1, [r7, #0]
	p_efc->EEFC_FMR = ul_fmr;
200000b8:	687b      	ldr	r3, [r7, #4]
200000ba:	683a      	ldr	r2, [r7, #0]
200000bc:	601a      	str	r2, [r3, #0]
}
200000be:	bf00      	nop
200000c0:	370c      	adds	r7, #12
200000c2:	46bd      	mov	sp, r7
200000c4:	f85d 7b04 	ldr.w	r7, [sp], #4
200000c8:	4770      	bx	lr

200000ca <efc_perform_fcr>:
 * \return The current status.
 */
__no_inline
RAMFUNC
uint32_t efc_perform_fcr(Efc *p_efc, uint32_t ul_fcr)
{
200000ca:	b480      	push	{r7}
200000cc:	b085      	sub	sp, #20
200000ce:	af00      	add	r7, sp, #0
200000d0:	6078      	str	r0, [r7, #4]
200000d2:	6039      	str	r1, [r7, #0]
	volatile uint32_t ul_status;

	p_efc->EEFC_FCR = ul_fcr;
200000d4:	687b      	ldr	r3, [r7, #4]
200000d6:	683a      	ldr	r2, [r7, #0]
200000d8:	605a      	str	r2, [r3, #4]
	do {
		ul_status = p_efc->EEFC_FSR;
200000da:	687b      	ldr	r3, [r7, #4]
200000dc:	689b      	ldr	r3, [r3, #8]
200000de:	60fb      	str	r3, [r7, #12]
	} while ((ul_status & EEFC_FSR_FRDY) != EEFC_FSR_FRDY);
200000e0:	68fb      	ldr	r3, [r7, #12]
200000e2:	f003 0301 	and.w	r3, r3, #1
200000e6:	2b01      	cmp	r3, #1
200000e8:	d1f7      	bne.n	200000da <efc_perform_fcr+0x10>

	return (ul_status & EEFC_ERROR_FLAGS);
200000ea:	68fb      	ldr	r3, [r7, #12]
200000ec:	f003 030e 	and.w	r3, r3, #14
}
200000f0:	4618      	mov	r0, r3
200000f2:	3714      	adds	r7, #20
200000f4:	46bd      	mov	sp, r7
200000f6:	f85d 7b04 	ldr.w	r7, [sp], #4
200000fa:	4770      	bx	lr

200000fc <cfg_acc_fsr>:
200000fc:	0004 0000                                   ....

20000100 <cfg_gyr_fsr>:
20000100:	07d0 0000                                   ....

20000104 <convert_to_generic_ids>:
20000104:	0401 2120 100e 121a 0f13 140b 1102 1619     .. !............
20000114:	0a09 1c03                                   ....

20000118 <I2C_Address>:
20000118:	0169                                             i

20000119 <g_interrupt_enabled>:
20000119:	0001 0000                                        ...

2000011c <SystemCoreClock>:
2000011c:	1200 007a                                   ..z.

20000120 <constA7.6587>:
20000120:	7fe4 0000 d6f9 ffff 128f 0000 fb1a ffff     ................

20000130 <PI15.6588>:
20000130:	9220 0001                                    ...

20000134 <sensor_str.5457>:
20000134:	bf20 0041 bf30 0041 bf44 0041 bf5c 0041      .A.0.A.D.A.\.A.
20000144:	bf74 0041 bf88 0041 bfa0 0041 bfb4 0041     t.A...A...A...A.
20000154:	bfcc 0041 bfe0 0041 bff4 0041 c004 0041     ..A...A...A...A.
20000164:	c014 0041 c024 0041 c038 0041 c04c 0041     ..A.$.A.8.A.L.A.
20000174:	c064 0041 c078 0041 c08c 0041 c09c 0041     d.A.x.A...A...A.
20000184:	c0b0 0041 c0cc 0041 c0ec 0041 c104 0041     ..A...A...A...A.
20000194:	c120 0041 c130 0041 c144 0041 c160 0041      .A.0.A.D.A.`.A.
200001a4:	c180 0041 c19c 0041 c1bc 0041 c1d8 0041     ..A...A...A...A.
200001b4:	c1f8 0041 c210 0041 c22c 0041 c238 0041     ..A...A.,.A.8.A.
200001c4:	c248 0041 c260 0041 c278 0041 c28c 0041     H.A.`.A.x.A...A.
200001d4:	c2a4 0041 c2c4 0041 c2e8 0041 c2fc 0041     ..A...A...A...A.
200001e4:	c314 0041 c32c 0041 c344 0041 c358 0041     ..A.,.A.D.A.X.A.
200001f4:	c370 0041 c388 0041 c3a4 0041 c3bc 0041     p.A...A...A...A.
20000204:	c3d8 0041 c3e4 0041 c3f4 0041 c400 0041     ..A...A...A...A.
20000214:	c410 0041 c41c 0041 c42c 0041 c43c 0041     ..A...A.,.A.<.A.
20000224:	c44c 0041 c458 0041 c468 0041 c478 0041     L.A.X.A.h.A.x.A.
20000234:	c488 0041 c4a4 0041 c4c0 0041 c4d8 0041     ..A...A...A...A.
20000244:	c4f0 0041 c508 0041 c524 0041 c53c 0041     ..A...A.$.A.<.A.
20000254:	c558 0041 c570 0041 c58c 0041 c598 0041     X.A.p.A...A...A.
20000264:	c5a8 0041 c5b8 0041 c5c8 0041 c5d8 0041     ..A...A...A...A.
20000274:	c5ec 0041 c5f8 0041 c608 0041 c620 0041     ..A...A...A. .A.
20000284:	c63c 0041 c650 0041 c668 0041 c680 0041     <.A.P.A.h.A...A.
20000294:	c69c 0041 c6b8 0041 c6d8 0041 c6f4 0041     ..A...A...A...A.
200002a4:	c714 0041 c724 0041 c738 0041 c748 0041     ..A.$.A.8.A.H.A.
200002b4:	c758 0041 c758 0041 c76c 0041 c77c 0041     X.A.X.A.l.A.|.A.
200002c4:	c790 0041 c7a0 0041 c7b4 0041 c7c4 0041     ..A...A...A...A.
200002d4:	c7d8 0041 c7e8 0041 c7fc 0041 c80c 0041     ..A...A...A...A.
200002e4:	c820 0041 c830 0041 c844 0041 c854 0041      .A.0.A.D.A.T.A.
200002f4:	c868 0041 c878 0041 c88c 0041 c898 0041     h.A.x.A...A...A.
20000304:	c8a8 0041 c8c0 0041 c8dc 0041 c8f4 0041     ..A...A...A...A.
20000314:	c910 0041 c924 0041 c93c 0041 c954 0041     ..A.$.A.<.A.T.A.
20000324:	c970 0041 c990 0041 c9b0 0041 c9c4 0041     p.A...A...A...A.
20000334:	c9dc 0041 c9f0 0041 ca08 0041 ca1c 0041     ..A...A...A...A.
20000344:	ca34 0041 ca44 0041 0000 0000 0000 0000     4.A.D.A.........

20000354 <__fdlib_version>:
20000354:	0001 0000                                   ....

20000358 <_impure_ptr>:
20000358:	0360 2000 0000 0000                         `.. ....

20000360 <impure_data>:
20000360:	0000 0000 064c 2000 06b4 2000 071c 2000     ....L.. ... ... 
	...
20000408:	0001 0000 0000 0000 330e abcd 1234 e66d     .........3..4.m.
20000418:	deec 0005 000b 0000 0000 0000 0000 0000     ................
	...

20000788 <__atexit_recursive_mutex>:
20000788:	211c 2000                                   .!. 

2000078c <__malloc_av_>:
	...
20000794:	078c 2000 078c 2000 0794 2000 0794 2000     ... ... ... ... 
200007a4:	079c 2000 079c 2000 07a4 2000 07a4 2000     ... ... ... ... 
200007b4:	07ac 2000 07ac 2000 07b4 2000 07b4 2000     ... ... ... ... 
200007c4:	07bc 2000 07bc 2000 07c4 2000 07c4 2000     ... ... ... ... 
200007d4:	07cc 2000 07cc 2000 07d4 2000 07d4 2000     ... ... ... ... 
200007e4:	07dc 2000 07dc 2000 07e4 2000 07e4 2000     ... ... ... ... 
200007f4:	07ec 2000 07ec 2000 07f4 2000 07f4 2000     ... ... ... ... 
20000804:	07fc 2000 07fc 2000 0804 2000 0804 2000     ... ... ... ... 
20000814:	080c 2000 080c 2000 0814 2000 0814 2000     ... ... ... ... 
20000824:	081c 2000 081c 2000 0824 2000 0824 2000     ... ... $.. $.. 
20000834:	082c 2000 082c 2000 0834 2000 0834 2000     ,.. ,.. 4.. 4.. 
20000844:	083c 2000 083c 2000 0844 2000 0844 2000     <.. <.. D.. D.. 
20000854:	084c 2000 084c 2000 0854 2000 0854 2000     L.. L.. T.. T.. 
20000864:	085c 2000 085c 2000 0864 2000 0864 2000     \.. \.. d.. d.. 
20000874:	086c 2000 086c 2000 0874 2000 0874 2000     l.. l.. t.. t.. 
20000884:	087c 2000 087c 2000 0884 2000 0884 2000     |.. |.. ... ... 
20000894:	088c 2000 088c 2000 0894 2000 0894 2000     ... ... ... ... 
200008a4:	089c 2000 089c 2000 08a4 2000 08a4 2000     ... ... ... ... 
200008b4:	08ac 2000 08ac 2000 08b4 2000 08b4 2000     ... ... ... ... 
200008c4:	08bc 2000 08bc 2000 08c4 2000 08c4 2000     ... ... ... ... 
200008d4:	08cc 2000 08cc 2000 08d4 2000 08d4 2000     ... ... ... ... 
200008e4:	08dc 2000 08dc 2000 08e4 2000 08e4 2000     ... ... ... ... 
200008f4:	08ec 2000 08ec 2000 08f4 2000 08f4 2000     ... ... ... ... 
20000904:	08fc 2000 08fc 2000 0904 2000 0904 2000     ... ... ... ... 
20000914:	090c 2000 090c 2000 0914 2000 0914 2000     ... ... ... ... 
20000924:	091c 2000 091c 2000 0924 2000 0924 2000     ... ... $.. $.. 
20000934:	092c 2000 092c 2000 0934 2000 0934 2000     ,.. ,.. 4.. 4.. 
20000944:	093c 2000 093c 2000 0944 2000 0944 2000     <.. <.. D.. D.. 
20000954:	094c 2000 094c 2000 0954 2000 0954 2000     L.. L.. T.. T.. 
20000964:	095c 2000 095c 2000 0964 2000 0964 2000     \.. \.. d.. d.. 
20000974:	096c 2000 096c 2000 0974 2000 0974 2000     l.. l.. t.. t.. 
20000984:	097c 2000 097c 2000 0984 2000 0984 2000     |.. |.. ... ... 
20000994:	098c 2000 098c 2000 0994 2000 0994 2000     ... ... ... ... 
200009a4:	099c 2000 099c 2000 09a4 2000 09a4 2000     ... ... ... ... 
200009b4:	09ac 2000 09ac 2000 09b4 2000 09b4 2000     ... ... ... ... 
200009c4:	09bc 2000 09bc 2000 09c4 2000 09c4 2000     ... ... ... ... 
200009d4:	09cc 2000 09cc 2000 09d4 2000 09d4 2000     ... ... ... ... 
200009e4:	09dc 2000 09dc 2000 09e4 2000 09e4 2000     ... ... ... ... 
200009f4:	09ec 2000 09ec 2000 09f4 2000 09f4 2000     ... ... ... ... 
20000a04:	09fc 2000 09fc 2000 0a04 2000 0a04 2000     ... ... ... ... 
20000a14:	0a0c 2000 0a0c 2000 0a14 2000 0a14 2000     ... ... ... ... 
20000a24:	0a1c 2000 0a1c 2000 0a24 2000 0a24 2000     ... ... $.. $.. 
20000a34:	0a2c 2000 0a2c 2000 0a34 2000 0a34 2000     ,.. ,.. 4.. 4.. 
20000a44:	0a3c 2000 0a3c 2000 0a44 2000 0a44 2000     <.. <.. D.. D.. 
20000a54:	0a4c 2000 0a4c 2000 0a54 2000 0a54 2000     L.. L.. T.. T.. 
20000a64:	0a5c 2000 0a5c 2000 0a64 2000 0a64 2000     \.. \.. d.. d.. 
20000a74:	0a6c 2000 0a6c 2000 0a74 2000 0a74 2000     l.. l.. t.. t.. 
20000a84:	0a7c 2000 0a7c 2000 0a84 2000 0a84 2000     |.. |.. ... ... 
20000a94:	0a8c 2000 0a8c 2000 0a94 2000 0a94 2000     ... ... ... ... 
20000aa4:	0a9c 2000 0a9c 2000 0aa4 2000 0aa4 2000     ... ... ... ... 
20000ab4:	0aac 2000 0aac 2000 0ab4 2000 0ab4 2000     ... ... ... ... 
20000ac4:	0abc 2000 0abc 2000 0ac4 2000 0ac4 2000     ... ... ... ... 
20000ad4:	0acc 2000 0acc 2000 0ad4 2000 0ad4 2000     ... ... ... ... 
20000ae4:	0adc 2000 0adc 2000 0ae4 2000 0ae4 2000     ... ... ... ... 
20000af4:	0aec 2000 0aec 2000 0af4 2000 0af4 2000     ... ... ... ... 
20000b04:	0afc 2000 0afc 2000 0b04 2000 0b04 2000     ... ... ... ... 
20000b14:	0b0c 2000 0b0c 2000 0b14 2000 0b14 2000     ... ... ... ... 
20000b24:	0b1c 2000 0b1c 2000 0b24 2000 0b24 2000     ... ... $.. $.. 
20000b34:	0b2c 2000 0b2c 2000 0b34 2000 0b34 2000     ,.. ,.. 4.. 4.. 
20000b44:	0b3c 2000 0b3c 2000 0b44 2000 0b44 2000     <.. <.. D.. D.. 
20000b54:	0b4c 2000 0b4c 2000 0b54 2000 0b54 2000     L.. L.. T.. T.. 
20000b64:	0b5c 2000 0b5c 2000 0b64 2000 0b64 2000     \.. \.. d.. d.. 
20000b74:	0b6c 2000 0b6c 2000 0b74 2000 0b74 2000     l.. l.. t.. t.. 
20000b84:	0b7c 2000 0b7c 2000 0b84 2000 0b84 2000     |.. |.. ... ... 

20000b94 <__malloc_sbrk_base>:
20000b94:	ffff ffff                                   ....

20000b98 <__malloc_trim_threshold>:
20000b98:	0000 0002                                   ....

20000b9c <__global_locale>:
20000b9c:	0043 0000 0000 0000 0000 0000 0000 0000     C...............
	...
20000bbc:	0043 0000 0000 0000 0000 0000 0000 0000     C...............
	...
20000bdc:	0043 0000 0000 0000 0000 0000 0000 0000     C...............
	...
20000bfc:	0043 0000 0000 0000 0000 0000 0000 0000     C...............
	...
20000c1c:	0043 0000 0000 0000 0000 0000 0000 0000     C...............
	...
20000c3c:	0043 0000 0000 0000 0000 0000 0000 0000     C...............
	...
20000c5c:	0043 0000 0000 0000 0000 0000 0000 0000     C...............
	...
20000c7c:	7de1 0041 7a69 0041 0000 0000 d7ac 0041     .}A.izA.......A.
20000c8c:	d7a8 0041 d648 0041 d648 0041 d648 0041     ..A.H.A.H.A.H.A.
20000c9c:	d648 0041 d648 0041 d648 0041 d648 0041     H.A.H.A.H.A.H.A.
20000cac:	d648 0041 d648 0041 ffff ffff ffff ffff     H.A.H.A.........
20000cbc:	ffff ffff ffff 0000 0001 5341 4943 0049     ..........ASCII.
	...
20000ce4:	0000 5341 4943 0049 0000 0000 0000 0000     ..ASCII.........
	...
